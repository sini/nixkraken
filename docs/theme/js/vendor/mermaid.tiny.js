'use strict'
var __esbuild_esm_mermaid_nm
;(__esbuild_esm_mermaid_nm ||= {}).mermaid = (() => {
  var Ylt = Object.create
  var Um = Object.defineProperty
  var Xlt = Object.getOwnPropertyDescriptor
  var Klt = Object.getOwnPropertyNames
  var Qlt = Object.getPrototypeOf,
    Zlt = Object.prototype.hasOwnProperty
  var a = (e, t) => Um(e, 'name', { value: t, configurable: !0 })
  var x = (e, t) => () => (e && (t = e((e = 0))), t)
  var Ja = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    Oe = (e, t) => {
      for (var r in t) Um(e, r, { get: t[r], enumerable: !0 })
    },
    ix = (e, t, r, n) => {
      if ((t && typeof t == 'object') || typeof t == 'function')
        for (let i of Klt(t))
          !Zlt.call(e, i) && i !== r && Um(e, i, { get: () => t[i], enumerable: !(n = Xlt(t, i)) || n.enumerable })
      return e
    },
    qe = (e, t, r) => (ix(e, t, 'default'), r && ix(r, t, 'default')),
    Ss = (e, t, r) => (
      (r = e != null ? Ylt(Qlt(e)) : {}),
      ix(t || !e || !e.__esModule ? Um(r, 'default', { value: e, enumerable: !0 }) : r, e)
    ),
    Jlt = (e) => ix(Um({}, '__esModule', { value: !0 }), e)
  var tct,
    af,
    RC,
    U8,
    sx = x(() => {
      'use strict'
      ;(tct = Object.freeze({ left: 0, top: 0, width: 16, height: 16 })),
        (af = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 })),
        (RC = Object.freeze({ ...tct, ...af })),
        (U8 = Object.freeze({ ...RC, body: '', hidden: !1 }))
    })
  var ect,
    j8,
    q8 = x(() => {
      'use strict'
      sx()
      ;(ect = Object.freeze({ width: null, height: null })), (j8 = Object.freeze({ ...ect, ...af }))
    })
  var DC,
    ax,
    H8 = x(() => {
      'use strict'
      ;(DC = a((e, t, r, n = '') => {
        let i = e.split(':')
        if (e.slice(0, 1) === '@') {
          if (i.length < 2 || i.length > 3) return null
          n = i.shift().slice(1)
        }
        if (i.length > 3 || !i.length) return null
        if (i.length > 1) {
          let l = i.pop(),
            u = i.pop(),
            h = { provider: i.length > 0 ? i[0] : n, prefix: u, name: l }
          return t && !ax(h) ? null : h
        }
        let s = i[0],
          o = s.split('-')
        if (o.length > 1) {
          let l = { provider: n, prefix: o.shift(), name: o.join('-') }
          return t && !ax(l) ? null : l
        }
        if (r && n === '') {
          let l = { provider: n, prefix: '', name: s }
          return t && !ax(l, r) ? null : l
        }
        return null
      }, 'stringToIcon')),
        (ax = a((e, t) => (e ? !!(((t && e.prefix === '') || e.prefix) && e.name) : !1), 'validateIconName'))
    })
  function Y8(e, t) {
    let r = {}
    !e.hFlip != !t.hFlip && (r.hFlip = !0), !e.vFlip != !t.vFlip && (r.vFlip = !0)
    let n = ((e.rotate || 0) + (t.rotate || 0)) % 4
    return n && (r.rotate = n), r
  }
  var X8 = x(() => {
    'use strict'
    a(Y8, 'mergeIconTransformations')
  })
  function NC(e, t) {
    let r = Y8(e, t)
    for (let n in U8) n in af ? n in e && !(n in r) && (r[n] = af[n]) : n in t ? (r[n] = t[n]) : n in e && (r[n] = e[n])
    return r
  }
  var K8 = x(() => {
    'use strict'
    sx()
    X8()
    a(NC, 'mergeIconData')
  })
  function Q8(e, t) {
    let r = e.icons,
      n = e.aliases || Object.create(null),
      i = Object.create(null)
    function s(o) {
      if (r[o]) return (i[o] = [])
      if (!(o in i)) {
        i[o] = null
        let l = n[o] && n[o].parent,
          u = l && s(l)
        u && (i[o] = [l].concat(u))
      }
      return i[o]
    }
    return a(s, 'resolve'), (t || Object.keys(r).concat(Object.keys(n))).forEach(s), i
  }
  var Z8 = x(() => {
    'use strict'
    a(Q8, 'getIconsTree')
  })
  function J8(e, t, r) {
    let n = e.icons,
      i = e.aliases || Object.create(null),
      s = {}
    function o(l) {
      s = NC(n[l] || i[l], s)
    }
    return a(o, 'parse'), o(t), r.forEach(o), NC(e, s)
  }
  function IC(e, t) {
    if (e.icons[t]) return J8(e, t, [])
    let r = Q8(e, [t])[t]
    return r ? J8(e, t, r) : null
  }
  var t7 = x(() => {
    'use strict'
    K8()
    Z8()
    a(J8, 'internalGetIconData')
    a(IC, 'getIconData')
  })
  function MC(e, t, r) {
    if (t === 1) return e
    if (((r = r || 100), typeof e == 'number')) return Math.ceil(e * t * r) / r
    if (typeof e != 'string') return e
    let n = e.split(rct)
    if (n === null || !n.length) return e
    let i = [],
      s = n.shift(),
      o = nct.test(s)
    for (;;) {
      if (o) {
        let l = parseFloat(s)
        isNaN(l) ? i.push(s) : i.push(Math.ceil(l * t * r) / r)
      } else i.push(s)
      if (((s = n.shift()), s === void 0)) return i.join('')
      o = !o
    }
  }
  var rct,
    nct,
    e7 = x(() => {
      'use strict'
      ;(rct = /(-?[0-9.]*[0-9]+[0-9.]*)/g), (nct = /^-?[0-9.]*[0-9]+[0-9.]*$/g)
      a(MC, 'calculateSize')
    })
  function ict(e, t = 'defs') {
    let r = '',
      n = e.indexOf('<' + t)
    for (; n >= 0; ) {
      let i = e.indexOf('>', n),
        s = e.indexOf('</' + t)
      if (i === -1 || s === -1) break
      let o = e.indexOf('>', s)
      if (o === -1) break
      ;(r += e.slice(i + 1, s).trim()), (e = e.slice(0, n).trim() + e.slice(o + 1))
    }
    return { defs: r, content: e }
  }
  function sct(e, t) {
    return e ? '<defs>' + e + '</defs>' + t : t
  }
  function r7(e, t, r) {
    let n = ict(e)
    return sct(n.defs, t + n.content + r)
  }
  var n7 = x(() => {
    'use strict'
    a(ict, 'splitSVGDefs')
    a(sct, 'mergeDefsAndContent')
    a(r7, 'wrapSVGContent')
  })
  function OC(e, t) {
    let r = { ...RC, ...e },
      n = { ...j8, ...t },
      i = { left: r.left, top: r.top, width: r.width, height: r.height },
      s = r.body
    ;[r, n].forEach((y) => {
      let b = [],
        k = y.hFlip,
        T = y.vFlip,
        C = y.rotate
      k
        ? T
          ? (C += 2)
          : (b.push('translate(' + (i.width + i.left).toString() + ' ' + (0 - i.top).toString() + ')'),
            b.push('scale(-1 1)'),
            (i.top = i.left = 0))
        : T &&
          (b.push('translate(' + (0 - i.left).toString() + ' ' + (i.height + i.top).toString() + ')'),
          b.push('scale(1 -1)'),
          (i.top = i.left = 0))
      let A
      switch ((C < 0 && (C -= Math.floor(C / 4) * 4), (C = C % 4), C)) {
        case 1:
          ;(A = i.height / 2 + i.top), b.unshift('rotate(90 ' + A.toString() + ' ' + A.toString() + ')')
          break
        case 2:
          b.unshift('rotate(180 ' + (i.width / 2 + i.left).toString() + ' ' + (i.height / 2 + i.top).toString() + ')')
          break
        case 3:
          ;(A = i.width / 2 + i.left), b.unshift('rotate(-90 ' + A.toString() + ' ' + A.toString() + ')')
          break
      }
      C % 2 === 1 &&
        (i.left !== i.top && ((A = i.left), (i.left = i.top), (i.top = A)),
        i.width !== i.height && ((A = i.width), (i.width = i.height), (i.height = A))),
        b.length && (s = r7(s, '<g transform="' + b.join(' ') + '">', '</g>'))
    })
    let o = n.width,
      l = n.height,
      u = i.width,
      h = i.height,
      f,
      d
    o === null
      ? ((d = l === null ? '1em' : l === 'auto' ? h : l), (f = MC(d, u / h)))
      : ((f = o === 'auto' ? u : o), (d = l === null ? MC(f, h / u) : l === 'auto' ? h : l))
    let p = {},
      m = a((y, b) => {
        act(b) || (p[y] = b.toString())
      }, 'setAttr')
    m('width', f), m('height', d)
    let g = [i.left, i.top, u, h]
    return (p.viewBox = g.join(' ')), { attributes: p, viewBox: g, body: s }
  }
  var act,
    i7 = x(() => {
      'use strict'
      sx()
      q8()
      e7()
      n7()
      act = a((e) => e === 'unset' || e === 'undefined' || e === 'none', 'isUnsetKeyword')
      a(OC, 'iconToSVG')
    })
  function PC(e, t = lct) {
    let r = [],
      n
    for (; (n = oct.exec(e)); ) r.push(n[1])
    if (!r.length) return e
    let i = 'suffix' + ((Math.random() * 16777216) | Date.now()).toString(16)
    return (
      r.forEach((s) => {
        let o = typeof t == 'function' ? t(s) : t + (cct++).toString(),
          l = s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        e = e.replace(new RegExp('([#;"])(' + l + ')([")]|\\.[a-z])', 'g'), '$1' + o + i + '$3')
      }),
      (e = e.replace(new RegExp(i, 'g'), '')),
      e
    )
  }
  var oct,
    lct,
    cct,
    s7 = x(() => {
      'use strict'
      ;(oct = /\sid="(\S+)"/g),
        (lct = 'IconifyId' + Date.now().toString(16) + ((Math.random() * 16777216) | 0).toString(16)),
        (cct = 0)
      a(PC, 'replaceIDs')
    })
  function BC(e, t) {
    let r = e.indexOf('xlink:') === -1 ? '' : ' xmlns:xlink="http://www.w3.org/1999/xlink"'
    for (let n in t) r += ' ' + n + '="' + t[n] + '"'
    return '<svg xmlns="http://www.w3.org/2000/svg"' + r + '>' + e + '</svg>'
  }
  var a7 = x(() => {
    'use strict'
    a(BC, 'iconToHTML')
  })
  var o7 = x(() => {
    'use strict'
    H8()
    t7()
    i7()
    s7()
    a7()
  })
  var FC,
    Kr,
    of = x(() => {
      'use strict'
      ;(FC = a((e, t, { depth: r = 2, clobber: n = !1 } = {}) => {
        let i = { depth: r, clobber: n }
        return Array.isArray(t) && !Array.isArray(e)
          ? (t.forEach((s) => FC(e, s, i)), e)
          : Array.isArray(t) && Array.isArray(e)
            ? (t.forEach((s) => {
                e.includes(s) || e.push(s)
              }),
              e)
            : e === void 0 || r <= 0
              ? e != null && typeof e == 'object' && typeof t == 'object'
                ? Object.assign(e, t)
                : t
              : (t !== void 0 &&
                  typeof e == 'object' &&
                  typeof t == 'object' &&
                  Object.keys(t).forEach((s) => {
                    typeof t[s] == 'object' && (e[s] === void 0 || typeof e[s] == 'object')
                      ? (e[s] === void 0 && (e[s] = Array.isArray(t[s]) ? [] : {}),
                        (e[s] = FC(e[s], t[s], { depth: r - 1, clobber: n })))
                      : (n || (typeof e[s] != 'object' && typeof t[s] != 'object')) && (e[s] = t[s])
                  }),
                e)
      }, 'assignWithDepth')),
        (Kr = FC)
    })
  var ox = Ja(($C, GC) => {
    'use strict'
    ;(function (e, t) {
      typeof $C == 'object' && typeof GC < 'u'
        ? (GC.exports = t())
        : typeof define == 'function' && define.amd
          ? define(t)
          : ((e = typeof globalThis < 'u' ? globalThis : e || self).dayjs = t())
    })($C, function () {
      'use strict'
      var e = 1e3,
        t = 6e4,
        r = 36e5,
        n = 'millisecond',
        i = 'second',
        s = 'minute',
        o = 'hour',
        l = 'day',
        u = 'week',
        h = 'month',
        f = 'quarter',
        d = 'year',
        p = 'date',
        m = 'Invalid Date',
        g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        b = {
          name: 'en',
          weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          ordinal: a(function (O) {
            var E = ['th', 'st', 'nd', 'rd'],
              _ = O % 100
            return '[' + O + (E[(_ - 20) % 10] || E[_] || E[0]) + ']'
          }, 'ordinal'),
        },
        k = a(function (O, E, _) {
          var L = String(O)
          return !L || L.length >= E ? O : '' + Array(E + 1 - L.length).join(_) + O
        }, 'm'),
        T = {
          s: k,
          z: a(function (O) {
            var E = -O.utcOffset(),
              _ = Math.abs(E),
              L = Math.floor(_ / 60),
              N = _ % 60
            return (E <= 0 ? '+' : '-') + k(L, 2, '0') + ':' + k(N, 2, '0')
          }, 'z'),
          m: a(function O(E, _) {
            if (E.date() < _.date()) return -O(_, E)
            var L = 12 * (_.year() - E.year()) + (_.month() - E.month()),
              N = E.clone().add(L, h),
              P = _ - N < 0,
              I = E.clone().add(L + (P ? -1 : 1), h)
            return +(-(L + (_ - N) / (P ? N - I : I - N)) || 0)
          }, 't'),
          a: a(function (O) {
            return O < 0 ? Math.ceil(O) || 0 : Math.floor(O)
          }, 'a'),
          p: a(function (O) {
            return (
              { M: h, y: d, w: u, d: l, D: p, h: o, m: s, s: i, ms: n, Q: f }[O] ||
              String(O || '')
                .toLowerCase()
                .replace(/s$/, '')
            )
          }, 'p'),
          u: a(function (O) {
            return O === void 0
          }, 'u'),
        },
        C = 'en',
        A = {}
      A[C] = b
      var w = '$isDayjsObject',
        D = a(function (O) {
          return O instanceof F || !(!O || !O[w])
        }, 'S'),
        G = a(function O(E, _, L) {
          var N
          if (!E) return C
          if (typeof E == 'string') {
            var P = E.toLowerCase()
            A[P] && (N = P), _ && ((A[P] = _), (N = P))
            var I = E.split('-')
            if (!N && I.length > 1) return O(I[0])
          } else {
            var M = E.name
            ;(A[M] = E), (N = M)
          }
          return !L && N && (C = N), N || (!L && C)
        }, 't'),
        v = a(function (O, E) {
          if (D(O)) return O.clone()
          var _ = typeof E == 'object' ? E : {}
          return (_.date = O), (_.args = arguments), new F(_)
        }, 'O'),
        R = T
      ;(R.l = G),
        (R.i = D),
        (R.w = function (O, E) {
          return v(O, { locale: E.$L, utc: E.$u, x: E.$x, $offset: E.$offset })
        })
      var F = (function () {
          function O(_) {
            ;(this.$L = G(_.locale, null, !0)), this.parse(_), (this.$x = this.$x || _.x || {}), (this[w] = !0)
          }
          a(O, 'M')
          var E = O.prototype
          return (
            (E.parse = function (_) {
              ;(this.$d = (function (L) {
                var N = L.date,
                  P = L.utc
                if (N === null) return new Date(NaN)
                if (R.u(N)) return new Date()
                if (N instanceof Date) return new Date(N)
                if (typeof N == 'string' && !/Z$/i.test(N)) {
                  var I = N.match(g)
                  if (I) {
                    var M = I[2] - 1 || 0,
                      V = (I[7] || '0').substring(0, 3)
                    return P
                      ? new Date(Date.UTC(I[1], M, I[3] || 1, I[4] || 0, I[5] || 0, I[6] || 0, V))
                      : new Date(I[1], M, I[3] || 1, I[4] || 0, I[5] || 0, I[6] || 0, V)
                  }
                }
                return new Date(N)
              })(_)),
                this.init()
            }),
            (E.init = function () {
              var _ = this.$d
              ;(this.$y = _.getFullYear()),
                (this.$M = _.getMonth()),
                (this.$D = _.getDate()),
                (this.$W = _.getDay()),
                (this.$H = _.getHours()),
                (this.$m = _.getMinutes()),
                (this.$s = _.getSeconds()),
                (this.$ms = _.getMilliseconds())
            }),
            (E.$utils = function () {
              return R
            }),
            (E.isValid = function () {
              return this.$d.toString() !== m
            }),
            (E.isSame = function (_, L) {
              var N = v(_)
              return this.startOf(L) <= N && N <= this.endOf(L)
            }),
            (E.isAfter = function (_, L) {
              return v(_) < this.startOf(L)
            }),
            (E.isBefore = function (_, L) {
              return this.endOf(L) < v(_)
            }),
            (E.$g = function (_, L, N) {
              return R.u(_) ? this[L] : this.set(N, _)
            }),
            (E.unix = function () {
              return Math.floor(this.valueOf() / 1e3)
            }),
            (E.valueOf = function () {
              return this.$d.getTime()
            }),
            (E.startOf = function (_, L) {
              var N = this,
                P = !!R.u(L) || L,
                I = R.p(_),
                M = a(function (ht, yt) {
                  var ot = R.w(N.$u ? Date.UTC(N.$y, yt, ht) : new Date(N.$y, yt, ht), N)
                  return P ? ot : ot.endOf(l)
                }, 'l'),
                V = a(function (ht, yt) {
                  return R.w(N.toDate()[ht].apply(N.toDate('s'), (P ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(yt)), N)
                }, '$'),
                $ = this.$W,
                q = this.$M,
                tt = this.$D,
                ft = 'set' + (this.$u ? 'UTC' : '')
              switch (I) {
                case d:
                  return P ? M(1, 0) : M(31, 11)
                case h:
                  return P ? M(1, q) : M(0, q + 1)
                case u:
                  var H = this.$locale().weekStart || 0,
                    kt = ($ < H ? $ + 7 : $) - H
                  return M(P ? tt - kt : tt + (6 - kt), q)
                case l:
                case p:
                  return V(ft + 'Hours', 0)
                case o:
                  return V(ft + 'Minutes', 1)
                case s:
                  return V(ft + 'Seconds', 2)
                case i:
                  return V(ft + 'Milliseconds', 3)
                default:
                  return this.clone()
              }
            }),
            (E.endOf = function (_) {
              return this.startOf(_, !1)
            }),
            (E.$set = function (_, L) {
              var N,
                P = R.p(_),
                I = 'set' + (this.$u ? 'UTC' : ''),
                M = ((N = {}),
                (N[l] = I + 'Date'),
                (N[p] = I + 'Date'),
                (N[h] = I + 'Month'),
                (N[d] = I + 'FullYear'),
                (N[o] = I + 'Hours'),
                (N[s] = I + 'Minutes'),
                (N[i] = I + 'Seconds'),
                (N[n] = I + 'Milliseconds'),
                N)[P],
                V = P === l ? this.$D + (L - this.$W) : L
              if (P === h || P === d) {
                var $ = this.clone().set(p, 1)
                $.$d[M](V), $.init(), (this.$d = $.set(p, Math.min(this.$D, $.daysInMonth())).$d)
              } else M && this.$d[M](V)
              return this.init(), this
            }),
            (E.set = function (_, L) {
              return this.clone().$set(_, L)
            }),
            (E.get = function (_) {
              return this[R.p(_)]()
            }),
            (E.add = function (_, L) {
              var N,
                P = this
              _ = Number(_)
              var I = R.p(L),
                M = a(function (q) {
                  var tt = v(P)
                  return R.w(tt.date(tt.date() + Math.round(q * _)), P)
                }, 'y')
              if (I === h) return this.set(h, this.$M + _)
              if (I === d) return this.set(d, this.$y + _)
              if (I === l) return M(1)
              if (I === u) return M(7)
              var V = ((N = {}), (N[s] = t), (N[o] = r), (N[i] = e), N)[I] || 1,
                $ = this.$d.getTime() + _ * V
              return R.w($, this)
            }),
            (E.subtract = function (_, L) {
              return this.add(-1 * _, L)
            }),
            (E.format = function (_) {
              var L = this,
                N = this.$locale()
              if (!this.isValid()) return N.invalidDate || m
              var P = _ || 'YYYY-MM-DDTHH:mm:ssZ',
                I = R.z(this),
                M = this.$H,
                V = this.$m,
                $ = this.$M,
                q = N.weekdays,
                tt = N.months,
                ft = N.meridiem,
                H = a(function (yt, ot, dt, it) {
                  return (yt && (yt[ot] || yt(L, P))) || dt[ot].slice(0, it)
                }, 'h'),
                kt = a(function (yt) {
                  return R.s(M % 12 || 12, yt, '0')
                }, 'd'),
                ht =
                  ft ||
                  function (yt, ot, dt) {
                    var it = yt < 12 ? 'AM' : 'PM'
                    return dt ? it.toLowerCase() : it
                  }
              return P.replace(y, function (yt, ot) {
                return (
                  ot ||
                  (function (dt) {
                    switch (dt) {
                      case 'YY':
                        return String(L.$y).slice(-2)
                      case 'YYYY':
                        return R.s(L.$y, 4, '0')
                      case 'M':
                        return $ + 1
                      case 'MM':
                        return R.s($ + 1, 2, '0')
                      case 'MMM':
                        return H(N.monthsShort, $, tt, 3)
                      case 'MMMM':
                        return H(tt, $)
                      case 'D':
                        return L.$D
                      case 'DD':
                        return R.s(L.$D, 2, '0')
                      case 'd':
                        return String(L.$W)
                      case 'dd':
                        return H(N.weekdaysMin, L.$W, q, 2)
                      case 'ddd':
                        return H(N.weekdaysShort, L.$W, q, 3)
                      case 'dddd':
                        return q[L.$W]
                      case 'H':
                        return String(M)
                      case 'HH':
                        return R.s(M, 2, '0')
                      case 'h':
                        return kt(1)
                      case 'hh':
                        return kt(2)
                      case 'a':
                        return ht(M, V, !0)
                      case 'A':
                        return ht(M, V, !1)
                      case 'm':
                        return String(V)
                      case 'mm':
                        return R.s(V, 2, '0')
                      case 's':
                        return String(L.$s)
                      case 'ss':
                        return R.s(L.$s, 2, '0')
                      case 'SSS':
                        return R.s(L.$ms, 3, '0')
                      case 'Z':
                        return I
                    }
                    return null
                  })(yt) ||
                  I.replace(':', '')
                )
              })
            }),
            (E.utcOffset = function () {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }),
            (E.diff = function (_, L, N) {
              var P,
                I = this,
                M = R.p(L),
                V = v(_),
                $ = (V.utcOffset() - this.utcOffset()) * t,
                q = this - V,
                tt = a(function () {
                  return R.m(I, V)
                }, 'D')
              switch (M) {
                case d:
                  P = tt() / 12
                  break
                case h:
                  P = tt()
                  break
                case f:
                  P = tt() / 3
                  break
                case u:
                  P = (q - $) / 6048e5
                  break
                case l:
                  P = (q - $) / 864e5
                  break
                case o:
                  P = q / r
                  break
                case s:
                  P = q / t
                  break
                case i:
                  P = q / e
                  break
                default:
                  P = q
              }
              return N ? P : R.a(P)
            }),
            (E.daysInMonth = function () {
              return this.endOf(h).$D
            }),
            (E.$locale = function () {
              return A[this.$L]
            }),
            (E.locale = function (_, L) {
              if (!_) return this.$L
              var N = this.clone(),
                P = G(_, L, !0)
              return P && (N.$L = P), N
            }),
            (E.clone = function () {
              return R.w(this.$d, this)
            }),
            (E.toDate = function () {
              return new Date(this.valueOf())
            }),
            (E.toJSON = function () {
              return this.isValid() ? this.toISOString() : null
            }),
            (E.toISOString = function () {
              return this.$d.toISOString()
            }),
            (E.toString = function () {
              return this.$d.toUTCString()
            }),
            O
          )
        })(),
        S = F.prototype
      return (
        (v.prototype = S),
        [
          ['$ms', n],
          ['$s', i],
          ['$m', s],
          ['$H', o],
          ['$W', l],
          ['$M', h],
          ['$y', d],
          ['$D', p],
        ].forEach(function (O) {
          S[O[1]] = function (E) {
            return this.$g(E, O[0], O[1])
          }
        }),
        (v.extend = function (O, E) {
          return O.$i || (O(E, F, v), (O.$i = !0)), v
        }),
        (v.locale = G),
        (v.isDayjs = D),
        (v.unix = function (O) {
          return v(1e3 * O)
        }),
        (v.en = A[C]),
        (v.Ls = A),
        (v.p = {}),
        v
      )
    })
  })
  var l7,
    Ko,
    B,
    jm,
    Us,
    Vt = x(() => {
      'use strict'
      ;(l7 = Ss(ox(), 1)),
        (Ko = { trace: 0, debug: 1, info: 2, warn: 3, error: 4, fatal: 5 }),
        (B = {
          trace: a((...e) => {}, 'trace'),
          debug: a((...e) => {}, 'debug'),
          info: a((...e) => {}, 'info'),
          warn: a((...e) => {}, 'warn'),
          error: a((...e) => {}, 'error'),
          fatal: a((...e) => {}, 'fatal'),
        }),
        (jm = a(function (e = 'fatal') {
          let t = Ko.fatal
          typeof e == 'string' ? e.toLowerCase() in Ko && (t = Ko[e]) : typeof e == 'number' && (t = e),
            (B.trace = () => {}),
            (B.debug = () => {}),
            (B.info = () => {}),
            (B.warn = () => {}),
            (B.error = () => {}),
            (B.fatal = () => {}),
            t <= Ko.fatal &&
              (B.fatal = console.error
                ? console.error.bind(console, Us('FATAL'), 'color: orange')
                : console.log.bind(console, '\x1B[35m', Us('FATAL'))),
            t <= Ko.error &&
              (B.error = console.error
                ? console.error.bind(console, Us('ERROR'), 'color: orange')
                : console.log.bind(console, '\x1B[31m', Us('ERROR'))),
            t <= Ko.warn &&
              (B.warn = console.warn
                ? console.warn.bind(console, Us('WARN'), 'color: orange')
                : console.log.bind(console, '\x1B[33m', Us('WARN'))),
            t <= Ko.info &&
              (B.info = console.info
                ? console.info.bind(console, Us('INFO'), 'color: lightblue')
                : console.log.bind(console, '\x1B[34m', Us('INFO'))),
            t <= Ko.debug &&
              (B.debug = console.debug
                ? console.debug.bind(console, Us('DEBUG'), 'color: lightgreen')
                : console.log.bind(console, '\x1B[32m', Us('DEBUG'))),
            t <= Ko.trace &&
              (B.trace = console.debug
                ? console.debug.bind(console, Us('TRACE'), 'color: lightgreen')
                : console.log.bind(console, '\x1B[32m', Us('TRACE')))
        }, 'setLogLevel')),
        (Us = a((e) => `%c${(0, l7.default)().format('ss.SSS')} : ${e} : `, 'format'))
    })
  var lx,
    c7,
    u7 = x(() => {
      'use strict'
      ;(lx = {
        min: { r: 0, g: 0, b: 0, s: 0, l: 0, a: 0 },
        max: { r: 255, g: 255, b: 255, h: 360, s: 100, l: 100, a: 1 },
        clamp: {
          r: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), 'r'),
          g: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), 'g'),
          b: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), 'b'),
          h: a((e) => e % 360, 'h'),
          s: a((e) => (e >= 100 ? 100 : e < 0 ? 0 : e), 's'),
          l: a((e) => (e >= 100 ? 100 : e < 0 ? 0 : e), 'l'),
          a: a((e) => (e >= 1 ? 1 : e < 0 ? 0 : e), 'a'),
        },
        toLinear: a((e) => {
          let t = e / 255
          return e > 0.03928 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92
        }, 'toLinear'),
        hue2rgb: a(
          (e, t, r) => (
            r < 0 && (r += 1),
            r > 1 && (r -= 1),
            r < 0.16666666666666666
              ? e + (t - e) * 6 * r
              : r < 0.5
                ? t
                : r < 0.6666666666666666
                  ? e + (t - e) * (0.6666666666666666 - r) * 6
                  : e
          ),
          'hue2rgb',
        ),
        hsl2rgb: a(({ h: e, s: t, l: r }, n) => {
          if (!t) return r * 2.55
          ;(e /= 360), (t /= 100), (r /= 100)
          let i = r < 0.5 ? r * (1 + t) : r + t - r * t,
            s = 2 * r - i
          switch (n) {
            case 'r':
              return lx.hue2rgb(s, i, e + 0.3333333333333333) * 255
            case 'g':
              return lx.hue2rgb(s, i, e) * 255
            case 'b':
              return lx.hue2rgb(s, i, e - 0.3333333333333333) * 255
          }
        }, 'hsl2rgb'),
        rgb2hsl: a(({ r: e, g: t, b: r }, n) => {
          ;(e /= 255), (t /= 255), (r /= 255)
          let i = Math.max(e, t, r),
            s = Math.min(e, t, r),
            o = (i + s) / 2
          if (n === 'l') return o * 100
          if (i === s) return 0
          let l = i - s,
            u = o > 0.5 ? l / (2 - i - s) : l / (i + s)
          if (n === 's') return u * 100
          switch (i) {
            case e:
              return ((t - r) / l + (t < r ? 6 : 0)) * 60
            case t:
              return ((r - e) / l + 2) * 60
            case r:
              return ((e - t) / l + 4) * 60
            default:
              return -1
          }
        }, 'rgb2hsl'),
      }),
        (c7 = lx)
    })
  var uct,
    h7,
    f7 = x(() => {
      'use strict'
      ;(uct = {
        clamp: a((e, t, r) => (t > r ? Math.min(t, Math.max(r, e)) : Math.min(r, Math.max(t, e))), 'clamp'),
        round: a((e) => Math.round(e * 1e10) / 1e10, 'round'),
      }),
        (h7 = uct)
    })
  var hct,
    d7,
    p7 = x(() => {
      'use strict'
      ;(hct = {
        dec2hex: a((e) => {
          let t = Math.round(e).toString(16)
          return t.length > 1 ? t : `0${t}`
        }, 'dec2hex'),
      }),
        (d7 = hct)
    })
  var fct,
    de,
    to = x(() => {
      'use strict'
      u7()
      f7()
      p7()
      ;(fct = { channel: c7, lang: h7, unit: d7 }), (de = fct)
    })
  var Qo,
    In,
    qm = x(() => {
      'use strict'
      to()
      Qo = {}
      for (let e = 0; e <= 255; e++) Qo[e] = de.unit.dec2hex(e)
      In = { ALL: 0, RGB: 1, HSL: 2 }
    })
  var VC,
    m7,
    g7 = x(() => {
      'use strict'
      qm()
      ;(VC = class {
        static {
          a(this, 'Type')
        }
        constructor() {
          this.type = In.ALL
        }
        get() {
          return this.type
        }
        set(t) {
          if (this.type && this.type !== t) throw new Error('Cannot change both RGB and HSL channels at the same time')
          this.type = t
        }
        reset() {
          this.type = In.ALL
        }
        is(t) {
          return this.type === t
        }
      }),
        (m7 = VC)
    })
  var zC,
    y7,
    x7 = x(() => {
      'use strict'
      to()
      g7()
      qm()
      ;(zC = class {
        static {
          a(this, 'Channels')
        }
        constructor(t, r) {
          ;(this.color = r), (this.changed = !1), (this.data = t), (this.type = new m7())
        }
        set(t, r) {
          return (this.color = r), (this.changed = !1), (this.data = t), (this.type.type = In.ALL), this
        }
        _ensureHSL() {
          let t = this.data,
            { h: r, s: n, l: i } = t
          r === void 0 && (t.h = de.channel.rgb2hsl(t, 'h')),
            n === void 0 && (t.s = de.channel.rgb2hsl(t, 's')),
            i === void 0 && (t.l = de.channel.rgb2hsl(t, 'l'))
        }
        _ensureRGB() {
          let t = this.data,
            { r, g: n, b: i } = t
          r === void 0 && (t.r = de.channel.hsl2rgb(t, 'r')),
            n === void 0 && (t.g = de.channel.hsl2rgb(t, 'g')),
            i === void 0 && (t.b = de.channel.hsl2rgb(t, 'b'))
        }
        get r() {
          let t = this.data,
            r = t.r
          return !this.type.is(In.HSL) && r !== void 0 ? r : (this._ensureHSL(), de.channel.hsl2rgb(t, 'r'))
        }
        get g() {
          let t = this.data,
            r = t.g
          return !this.type.is(In.HSL) && r !== void 0 ? r : (this._ensureHSL(), de.channel.hsl2rgb(t, 'g'))
        }
        get b() {
          let t = this.data,
            r = t.b
          return !this.type.is(In.HSL) && r !== void 0 ? r : (this._ensureHSL(), de.channel.hsl2rgb(t, 'b'))
        }
        get h() {
          let t = this.data,
            r = t.h
          return !this.type.is(In.RGB) && r !== void 0 ? r : (this._ensureRGB(), de.channel.rgb2hsl(t, 'h'))
        }
        get s() {
          let t = this.data,
            r = t.s
          return !this.type.is(In.RGB) && r !== void 0 ? r : (this._ensureRGB(), de.channel.rgb2hsl(t, 's'))
        }
        get l() {
          let t = this.data,
            r = t.l
          return !this.type.is(In.RGB) && r !== void 0 ? r : (this._ensureRGB(), de.channel.rgb2hsl(t, 'l'))
        }
        get a() {
          return this.data.a
        }
        set r(t) {
          this.type.set(In.RGB), (this.changed = !0), (this.data.r = t)
        }
        set g(t) {
          this.type.set(In.RGB), (this.changed = !0), (this.data.g = t)
        }
        set b(t) {
          this.type.set(In.RGB), (this.changed = !0), (this.data.b = t)
        }
        set h(t) {
          this.type.set(In.HSL), (this.changed = !0), (this.data.h = t)
        }
        set s(t) {
          this.type.set(In.HSL), (this.changed = !0), (this.data.s = t)
        }
        set l(t) {
          this.type.set(In.HSL), (this.changed = !0), (this.data.l = t)
        }
        set a(t) {
          ;(this.changed = !0), (this.data.a = t)
        }
      }),
        (y7 = zC)
    })
  var dct,
    Wl,
    Hm = x(() => {
      'use strict'
      x7()
      ;(dct = new y7({ r: 0, g: 0, b: 0, a: 0 }, 'transparent')), (Wl = dct)
    })
  var b7,
    mu,
    WC = x(() => {
      'use strict'
      Hm()
      qm()
      ;(b7 = {
        re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
        parse: a((e) => {
          if (e.charCodeAt(0) !== 35) return
          let t = e.match(b7.re)
          if (!t) return
          let r = t[1],
            n = parseInt(r, 16),
            i = r.length,
            s = i % 4 === 0,
            o = i > 4,
            l = o ? 1 : 17,
            u = o ? 8 : 4,
            h = s ? 0 : -1,
            f = o ? 255 : 15
          return Wl.set(
            {
              r: ((n >> (u * (h + 3))) & f) * l,
              g: ((n >> (u * (h + 2))) & f) * l,
              b: ((n >> (u * (h + 1))) & f) * l,
              a: s ? ((n & f) * l) / 255 : 1,
            },
            e,
          )
        }, 'parse'),
        stringify: a((e) => {
          let { r: t, g: r, b: n, a: i } = e
          return i < 1
            ? `#${Qo[Math.round(t)]}${Qo[Math.round(r)]}${Qo[Math.round(n)]}${Qo[Math.round(i * 255)]}`
            : `#${Qo[Math.round(t)]}${Qo[Math.round(r)]}${Qo[Math.round(n)]}`
        }, 'stringify'),
      }),
        (mu = b7)
    })
  var cx,
    Ym,
    k7 = x(() => {
      'use strict'
      to()
      Hm()
      ;(cx = {
        re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
        hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
        _hue2deg: a((e) => {
          let t = e.match(cx.hueRe)
          if (t) {
            let [, r, n] = t
            switch (n) {
              case 'grad':
                return de.channel.clamp.h(parseFloat(r) * 0.9)
              case 'rad':
                return de.channel.clamp.h((parseFloat(r) * 180) / Math.PI)
              case 'turn':
                return de.channel.clamp.h(parseFloat(r) * 360)
            }
          }
          return de.channel.clamp.h(parseFloat(e))
        }, '_hue2deg'),
        parse: a((e) => {
          let t = e.charCodeAt(0)
          if (t !== 104 && t !== 72) return
          let r = e.match(cx.re)
          if (!r) return
          let [, n, i, s, o, l] = r
          return Wl.set(
            {
              h: cx._hue2deg(n),
              s: de.channel.clamp.s(parseFloat(i)),
              l: de.channel.clamp.l(parseFloat(s)),
              a: o ? de.channel.clamp.a(l ? parseFloat(o) / 100 : parseFloat(o)) : 1,
            },
            e,
          )
        }, 'parse'),
        stringify: a((e) => {
          let { h: t, s: r, l: n, a: i } = e
          return i < 1
            ? `hsla(${de.lang.round(t)}, ${de.lang.round(r)}%, ${de.lang.round(n)}%, ${i})`
            : `hsl(${de.lang.round(t)}, ${de.lang.round(r)}%, ${de.lang.round(n)}%)`
        }, 'stringify'),
      }),
        (Ym = cx)
    })
  var ux,
    UC,
    T7 = x(() => {
      'use strict'
      WC()
      ;(ux = {
        colors: {
          aliceblue: '#f0f8ff',
          antiquewhite: '#faebd7',
          aqua: '#00ffff',
          aquamarine: '#7fffd4',
          azure: '#f0ffff',
          beige: '#f5f5dc',
          bisque: '#ffe4c4',
          black: '#000000',
          blanchedalmond: '#ffebcd',
          blue: '#0000ff',
          blueviolet: '#8a2be2',
          brown: '#a52a2a',
          burlywood: '#deb887',
          cadetblue: '#5f9ea0',
          chartreuse: '#7fff00',
          chocolate: '#d2691e',
          coral: '#ff7f50',
          cornflowerblue: '#6495ed',
          cornsilk: '#fff8dc',
          crimson: '#dc143c',
          cyanaqua: '#00ffff',
          darkblue: '#00008b',
          darkcyan: '#008b8b',
          darkgoldenrod: '#b8860b',
          darkgray: '#a9a9a9',
          darkgreen: '#006400',
          darkgrey: '#a9a9a9',
          darkkhaki: '#bdb76b',
          darkmagenta: '#8b008b',
          darkolivegreen: '#556b2f',
          darkorange: '#ff8c00',
          darkorchid: '#9932cc',
          darkred: '#8b0000',
          darksalmon: '#e9967a',
          darkseagreen: '#8fbc8f',
          darkslateblue: '#483d8b',
          darkslategray: '#2f4f4f',
          darkslategrey: '#2f4f4f',
          darkturquoise: '#00ced1',
          darkviolet: '#9400d3',
          deeppink: '#ff1493',
          deepskyblue: '#00bfff',
          dimgray: '#696969',
          dimgrey: '#696969',
          dodgerblue: '#1e90ff',
          firebrick: '#b22222',
          floralwhite: '#fffaf0',
          forestgreen: '#228b22',
          fuchsia: '#ff00ff',
          gainsboro: '#dcdcdc',
          ghostwhite: '#f8f8ff',
          gold: '#ffd700',
          goldenrod: '#daa520',
          gray: '#808080',
          green: '#008000',
          greenyellow: '#adff2f',
          grey: '#808080',
          honeydew: '#f0fff0',
          hotpink: '#ff69b4',
          indianred: '#cd5c5c',
          indigo: '#4b0082',
          ivory: '#fffff0',
          khaki: '#f0e68c',
          lavender: '#e6e6fa',
          lavenderblush: '#fff0f5',
          lawngreen: '#7cfc00',
          lemonchiffon: '#fffacd',
          lightblue: '#add8e6',
          lightcoral: '#f08080',
          lightcyan: '#e0ffff',
          lightgoldenrodyellow: '#fafad2',
          lightgray: '#d3d3d3',
          lightgreen: '#90ee90',
          lightgrey: '#d3d3d3',
          lightpink: '#ffb6c1',
          lightsalmon: '#ffa07a',
          lightseagreen: '#20b2aa',
          lightskyblue: '#87cefa',
          lightslategray: '#778899',
          lightslategrey: '#778899',
          lightsteelblue: '#b0c4de',
          lightyellow: '#ffffe0',
          lime: '#00ff00',
          limegreen: '#32cd32',
          linen: '#faf0e6',
          magenta: '#ff00ff',
          maroon: '#800000',
          mediumaquamarine: '#66cdaa',
          mediumblue: '#0000cd',
          mediumorchid: '#ba55d3',
          mediumpurple: '#9370db',
          mediumseagreen: '#3cb371',
          mediumslateblue: '#7b68ee',
          mediumspringgreen: '#00fa9a',
          mediumturquoise: '#48d1cc',
          mediumvioletred: '#c71585',
          midnightblue: '#191970',
          mintcream: '#f5fffa',
          mistyrose: '#ffe4e1',
          moccasin: '#ffe4b5',
          navajowhite: '#ffdead',
          navy: '#000080',
          oldlace: '#fdf5e6',
          olive: '#808000',
          olivedrab: '#6b8e23',
          orange: '#ffa500',
          orangered: '#ff4500',
          orchid: '#da70d6',
          palegoldenrod: '#eee8aa',
          palegreen: '#98fb98',
          paleturquoise: '#afeeee',
          palevioletred: '#db7093',
          papayawhip: '#ffefd5',
          peachpuff: '#ffdab9',
          peru: '#cd853f',
          pink: '#ffc0cb',
          plum: '#dda0dd',
          powderblue: '#b0e0e6',
          purple: '#800080',
          rebeccapurple: '#663399',
          red: '#ff0000',
          rosybrown: '#bc8f8f',
          royalblue: '#4169e1',
          saddlebrown: '#8b4513',
          salmon: '#fa8072',
          sandybrown: '#f4a460',
          seagreen: '#2e8b57',
          seashell: '#fff5ee',
          sienna: '#a0522d',
          silver: '#c0c0c0',
          skyblue: '#87ceeb',
          slateblue: '#6a5acd',
          slategray: '#708090',
          slategrey: '#708090',
          snow: '#fffafa',
          springgreen: '#00ff7f',
          tan: '#d2b48c',
          teal: '#008080',
          thistle: '#d8bfd8',
          transparent: '#00000000',
          turquoise: '#40e0d0',
          violet: '#ee82ee',
          wheat: '#f5deb3',
          white: '#ffffff',
          whitesmoke: '#f5f5f5',
          yellow: '#ffff00',
          yellowgreen: '#9acd32',
        },
        parse: a((e) => {
          e = e.toLowerCase()
          let t = ux.colors[e]
          if (t) return mu.parse(t)
        }, 'parse'),
        stringify: a((e) => {
          let t = mu.stringify(e)
          for (let r in ux.colors) if (ux.colors[r] === t) return r
        }, 'stringify'),
      }),
        (UC = ux)
    })
  var S7,
    Xm,
    _7 = x(() => {
      'use strict'
      to()
      Hm()
      ;(S7 = {
        re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
        parse: a((e) => {
          let t = e.charCodeAt(0)
          if (t !== 114 && t !== 82) return
          let r = e.match(S7.re)
          if (!r) return
          let [, n, i, s, o, l, u, h, f] = r
          return Wl.set(
            {
              r: de.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
              g: de.channel.clamp.g(o ? parseFloat(s) * 2.55 : parseFloat(s)),
              b: de.channel.clamp.b(u ? parseFloat(l) * 2.55 : parseFloat(l)),
              a: h ? de.channel.clamp.a(f ? parseFloat(h) / 100 : parseFloat(h)) : 1,
            },
            e,
          )
        }, 'parse'),
        stringify: a((e) => {
          let { r: t, g: r, b: n, a: i } = e
          return i < 1
            ? `rgba(${de.lang.round(t)}, ${de.lang.round(r)}, ${de.lang.round(n)}, ${de.lang.round(i)})`
            : `rgb(${de.lang.round(t)}, ${de.lang.round(r)}, ${de.lang.round(n)})`
        }, 'stringify'),
      }),
        (Xm = S7)
    })
  var pct,
    Mn,
    Zo = x(() => {
      'use strict'
      WC()
      k7()
      T7()
      _7()
      qm()
      ;(pct = {
        format: { keyword: UC, hex: mu, rgb: Xm, rgba: Xm, hsl: Ym, hsla: Ym },
        parse: a((e) => {
          if (typeof e != 'string') return e
          let t = mu.parse(e) || Xm.parse(e) || Ym.parse(e) || UC.parse(e)
          if (t) return t
          throw new Error(`Unsupported color format: "${e}"`)
        }, 'parse'),
        stringify: a(
          (e) =>
            !e.changed && e.color
              ? e.color
              : e.type.is(In.HSL) || e.data.r === void 0
                ? Ym.stringify(e)
                : e.a < 1 || !Number.isInteger(e.r) || !Number.isInteger(e.g) || !Number.isInteger(e.b)
                  ? Xm.stringify(e)
                  : mu.stringify(e),
          'stringify',
        ),
      }),
        (Mn = pct)
    })
  var mct,
    hx,
    jC = x(() => {
      'use strict'
      to()
      Zo()
      ;(mct = a((e, t) => {
        let r = Mn.parse(e)
        for (let n in t) r[n] = de.channel.clamp[n](t[n])
        return Mn.stringify(r)
      }, 'change')),
        (hx = mct)
    })
  var gct,
    Ni,
    qC = x(() => {
      'use strict'
      to()
      Hm()
      Zo()
      jC()
      ;(gct = a((e, t, r = 0, n = 1) => {
        if (typeof e != 'number') return hx(e, { a: t })
        let i = Wl.set({
          r: de.channel.clamp.r(e),
          g: de.channel.clamp.g(t),
          b: de.channel.clamp.b(r),
          a: de.channel.clamp.a(n),
        })
        return Mn.stringify(i)
      }, 'rgba')),
        (Ni = gct)
    })
  var yct,
    gu,
    C7 = x(() => {
      'use strict'
      to()
      Zo()
      ;(yct = a((e, t) => de.lang.round(Mn.parse(e)[t]), 'channel')), (gu = yct)
    })
  var xct,
    w7,
    E7 = x(() => {
      'use strict'
      to()
      Zo()
      ;(xct = a((e) => {
        let { r: t, g: r, b: n } = Mn.parse(e),
          i = 0.2126 * de.channel.toLinear(t) + 0.7152 * de.channel.toLinear(r) + 0.0722 * de.channel.toLinear(n)
        return de.lang.round(i)
      }, 'luminance')),
        (w7 = xct)
    })
  var bct,
    v7,
    A7 = x(() => {
      'use strict'
      E7()
      ;(bct = a((e) => w7(e) >= 0.5, 'isLight')), (v7 = bct)
    })
  var kct,
    Ii,
    L7 = x(() => {
      'use strict'
      A7()
      ;(kct = a((e) => !v7(e), 'isDark')), (Ii = kct)
    })
  var Tct,
    fx,
    HC = x(() => {
      'use strict'
      to()
      Zo()
      ;(Tct = a((e, t, r) => {
        let n = Mn.parse(e),
          i = n[t],
          s = de.channel.clamp[t](i + r)
        return i !== s && (n[t] = s), Mn.stringify(n)
      }, 'adjustChannel')),
        (fx = Tct)
    })
  var Sct,
    Yt,
    R7 = x(() => {
      'use strict'
      HC()
      ;(Sct = a((e, t) => fx(e, 'l', t), 'lighten')), (Yt = Sct)
    })
  var _ct,
    ee,
    D7 = x(() => {
      'use strict'
      HC()
      ;(_ct = a((e, t) => fx(e, 'l', -t), 'darken')), (ee = _ct)
    })
  var Cct,
    ut,
    N7 = x(() => {
      'use strict'
      Zo()
      jC()
      ;(Cct = a((e, t) => {
        let r = Mn.parse(e),
          n = {}
        for (let i in t) t[i] && (n[i] = r[i] + t[i])
        return hx(e, n)
      }, 'adjust')),
        (ut = Cct)
    })
  var wct,
    I7,
    M7 = x(() => {
      'use strict'
      Zo()
      qC()
      ;(wct = a((e, t, r = 50) => {
        let { r: n, g: i, b: s, a: o } = Mn.parse(e),
          { r: l, g: u, b: h, a: f } = Mn.parse(t),
          d = r / 100,
          p = d * 2 - 1,
          m = o - f,
          y = ((p * m === -1 ? p : (p + m) / (1 + p * m)) + 1) / 2,
          b = 1 - y,
          k = n * y + l * b,
          T = i * y + u * b,
          C = s * y + h * b,
          A = o * d + f * (1 - d)
        return Ni(k, T, C, A)
      }, 'mix')),
        (I7 = wct)
    })
  var Ect,
    Ut,
    O7 = x(() => {
      'use strict'
      Zo()
      M7()
      ;(Ect = a((e, t = 100) => {
        let r = Mn.parse(e)
        return (r.r = 255 - r.r), (r.g = 255 - r.g), (r.b = 255 - r.b), I7(r, e, t)
      }, 'invert')),
        (Ut = Ect)
    })
  var P7 = x(() => {
    'use strict'
    qC()
    C7()
    L7()
    R7()
    D7()
    N7()
    O7()
  })
  var js = x(() => {
    'use strict'
    P7()
  })
  var Ul,
    jl,
    Km = x(() => {
      'use strict'
      ;(Ul = '#ffffff'), (jl = '#f2f2f2')
    })
  var En,
    lf = x(() => {
      'use strict'
      js()
      En = a((e, t) => (t ? ut(e, { s: -40, l: 10 }) : ut(e, { s: -40, l: -10 })), 'mkBorder')
    })
  var XC,
    B7,
    F7 = x(() => {
      'use strict'
      js()
      Km()
      lf()
      ;(XC = class {
        static {
          a(this, 'Theme')
        }
        constructor() {
          ;(this.background = '#f4f4f4'),
            (this.primaryColor = '#fff4dd'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = '#333'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px')
        }
        updateColors() {
          if (
            ((this.primaryTextColor = this.primaryTextColor || (this.darkMode ? '#eee' : '#333')),
            (this.secondaryColor = this.secondaryColor || ut(this.primaryColor, { h: -120 })),
            (this.tertiaryColor = this.tertiaryColor || ut(this.primaryColor, { h: 180, l: 5 })),
            (this.primaryBorderColor = this.primaryBorderColor || En(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = this.secondaryBorderColor || En(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = this.tertiaryBorderColor || En(this.tertiaryColor, this.darkMode)),
            (this.noteBorderColor = this.noteBorderColor || En(this.noteBkgColor, this.darkMode)),
            (this.noteBkgColor = this.noteBkgColor || '#fff5ad'),
            (this.noteTextColor = this.noteTextColor || '#333'),
            (this.secondaryTextColor = this.secondaryTextColor || Ut(this.secondaryColor)),
            (this.tertiaryTextColor = this.tertiaryTextColor || Ut(this.tertiaryColor)),
            (this.lineColor = this.lineColor || Ut(this.background)),
            (this.arrowheadColor = this.arrowheadColor || Ut(this.background)),
            (this.textColor = this.textColor || this.primaryTextColor),
            (this.border2 = this.border2 || this.tertiaryBorderColor),
            (this.nodeBkg = this.nodeBkg || this.primaryColor),
            (this.mainBkg = this.mainBkg || this.primaryColor),
            (this.nodeBorder = this.nodeBorder || this.primaryBorderColor),
            (this.clusterBkg = this.clusterBkg || this.tertiaryColor),
            (this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor),
            (this.defaultLinkColor = this.defaultLinkColor || this.lineColor),
            (this.titleColor = this.titleColor || this.tertiaryTextColor),
            (this.edgeLabelBackground =
              this.edgeLabelBackground || (this.darkMode ? ee(this.secondaryColor, 30) : this.secondaryColor)),
            (this.nodeTextColor = this.nodeTextColor || this.primaryTextColor),
            (this.actorBorder = this.actorBorder || this.primaryBorderColor),
            (this.actorBkg = this.actorBkg || this.mainBkg),
            (this.actorTextColor = this.actorTextColor || this.primaryTextColor),
            (this.actorLineColor = this.actorLineColor || this.actorBorder),
            (this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg),
            (this.signalColor = this.signalColor || this.textColor),
            (this.signalTextColor = this.signalTextColor || this.textColor),
            (this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder),
            (this.labelTextColor = this.labelTextColor || this.actorTextColor),
            (this.loopTextColor = this.loopTextColor || this.actorTextColor),
            (this.activationBorderColor = this.activationBorderColor || ee(this.secondaryColor, 10)),
            (this.activationBkgColor = this.activationBkgColor || this.secondaryColor),
            (this.sequenceNumberColor = this.sequenceNumberColor || Ut(this.lineColor)),
            (this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor),
            (this.altSectionBkgColor = this.altSectionBkgColor || 'white'),
            (this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor),
            (this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor),
            (this.excludeBkgColor = this.excludeBkgColor || '#eeeeee'),
            (this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor),
            (this.taskBkgColor = this.taskBkgColor || this.primaryColor),
            (this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor),
            (this.activeTaskBkgColor = this.activeTaskBkgColor || Yt(this.primaryColor, 23)),
            (this.gridColor = this.gridColor || 'lightgrey'),
            (this.doneTaskBkgColor = this.doneTaskBkgColor || 'lightgrey'),
            (this.doneTaskBorderColor = this.doneTaskBorderColor || 'grey'),
            (this.critBorderColor = this.critBorderColor || '#ff8888'),
            (this.critBkgColor = this.critBkgColor || 'red'),
            (this.todayLineColor = this.todayLineColor || 'red'),
            (this.vertLineColor = this.vertLineColor || 'navy'),
            (this.taskTextColor = this.taskTextColor || this.textColor),
            (this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor),
            (this.taskTextLightColor = this.taskTextLightColor || this.textColor),
            (this.taskTextColor = this.taskTextColor || this.primaryTextColor),
            (this.taskTextDarkColor = this.taskTextDarkColor || this.textColor),
            (this.taskTextClickableColor = this.taskTextClickableColor || '#003163'),
            (this.personBorder = this.personBorder || this.primaryBorderColor),
            (this.personBkg = this.personBkg || this.mainBkg),
            this.darkMode
              ? ((this.rowOdd = this.rowOdd || ee(this.mainBkg, 5) || '#ffffff'),
                (this.rowEven = this.rowEven || ee(this.mainBkg, 10)))
              : ((this.rowOdd = this.rowOdd || Yt(this.mainBkg, 75) || '#ffffff'),
                (this.rowEven = this.rowEven || Yt(this.mainBkg, 5))),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || this.tertiaryColor),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.specialStateColor = this.lineColor),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210, l: 150 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || ut(this.primaryColor, { h: 330 })),
            this.darkMode)
          )
            for (let r = 0; r < this.THEME_COLOR_LIMIT; r++) this['cScale' + r] = ee(this['cScale' + r], 75)
          else for (let r = 0; r < this.THEME_COLOR_LIMIT; r++) this['cScale' + r] = ee(this['cScale' + r], 25)
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this['cScaleInv' + r] = this['cScaleInv' + r] || Ut(this['cScale' + r])
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this.darkMode
              ? (this['cScalePeer' + r] = this['cScalePeer' + r] || Yt(this['cScale' + r], 10))
              : (this['cScalePeer' + r] = this['cScalePeer' + r] || ee(this['cScale' + r], 10))
          this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this['cScaleLabel' + r] = this['cScaleLabel' + r] || this.scaleLabelColor
          let t = this.darkMode ? -4 : -1
          for (let r = 0; r < 5; r++)
            (this['surface' + r] = this['surface' + r] || ut(this.mainBkg, { h: 180, s: -15, l: t * (5 + r * 3) })),
              (this['surfacePeer' + r] =
                this['surfacePeer' + r] || ut(this.mainBkg, { h: 180, s: -15, l: t * (8 + r * 3) }))
          ;(this.classText = this.classText || this.textColor),
            (this.fillType0 = this.fillType0 || this.primaryColor),
            (this.fillType1 = this.fillType1 || this.secondaryColor),
            (this.fillType2 = this.fillType2 || ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = this.fillType3 || ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = this.fillType4 || ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = this.fillType5 || ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = this.fillType6 || ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = this.fillType7 || ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -10 })),
            (this.pie6 = this.pie6 || ut(this.tertiaryColor, { l: -10 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 = this.pie8 || ut(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || ut(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 = this.pie10 || ut(this.primaryColor, { h: 60, l: -20 })),
            (this.pie11 = this.pie11 || ut(this.primaryColor, { h: -60, l: -20 })),
            (this.pie12 = this.pie12 || ut(this.primaryColor, { h: 120, l: -10 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || '#DEDEDE',
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.archEdgeColor = this.archEdgeColor || '#777'),
            (this.archEdgeArrowColor = this.archEdgeArrowColor || '#777'),
            (this.archEdgeWidth = this.archEdgeWidth || '3'),
            (this.archGroupBorderColor = this.archGroupBorderColor || '#000'),
            (this.archGroupBorderWidth = this.archGroupBorderWidth || '2px'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill = this.quadrant2Fill || ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill = this.quadrant3Fill || ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill = this.quadrant4Fill || ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill = this.quadrant2TextFill || ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill = this.quadrant3TextFill || ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill = this.quadrant4TextFill || ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ii(this.quadrant1Fill) ? Yt(this.quadrant1Fill) : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                '#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || (this.darkMode ? ee(this.secondaryColor, 30) : this.secondaryColor)),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.branchLabelColor = this.branchLabelColor || (this.darkMode ? 'black' : this.labelTextColor)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ul),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || jl)
        }
        calculate(t) {
          if (typeof t != 'object') {
            this.updateColors()
            return
          }
          let r = Object.keys(t)
          r.forEach((n) => {
            this[n] = t[n]
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n]
            })
        }
      }),
        (B7 = a((e) => {
          let t = new XC()
          return t.calculate(e), t
        }, 'getThemeVariables'))
    })
  var KC,
    $7,
    G7 = x(() => {
      'use strict'
      js()
      lf()
      ;(KC = class {
        static {
          a(this, 'Theme')
        }
        constructor() {
          ;(this.background = '#333'),
            (this.primaryColor = '#1f2020'),
            (this.secondaryColor = Yt(this.primaryColor, 16)),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = Ut(this.background)),
            (this.secondaryBorderColor = En(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = En(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.mainBkg = '#1f2020'),
            (this.secondBkg = 'calculated'),
            (this.mainContrastColor = 'lightgrey'),
            (this.darkTextColor = Yt(Ut('#323D47'), 10)),
            (this.lineColor = 'calculated'),
            (this.border1 = '#ccc'),
            (this.border2 = Ni(255, 255, 255, 0.25)),
            (this.arrowheadColor = 'calculated'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.labelBackground = '#181818'),
            (this.textColor = '#ccc'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = '#F9FFFE'),
            (this.edgeLabelBackground = 'calculated'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'calculated'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = 'calculated'),
            (this.activationBkgColor = 'calculated'),
            (this.sequenceNumberColor = 'black'),
            (this.sectionBkgColor = ee('#EAE8D9', 30)),
            (this.altSectionBkgColor = 'calculated'),
            (this.sectionBkgColor2 = '#EAE8D9'),
            (this.excludeBkgColor = ee(this.sectionBkgColor, 10)),
            (this.taskBorderColor = Ni(255, 255, 255, 70)),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextLightColor = 'calculated'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = Ni(255, 255, 255, 50)),
            (this.activeTaskBkgColor = '#81B1DB'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#E83737'),
            (this.critBkgColor = '#E83737'),
            (this.taskTextDarkColor = 'calculated'),
            (this.todayLineColor = '#DB5757'),
            (this.vertLineColor = '#00BFFF'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 5) || '#ffffff'),
            (this.rowEven = this.rowEven || ee(this.mainBkg, 10)),
            (this.labelColor = 'calculated'),
            (this.errorBkgColor = '#a44141'),
            (this.errorTextColor = '#ddd')
        }
        updateColors() {
          ;(this.secondBkg = Yt(this.mainBkg, 16)),
            (this.lineColor = this.mainContrastColor),
            (this.arrowheadColor = this.mainContrastColor),
            (this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.edgeLabelBackground = Yt(this.labelBackground, 25)),
            (this.actorBorder = this.border1),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.mainContrastColor),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.mainContrastColor),
            (this.signalTextColor = this.mainContrastColor),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.mainContrastColor),
            (this.loopTextColor = this.mainContrastColor),
            (this.noteBorderColor = this.secondaryBorderColor),
            (this.noteBkgColor = this.secondBkg),
            (this.noteTextColor = this.secondaryTextColor),
            (this.activationBorderColor = this.border1),
            (this.activationBkgColor = this.secondBkg),
            (this.altSectionBkgColor = this.background),
            (this.taskBkgColor = Yt(this.mainBkg, 23)),
            (this.taskTextColor = this.darkTextColor),
            (this.taskTextLightColor = this.mainContrastColor),
            (this.taskTextOutsideColor = this.taskTextLightColor),
            (this.gridColor = this.mainContrastColor),
            (this.doneTaskBkgColor = this.mainContrastColor),
            (this.taskTextDarkColor = this.darkTextColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#555'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = '#f4f4f4'),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.cScale1 = this.cScale1 || '#0b0000'),
            (this.cScale2 = this.cScale2 || '#4d1037'),
            (this.cScale3 = this.cScale3 || '#3f5258'),
            (this.cScale4 = this.cScale4 || '#4f2f1b'),
            (this.cScale5 = this.cScale5 || '#6e0a0a'),
            (this.cScale6 = this.cScale6 || '#3b0048'),
            (this.cScale7 = this.cScale7 || '#995a01'),
            (this.cScale8 = this.cScale8 || '#154706'),
            (this.cScale9 = this.cScale9 || '#161722'),
            (this.cScale10 = this.cScale10 || '#00296f'),
            (this.cScale11 = this.cScale11 || '#01629c'),
            (this.cScale12 = this.cScale12 || '#010029'),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || ut(this.primaryColor, { h: 330 }))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleInv' + t] = this['cScaleInv' + t] || Ut(this['cScale' + t])
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScalePeer' + t] = this['cScalePeer' + t] || Yt(this['cScale' + t], 10)
          for (let t = 0; t < 5; t++)
            (this['surface' + t] = this['surface' + t] || ut(this.mainBkg, { h: 30, s: -30, l: -(-10 + t * 4) })),
              (this['surfacePeer' + t] =
                this['surfacePeer' + t] || ut(this.mainBkg, { h: 30, s: -30, l: -(-7 + t * 4) }))
          this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? 'black' : this.labelTextColor)
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleLabel' + t] = this['cScaleLabel' + t] || this.scaleLabelColor
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this['pie' + t] = this['cScale' + t]
          ;(this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill = this.quadrant2Fill || ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill = this.quadrant3Fill || ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill = this.quadrant4Fill || ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill = this.quadrant2TextFill || ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill = this.quadrant3TextFill || ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill = this.quadrant4TextFill || ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ii(this.quadrant1Fill) ? Yt(this.quadrant1Fill) : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                '#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22',
            }),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.background,
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || '#DEDEDE',
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.classText = this.primaryTextColor),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || (this.darkMode ? ee(this.secondaryColor, 30) : this.secondaryColor)),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = Yt(this.secondaryColor, 20)),
            (this.git1 = Yt(this.pie2 || this.secondaryColor, 20)),
            (this.git2 = Yt(this.pie3 || this.tertiaryColor, 20)),
            (this.git3 = Yt(this.pie4 || ut(this.primaryColor, { h: -30 }), 20)),
            (this.git4 = Yt(this.pie5 || ut(this.primaryColor, { h: -60 }), 20)),
            (this.git5 = Yt(this.pie6 || ut(this.primaryColor, { h: -90 }), 10)),
            (this.git6 = Yt(this.pie7 || ut(this.primaryColor, { h: 60 }), 10)),
            (this.git7 = Yt(this.pie8 || ut(this.primaryColor, { h: 120 }), 20)),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Yt(this.background, 12)),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Yt(this.background, 2)),
            (this.nodeBorder = this.nodeBorder || '#999')
        }
        calculate(t) {
          if (typeof t != 'object') {
            this.updateColors()
            return
          }
          let r = Object.keys(t)
          r.forEach((n) => {
            this[n] = t[n]
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n]
            })
        }
      }),
        ($7 = a((e) => {
          let t = new KC()
          return t.calculate(e), t
        }, 'getThemeVariables'))
    })
  var QC,
    ql,
    Qm = x(() => {
      'use strict'
      js()
      lf()
      Km()
      ;(QC = class {
        static {
          a(this, 'Theme')
        }
        constructor() {
          ;(this.background = '#f4f4f4'),
            (this.primaryColor = '#ECECFF'),
            (this.secondaryColor = ut(this.primaryColor, { h: 120 })),
            (this.secondaryColor = '#ffffde'),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = En(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = En(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = En(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.background = 'white'),
            (this.mainBkg = '#ECECFF'),
            (this.secondBkg = '#ffffde'),
            (this.lineColor = '#333333'),
            (this.border1 = '#9370DB'),
            (this.border2 = '#aaaa33'),
            (this.arrowheadColor = '#333333'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.labelBackground = 'rgba(232,232,232, 0.8)'),
            (this.textColor = '#333'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = 'calculated'),
            (this.edgeLabelBackground = 'calculated'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'black'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = 'calculated'),
            (this.altSectionBkgColor = 'calculated'),
            (this.sectionBkgColor2 = 'calculated'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextLightColor = 'calculated'),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = 'calculated'),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.taskTextClickableColor = 'calculated'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'calculated'),
            (this.critBorderColor = 'calculated'),
            (this.critBkgColor = 'calculated'),
            (this.todayLineColor = 'calculated'),
            (this.vertLineColor = 'calculated'),
            (this.sectionBkgColor = Ni(102, 102, 255, 0.49)),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = '#fff400'),
            (this.taskBorderColor = '#534fbc'),
            (this.taskBkgColor = '#8a90dd'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'black'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = '#534fbc'),
            (this.activeTaskBkgColor = '#bfc7ff'),
            (this.gridColor = 'lightgrey'),
            (this.doneTaskBkgColor = 'lightgrey'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#ff8888'),
            (this.critBkgColor = 'red'),
            (this.todayLineColor = 'red'),
            (this.vertLineColor = 'navy'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = 'calculated'),
            (this.rowEven = 'calculated'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222'),
            this.updateColors()
        }
        updateColors() {
          ;(this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || ut(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 = this.cScalePeer1 || ee(this.secondaryColor, 45)),
            (this.cScalePeer2 = this.cScalePeer2 || ee(this.tertiaryColor, 40))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            (this['cScale' + t] = ee(this['cScale' + t], 10)),
              (this['cScalePeer' + t] = this['cScalePeer' + t] || ee(this['cScale' + t], 25))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleInv' + t] = this['cScaleInv' + t] || ut(this['cScale' + t], { h: 180 })
          for (let t = 0; t < 5; t++)
            (this['surface' + t] = this['surface' + t] || ut(this.mainBkg, { h: 30, l: -(5 + t * 5) })),
              (this['surfacePeer' + t] = this['surfacePeer' + t] || ut(this.mainBkg, { h: 30, l: -(7 + t * 5) }))
          if (
            ((this.scaleLabelColor =
              this.scaleLabelColor !== 'calculated' && this.scaleLabelColor
                ? this.scaleLabelColor
                : this.labelTextColor),
            this.labelTextColor !== 'calculated')
          ) {
            ;(this.cScaleLabel0 = this.cScaleLabel0 || Ut(this.labelTextColor)),
              (this.cScaleLabel3 = this.cScaleLabel3 || Ut(this.labelTextColor))
            for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
              this['cScaleLabel' + t] = this['cScaleLabel' + t] || this.labelTextColor
          }
          ;(this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.textColor),
            (this.edgeLabelBackground = this.labelBackground),
            (this.actorBorder = Yt(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.signalColor = this.textColor),
            (this.signalTextColor = this.textColor),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd = this.rowOdd || Yt(this.primaryColor, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || Yt(this.primaryColor, 1)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f0f0f0'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || ut(this.tertiaryColor, { l: -40 })),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -30 })),
            (this.pie6 = this.pie6 || ut(this.tertiaryColor, { l: -20 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -20 })),
            (this.pie8 = this.pie8 || ut(this.primaryColor, { h: -60, l: -40 })),
            (this.pie9 = this.pie9 || ut(this.primaryColor, { h: 120, l: -40 })),
            (this.pie10 = this.pie10 || ut(this.primaryColor, { h: 60, l: -40 })),
            (this.pie11 = this.pie11 || ut(this.primaryColor, { h: -90, l: -40 })),
            (this.pie12 = this.pie12 || ut(this.primaryColor, { h: 120, l: -30 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill = this.quadrant2Fill || ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill = this.quadrant3Fill || ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill = this.quadrant4Fill || ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill = this.quadrant2TextFill || ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill = this.quadrant3TextFill || ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill = this.quadrant4TextFill || ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ii(this.quadrant1Fill) ? Yt(this.quadrant1Fill) : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || '#DEDEDE',
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                '#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground = this.relationLabelBackground || this.labelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || ee(Ut(this.git0), 25)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ul),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || jl)
        }
        calculate(t) {
          if (
            (Object.keys(this).forEach((n) => {
              this[n] === 'calculated' && (this[n] = void 0)
            }),
            typeof t != 'object')
          ) {
            this.updateColors()
            return
          }
          let r = Object.keys(t)
          r.forEach((n) => {
            this[n] = t[n]
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n]
            })
        }
      }),
        (ql = a((e) => {
          let t = new QC()
          return t.calculate(e), t
        }, 'getThemeVariables'))
    })
  var ZC,
    V7,
    z7 = x(() => {
      'use strict'
      js()
      Km()
      lf()
      ;(ZC = class {
        static {
          a(this, 'Theme')
        }
        constructor() {
          ;(this.background = '#f4f4f4'),
            (this.primaryColor = '#cde498'),
            (this.secondaryColor = '#cdffb2'),
            (this.background = 'white'),
            (this.mainBkg = '#cde498'),
            (this.secondBkg = '#cdffb2'),
            (this.lineColor = 'green'),
            (this.border1 = '#13540c'),
            (this.border2 = '#6eaa49'),
            (this.arrowheadColor = 'green'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.tertiaryColor = Yt('#cde498', 10)),
            (this.primaryBorderColor = En(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = En(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = En(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.primaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = '#333'),
            (this.edgeLabelBackground = '#e8e8e8'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'black'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = '#333'),
            (this.signalTextColor = '#333'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = '#326932'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = '#6eaa49'),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = '#6eaa49'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = '#487e3a'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'black'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'lightgrey'),
            (this.doneTaskBkgColor = 'lightgrey'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#ff8888'),
            (this.critBkgColor = 'red'),
            (this.todayLineColor = 'red'),
            (this.vertLineColor = '#00BFFF'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222')
        }
        updateColors() {
          ;(this.actorBorder = ee(this.mainBkg, 20)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || ut(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 = this.cScalePeer1 || ee(this.secondaryColor, 45)),
            (this.cScalePeer2 = this.cScalePeer2 || ee(this.tertiaryColor, 40))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            (this['cScale' + t] = ee(this['cScale' + t], 10)),
              (this['cScalePeer' + t] = this['cScalePeer' + t] || ee(this['cScale' + t], 25))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleInv' + t] = this['cScaleInv' + t] || ut(this['cScale' + t], { h: 180 })
          this.scaleLabelColor =
            this.scaleLabelColor !== 'calculated' && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleLabel' + t] = this['cScaleLabel' + t] || this.scaleLabelColor
          for (let t = 0; t < 5; t++)
            (this['surface' + t] = this['surface' + t] || ut(this.mainBkg, { h: 30, s: -30, l: -(5 + t * 5) })),
              (this['surfacePeer' + t] =
                this['surfacePeer' + t] || ut(this.mainBkg, { h: 30, s: -30, l: -(8 + t * 5) }))
          ;(this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.taskBorderColor = this.border1),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || Yt(this.mainBkg, 20)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f0f0f0'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -30 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -30 })),
            (this.pie6 = this.pie6 || ut(this.tertiaryColor, { h: 40, l: -40 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 = this.pie8 || ut(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || ut(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 = this.pie10 || ut(this.primaryColor, { h: 60, l: -50 })),
            (this.pie11 = this.pie11 || ut(this.primaryColor, { h: -60, l: -50 })),
            (this.pie12 = this.pie12 || ut(this.primaryColor, { h: 120, l: -50 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill = this.quadrant2Fill || ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill = this.quadrant3Fill || ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill = this.quadrant4Fill || ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill = this.quadrant2TextFill || ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill = this.quadrant3TextFill || ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill = this.quadrant4TextFill || ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ii(this.quadrant1Fill) ? Yt(this.quadrant1Fill) : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.mainBkg,
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || '#DEDEDE',
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                '#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ul),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || jl)
        }
        calculate(t) {
          if (typeof t != 'object') {
            this.updateColors()
            return
          }
          let r = Object.keys(t)
          r.forEach((n) => {
            this[n] = t[n]
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n]
            })
        }
      }),
        (V7 = a((e) => {
          let t = new ZC()
          return t.calculate(e), t
        }, 'getThemeVariables'))
    })
  var JC,
    W7,
    U7 = x(() => {
      'use strict'
      js()
      lf()
      Km()
      ;(JC = class {
        static {
          a(this, 'Theme')
        }
        constructor() {
          ;(this.primaryColor = '#eee'),
            (this.contrast = '#707070'),
            (this.secondaryColor = Yt(this.contrast, 55)),
            (this.background = '#ffffff'),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = En(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = En(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = En(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.mainBkg = '#eee'),
            (this.secondBkg = 'calculated'),
            (this.lineColor = '#666'),
            (this.border1 = '#999'),
            (this.border2 = 'calculated'),
            (this.note = '#ffa'),
            (this.text = '#333'),
            (this.critical = '#d42'),
            (this.done = '#bbb'),
            (this.arrowheadColor = '#333333'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = 'calculated'),
            (this.edgeLabelBackground = 'white'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'calculated'),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = 'calculated'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = 'calculated'),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = 'calculated'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'calculated'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'calculated'),
            (this.critBkgColor = 'calculated'),
            (this.critBorderColor = 'calculated'),
            (this.todayLineColor = 'calculated'),
            (this.vertLineColor = 'calculated'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || '#f4f4f4'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222')
        }
        updateColors() {
          ;(this.secondBkg = Yt(this.contrast, 55)),
            (this.border2 = this.contrast),
            (this.actorBorder = Yt(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.text),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.text),
            (this.signalTextColor = this.text),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.text),
            (this.loopTextColor = this.text),
            (this.noteBorderColor = '#999'),
            (this.noteBkgColor = '#666'),
            (this.noteTextColor = '#fff'),
            (this.cScale0 = this.cScale0 || '#555'),
            (this.cScale1 = this.cScale1 || '#F4F4F4'),
            (this.cScale2 = this.cScale2 || '#555'),
            (this.cScale3 = this.cScale3 || '#BBB'),
            (this.cScale4 = this.cScale4 || '#777'),
            (this.cScale5 = this.cScale5 || '#999'),
            (this.cScale6 = this.cScale6 || '#DDD'),
            (this.cScale7 = this.cScale7 || '#FFF'),
            (this.cScale8 = this.cScale8 || '#DDD'),
            (this.cScale9 = this.cScale9 || '#BBB'),
            (this.cScale10 = this.cScale10 || '#999'),
            (this.cScale11 = this.cScale11 || '#777')
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleInv' + t] = this['cScaleInv' + t] || Ut(this['cScale' + t])
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this.darkMode
              ? (this['cScalePeer' + t] = this['cScalePeer' + t] || Yt(this['cScale' + t], 10))
              : (this['cScalePeer' + t] = this['cScalePeer' + t] || ee(this['cScale' + t], 10))
          ;(this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? 'black' : this.labelTextColor)),
            (this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1),
            (this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1)
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this['cScaleLabel' + t] = this['cScaleLabel' + t] || this.scaleLabelColor
          for (let t = 0; t < 5; t++)
            (this['surface' + t] = this['surface' + t] || ut(this.mainBkg, { l: -(5 + t * 5) })),
              (this['surfacePeer' + t] = this['surfacePeer' + t] || ut(this.mainBkg, { l: -(8 + t * 5) }))
          ;(this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.text),
            (this.sectionBkgColor = Yt(this.contrast, 30)),
            (this.sectionBkgColor2 = Yt(this.contrast, 30)),
            (this.taskBorderColor = ee(this.contrast, 10)),
            (this.taskBkgColor = this.contrast),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = this.text),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.gridColor = Yt(this.border1, 30)),
            (this.doneTaskBkgColor = this.done),
            (this.doneTaskBorderColor = this.lineColor),
            (this.critBkgColor = this.critical),
            (this.critBorderColor = ee(this.critBkgColor, 10)),
            (this.todayLineColor = this.critBkgColor),
            (this.vertLineColor = this.critBkgColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || '#000'),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f4f4f4'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.stateBorder = this.stateBorder || '#000'),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = '#222'),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 }))
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this['pie' + t] = this['cScale' + t]
          ;(this.pie12 = this.pie0),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill = this.quadrant2Fill || ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill = this.quadrant3Fill || ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill = this.quadrant4Fill || ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill = this.quadrant2TextFill || ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill = this.quadrant3TextFill || ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill = this.quadrant4TextFill || ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ii(this.quadrant1Fill) ? Yt(this.quadrant1Fill) : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                '#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0',
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || '#DEDEDE',
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = ee(this.pie1, 25) || this.primaryColor),
            (this.git1 = this.pie2 || this.secondaryColor),
            (this.git2 = this.pie3 || this.tertiaryColor),
            (this.git3 = this.pie4 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.pie5 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.pie6 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.pie7 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.pie8 || ut(this.primaryColor, { h: 120 })),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.branchLabelColor = this.branchLabelColor || this.labelTextColor),
            (this.gitBranchLabel0 = this.branchLabelColor),
            (this.gitBranchLabel1 = 'white'),
            (this.gitBranchLabel2 = this.branchLabelColor),
            (this.gitBranchLabel3 = 'white'),
            (this.gitBranchLabel4 = this.branchLabelColor),
            (this.gitBranchLabel5 = this.branchLabelColor),
            (this.gitBranchLabel6 = this.branchLabelColor),
            (this.gitBranchLabel7 = this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ul),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || jl)
        }
        calculate(t) {
          if (typeof t != 'object') {
            this.updateColors()
            return
          }
          let r = Object.keys(t)
          r.forEach((n) => {
            this[n] = t[n]
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n]
            })
        }
      }),
        (W7 = a((e) => {
          let t = new JC()
          return t.calculate(e), t
        }, 'getThemeVariables'))
    })
  var qs,
    dx = x(() => {
      'use strict'
      F7()
      G7()
      Qm()
      z7()
      U7()
      qs = {
        base: { getThemeVariables: B7 },
        dark: { getThemeVariables: $7 },
        default: { getThemeVariables: ql },
        forest: { getThemeVariables: V7 },
        neutral: { getThemeVariables: W7 },
      }
    })
  var ka,
    j7 = x(() => {
      'use strict'
      ka = {
        flowchart: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          subGraphTitleMargin: { top: 0, bottom: 0 },
          diagramPadding: 8,
          htmlLabels: !0,
          nodeSpacing: 50,
          rankSpacing: 50,
          curve: 'basis',
          padding: 15,
          defaultRenderer: 'dagre-wrapper',
          wrappingWidth: 200,
          inheritDir: !1,
        },
        sequence: {
          useMaxWidth: !0,
          hideUnusedParticipants: !1,
          activationWidth: 10,
          diagramMarginX: 50,
          diagramMarginY: 10,
          actorMargin: 50,
          width: 150,
          height: 65,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: 'center',
          mirrorActors: !0,
          forceMenus: !1,
          bottomMarginAdj: 1,
          rightAngles: !1,
          showSequenceNumbers: !1,
          actorFontSize: 14,
          actorFontFamily: '"Open Sans", sans-serif',
          actorFontWeight: 400,
          noteFontSize: 14,
          noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          noteFontWeight: 400,
          noteAlign: 'center',
          messageFontSize: 16,
          messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          messageFontWeight: 400,
          wrap: !1,
          wrapPadding: 10,
          labelBoxWidth: 50,
          labelBoxHeight: 20,
        },
        gantt: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          barHeight: 20,
          barGap: 4,
          topPadding: 50,
          rightPadding: 75,
          leftPadding: 75,
          gridLineStartPadding: 35,
          fontSize: 11,
          sectionFontSize: 11,
          numberSectionStyles: 4,
          axisFormat: '%Y-%m-%d',
          topAxis: !1,
          displayMode: '',
          weekday: 'sunday',
        },
        journey: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          leftMargin: 150,
          maxLabelWidth: 360,
          width: 150,
          height: 50,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: 'center',
          bottomMarginAdj: 1,
          rightAngles: !1,
          taskFontSize: 14,
          taskFontFamily: '"Open Sans", sans-serif',
          taskMargin: 50,
          activationWidth: 10,
          textPlacement: 'fo',
          actorColours: ['#8FBC8F', '#7CFC00', '#00FFFF', '#20B2AA', '#B0E0E6', '#FFFFE0'],
          sectionFills: ['#191970', '#8B008B', '#4B0082', '#2F4F4F', '#800000', '#8B4513', '#00008B'],
          sectionColours: ['#fff'],
          titleColor: '',
          titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          titleFontSize: '4ex',
        },
        class: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          arrowMarkerAbsolute: !1,
          dividerMargin: 10,
          padding: 5,
          textHeight: 10,
          defaultRenderer: 'dagre-wrapper',
          htmlLabels: !1,
          hideEmptyMembersBox: !1,
        },
        state: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          dividerMargin: 10,
          sizeUnit: 5,
          padding: 8,
          textHeight: 10,
          titleShift: -15,
          noteMargin: 10,
          forkWidth: 70,
          forkHeight: 7,
          miniPadding: 2,
          fontSizeFactor: 5.02,
          fontSize: 24,
          labelHeight: 16,
          edgeLengthFactor: '20',
          compositTitleSize: 35,
          radius: 5,
          defaultRenderer: 'dagre-wrapper',
        },
        er: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          diagramPadding: 20,
          layoutDirection: 'TB',
          minEntityWidth: 100,
          minEntityHeight: 75,
          entityPadding: 15,
          nodeSpacing: 140,
          rankSpacing: 80,
          stroke: 'gray',
          fill: 'honeydew',
          fontSize: 12,
        },
        pie: { useMaxWidth: !0, textPosition: 0.75 },
        quadrantChart: {
          useMaxWidth: !0,
          chartWidth: 500,
          chartHeight: 500,
          titleFontSize: 20,
          titlePadding: 10,
          quadrantPadding: 5,
          xAxisLabelPadding: 5,
          yAxisLabelPadding: 5,
          xAxisLabelFontSize: 16,
          yAxisLabelFontSize: 16,
          quadrantLabelFontSize: 16,
          quadrantTextTopPadding: 5,
          pointTextPadding: 5,
          pointLabelFontSize: 12,
          pointRadius: 5,
          xAxisPosition: 'top',
          yAxisPosition: 'left',
          quadrantInternalBorderStrokeWidth: 1,
          quadrantExternalBorderStrokeWidth: 2,
        },
        xyChart: {
          useMaxWidth: !0,
          width: 700,
          height: 500,
          titleFontSize: 20,
          titlePadding: 10,
          showDataLabel: !1,
          showTitle: !0,
          xAxis: {
            $ref: '#/$defs/XYChartAxisConfig',
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2,
          },
          yAxis: {
            $ref: '#/$defs/XYChartAxisConfig',
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2,
          },
          chartOrientation: 'vertical',
          plotReservedSpacePercent: 50,
        },
        requirement: {
          useMaxWidth: !0,
          rect_fill: '#f9f9f9',
          text_color: '#333',
          rect_border_size: '0.5px',
          rect_border_color: '#bbb',
          rect_min_width: 200,
          rect_min_height: 200,
          fontSize: 14,
          rect_padding: 10,
          line_height: 20,
        },
        mindmap: { useMaxWidth: !0, padding: 10, maxNodeWidth: 200, layoutAlgorithm: 'cose-bilkent' },
        kanban: { useMaxWidth: !0, padding: 8, sectionWidth: 200, ticketBaseUrl: '' },
        timeline: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          leftMargin: 150,
          width: 150,
          height: 50,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: 'center',
          bottomMarginAdj: 1,
          rightAngles: !1,
          taskFontSize: 14,
          taskFontFamily: '"Open Sans", sans-serif',
          taskMargin: 50,
          activationWidth: 10,
          textPlacement: 'fo',
          actorColours: ['#8FBC8F', '#7CFC00', '#00FFFF', '#20B2AA', '#B0E0E6', '#FFFFE0'],
          sectionFills: ['#191970', '#8B008B', '#4B0082', '#2F4F4F', '#800000', '#8B4513', '#00008B'],
          sectionColours: ['#fff'],
          disableMulticolor: !1,
        },
        gitGraph: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          diagramPadding: 8,
          nodeLabel: { width: 75, height: 100, x: -25, y: 0 },
          mainBranchName: 'main',
          mainBranchOrder: 0,
          showCommitLabel: !0,
          showBranches: !0,
          rotateCommitLabel: !0,
          parallelCommits: !1,
          arrowMarkerAbsolute: !1,
        },
        c4: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          c4ShapeMargin: 50,
          c4ShapePadding: 20,
          width: 216,
          height: 60,
          boxMargin: 10,
          c4ShapeInRow: 4,
          nextLinePaddingX: 0,
          c4BoundaryInRow: 2,
          personFontSize: 14,
          personFontFamily: '"Open Sans", sans-serif',
          personFontWeight: 'normal',
          external_personFontSize: 14,
          external_personFontFamily: '"Open Sans", sans-serif',
          external_personFontWeight: 'normal',
          systemFontSize: 14,
          systemFontFamily: '"Open Sans", sans-serif',
          systemFontWeight: 'normal',
          external_systemFontSize: 14,
          external_systemFontFamily: '"Open Sans", sans-serif',
          external_systemFontWeight: 'normal',
          system_dbFontSize: 14,
          system_dbFontFamily: '"Open Sans", sans-serif',
          system_dbFontWeight: 'normal',
          external_system_dbFontSize: 14,
          external_system_dbFontFamily: '"Open Sans", sans-serif',
          external_system_dbFontWeight: 'normal',
          system_queueFontSize: 14,
          system_queueFontFamily: '"Open Sans", sans-serif',
          system_queueFontWeight: 'normal',
          external_system_queueFontSize: 14,
          external_system_queueFontFamily: '"Open Sans", sans-serif',
          external_system_queueFontWeight: 'normal',
          boundaryFontSize: 14,
          boundaryFontFamily: '"Open Sans", sans-serif',
          boundaryFontWeight: 'normal',
          messageFontSize: 12,
          messageFontFamily: '"Open Sans", sans-serif',
          messageFontWeight: 'normal',
          containerFontSize: 14,
          containerFontFamily: '"Open Sans", sans-serif',
          containerFontWeight: 'normal',
          external_containerFontSize: 14,
          external_containerFontFamily: '"Open Sans", sans-serif',
          external_containerFontWeight: 'normal',
          container_dbFontSize: 14,
          container_dbFontFamily: '"Open Sans", sans-serif',
          container_dbFontWeight: 'normal',
          external_container_dbFontSize: 14,
          external_container_dbFontFamily: '"Open Sans", sans-serif',
          external_container_dbFontWeight: 'normal',
          container_queueFontSize: 14,
          container_queueFontFamily: '"Open Sans", sans-serif',
          container_queueFontWeight: 'normal',
          external_container_queueFontSize: 14,
          external_container_queueFontFamily: '"Open Sans", sans-serif',
          external_container_queueFontWeight: 'normal',
          componentFontSize: 14,
          componentFontFamily: '"Open Sans", sans-serif',
          componentFontWeight: 'normal',
          external_componentFontSize: 14,
          external_componentFontFamily: '"Open Sans", sans-serif',
          external_componentFontWeight: 'normal',
          component_dbFontSize: 14,
          component_dbFontFamily: '"Open Sans", sans-serif',
          component_dbFontWeight: 'normal',
          external_component_dbFontSize: 14,
          external_component_dbFontFamily: '"Open Sans", sans-serif',
          external_component_dbFontWeight: 'normal',
          component_queueFontSize: 14,
          component_queueFontFamily: '"Open Sans", sans-serif',
          component_queueFontWeight: 'normal',
          external_component_queueFontSize: 14,
          external_component_queueFontFamily: '"Open Sans", sans-serif',
          external_component_queueFontWeight: 'normal',
          wrap: !0,
          wrapPadding: 10,
          person_bg_color: '#08427B',
          person_border_color: '#073B6F',
          external_person_bg_color: '#686868',
          external_person_border_color: '#8A8A8A',
          system_bg_color: '#1168BD',
          system_border_color: '#3C7FC0',
          system_db_bg_color: '#1168BD',
          system_db_border_color: '#3C7FC0',
          system_queue_bg_color: '#1168BD',
          system_queue_border_color: '#3C7FC0',
          external_system_bg_color: '#999999',
          external_system_border_color: '#8A8A8A',
          external_system_db_bg_color: '#999999',
          external_system_db_border_color: '#8A8A8A',
          external_system_queue_bg_color: '#999999',
          external_system_queue_border_color: '#8A8A8A',
          container_bg_color: '#438DD5',
          container_border_color: '#3C7FC0',
          container_db_bg_color: '#438DD5',
          container_db_border_color: '#3C7FC0',
          container_queue_bg_color: '#438DD5',
          container_queue_border_color: '#3C7FC0',
          external_container_bg_color: '#B3B3B3',
          external_container_border_color: '#A6A6A6',
          external_container_db_bg_color: '#B3B3B3',
          external_container_db_border_color: '#A6A6A6',
          external_container_queue_bg_color: '#B3B3B3',
          external_container_queue_border_color: '#A6A6A6',
          component_bg_color: '#85BBF0',
          component_border_color: '#78A8D8',
          component_db_bg_color: '#85BBF0',
          component_db_border_color: '#78A8D8',
          component_queue_bg_color: '#85BBF0',
          component_queue_border_color: '#78A8D8',
          external_component_bg_color: '#CCCCCC',
          external_component_border_color: '#BFBFBF',
          external_component_db_bg_color: '#CCCCCC',
          external_component_db_border_color: '#BFBFBF',
          external_component_queue_bg_color: '#CCCCCC',
          external_component_queue_border_color: '#BFBFBF',
        },
        sankey: {
          useMaxWidth: !0,
          width: 600,
          height: 400,
          linkColor: 'gradient',
          nodeAlignment: 'justify',
          showValues: !0,
          prefix: '',
          suffix: '',
        },
        block: { useMaxWidth: !0, padding: 8 },
        packet: {
          useMaxWidth: !0,
          rowHeight: 32,
          bitWidth: 32,
          bitsPerRow: 32,
          showBits: !0,
          paddingX: 5,
          paddingY: 5,
        },
        architecture: { useMaxWidth: !0, padding: 40, iconSize: 80, fontSize: 16 },
        radar: {
          useMaxWidth: !0,
          width: 600,
          height: 600,
          marginTop: 50,
          marginRight: 50,
          marginBottom: 50,
          marginLeft: 50,
          axisScaleFactor: 1,
          axisLabelFactor: 1.05,
          curveTension: 0.17,
        },
        theme: 'default',
        look: 'classic',
        handDrawnSeed: 0,
        layout: 'dagre',
        maxTextSize: 5e4,
        maxEdges: 500,
        darkMode: !1,
        fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
        logLevel: 5,
        securityLevel: 'strict',
        startOnLoad: !0,
        arrowMarkerAbsolute: !1,
        secure: ['secure', 'securityLevel', 'startOnLoad', 'maxTextSize', 'suppressErrorRendering', 'maxEdges'],
        legacyMathML: !1,
        forceLegacyMathML: !1,
        deterministicIds: !1,
        fontSize: 16,
        markdownAutoWrap: !0,
        suppressErrorRendering: !1,
      }
    })
  var q7,
    H7,
    Y7,
    ze,
    _s = x(() => {
      'use strict'
      dx()
      j7()
      ;(q7 = {
        ...ka,
        deterministicIDSeed: void 0,
        elk: {
          mergeEdges: !1,
          nodePlacementStrategy: 'BRANDES_KOEPF',
          forceNodeModelOrder: !1,
          considerModelOrder: 'NODES_AND_EDGES',
        },
        themeCSS: void 0,
        themeVariables: qs.default.getThemeVariables(),
        sequence: {
          ...ka.sequence,
          messageFont: a(function () {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight,
            }
          }, 'messageFont'),
          noteFont: a(function () {
            return { fontFamily: this.noteFontFamily, fontSize: this.noteFontSize, fontWeight: this.noteFontWeight }
          }, 'noteFont'),
          actorFont: a(function () {
            return { fontFamily: this.actorFontFamily, fontSize: this.actorFontSize, fontWeight: this.actorFontWeight }
          }, 'actorFont'),
        },
        class: { hideEmptyMembersBox: !1 },
        gantt: { ...ka.gantt, tickInterval: void 0, useWidth: void 0 },
        c4: {
          ...ka.c4,
          useWidth: void 0,
          personFont: a(function () {
            return {
              fontFamily: this.personFontFamily,
              fontSize: this.personFontSize,
              fontWeight: this.personFontWeight,
            }
          }, 'personFont'),
          flowchart: { ...ka.flowchart, inheritDir: !1 },
          external_personFont: a(function () {
            return {
              fontFamily: this.external_personFontFamily,
              fontSize: this.external_personFontSize,
              fontWeight: this.external_personFontWeight,
            }
          }, 'external_personFont'),
          systemFont: a(function () {
            return {
              fontFamily: this.systemFontFamily,
              fontSize: this.systemFontSize,
              fontWeight: this.systemFontWeight,
            }
          }, 'systemFont'),
          external_systemFont: a(function () {
            return {
              fontFamily: this.external_systemFontFamily,
              fontSize: this.external_systemFontSize,
              fontWeight: this.external_systemFontWeight,
            }
          }, 'external_systemFont'),
          system_dbFont: a(function () {
            return {
              fontFamily: this.system_dbFontFamily,
              fontSize: this.system_dbFontSize,
              fontWeight: this.system_dbFontWeight,
            }
          }, 'system_dbFont'),
          external_system_dbFont: a(function () {
            return {
              fontFamily: this.external_system_dbFontFamily,
              fontSize: this.external_system_dbFontSize,
              fontWeight: this.external_system_dbFontWeight,
            }
          }, 'external_system_dbFont'),
          system_queueFont: a(function () {
            return {
              fontFamily: this.system_queueFontFamily,
              fontSize: this.system_queueFontSize,
              fontWeight: this.system_queueFontWeight,
            }
          }, 'system_queueFont'),
          external_system_queueFont: a(function () {
            return {
              fontFamily: this.external_system_queueFontFamily,
              fontSize: this.external_system_queueFontSize,
              fontWeight: this.external_system_queueFontWeight,
            }
          }, 'external_system_queueFont'),
          containerFont: a(function () {
            return {
              fontFamily: this.containerFontFamily,
              fontSize: this.containerFontSize,
              fontWeight: this.containerFontWeight,
            }
          }, 'containerFont'),
          external_containerFont: a(function () {
            return {
              fontFamily: this.external_containerFontFamily,
              fontSize: this.external_containerFontSize,
              fontWeight: this.external_containerFontWeight,
            }
          }, 'external_containerFont'),
          container_dbFont: a(function () {
            return {
              fontFamily: this.container_dbFontFamily,
              fontSize: this.container_dbFontSize,
              fontWeight: this.container_dbFontWeight,
            }
          }, 'container_dbFont'),
          external_container_dbFont: a(function () {
            return {
              fontFamily: this.external_container_dbFontFamily,
              fontSize: this.external_container_dbFontSize,
              fontWeight: this.external_container_dbFontWeight,
            }
          }, 'external_container_dbFont'),
          container_queueFont: a(function () {
            return {
              fontFamily: this.container_queueFontFamily,
              fontSize: this.container_queueFontSize,
              fontWeight: this.container_queueFontWeight,
            }
          }, 'container_queueFont'),
          external_container_queueFont: a(function () {
            return {
              fontFamily: this.external_container_queueFontFamily,
              fontSize: this.external_container_queueFontSize,
              fontWeight: this.external_container_queueFontWeight,
            }
          }, 'external_container_queueFont'),
          componentFont: a(function () {
            return {
              fontFamily: this.componentFontFamily,
              fontSize: this.componentFontSize,
              fontWeight: this.componentFontWeight,
            }
          }, 'componentFont'),
          external_componentFont: a(function () {
            return {
              fontFamily: this.external_componentFontFamily,
              fontSize: this.external_componentFontSize,
              fontWeight: this.external_componentFontWeight,
            }
          }, 'external_componentFont'),
          component_dbFont: a(function () {
            return {
              fontFamily: this.component_dbFontFamily,
              fontSize: this.component_dbFontSize,
              fontWeight: this.component_dbFontWeight,
            }
          }, 'component_dbFont'),
          external_component_dbFont: a(function () {
            return {
              fontFamily: this.external_component_dbFontFamily,
              fontSize: this.external_component_dbFontSize,
              fontWeight: this.external_component_dbFontWeight,
            }
          }, 'external_component_dbFont'),
          component_queueFont: a(function () {
            return {
              fontFamily: this.component_queueFontFamily,
              fontSize: this.component_queueFontSize,
              fontWeight: this.component_queueFontWeight,
            }
          }, 'component_queueFont'),
          external_component_queueFont: a(function () {
            return {
              fontFamily: this.external_component_queueFontFamily,
              fontSize: this.external_component_queueFontSize,
              fontWeight: this.external_component_queueFontWeight,
            }
          }, 'external_component_queueFont'),
          boundaryFont: a(function () {
            return {
              fontFamily: this.boundaryFontFamily,
              fontSize: this.boundaryFontSize,
              fontWeight: this.boundaryFontWeight,
            }
          }, 'boundaryFont'),
          messageFont: a(function () {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight,
            }
          }, 'messageFont'),
        },
        pie: { ...ka.pie, useWidth: 984 },
        xyChart: { ...ka.xyChart, useWidth: void 0 },
        requirement: { ...ka.requirement, useWidth: void 0 },
        packet: { ...ka.packet },
        radar: { ...ka.radar },
        treemap: {
          useMaxWidth: !0,
          padding: 10,
          diagramPadding: 8,
          showValues: !0,
          nodeWidth: 100,
          nodeHeight: 40,
          borderWidth: 1,
          valueFontSize: 12,
          labelFontSize: 14,
          valueFormat: ',',
        },
      }),
        (H7 = a(
          (e, t = '') =>
            Object.keys(e).reduce(
              (r, n) =>
                Array.isArray(e[n])
                  ? r
                  : typeof e[n] == 'object' && e[n] !== null
                    ? [...r, t + n, ...H7(e[n], '')]
                    : [...r, t + n],
              [],
            ),
          'keyify',
        )),
        (Y7 = new Set(H7(q7, ''))),
        (ze = q7)
    })
  var cf,
    vct,
    tw = x(() => {
      'use strict'
      _s()
      Vt()
      ;(cf = a((e) => {
        if ((B.debug('sanitizeDirective called with', e), !(typeof e != 'object' || e == null))) {
          if (Array.isArray(e)) {
            e.forEach((t) => cf(t))
            return
          }
          for (let t of Object.keys(e)) {
            if (
              (B.debug('Checking key', t),
              t.startsWith('__') || t.includes('proto') || t.includes('constr') || !Y7.has(t) || e[t] == null)
            ) {
              B.debug('sanitize deleting key: ', t), delete e[t]
              continue
            }
            if (typeof e[t] == 'object') {
              B.debug('sanitizing object', t), cf(e[t])
              continue
            }
            let r = ['themeCSS', 'fontFamily', 'altFontFamily']
            for (let n of r) t.includes(n) && (B.debug('sanitizing css option', t), (e[t] = vct(e[t])))
          }
          if (e.themeVariables)
            for (let t of Object.keys(e.themeVariables)) {
              let r = e.themeVariables[t]
              r?.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (e.themeVariables[t] = '')
            }
          B.debug('After sanitization', e)
        }
      }, 'sanitizeDirective')),
        (vct = a((e) => {
          let t = 0,
            r = 0
          for (let n of e) {
            if (t < r) return '{ /* ERROR: Unbalanced CSS */ }'
            n === '{' ? t++ : n === '}' && r++
          }
          return t !== r ? '{ /* ERROR: Unbalanced CSS */ }' : e
        }, 'sanitizeCss'))
    })
  var Hl,
    ts,
    K7,
    uf,
    Zm,
    px,
    ew,
    Q7,
    Z7,
    rw,
    mx,
    Te,
    J7,
    tI,
    Jm,
    Act,
    X7,
    Lct,
    eI,
    fn = x(() => {
      'use strict'
      of()
      Vt()
      dx()
      _s()
      tw()
      ;(Hl = Object.freeze(ze)),
        (ts = Kr({}, Hl)),
        (uf = []),
        (Zm = Kr({}, Hl)),
        (px = a((e, t) => {
          let r = Kr({}, e),
            n = {}
          for (let i of t) J7(i), (n = Kr(n, i))
          if (((r = Kr(r, n)), n.theme && n.theme in qs)) {
            let i = Kr({}, K7),
              s = Kr(i.themeVariables || {}, n.themeVariables)
            r.theme && r.theme in qs && (r.themeVariables = qs[r.theme].getThemeVariables(s))
          }
          return (Zm = r), eI(Zm), Zm
        }, 'updateCurrentConfig')),
        (ew = a(
          (e) => (
            (ts = Kr({}, Hl)),
            (ts = Kr(ts, e)),
            e.theme && qs[e.theme] && (ts.themeVariables = qs[e.theme].getThemeVariables(e.themeVariables)),
            px(ts, uf),
            ts
          ),
          'setSiteConfig',
        )),
        (Q7 = a((e) => {
          K7 = Kr({}, e)
        }, 'saveConfigFromInitialize')),
        (Z7 = a((e) => ((ts = Kr(ts, e)), px(ts, uf), ts), 'updateSiteConfig')),
        (rw = a(() => Kr({}, ts), 'getSiteConfig')),
        (mx = a((e) => (eI(e), Kr(Zm, e), Te()), 'setConfig')),
        (Te = a(() => Kr({}, Zm), 'getConfig')),
        (J7 = a((e) => {
          e &&
            (['secure', ...(ts.secure ?? [])].forEach((t) => {
              Object.hasOwn(e, t) && (B.debug(`Denied attempt to modify a secure key ${t}`, e[t]), delete e[t])
            }),
            Object.keys(e).forEach((t) => {
              t.startsWith('__') && delete e[t]
            }),
            Object.keys(e).forEach((t) => {
              typeof e[t] == 'string' &&
                (e[t].includes('<') || e[t].includes('>') || e[t].includes('url(data:')) &&
                delete e[t],
                typeof e[t] == 'object' && J7(e[t])
            }))
        }, 'sanitize')),
        (tI = a((e) => {
          cf(e),
            e.fontFamily &&
              !e.themeVariables?.fontFamily &&
              (e.themeVariables = { ...e.themeVariables, fontFamily: e.fontFamily }),
            uf.push(e),
            px(ts, uf)
        }, 'addDirective')),
        (Jm = a((e = ts) => {
          ;(uf = []), px(e, uf)
        }, 'reset')),
        (Act = {
          LAZY_LOAD_DEPRECATED:
            'The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.',
        }),
        (X7 = {}),
        (Lct = a((e) => {
          X7[e] || (B.warn(Act[e]), (X7[e] = !0))
        }, 'issueWarning')),
        (eI = a((e) => {
          e && (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && Lct('LAZY_LOAD_DEPRECATED')
        }, 'checkConfig'))
    })
  function Pi(e) {
    return function (t) {
      t instanceof RegExp && (t.lastIndex = 0)
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i]
      return lw(e, t, n)
    }
  }
  function Bct(e) {
    return function () {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n]
      return cw(e, r)
    }
  }
  function He(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xx
    rI && rI(e, null)
    let n = t.length
    for (; n--; ) {
      let i = t[n]
      if (typeof i == 'string') {
        let s = r(i)
        s !== i && (Rct(t) || (t[n] = s), (i = s))
      }
      e[i] = !0
    }
    return e
  }
  function Fct(e) {
    for (let t = 0; t < e.length; t++) Ta(e, t) || (e[t] = null)
    return e
  }
  function Jo(e) {
    let t = fI(null)
    for (let [r, n] of hI(e))
      Ta(e, r) &&
        (Array.isArray(n)
          ? (t[r] = Fct(n))
          : n && typeof n == 'object' && n.constructor === Object
            ? (t[r] = Jo(n))
            : (t[r] = n))
    return t
  }
  function ng(e, t) {
    for (; e !== null; ) {
      let n = Nct(e, t)
      if (n) {
        if (n.get) return Pi(n.get)
        if (typeof n.value == 'function') return Pi(n.value)
      }
      e = Dct(e)
    }
    function r() {
      return null
    }
    return a(r, 'fallbackValue'), r
  }
  function mI() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Xct(),
      t = a((Zt) => mI(Zt), 'DOMPurify')
    if (
      ((t.version = '3.2.6'), (t.removed = []), !e || !e.document || e.document.nodeType !== ig.document || !e.Element)
    )
      return (t.isSupported = !1), t
    let { document: r } = e,
      n = r,
      i = n.currentScript,
      {
        DocumentFragment: s,
        HTMLTemplateElement: o,
        Node: l,
        Element: u,
        NodeFilter: h,
        NamedNodeMap: f = e.NamedNodeMap || e.MozNamedAttrMap,
        HTMLFormElement: d,
        DOMParser: p,
        trustedTypes: m,
      } = e,
      g = u.prototype,
      y = ng(g, 'cloneNode'),
      b = ng(g, 'remove'),
      k = ng(g, 'nextSibling'),
      T = ng(g, 'childNodes'),
      C = ng(g, 'parentNode')
    if (typeof o == 'function') {
      let Zt = r.createElement('template')
      Zt.content && Zt.content.ownerDocument && (r = Zt.content.ownerDocument)
    }
    let A,
      w = '',
      { implementation: D, createNodeIterator: G, createDocumentFragment: v, getElementsByTagName: R } = r,
      { importNode: F } = n,
      S = uI()
    t.isSupported = typeof hI == 'function' && typeof C == 'function' && D && D.createHTMLDocument !== void 0
    let {
        MUSTACHE_EXPR: O,
        ERB_EXPR: E,
        TMPLIT_EXPR: _,
        DATA_ATTR: L,
        ARIA_ATTR: N,
        IS_SCRIPT_OR_DATA: P,
        ATTR_WHITESPACE: I,
        CUSTOM_ELEMENT: M,
      } = cI,
      { IS_ALLOWED_URI: V } = cI,
      $ = null,
      q = He({}, [...sI, ...iw, ...sw, ...aw, ...aI]),
      tt = null,
      ft = He({}, [...oI, ...ow, ...lI, ...yx]),
      H = Object.seal(
        fI(null, {
          tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 },
        }),
      ),
      kt = null,
      ht = null,
      yt = !0,
      ot = !0,
      dt = !1,
      it = !0,
      Q = !1,
      et = !0,
      X = !1,
      st = !1,
      U = !1,
      gt = !1,
      z = !1,
      ge = !1,
      lt = !0,
      jt = !1,
      Me = 'user-content-',
      se = !0,
      Nt = !1,
      At = {},
      bt = null,
      ct = He({}, [
        'annotation-xml',
        'audio',
        'colgroup',
        'desc',
        'foreignobject',
        'head',
        'iframe',
        'math',
        'mi',
        'mn',
        'mo',
        'ms',
        'mtext',
        'noembed',
        'noframes',
        'noscript',
        'plaintext',
        'script',
        'style',
        'svg',
        'template',
        'thead',
        'title',
        'video',
        'xmp',
      ]),
      Lt = null,
      Z = He({}, ['audio', 'video', 'img', 'source', 'image', 'track']),
      Mt = null,
      W = He({}, [
        'alt',
        'class',
        'for',
        'id',
        'label',
        'name',
        'pattern',
        'placeholder',
        'role',
        'summary',
        'title',
        'value',
        'style',
        'xmlns',
      ]),
      Gt = 'http://www.w3.org/1998/Math/MathML',
      j = 'http://www.w3.org/2000/svg',
      vt = 'http://www.w3.org/1999/xhtml',
      mt = vt,
      Xt = !1,
      Ft = null,
      _t = He({}, [Gt, j, vt], nw),
      Qe = He({}, ['mi', 'mo', 'mn', 'ms', 'mtext']),
      It = He({}, ['annotation-xml']),
      xr = He({}, ['title', 'style', 'font', 'a', 'script']),
      Ze = null,
      yn = ['application/xhtml+xml', 'text/html'],
      Ae = 'text/html',
      Se = null,
      Je = null,
      _e = r.createElement('form'),
      hr = a(function (nt) {
        return nt instanceof RegExp || nt instanceof Function
      }, 'isRegexOrFunction'),
      Cn = a(function () {
        let nt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        if (!(Je && Je === nt)) {
          if (
            ((!nt || typeof nt != 'object') && (nt = {}),
            (nt = Jo(nt)),
            (Ze = yn.indexOf(nt.PARSER_MEDIA_TYPE) === -1 ? Ae : nt.PARSER_MEDIA_TYPE),
            (Se = Ze === 'application/xhtml+xml' ? nw : xx),
            ($ = Ta(nt, 'ALLOWED_TAGS') ? He({}, nt.ALLOWED_TAGS, Se) : q),
            (tt = Ta(nt, 'ALLOWED_ATTR') ? He({}, nt.ALLOWED_ATTR, Se) : ft),
            (Ft = Ta(nt, 'ALLOWED_NAMESPACES') ? He({}, nt.ALLOWED_NAMESPACES, nw) : _t),
            (Mt = Ta(nt, 'ADD_URI_SAFE_ATTR') ? He(Jo(W), nt.ADD_URI_SAFE_ATTR, Se) : W),
            (Lt = Ta(nt, 'ADD_DATA_URI_TAGS') ? He(Jo(Z), nt.ADD_DATA_URI_TAGS, Se) : Z),
            (bt = Ta(nt, 'FORBID_CONTENTS') ? He({}, nt.FORBID_CONTENTS, Se) : ct),
            (kt = Ta(nt, 'FORBID_TAGS') ? He({}, nt.FORBID_TAGS, Se) : Jo({})),
            (ht = Ta(nt, 'FORBID_ATTR') ? He({}, nt.FORBID_ATTR, Se) : Jo({})),
            (At = Ta(nt, 'USE_PROFILES') ? nt.USE_PROFILES : !1),
            (yt = nt.ALLOW_ARIA_ATTR !== !1),
            (ot = nt.ALLOW_DATA_ATTR !== !1),
            (dt = nt.ALLOW_UNKNOWN_PROTOCOLS || !1),
            (it = nt.ALLOW_SELF_CLOSE_IN_ATTR !== !1),
            (Q = nt.SAFE_FOR_TEMPLATES || !1),
            (et = nt.SAFE_FOR_XML !== !1),
            (X = nt.WHOLE_DOCUMENT || !1),
            (gt = nt.RETURN_DOM || !1),
            (z = nt.RETURN_DOM_FRAGMENT || !1),
            (ge = nt.RETURN_TRUSTED_TYPE || !1),
            (U = nt.FORCE_BODY || !1),
            (lt = nt.SANITIZE_DOM !== !1),
            (jt = nt.SANITIZE_NAMED_PROPS || !1),
            (se = nt.KEEP_CONTENT !== !1),
            (Nt = nt.IN_PLACE || !1),
            (V = nt.ALLOWED_URI_REGEXP || dI),
            (mt = nt.NAMESPACE || vt),
            (Qe = nt.MATHML_TEXT_INTEGRATION_POINTS || Qe),
            (It = nt.HTML_INTEGRATION_POINTS || It),
            (H = nt.CUSTOM_ELEMENT_HANDLING || {}),
            nt.CUSTOM_ELEMENT_HANDLING &&
              hr(nt.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
              (H.tagNameCheck = nt.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
            nt.CUSTOM_ELEMENT_HANDLING &&
              hr(nt.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
              (H.attributeNameCheck = nt.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
            nt.CUSTOM_ELEMENT_HANDLING &&
              typeof nt.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == 'boolean' &&
              (H.allowCustomizedBuiltInElements = nt.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
            Q && (ot = !1),
            z && (gt = !0),
            At &&
              (($ = He({}, aI)),
              (tt = []),
              At.html === !0 && (He($, sI), He(tt, oI)),
              At.svg === !0 && (He($, iw), He(tt, ow), He(tt, yx)),
              At.svgFilters === !0 && (He($, sw), He(tt, ow), He(tt, yx)),
              At.mathMl === !0 && (He($, aw), He(tt, lI), He(tt, yx))),
            nt.ADD_TAGS && ($ === q && ($ = Jo($)), He($, nt.ADD_TAGS, Se)),
            nt.ADD_ATTR && (tt === ft && (tt = Jo(tt)), He(tt, nt.ADD_ATTR, Se)),
            nt.ADD_URI_SAFE_ATTR && He(Mt, nt.ADD_URI_SAFE_ATTR, Se),
            nt.FORBID_CONTENTS && (bt === ct && (bt = Jo(bt)), He(bt, nt.FORBID_CONTENTS, Se)),
            se && ($['#text'] = !0),
            X && He($, ['html', 'head', 'body']),
            $.table && (He($, ['tbody']), delete kt.tbody),
            nt.TRUSTED_TYPES_POLICY)
          ) {
            if (typeof nt.TRUSTED_TYPES_POLICY.createHTML != 'function')
              throw rg('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.')
            if (typeof nt.TRUSTED_TYPES_POLICY.createScriptURL != 'function')
              throw rg('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.')
            ;(A = nt.TRUSTED_TYPES_POLICY), (w = A.createHTML(''))
          } else A === void 0 && (A = Kct(m, i)), A !== null && typeof w == 'string' && (w = A.createHTML(''))
          Oi && Oi(nt), (Je = nt)
        }
      }, '_parseConfig'),
      ve = He({}, [...iw, ...sw, ...$ct]),
      $e = He({}, [...aw, ...Gct]),
      Le = a(function (nt) {
        let $t = C(nt)
        ;(!$t || !$t.tagName) && ($t = { namespaceURI: mt, tagName: 'template' })
        let Kt = xx(nt.tagName),
          or = xx($t.tagName)
        return Ft[nt.namespaceURI]
          ? nt.namespaceURI === j
            ? $t.namespaceURI === vt
              ? Kt === 'svg'
              : $t.namespaceURI === Gt
                ? Kt === 'svg' && (or === 'annotation-xml' || Qe[or])
                : !!ve[Kt]
            : nt.namespaceURI === Gt
              ? $t.namespaceURI === vt
                ? Kt === 'math'
                : $t.namespaceURI === j
                  ? Kt === 'math' && It[or]
                  : !!$e[Kt]
              : nt.namespaceURI === vt
                ? ($t.namespaceURI === j && !It[or]) || ($t.namespaceURI === Gt && !Qe[or])
                  ? !1
                  : !$e[Kt] && (xr[Kt] || !ve[Kt])
                : !!(Ze === 'application/xhtml+xml' && Ft[nt.namespaceURI])
          : !1
      }, '_checkValidNamespace'),
      xe = a(function (nt) {
        tg(t.removed, { element: nt })
        try {
          C(nt).removeChild(nt)
        } catch {
          b(nt)
        }
      }, '_forceRemove'),
      ce = a(function (nt, $t) {
        try {
          tg(t.removed, { attribute: $t.getAttributeNode(nt), from: $t })
        } catch {
          tg(t.removed, { attribute: null, from: $t })
        }
        if (($t.removeAttribute(nt), nt === 'is'))
          if (gt || z)
            try {
              xe($t)
            } catch {}
          else
            try {
              $t.setAttribute(nt, '')
            } catch {}
      }, '_removeAttribute'),
      ye = a(function (nt) {
        let $t = null,
          Kt = null
        if (U) nt = '<remove></remove>' + nt
        else {
          let hn = iI(nt, /^[\r\n\t ]+/)
          Kt = hn && hn[0]
        }
        Ze === 'application/xhtml+xml' &&
          mt === vt &&
          (nt = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + nt + '</body></html>')
        let or = A ? A.createHTML(nt) : nt
        if (mt === vt)
          try {
            $t = new p().parseFromString(or, Ze)
          } catch {}
        if (!$t || !$t.documentElement) {
          $t = D.createDocument(mt, 'template', null)
          try {
            $t.documentElement.innerHTML = Xt ? w : or
          } catch {}
        }
        let an = $t.body || $t.documentElement
        return (
          nt && Kt && an.insertBefore(r.createTextNode(Kt), an.childNodes[0] || null),
          mt === vt ? R.call($t, X ? 'html' : 'body')[0] : X ? $t.documentElement : an
        )
      }, '_initDocument'),
      be = a(function (nt) {
        return G.call(
          nt.ownerDocument || nt,
          nt,
          h.SHOW_ELEMENT | h.SHOW_COMMENT | h.SHOW_TEXT | h.SHOW_PROCESSING_INSTRUCTION | h.SHOW_CDATA_SECTION,
          null,
        )
      }, '_createNodeIterator'),
      Ht = a(function (nt) {
        return (
          nt instanceof d &&
          (typeof nt.nodeName != 'string' ||
            typeof nt.textContent != 'string' ||
            typeof nt.removeChild != 'function' ||
            !(nt.attributes instanceof f) ||
            typeof nt.removeAttribute != 'function' ||
            typeof nt.setAttribute != 'function' ||
            typeof nt.namespaceURI != 'string' ||
            typeof nt.insertBefore != 'function' ||
            typeof nt.hasChildNodes != 'function')
        )
      }, '_isClobbered'),
      Nn = a(function (nt) {
        return typeof l == 'function' && nt instanceof l
      }, '_isNode')
    function ne(Zt, nt, $t) {
      gx(Zt, (Kt) => {
        Kt.call(t, nt, $t, Je)
      })
    }
    a(ne, '_executeHooks')
    let Ri = a(function (nt) {
        let $t = null
        if ((ne(S.beforeSanitizeElements, nt, null), Ht(nt))) return xe(nt), !0
        let Kt = Se(nt.nodeName)
        if (
          (ne(S.uponSanitizeElement, nt, { tagName: Kt, allowedTags: $ }),
          (et &&
            nt.hasChildNodes() &&
            !Nn(nt.firstElementChild) &&
            Mi(/<[/\w!]/g, nt.innerHTML) &&
            Mi(/<[/\w!]/g, nt.textContent)) ||
            nt.nodeType === ig.progressingInstruction ||
            (et && nt.nodeType === ig.comment && Mi(/<[/\w]/g, nt.data)))
        )
          return xe(nt), !0
        if (!$[Kt] || kt[Kt]) {
          if (
            !kt[Kt] &&
            Br(Kt) &&
            ((H.tagNameCheck instanceof RegExp && Mi(H.tagNameCheck, Kt)) ||
              (H.tagNameCheck instanceof Function && H.tagNameCheck(Kt)))
          )
            return !1
          if (se && !bt[Kt]) {
            let or = C(nt) || nt.parentNode,
              an = T(nt) || nt.childNodes
            if (an && or) {
              let hn = an.length
              for (let jr = hn - 1; jr >= 0; --jr) {
                let ks = y(an[jr], !0)
                ;(ks.__removalCount = (nt.__removalCount || 0) + 1), or.insertBefore(ks, k(nt))
              }
            }
          }
          return xe(nt), !0
        }
        return (nt instanceof u && !Le(nt)) ||
          ((Kt === 'noscript' || Kt === 'noembed' || Kt === 'noframes') &&
            Mi(/<\/no(script|embed|frames)/i, nt.innerHTML))
          ? (xe(nt), !0)
          : (Q &&
              nt.nodeType === ig.text &&
              (($t = nt.textContent),
              gx([O, E, _], (or) => {
                $t = eg($t, or, ' ')
              }),
              nt.textContent !== $t && (tg(t.removed, { element: nt.cloneNode() }), (nt.textContent = $t))),
            ne(S.afterSanitizeElements, nt, null),
            !1)
      }, '_sanitizeElements'),
      xn = a(function (nt, $t, Kt) {
        if (lt && ($t === 'id' || $t === 'name') && (Kt in r || Kt in _e)) return !1
        if (!(ot && !ht[$t] && Mi(L, $t))) {
          if (!(yt && Mi(N, $t))) {
            if (!tt[$t] || ht[$t]) {
              if (
                !(
                  (Br(nt) &&
                    ((H.tagNameCheck instanceof RegExp && Mi(H.tagNameCheck, nt)) ||
                      (H.tagNameCheck instanceof Function && H.tagNameCheck(nt))) &&
                    ((H.attributeNameCheck instanceof RegExp && Mi(H.attributeNameCheck, $t)) ||
                      (H.attributeNameCheck instanceof Function && H.attributeNameCheck($t)))) ||
                  ($t === 'is' &&
                    H.allowCustomizedBuiltInElements &&
                    ((H.tagNameCheck instanceof RegExp && Mi(H.tagNameCheck, Kt)) ||
                      (H.tagNameCheck instanceof Function && H.tagNameCheck(Kt))))
                )
              )
                return !1
            } else if (!Mt[$t]) {
              if (!Mi(V, eg(Kt, I, ''))) {
                if (
                  !(
                    ($t === 'src' || $t === 'xlink:href' || $t === 'href') &&
                    nt !== 'script' &&
                    Oct(Kt, 'data:') === 0 &&
                    Lt[nt]
                  )
                ) {
                  if (!(dt && !Mi(P, eg(Kt, I, '')))) {
                    if (Kt) return !1
                  }
                }
              }
            }
          }
        }
        return !0
      }, '_isValidAttribute'),
      Br = a(function (nt) {
        return nt !== 'annotation-xml' && iI(nt, M)
      }, '_isBasicCustomElement'),
      vr = a(function (nt) {
        ne(S.beforeSanitizeAttributes, nt, null)
        let { attributes: $t } = nt
        if (!$t || Ht(nt)) return
        let Kt = { attrName: '', attrValue: '', keepAttr: !0, allowedAttributes: tt, forceKeepAttr: void 0 },
          or = $t.length
        for (; or--; ) {
          let an = $t[or],
            { name: hn, namespaceURI: jr, value: ks } = an,
            uu = Se(hn),
            hu = ks,
            qr = hn === 'value' ? hu : Pct(hu)
          if (
            ((Kt.attrName = uu),
            (Kt.attrValue = qr),
            (Kt.keepAttr = !0),
            (Kt.forceKeepAttr = void 0),
            ne(S.uponSanitizeAttribute, nt, Kt),
            (qr = Kt.attrValue),
            jt && (uu === 'id' || uu === 'name') && (ce(hn, nt), (qr = Me + qr)),
            et && Mi(/((--!?|])>)|<\/(style|title)/i, qr))
          ) {
            ce(hn, nt)
            continue
          }
          if (Kt.forceKeepAttr) continue
          if (!Kt.keepAttr) {
            ce(hn, nt)
            continue
          }
          if (!it && Mi(/\/>/i, qr)) {
            ce(hn, nt)
            continue
          }
          Q &&
            gx([O, E, _], (ke) => {
              qr = eg(qr, ke, ' ')
            })
          let ue = Se(nt.nodeName)
          if (!xn(ue, uu, qr)) {
            ce(hn, nt)
            continue
          }
          if (A && typeof m == 'object' && typeof m.getAttributeType == 'function' && !jr)
            switch (m.getAttributeType(ue, uu)) {
              case 'TrustedHTML': {
                qr = A.createHTML(qr)
                break
              }
              case 'TrustedScriptURL': {
                qr = A.createScriptURL(qr)
                break
              }
            }
          if (qr !== hu)
            try {
              jr ? nt.setAttributeNS(jr, hn, qr) : nt.setAttribute(hn, qr), Ht(nt) ? xe(nt) : nI(t.removed)
            } catch {
              ce(hn, nt)
            }
        }
        ne(S.afterSanitizeAttributes, nt, null)
      }, '_sanitizeAttributes'),
      mi = a(function Zt(nt) {
        let $t = null,
          Kt = be(nt)
        for (ne(S.beforeSanitizeShadowDOM, nt, null); ($t = Kt.nextNode()); )
          ne(S.uponSanitizeShadowNode, $t, null), Ri($t), vr($t), $t.content instanceof s && Zt($t.content)
        ne(S.afterSanitizeShadowDOM, nt, null)
      }, '_sanitizeShadowDOM')
    return (
      (t.sanitize = function (Zt) {
        let nt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          $t = null,
          Kt = null,
          or = null,
          an = null
        if (((Xt = !Zt), Xt && (Zt = '<!-->'), typeof Zt != 'string' && !Nn(Zt)))
          if (typeof Zt.toString == 'function') {
            if (((Zt = Zt.toString()), typeof Zt != 'string')) throw rg('dirty is not a string, aborting')
          } else throw rg('toString is not a function')
        if (!t.isSupported) return Zt
        if ((st || Cn(nt), (t.removed = []), typeof Zt == 'string' && (Nt = !1), Nt)) {
          if (Zt.nodeName) {
            let ks = Se(Zt.nodeName)
            if (!$[ks] || kt[ks]) throw rg('root node is forbidden and cannot be sanitized in-place')
          }
        } else if (Zt instanceof l)
          ($t = ye('<!---->')),
            (Kt = $t.ownerDocument.importNode(Zt, !0)),
            (Kt.nodeType === ig.element && Kt.nodeName === 'BODY') || Kt.nodeName === 'HTML'
              ? ($t = Kt)
              : $t.appendChild(Kt)
        else {
          if (!gt && !Q && !X && Zt.indexOf('<') === -1) return A && ge ? A.createHTML(Zt) : Zt
          if ((($t = ye(Zt)), !$t)) return gt ? null : ge ? w : ''
        }
        $t && U && xe($t.firstChild)
        let hn = be(Nt ? Zt : $t)
        for (; (or = hn.nextNode()); ) Ri(or), vr(or), or.content instanceof s && mi(or.content)
        if (Nt) return Zt
        if (gt) {
          if (z) for (an = v.call($t.ownerDocument); $t.firstChild; ) an.appendChild($t.firstChild)
          else an = $t
          return (tt.shadowroot || tt.shadowrootmode) && (an = F.call(n, an, !0)), an
        }
        let jr = X ? $t.outerHTML : $t.innerHTML
        return (
          X &&
            $['!doctype'] &&
            $t.ownerDocument &&
            $t.ownerDocument.doctype &&
            $t.ownerDocument.doctype.name &&
            Mi(pI, $t.ownerDocument.doctype.name) &&
            (jr =
              '<!DOCTYPE ' +
              $t.ownerDocument.doctype.name +
              `>
` +
              jr),
          Q &&
            gx([O, E, _], (ks) => {
              jr = eg(jr, ks, ' ')
            }),
          A && ge ? A.createHTML(jr) : jr
        )
      }),
      (t.setConfig = function () {
        let Zt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        Cn(Zt), (st = !0)
      }),
      (t.clearConfig = function () {
        ;(Je = null), (st = !1)
      }),
      (t.isValidAttribute = function (Zt, nt, $t) {
        Je || Cn({})
        let Kt = Se(Zt),
          or = Se(nt)
        return xn(Kt, or, $t)
      }),
      (t.addHook = function (Zt, nt) {
        typeof nt == 'function' && tg(S[Zt], nt)
      }),
      (t.removeHook = function (Zt, nt) {
        if (nt !== void 0) {
          let $t = Ict(S[Zt], nt)
          return $t === -1 ? void 0 : Mct(S[Zt], $t, 1)[0]
        }
        return nI(S[Zt])
      }),
      (t.removeHooks = function (Zt) {
        S[Zt] = []
      }),
      (t.removeAllHooks = function () {
        S = uI()
      }),
      t
    )
  }
  var hI,
    rI,
    Rct,
    Dct,
    Nct,
    Oi,
    Hs,
    fI,
    lw,
    cw,
    gx,
    Ict,
    nI,
    tg,
    Mct,
    xx,
    nw,
    iI,
    eg,
    Oct,
    Pct,
    Ta,
    Mi,
    rg,
    sI,
    iw,
    sw,
    $ct,
    aw,
    Gct,
    aI,
    oI,
    ow,
    lI,
    yx,
    Vct,
    zct,
    Wct,
    Uct,
    jct,
    dI,
    qct,
    Hct,
    pI,
    Yct,
    cI,
    ig,
    Xct,
    Kct,
    uI,
    Yl,
    uw = x(() => {
      'use strict'
      ;({
        entries: hI,
        setPrototypeOf: rI,
        isFrozen: Rct,
        getPrototypeOf: Dct,
        getOwnPropertyDescriptor: Nct,
      } = Object),
        ({ freeze: Oi, seal: Hs, create: fI } = Object),
        ({ apply: lw, construct: cw } = typeof Reflect < 'u' && Reflect)
      Oi ||
        (Oi = a(function (t) {
          return t
        }, 'freeze'))
      Hs ||
        (Hs = a(function (t) {
          return t
        }, 'seal'))
      lw ||
        (lw = a(function (t, r, n) {
          return t.apply(r, n)
        }, 'apply'))
      cw ||
        (cw = a(function (t, r) {
          return new t(...r)
        }, 'construct'))
      ;(gx = Pi(Array.prototype.forEach)),
        (Ict = Pi(Array.prototype.lastIndexOf)),
        (nI = Pi(Array.prototype.pop)),
        (tg = Pi(Array.prototype.push)),
        (Mct = Pi(Array.prototype.splice)),
        (xx = Pi(String.prototype.toLowerCase)),
        (nw = Pi(String.prototype.toString)),
        (iI = Pi(String.prototype.match)),
        (eg = Pi(String.prototype.replace)),
        (Oct = Pi(String.prototype.indexOf)),
        (Pct = Pi(String.prototype.trim)),
        (Ta = Pi(Object.prototype.hasOwnProperty)),
        (Mi = Pi(RegExp.prototype.test)),
        (rg = Bct(TypeError))
      a(Pi, 'unapply')
      a(Bct, 'unconstruct')
      a(He, 'addToSet')
      a(Fct, 'cleanArray')
      a(Jo, 'clone')
      a(ng, 'lookupGetter')
      ;(sI = Oi([
        'a',
        'abbr',
        'acronym',
        'address',
        'area',
        'article',
        'aside',
        'audio',
        'b',
        'bdi',
        'bdo',
        'big',
        'blink',
        'blockquote',
        'body',
        'br',
        'button',
        'canvas',
        'caption',
        'center',
        'cite',
        'code',
        'col',
        'colgroup',
        'content',
        'data',
        'datalist',
        'dd',
        'decorator',
        'del',
        'details',
        'dfn',
        'dialog',
        'dir',
        'div',
        'dl',
        'dt',
        'element',
        'em',
        'fieldset',
        'figcaption',
        'figure',
        'font',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'i',
        'img',
        'input',
        'ins',
        'kbd',
        'label',
        'legend',
        'li',
        'main',
        'map',
        'mark',
        'marquee',
        'menu',
        'menuitem',
        'meter',
        'nav',
        'nobr',
        'ol',
        'optgroup',
        'option',
        'output',
        'p',
        'picture',
        'pre',
        'progress',
        'q',
        'rp',
        'rt',
        'ruby',
        's',
        'samp',
        'section',
        'select',
        'shadow',
        'small',
        'source',
        'spacer',
        'span',
        'strike',
        'strong',
        'style',
        'sub',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'template',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'tr',
        'track',
        'tt',
        'u',
        'ul',
        'var',
        'video',
        'wbr',
      ])),
        (iw = Oi([
          'svg',
          'a',
          'altglyph',
          'altglyphdef',
          'altglyphitem',
          'animatecolor',
          'animatemotion',
          'animatetransform',
          'circle',
          'clippath',
          'defs',
          'desc',
          'ellipse',
          'filter',
          'font',
          'g',
          'glyph',
          'glyphref',
          'hkern',
          'image',
          'line',
          'lineargradient',
          'marker',
          'mask',
          'metadata',
          'mpath',
          'path',
          'pattern',
          'polygon',
          'polyline',
          'radialgradient',
          'rect',
          'stop',
          'style',
          'switch',
          'symbol',
          'text',
          'textpath',
          'title',
          'tref',
          'tspan',
          'view',
          'vkern',
        ])),
        (sw = Oi([
          'feBlend',
          'feColorMatrix',
          'feComponentTransfer',
          'feComposite',
          'feConvolveMatrix',
          'feDiffuseLighting',
          'feDisplacementMap',
          'feDistantLight',
          'feDropShadow',
          'feFlood',
          'feFuncA',
          'feFuncB',
          'feFuncG',
          'feFuncR',
          'feGaussianBlur',
          'feImage',
          'feMerge',
          'feMergeNode',
          'feMorphology',
          'feOffset',
          'fePointLight',
          'feSpecularLighting',
          'feSpotLight',
          'feTile',
          'feTurbulence',
        ])),
        ($ct = Oi([
          'animate',
          'color-profile',
          'cursor',
          'discard',
          'font-face',
          'font-face-format',
          'font-face-name',
          'font-face-src',
          'font-face-uri',
          'foreignobject',
          'hatch',
          'hatchpath',
          'mesh',
          'meshgradient',
          'meshpatch',
          'meshrow',
          'missing-glyph',
          'script',
          'set',
          'solidcolor',
          'unknown',
          'use',
        ])),
        (aw = Oi([
          'math',
          'menclose',
          'merror',
          'mfenced',
          'mfrac',
          'mglyph',
          'mi',
          'mlabeledtr',
          'mmultiscripts',
          'mn',
          'mo',
          'mover',
          'mpadded',
          'mphantom',
          'mroot',
          'mrow',
          'ms',
          'mspace',
          'msqrt',
          'mstyle',
          'msub',
          'msup',
          'msubsup',
          'mtable',
          'mtd',
          'mtext',
          'mtr',
          'munder',
          'munderover',
          'mprescripts',
        ])),
        (Gct = Oi([
          'maction',
          'maligngroup',
          'malignmark',
          'mlongdiv',
          'mscarries',
          'mscarry',
          'msgroup',
          'mstack',
          'msline',
          'msrow',
          'semantics',
          'annotation',
          'annotation-xml',
          'mprescripts',
          'none',
        ])),
        (aI = Oi(['#text'])),
        (oI = Oi([
          'accept',
          'action',
          'align',
          'alt',
          'autocapitalize',
          'autocomplete',
          'autopictureinpicture',
          'autoplay',
          'background',
          'bgcolor',
          'border',
          'capture',
          'cellpadding',
          'cellspacing',
          'checked',
          'cite',
          'class',
          'clear',
          'color',
          'cols',
          'colspan',
          'controls',
          'controlslist',
          'coords',
          'crossorigin',
          'datetime',
          'decoding',
          'default',
          'dir',
          'disabled',
          'disablepictureinpicture',
          'disableremoteplayback',
          'download',
          'draggable',
          'enctype',
          'enterkeyhint',
          'face',
          'for',
          'headers',
          'height',
          'hidden',
          'high',
          'href',
          'hreflang',
          'id',
          'inputmode',
          'integrity',
          'ismap',
          'kind',
          'label',
          'lang',
          'list',
          'loading',
          'loop',
          'low',
          'max',
          'maxlength',
          'media',
          'method',
          'min',
          'minlength',
          'multiple',
          'muted',
          'name',
          'nonce',
          'noshade',
          'novalidate',
          'nowrap',
          'open',
          'optimum',
          'pattern',
          'placeholder',
          'playsinline',
          'popover',
          'popovertarget',
          'popovertargetaction',
          'poster',
          'preload',
          'pubdate',
          'radiogroup',
          'readonly',
          'rel',
          'required',
          'rev',
          'reversed',
          'role',
          'rows',
          'rowspan',
          'spellcheck',
          'scope',
          'selected',
          'shape',
          'size',
          'sizes',
          'span',
          'srclang',
          'start',
          'src',
          'srcset',
          'step',
          'style',
          'summary',
          'tabindex',
          'title',
          'translate',
          'type',
          'usemap',
          'valign',
          'value',
          'width',
          'wrap',
          'xmlns',
          'slot',
        ])),
        (ow = Oi([
          'accent-height',
          'accumulate',
          'additive',
          'alignment-baseline',
          'amplitude',
          'ascent',
          'attributename',
          'attributetype',
          'azimuth',
          'basefrequency',
          'baseline-shift',
          'begin',
          'bias',
          'by',
          'class',
          'clip',
          'clippathunits',
          'clip-path',
          'clip-rule',
          'color',
          'color-interpolation',
          'color-interpolation-filters',
          'color-profile',
          'color-rendering',
          'cx',
          'cy',
          'd',
          'dx',
          'dy',
          'diffuseconstant',
          'direction',
          'display',
          'divisor',
          'dur',
          'edgemode',
          'elevation',
          'end',
          'exponent',
          'fill',
          'fill-opacity',
          'fill-rule',
          'filter',
          'filterunits',
          'flood-color',
          'flood-opacity',
          'font-family',
          'font-size',
          'font-size-adjust',
          'font-stretch',
          'font-style',
          'font-variant',
          'font-weight',
          'fx',
          'fy',
          'g1',
          'g2',
          'glyph-name',
          'glyphref',
          'gradientunits',
          'gradienttransform',
          'height',
          'href',
          'id',
          'image-rendering',
          'in',
          'in2',
          'intercept',
          'k',
          'k1',
          'k2',
          'k3',
          'k4',
          'kerning',
          'keypoints',
          'keysplines',
          'keytimes',
          'lang',
          'lengthadjust',
          'letter-spacing',
          'kernelmatrix',
          'kernelunitlength',
          'lighting-color',
          'local',
          'marker-end',
          'marker-mid',
          'marker-start',
          'markerheight',
          'markerunits',
          'markerwidth',
          'maskcontentunits',
          'maskunits',
          'max',
          'mask',
          'media',
          'method',
          'mode',
          'min',
          'name',
          'numoctaves',
          'offset',
          'operator',
          'opacity',
          'order',
          'orient',
          'orientation',
          'origin',
          'overflow',
          'paint-order',
          'path',
          'pathlength',
          'patterncontentunits',
          'patterntransform',
          'patternunits',
          'points',
          'preservealpha',
          'preserveaspectratio',
          'primitiveunits',
          'r',
          'rx',
          'ry',
          'radius',
          'refx',
          'refy',
          'repeatcount',
          'repeatdur',
          'restart',
          'result',
          'rotate',
          'scale',
          'seed',
          'shape-rendering',
          'slope',
          'specularconstant',
          'specularexponent',
          'spreadmethod',
          'startoffset',
          'stddeviation',
          'stitchtiles',
          'stop-color',
          'stop-opacity',
          'stroke-dasharray',
          'stroke-dashoffset',
          'stroke-linecap',
          'stroke-linejoin',
          'stroke-miterlimit',
          'stroke-opacity',
          'stroke',
          'stroke-width',
          'style',
          'surfacescale',
          'systemlanguage',
          'tabindex',
          'tablevalues',
          'targetx',
          'targety',
          'transform',
          'transform-origin',
          'text-anchor',
          'text-decoration',
          'text-rendering',
          'textlength',
          'type',
          'u1',
          'u2',
          'unicode',
          'values',
          'viewbox',
          'visibility',
          'version',
          'vert-adv-y',
          'vert-origin-x',
          'vert-origin-y',
          'width',
          'word-spacing',
          'wrap',
          'writing-mode',
          'xchannelselector',
          'ychannelselector',
          'x',
          'x1',
          'x2',
          'xmlns',
          'y',
          'y1',
          'y2',
          'z',
          'zoomandpan',
        ])),
        (lI = Oi([
          'accent',
          'accentunder',
          'align',
          'bevelled',
          'close',
          'columnsalign',
          'columnlines',
          'columnspan',
          'denomalign',
          'depth',
          'dir',
          'display',
          'displaystyle',
          'encoding',
          'fence',
          'frame',
          'height',
          'href',
          'id',
          'largeop',
          'length',
          'linethickness',
          'lspace',
          'lquote',
          'mathbackground',
          'mathcolor',
          'mathsize',
          'mathvariant',
          'maxsize',
          'minsize',
          'movablelimits',
          'notation',
          'numalign',
          'open',
          'rowalign',
          'rowlines',
          'rowspacing',
          'rowspan',
          'rspace',
          'rquote',
          'scriptlevel',
          'scriptminsize',
          'scriptsizemultiplier',
          'selection',
          'separator',
          'separators',
          'stretchy',
          'subscriptshift',
          'supscriptshift',
          'symmetric',
          'voffset',
          'width',
          'xmlns',
        ])),
        (yx = Oi(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink'])),
        (Vct = Hs(/\{\{[\w\W]*|[\w\W]*\}\}/gm)),
        (zct = Hs(/<%[\w\W]*|[\w\W]*%>/gm)),
        (Wct = Hs(/\$\{[\w\W]*/gm)),
        (Uct = Hs(/^data-[\-\w.\u00B7-\uFFFF]+$/)),
        (jct = Hs(/^aria-[\-\w]+$/)),
        (dI = Hs(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i)),
        (qct = Hs(/^(?:\w+script|data):/i)),
        (Hct = Hs(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g)),
        (pI = Hs(/^html$/i)),
        (Yct = Hs(/^[a-z][.\w]*(-[.\w]+)+$/i)),
        (cI = Object.freeze({
          __proto__: null,
          ARIA_ATTR: jct,
          ATTR_WHITESPACE: Hct,
          CUSTOM_ELEMENT: Yct,
          DATA_ATTR: Uct,
          DOCTYPE_NAME: pI,
          ERB_EXPR: zct,
          IS_ALLOWED_URI: dI,
          IS_SCRIPT_OR_DATA: qct,
          MUSTACHE_EXPR: Vct,
          TMPLIT_EXPR: Wct,
        })),
        (ig = {
          element: 1,
          attribute: 2,
          text: 3,
          cdataSection: 4,
          entityReference: 5,
          entityNode: 6,
          progressingInstruction: 7,
          comment: 8,
          document: 9,
          documentType: 10,
          documentFragment: 11,
          notation: 12,
        }),
        (Xct = a(function () {
          return typeof window > 'u' ? null : window
        }, 'getGlobal')),
        (Kct = a(function (t, r) {
          if (typeof t != 'object' || typeof t.createPolicy != 'function') return null
          let n = null,
            i = 'data-tt-policy-suffix'
          r && r.hasAttribute(i) && (n = r.getAttribute(i))
          let s = 'dompurify' + (n ? '#' + n : '')
          try {
            return t.createPolicy(s, {
              createHTML(o) {
                return o
              },
              createScriptURL(o) {
                return o
              },
            })
          } catch {
            return console.warn('TrustedTypes policy ' + s + ' could not be created.'), null
          }
        }, '_createTrustedTypesPolicy')),
        (uI = a(function () {
          return {
            afterSanitizeAttributes: [],
            afterSanitizeElements: [],
            afterSanitizeShadowDOM: [],
            beforeSanitizeAttributes: [],
            beforeSanitizeElements: [],
            beforeSanitizeShadowDOM: [],
            uponSanitizeAttribute: [],
            uponSanitizeElement: [],
            uponSanitizeShadowNode: [],
          }
        }, '_createHooksMap'))
      a(mI, 'createDOMPurify')
      Yl = mI()
    })
  function Jct() {
    let e = 'data-temp-href-target'
    Yl.addHook('beforeSanitizeAttributes', (t) => {
      t.tagName === 'A' && t.hasAttribute('target') && t.setAttribute(e, t.getAttribute('target') ?? '')
    }),
      Yl.addHook('afterSanitizeAttributes', (t) => {
        t.tagName === 'A' &&
          t.hasAttribute(e) &&
          (t.setAttribute('target', t.getAttribute(e) ?? ''),
          t.removeAttribute(e),
          t.getAttribute('target') === '_blank' && t.setAttribute('rel', 'noopener'))
      })
  }
  var ff,
    Qct,
    Zct,
    yI,
    gI,
    Ie,
    tut,
    eut,
    rut,
    nut,
    xI,
    yu,
    Pe,
    iut,
    sut,
    eo,
    hw,
    aut,
    out,
    lut,
    fw,
    $r,
    xu,
    cut,
    Xl,
    Rt,
    Be = x(() => {
      'use strict'
      uw()
      ;(ff = /<br\s*\/?>/gi),
        (Qct = a((e) => (e ? xI(e).replace(/\\n/g, '#br#').split('#br#') : ['']), 'getRows')),
        (Zct = (() => {
          let e = !1
          return () => {
            e || (Jct(), (e = !0))
          }
        })())
      a(Jct, 'setupDompurifyHooks')
      ;(yI = a((e) => (Zct(), Yl.sanitize(e)), 'removeScript')),
        (gI = a((e, t) => {
          if (t.flowchart?.htmlLabels !== !1) {
            let r = t.securityLevel
            r === 'antiscript' || r === 'strict'
              ? (e = yI(e))
              : r !== 'loose' &&
                ((e = xI(e)),
                (e = e.replace(/</g, '&lt;').replace(/>/g, '&gt;')),
                (e = e.replace(/=/g, '&equals;')),
                (e = nut(e)))
          }
          return e
        }, 'sanitizeMore')),
        (Ie = a(
          (e, t) =>
            e &&
            (t.dompurifyConfig
              ? (e = Yl.sanitize(gI(e, t), t.dompurifyConfig).toString())
              : (e = Yl.sanitize(gI(e, t), { FORBID_TAGS: ['style'] }).toString()),
            e),
          'sanitizeText',
        )),
        (tut = a((e, t) => (typeof e == 'string' ? Ie(e, t) : e.flat().map((r) => Ie(r, t))), 'sanitizeTextOrArray')),
        (eut = a((e) => ff.test(e), 'hasBreaks')),
        (rut = a((e) => e.split(ff), 'splitBreaks')),
        (nut = a((e) => e.replace(/#br#/g, '<br/>'), 'placeholderToBreak')),
        (xI = a((e) => e.replace(ff, '#br#'), 'breakToPlaceholder')),
        (yu = a((e) => {
          let t = ''
          return (
            e &&
              ((t =
                window.location.protocol +
                '//' +
                window.location.host +
                window.location.pathname +
                window.location.search),
              (t = CSS.escape(t))),
            t
          )
        }, 'getUrl')),
        (Pe = a((e) => !(e === !1 || ['false', 'null', '0'].includes(String(e).trim().toLowerCase())), 'evaluate')),
        (iut = a(function (...e) {
          let t = e.filter((r) => !isNaN(r))
          return Math.max(...t)
        }, 'getMax')),
        (sut = a(function (...e) {
          let t = e.filter((r) => !isNaN(r))
          return Math.min(...t)
        }, 'getMin')),
        (eo = a(function (e) {
          let t = e.split(/(,)/),
            r = []
          for (let n = 0; n < t.length; n++) {
            let i = t[n]
            if (i === ',' && n > 0 && n + 1 < t.length) {
              let s = t[n - 1],
                o = t[n + 1]
              aut(s, o) && ((i = s + ',' + o), n++, r.pop())
            }
            r.push(out(i))
          }
          return r.join('')
        }, 'parseGenericTypes')),
        (hw = a((e, t) => Math.max(0, e.split(t).length - 1), 'countOccurrence')),
        (aut = a((e, t) => {
          let r = hw(e, '~'),
            n = hw(t, '~')
          return r === 1 && n === 1
        }, 'shouldCombineSets')),
        (out = a((e) => {
          let t = hw(e, '~'),
            r = !1
          if (t <= 1) return e
          t % 2 !== 0 && e.startsWith('~') && ((e = e.substring(1)), (r = !0))
          let n = [...e],
            i = n.indexOf('~'),
            s = n.lastIndexOf('~')
          for (; i !== -1 && s !== -1 && i !== s; )
            (n[i] = '<'), (n[s] = '>'), (i = n.indexOf('~')), (s = n.lastIndexOf('~'))
          return r && n.unshift('~'), n.join('')
        }, 'processSet')),
        (lut = a(() => window.MathMLElement !== void 0, 'isMathMLSupported')),
        (fw = /\$\$(.*)\$\$/g),
        ($r = a((e) => (e.match(fw)?.length ?? 0) > 0, 'hasKatex')),
        (xu = a(async (e, t) => {
          let r = document.createElement('div')
          ;(r.innerHTML = await Xl(e, t)),
            (r.id = 'katex-temp'),
            (r.style.visibility = 'hidden'),
            (r.style.position = 'absolute'),
            (r.style.top = '0'),
            document.querySelector('body')?.insertAdjacentElement('beforeend', r)
          let i = { width: r.clientWidth, height: r.clientHeight }
          return r.remove(), i
        }, 'calculateMathMLDimensions')),
        (cut = a(
          async (e, t) =>
            $r(e)
              ? lut() || t.legacyMathML || t.forceLegacyMathML
                ? e.replace(fw, 'Katex is not supported in @mermaid-js/tiny. Please use the full mermaid library.')
                : e.replace(fw, 'MathML is unsupported in this environment.')
              : e,
          'renderKatexUnsanitized',
        )),
        (Xl = a(async (e, t) => Ie(await cut(e, t), t), 'renderKatexSanitized')),
        (Rt = {
          getRows: Qct,
          sanitizeText: Ie,
          sanitizeTextOrArray: tut,
          hasBreaks: eut,
          splitBreaks: rut,
          lineBreakRegex: ff,
          removeScript: yI,
          getUrl: yu,
          evaluate: Pe,
          getMax: iut,
          getMin: sut,
        })
    })
  var uut,
    dw,
    bI,
    kI,
    TI,
    SI,
    ro,
    bu = x(() => {
      'use strict'
      o7()
      fn()
      Be()
      Vt()
      ;(uut = {
        body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
        height: 80,
        width: 80,
      }),
        (dw = new Map()),
        (bI = new Map()),
        (kI = a((e) => {
          for (let t of e) {
            if (!t.name)
              throw new Error('Invalid icon loader. Must have a "name" property with non-empty string value.')
            if ((B.debug('Registering icon pack:', t.name), 'loader' in t)) bI.set(t.name, t.loader)
            else if ('icons' in t) dw.set(t.name, t.icons)
            else
              throw (
                (B.error('Invalid icon loader:', t),
                new Error('Invalid icon loader. Must have either "icons" or "loader" property.'))
              )
          }
        }, 'registerIconPacks')),
        (TI = a(async (e, t) => {
          let r = DC(e, !0, t !== void 0)
          if (!r) throw new Error(`Invalid icon name: ${e}`)
          let n = r.prefix || t
          if (!n) throw new Error(`Icon name must contain a prefix: ${e}`)
          let i = dw.get(n)
          if (!i) {
            let o = bI.get(n)
            if (!o) throw new Error(`Icon set not found: ${r.prefix}`)
            try {
              ;(i = { ...(await o()), prefix: n }), dw.set(n, i)
            } catch (l) {
              throw (B.error(l), new Error(`Failed to load icon set: ${r.prefix}`))
            }
          }
          let s = IC(i, r.name)
          if (!s) throw new Error(`Icon not found: ${e}`)
          return s
        }, 'getRegisteredIconData')),
        (SI = a(async (e) => {
          try {
            return await TI(e), !0
          } catch {
            return !1
          }
        }, 'isIconAvailable')),
        (ro = a(async (e, t, r) => {
          let n
          try {
            n = await TI(e, t?.fallbackPrefix)
          } catch (o) {
            B.error(o), (n = uut)
          }
          let i = OC(n, t),
            s = BC(PC(i.body), { ...i.attributes, ...r })
          return Ie(s, Te())
        }, 'getIconSVG'))
    })
  function bx(e) {
    for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
    var n = Array.from(typeof e == 'string' ? [e] : e)
    n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '')
    var i = n.reduce(function (l, u) {
      var h = u.match(/\n([\t ]+|(?!\s).)/g)
      return h
        ? l.concat(
            h.map(function (f) {
              var d, p
              return (p = (d = f.match(/[\t ]/g)) === null || d === void 0 ? void 0 : d.length) !== null && p !== void 0
                ? p
                : 0
            }),
          )
        : l
    }, [])
    if (i.length) {
      var s = new RegExp(
        `
[	 ]{` +
          Math.min.apply(Math, i) +
          '}',
        'g',
      )
      n = n.map(function (l) {
        return l.replace(
          s,
          `
`,
        )
      })
    }
    n[0] = n[0].replace(/^\r?\n/, '')
    var o = n[0]
    return (
      t.forEach(function (l, u) {
        var h = o.match(/(?:^|\n)( *)$/),
          f = h ? h[1] : '',
          d = l
        typeof l == 'string' &&
          l.includes(`
`) &&
          (d = String(l)
            .split(
              `
`,
            )
            .map(function (p, m) {
              return m === 0 ? p : '' + f + p
            }).join(`
`)),
          (o += d + n[u + 1])
      }),
      o
    )
  }
  var pw = x(() => {
    'use strict'
    a(bx, 'dedent')
  })
  var kx,
    ku,
    _I,
    Tx = x(() => {
      'use strict'
      ;(kx = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s),
        (ku = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi),
        (_I = /\s*%%.*\n/gm)
    })
  var df,
    mw = x(() => {
      'use strict'
      df = class extends Error {
        static {
          a(this, 'UnknownDiagramError')
        }
        constructor(t) {
          super(t), (this.name = 'UnknownDiagramError')
        }
      }
    })
  var tl,
    pf,
    Sx,
    gw,
    CI,
    Tu = x(() => {
      'use strict'
      Vt()
      Tx()
      mw()
      ;(tl = {}),
        (pf = a(function (e, t) {
          e = e
            .replace(kx, '')
            .replace(ku, '')
            .replace(
              _I,
              `
`,
            )
          for (let [r, { detector: n }] of Object.entries(tl)) if (n(e, t)) return r
          throw new df(`No diagram type detected matching given configuration for text: ${e}`)
        }, 'detectType')),
        (Sx = a((...e) => {
          for (let { id: t, detector: r, loader: n } of e) gw(t, r, n)
        }, 'registerLazyLoadedDiagrams')),
        (gw = a((e, t, r) => {
          tl[e] && B.warn(`Detector with key ${e} already exists. Overwriting.`),
            (tl[e] = { detector: t, loader: r }),
            B.debug(`Detector with key ${e} added${r ? ' with loader' : ''}`)
        }, 'addDetector')),
        (CI = a((e) => tl[e].loader, 'getDiagramLoader'))
    })
  var sg,
    wI,
    yw = x(() => {
      'use strict'
      sg = (function () {
        var e = a(function (se, Nt, At, bt) {
            for (At = At || {}, bt = se.length; bt--; At[se[bt]] = Nt);
            return At
          }, 'o'),
          t = [1, 24],
          r = [1, 25],
          n = [1, 26],
          i = [1, 27],
          s = [1, 28],
          o = [1, 63],
          l = [1, 64],
          u = [1, 65],
          h = [1, 66],
          f = [1, 67],
          d = [1, 68],
          p = [1, 69],
          m = [1, 29],
          g = [1, 30],
          y = [1, 31],
          b = [1, 32],
          k = [1, 33],
          T = [1, 34],
          C = [1, 35],
          A = [1, 36],
          w = [1, 37],
          D = [1, 38],
          G = [1, 39],
          v = [1, 40],
          R = [1, 41],
          F = [1, 42],
          S = [1, 43],
          O = [1, 44],
          E = [1, 45],
          _ = [1, 46],
          L = [1, 47],
          N = [1, 48],
          P = [1, 50],
          I = [1, 51],
          M = [1, 52],
          V = [1, 53],
          $ = [1, 54],
          q = [1, 55],
          tt = [1, 56],
          ft = [1, 57],
          H = [1, 58],
          kt = [1, 59],
          ht = [1, 60],
          yt = [14, 42],
          ot = [
            14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
          ],
          dt = [
            12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
            61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
          ],
          it = [1, 82],
          Q = [1, 83],
          et = [1, 84],
          X = [1, 85],
          st = [12, 14, 42],
          U = [12, 14, 33, 42],
          gt = [12, 14, 33, 42, 76, 77, 79, 80],
          z = [12, 33],
          ge = [
            34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
            64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
          ],
          lt = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mermaidDoc: 4,
              direction: 5,
              direction_tb: 6,
              direction_bt: 7,
              direction_rl: 8,
              direction_lr: 9,
              graphConfig: 10,
              C4_CONTEXT: 11,
              NEWLINE: 12,
              statements: 13,
              EOF: 14,
              C4_CONTAINER: 15,
              C4_COMPONENT: 16,
              C4_DYNAMIC: 17,
              C4_DEPLOYMENT: 18,
              otherStatements: 19,
              diagramStatements: 20,
              otherStatement: 21,
              title: 22,
              accDescription: 23,
              acc_title: 24,
              acc_title_value: 25,
              acc_descr: 26,
              acc_descr_value: 27,
              acc_descr_multiline_value: 28,
              boundaryStatement: 29,
              boundaryStartStatement: 30,
              boundaryStopStatement: 31,
              boundaryStart: 32,
              LBRACE: 33,
              ENTERPRISE_BOUNDARY: 34,
              attributes: 35,
              SYSTEM_BOUNDARY: 36,
              BOUNDARY: 37,
              CONTAINER_BOUNDARY: 38,
              NODE: 39,
              NODE_L: 40,
              NODE_R: 41,
              RBRACE: 42,
              diagramStatement: 43,
              PERSON: 44,
              PERSON_EXT: 45,
              SYSTEM: 46,
              SYSTEM_DB: 47,
              SYSTEM_QUEUE: 48,
              SYSTEM_EXT: 49,
              SYSTEM_EXT_DB: 50,
              SYSTEM_EXT_QUEUE: 51,
              CONTAINER: 52,
              CONTAINER_DB: 53,
              CONTAINER_QUEUE: 54,
              CONTAINER_EXT: 55,
              CONTAINER_EXT_DB: 56,
              CONTAINER_EXT_QUEUE: 57,
              COMPONENT: 58,
              COMPONENT_DB: 59,
              COMPONENT_QUEUE: 60,
              COMPONENT_EXT: 61,
              COMPONENT_EXT_DB: 62,
              COMPONENT_EXT_QUEUE: 63,
              REL: 64,
              BIREL: 65,
              REL_U: 66,
              REL_D: 67,
              REL_L: 68,
              REL_R: 69,
              REL_B: 70,
              REL_INDEX: 71,
              UPDATE_EL_STYLE: 72,
              UPDATE_REL_STYLE: 73,
              UPDATE_LAYOUT_CONFIG: 74,
              attribute: 75,
              STR: 76,
              STR_KEY: 77,
              STR_VALUE: 78,
              ATTRIBUTE: 79,
              ATTRIBUTE_EMPTY: 80,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              6: 'direction_tb',
              7: 'direction_bt',
              8: 'direction_rl',
              9: 'direction_lr',
              11: 'C4_CONTEXT',
              12: 'NEWLINE',
              14: 'EOF',
              15: 'C4_CONTAINER',
              16: 'C4_COMPONENT',
              17: 'C4_DYNAMIC',
              18: 'C4_DEPLOYMENT',
              22: 'title',
              23: 'accDescription',
              24: 'acc_title',
              25: 'acc_title_value',
              26: 'acc_descr',
              27: 'acc_descr_value',
              28: 'acc_descr_multiline_value',
              33: 'LBRACE',
              34: 'ENTERPRISE_BOUNDARY',
              36: 'SYSTEM_BOUNDARY',
              37: 'BOUNDARY',
              38: 'CONTAINER_BOUNDARY',
              39: 'NODE',
              40: 'NODE_L',
              41: 'NODE_R',
              42: 'RBRACE',
              44: 'PERSON',
              45: 'PERSON_EXT',
              46: 'SYSTEM',
              47: 'SYSTEM_DB',
              48: 'SYSTEM_QUEUE',
              49: 'SYSTEM_EXT',
              50: 'SYSTEM_EXT_DB',
              51: 'SYSTEM_EXT_QUEUE',
              52: 'CONTAINER',
              53: 'CONTAINER_DB',
              54: 'CONTAINER_QUEUE',
              55: 'CONTAINER_EXT',
              56: 'CONTAINER_EXT_DB',
              57: 'CONTAINER_EXT_QUEUE',
              58: 'COMPONENT',
              59: 'COMPONENT_DB',
              60: 'COMPONENT_QUEUE',
              61: 'COMPONENT_EXT',
              62: 'COMPONENT_EXT_DB',
              63: 'COMPONENT_EXT_QUEUE',
              64: 'REL',
              65: 'BIREL',
              66: 'REL_U',
              67: 'REL_D',
              68: 'REL_L',
              69: 'REL_R',
              70: 'REL_B',
              71: 'REL_INDEX',
              72: 'UPDATE_EL_STYLE',
              73: 'UPDATE_REL_STYLE',
              74: 'UPDATE_LAYOUT_CONFIG',
              76: 'STR',
              77: 'STR_KEY',
              78: 'STR_VALUE',
              79: 'ATTRIBUTE',
              80: 'ATTRIBUTE_EMPTY',
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [5, 1],
              [5, 1],
              [5, 1],
              [5, 1],
              [4, 1],
              [10, 4],
              [10, 4],
              [10, 4],
              [10, 4],
              [10, 4],
              [13, 1],
              [13, 1],
              [13, 2],
              [19, 1],
              [19, 2],
              [19, 3],
              [21, 1],
              [21, 1],
              [21, 2],
              [21, 2],
              [21, 1],
              [29, 3],
              [30, 3],
              [30, 3],
              [30, 4],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [31, 1],
              [20, 1],
              [20, 2],
              [20, 3],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 1],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [35, 1],
              [35, 2],
              [75, 1],
              [75, 2],
              [75, 1],
              [75, 1],
            ],
            performAction: a(function (Nt, At, bt, ct, Lt, Z, Mt) {
              var W = Z.length - 1
              switch (Lt) {
                case 3:
                  ct.setDirection('TB')
                  break
                case 4:
                  ct.setDirection('BT')
                  break
                case 5:
                  ct.setDirection('RL')
                  break
                case 6:
                  ct.setDirection('LR')
                  break
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                  ct.setC4Type(Z[W - 3])
                  break
                case 19:
                  ct.setTitle(Z[W].substring(6)), (this.$ = Z[W].substring(6))
                  break
                case 20:
                  ct.setAccDescription(Z[W].substring(15)), (this.$ = Z[W].substring(15))
                  break
                case 21:
                  ;(this.$ = Z[W].trim()), ct.setTitle(this.$)
                  break
                case 22:
                case 23:
                  ;(this.$ = Z[W].trim()), ct.setAccDescription(this.$)
                  break
                case 28:
                  Z[W].splice(2, 0, 'ENTERPRISE'), ct.addPersonOrSystemBoundary(...Z[W]), (this.$ = Z[W])
                  break
                case 29:
                  Z[W].splice(2, 0, 'SYSTEM'), ct.addPersonOrSystemBoundary(...Z[W]), (this.$ = Z[W])
                  break
                case 30:
                  ct.addPersonOrSystemBoundary(...Z[W]), (this.$ = Z[W])
                  break
                case 31:
                  Z[W].splice(2, 0, 'CONTAINER'), ct.addContainerBoundary(...Z[W]), (this.$ = Z[W])
                  break
                case 32:
                  ct.addDeploymentNode('node', ...Z[W]), (this.$ = Z[W])
                  break
                case 33:
                  ct.addDeploymentNode('nodeL', ...Z[W]), (this.$ = Z[W])
                  break
                case 34:
                  ct.addDeploymentNode('nodeR', ...Z[W]), (this.$ = Z[W])
                  break
                case 35:
                  ct.popBoundaryParseStack()
                  break
                case 39:
                  ct.addPersonOrSystem('person', ...Z[W]), (this.$ = Z[W])
                  break
                case 40:
                  ct.addPersonOrSystem('external_person', ...Z[W]), (this.$ = Z[W])
                  break
                case 41:
                  ct.addPersonOrSystem('system', ...Z[W]), (this.$ = Z[W])
                  break
                case 42:
                  ct.addPersonOrSystem('system_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 43:
                  ct.addPersonOrSystem('system_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 44:
                  ct.addPersonOrSystem('external_system', ...Z[W]), (this.$ = Z[W])
                  break
                case 45:
                  ct.addPersonOrSystem('external_system_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 46:
                  ct.addPersonOrSystem('external_system_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 47:
                  ct.addContainer('container', ...Z[W]), (this.$ = Z[W])
                  break
                case 48:
                  ct.addContainer('container_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 49:
                  ct.addContainer('container_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 50:
                  ct.addContainer('external_container', ...Z[W]), (this.$ = Z[W])
                  break
                case 51:
                  ct.addContainer('external_container_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 52:
                  ct.addContainer('external_container_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 53:
                  ct.addComponent('component', ...Z[W]), (this.$ = Z[W])
                  break
                case 54:
                  ct.addComponent('component_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 55:
                  ct.addComponent('component_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 56:
                  ct.addComponent('external_component', ...Z[W]), (this.$ = Z[W])
                  break
                case 57:
                  ct.addComponent('external_component_db', ...Z[W]), (this.$ = Z[W])
                  break
                case 58:
                  ct.addComponent('external_component_queue', ...Z[W]), (this.$ = Z[W])
                  break
                case 60:
                  ct.addRel('rel', ...Z[W]), (this.$ = Z[W])
                  break
                case 61:
                  ct.addRel('birel', ...Z[W]), (this.$ = Z[W])
                  break
                case 62:
                  ct.addRel('rel_u', ...Z[W]), (this.$ = Z[W])
                  break
                case 63:
                  ct.addRel('rel_d', ...Z[W]), (this.$ = Z[W])
                  break
                case 64:
                  ct.addRel('rel_l', ...Z[W]), (this.$ = Z[W])
                  break
                case 65:
                  ct.addRel('rel_r', ...Z[W]), (this.$ = Z[W])
                  break
                case 66:
                  ct.addRel('rel_b', ...Z[W]), (this.$ = Z[W])
                  break
                case 67:
                  Z[W].splice(0, 1), ct.addRel('rel', ...Z[W]), (this.$ = Z[W])
                  break
                case 68:
                  ct.updateElStyle('update_el_style', ...Z[W]), (this.$ = Z[W])
                  break
                case 69:
                  ct.updateRelStyle('update_rel_style', ...Z[W]), (this.$ = Z[W])
                  break
                case 70:
                  ct.updateLayoutConfig('update_layout_config', ...Z[W]), (this.$ = Z[W])
                  break
                case 71:
                  this.$ = [Z[W]]
                  break
                case 72:
                  Z[W].unshift(Z[W - 1]), (this.$ = Z[W])
                  break
                case 73:
                case 75:
                  this.$ = Z[W].trim()
                  break
                case 74:
                  let Gt = {}
                  ;(Gt[Z[W - 1].trim()] = Z[W].trim()), (this.$ = Gt)
                  break
                case 76:
                  this.$ = ''
                  break
              }
            }, 'anonymous'),
            table: [
              {
                3: 1,
                4: 2,
                5: 3,
                6: [1, 5],
                7: [1, 6],
                8: [1, 7],
                9: [1, 8],
                10: 4,
                11: [1, 9],
                15: [1, 10],
                16: [1, 11],
                17: [1, 12],
                18: [1, 13],
              },
              { 1: [3] },
              { 1: [2, 1] },
              { 1: [2, 2] },
              { 1: [2, 7] },
              { 1: [2, 3] },
              { 1: [2, 4] },
              { 1: [2, 5] },
              { 1: [2, 6] },
              { 12: [1, 14] },
              { 12: [1, 15] },
              { 12: [1, 16] },
              { 12: [1, 17] },
              { 12: [1, 18] },
              {
                13: 19,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              {
                13: 70,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              {
                13: 71,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              {
                13: 72,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              {
                13: 73,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              { 14: [1, 74] },
              e(yt, [2, 13], {
                43: 23,
                29: 49,
                30: 61,
                32: 62,
                20: 75,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              }),
              e(yt, [2, 14]),
              e(ot, [2, 16], { 12: [1, 76] }),
              e(yt, [2, 36], { 12: [1, 77] }),
              e(dt, [2, 19]),
              e(dt, [2, 20]),
              { 25: [1, 78] },
              { 27: [1, 79] },
              e(dt, [2, 23]),
              { 35: 80, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 86, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 87, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 88, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 89, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 90, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 91, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 92, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 93, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 94, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 95, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 96, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 97, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 98, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 99, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 100, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 101, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 102, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 103, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 104, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              e(st, [2, 59]),
              { 35: 105, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 106, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 107, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 108, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 109, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 110, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 111, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 112, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 113, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 114, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 115, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              {
                20: 116,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              },
              { 12: [1, 118], 33: [1, 117] },
              { 35: 119, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 120, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 121, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 122, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 123, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 124, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 35: 125, 75: 81, 76: it, 77: Q, 79: et, 80: X },
              { 14: [1, 126] },
              { 14: [1, 127] },
              { 14: [1, 128] },
              { 14: [1, 129] },
              { 1: [2, 8] },
              e(yt, [2, 15]),
              e(ot, [2, 17], { 21: 22, 19: 130, 22: t, 23: r, 24: n, 26: i, 28: s }),
              e(yt, [2, 37], {
                19: 20,
                20: 21,
                21: 22,
                43: 23,
                29: 49,
                30: 61,
                32: 62,
                13: 131,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: A,
                52: w,
                53: D,
                54: G,
                55: v,
                56: R,
                57: F,
                58: S,
                59: O,
                60: E,
                61: _,
                62: L,
                63: N,
                64: P,
                65: I,
                66: M,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ft,
                72: H,
                73: kt,
                74: ht,
              }),
              e(dt, [2, 21]),
              e(dt, [2, 22]),
              e(st, [2, 39]),
              e(U, [2, 71], { 75: 81, 35: 132, 76: it, 77: Q, 79: et, 80: X }),
              e(gt, [2, 73]),
              { 78: [1, 133] },
              e(gt, [2, 75]),
              e(gt, [2, 76]),
              e(st, [2, 40]),
              e(st, [2, 41]),
              e(st, [2, 42]),
              e(st, [2, 43]),
              e(st, [2, 44]),
              e(st, [2, 45]),
              e(st, [2, 46]),
              e(st, [2, 47]),
              e(st, [2, 48]),
              e(st, [2, 49]),
              e(st, [2, 50]),
              e(st, [2, 51]),
              e(st, [2, 52]),
              e(st, [2, 53]),
              e(st, [2, 54]),
              e(st, [2, 55]),
              e(st, [2, 56]),
              e(st, [2, 57]),
              e(st, [2, 58]),
              e(st, [2, 60]),
              e(st, [2, 61]),
              e(st, [2, 62]),
              e(st, [2, 63]),
              e(st, [2, 64]),
              e(st, [2, 65]),
              e(st, [2, 66]),
              e(st, [2, 67]),
              e(st, [2, 68]),
              e(st, [2, 69]),
              e(st, [2, 70]),
              { 31: 134, 42: [1, 135] },
              { 12: [1, 136] },
              { 33: [1, 137] },
              e(z, [2, 28]),
              e(z, [2, 29]),
              e(z, [2, 30]),
              e(z, [2, 31]),
              e(z, [2, 32]),
              e(z, [2, 33]),
              e(z, [2, 34]),
              { 1: [2, 9] },
              { 1: [2, 10] },
              { 1: [2, 11] },
              { 1: [2, 12] },
              e(ot, [2, 18]),
              e(yt, [2, 38]),
              e(U, [2, 72]),
              e(gt, [2, 74]),
              e(st, [2, 24]),
              e(st, [2, 35]),
              e(ge, [2, 25]),
              e(ge, [2, 26], { 12: [1, 138] }),
              e(ge, [2, 27]),
            ],
            defaultActions: {
              2: [2, 1],
              3: [2, 2],
              4: [2, 7],
              5: [2, 3],
              6: [2, 4],
              7: [2, 5],
              8: [2, 6],
              74: [2, 8],
              126: [2, 9],
              127: [2, 10],
              128: [2, 11],
              129: [2, 12],
            },
            parseError: a(function (Nt, At) {
              if (At.recoverable) this.trace(Nt)
              else {
                var bt = new Error(Nt)
                throw ((bt.hash = At), bt)
              }
            }, 'parseError'),
            parse: a(function (Nt) {
              var At = this,
                bt = [0],
                ct = [],
                Lt = [null],
                Z = [],
                Mt = this.table,
                W = '',
                Gt = 0,
                j = 0,
                vt = 0,
                mt = 2,
                Xt = 1,
                Ft = Z.slice.call(arguments, 1),
                _t = Object.create(this.lexer),
                Qe = { yy: {} }
              for (var It in this.yy) Object.prototype.hasOwnProperty.call(this.yy, It) && (Qe.yy[It] = this.yy[It])
              _t.setInput(Nt, Qe.yy),
                (Qe.yy.lexer = _t),
                (Qe.yy.parser = this),
                typeof _t.yylloc > 'u' && (_t.yylloc = {})
              var xr = _t.yylloc
              Z.push(xr)
              var Ze = _t.options && _t.options.ranges
              typeof Qe.yy.parseError == 'function'
                ? (this.parseError = Qe.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function yn(Ht) {
                ;(bt.length = bt.length - 2 * Ht), (Lt.length = Lt.length - Ht), (Z.length = Z.length - Ht)
              }
              a(yn, 'popStack')
              function Ae() {
                var Ht
                return (
                  (Ht = ct.pop() || _t.lex() || Xt),
                  typeof Ht != 'number' &&
                    (Ht instanceof Array && ((ct = Ht), (Ht = ct.pop())), (Ht = At.symbols_[Ht] || Ht)),
                  Ht
                )
              }
              a(Ae, 'lex')
              for (var Se, Je, _e, hr, Cn, ve, $e = {}, Le, xe, ce, ye; ; ) {
                if (
                  ((_e = bt[bt.length - 1]),
                  this.defaultActions[_e]
                    ? (hr = this.defaultActions[_e])
                    : ((Se === null || typeof Se > 'u') && (Se = Ae()), (hr = Mt[_e] && Mt[_e][Se])),
                  typeof hr > 'u' || !hr.length || !hr[0])
                ) {
                  var be = ''
                  ye = []
                  for (Le in Mt[_e]) this.terminals_[Le] && Le > mt && ye.push("'" + this.terminals_[Le] + "'")
                  _t.showPosition
                    ? (be =
                        'Parse error on line ' +
                        (Gt + 1) +
                        `:
` +
                        _t.showPosition() +
                        `
Expecting ` +
                        ye.join(', ') +
                        ", got '" +
                        (this.terminals_[Se] || Se) +
                        "'")
                    : (be =
                        'Parse error on line ' +
                        (Gt + 1) +
                        ': Unexpected ' +
                        (Se == Xt ? 'end of input' : "'" + (this.terminals_[Se] || Se) + "'")),
                    this.parseError(be, {
                      text: _t.match,
                      token: this.terminals_[Se] || Se,
                      line: _t.yylineno,
                      loc: xr,
                      expected: ye,
                    })
                }
                if (hr[0] instanceof Array && hr.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + _e + ', token: ' + Se)
                switch (hr[0]) {
                  case 1:
                    bt.push(Se),
                      Lt.push(_t.yytext),
                      Z.push(_t.yylloc),
                      bt.push(hr[1]),
                      (Se = null),
                      Je
                        ? ((Se = Je), (Je = null))
                        : ((j = _t.yyleng), (W = _t.yytext), (Gt = _t.yylineno), (xr = _t.yylloc), vt > 0 && vt--)
                    break
                  case 2:
                    if (
                      ((xe = this.productions_[hr[1]][1]),
                      ($e.$ = Lt[Lt.length - xe]),
                      ($e._$ = {
                        first_line: Z[Z.length - (xe || 1)].first_line,
                        last_line: Z[Z.length - 1].last_line,
                        first_column: Z[Z.length - (xe || 1)].first_column,
                        last_column: Z[Z.length - 1].last_column,
                      }),
                      Ze && ($e._$.range = [Z[Z.length - (xe || 1)].range[0], Z[Z.length - 1].range[1]]),
                      (ve = this.performAction.apply($e, [W, j, Gt, Qe.yy, hr[1], Lt, Z].concat(Ft))),
                      typeof ve < 'u')
                    )
                      return ve
                    xe && ((bt = bt.slice(0, -1 * xe * 2)), (Lt = Lt.slice(0, -1 * xe)), (Z = Z.slice(0, -1 * xe))),
                      bt.push(this.productions_[hr[1]][0]),
                      Lt.push($e.$),
                      Z.push($e._$),
                      (ce = Mt[bt[bt.length - 2]][bt[bt.length - 1]]),
                      bt.push(ce)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          jt = (function () {
            var se = {
              EOF: 1,
              parseError: a(function (At, bt) {
                if (this.yy.parser) this.yy.parser.parseError(At, bt)
                else throw new Error(At)
              }, 'parseError'),
              setInput: a(function (Nt, At) {
                return (
                  (this.yy = At || this.yy || {}),
                  (this._input = Nt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var Nt = this._input[0]
                ;(this.yytext += Nt), this.yyleng++, this.offset++, (this.match += Nt), (this.matched += Nt)
                var At = Nt.match(/(?:\r\n?|\n).*/g)
                return (
                  At ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  Nt
                )
              }, 'input'),
              unput: a(function (Nt) {
                var At = Nt.length,
                  bt = Nt.split(/(?:\r\n?|\n)/g)
                ;(this._input = Nt + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - At)),
                  (this.offset -= At)
                var ct = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  bt.length - 1 && (this.yylineno -= bt.length - 1)
                var Lt = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: bt
                      ? (bt.length === ct.length ? this.yylloc.first_column : 0) +
                        ct[ct.length - bt.length].length -
                        bt[0].length
                      : this.yylloc.first_column - At,
                  }),
                  this.options.ranges && (this.yylloc.range = [Lt[0], Lt[0] + this.yyleng - At]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (Nt) {
                this.unput(this.match.slice(Nt))
              }, 'less'),
              pastInput: a(function () {
                var Nt = this.matched.substr(0, this.matched.length - this.match.length)
                return (Nt.length > 20 ? '...' : '') + Nt.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var Nt = this.match
                return (
                  Nt.length < 20 && (Nt += this._input.substr(0, 20 - Nt.length)),
                  (Nt.substr(0, 20) + (Nt.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var Nt = this.pastInput(),
                  At = new Array(Nt.length + 1).join('-')
                return (
                  Nt +
                  this.upcomingInput() +
                  `
` +
                  At +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (Nt, At) {
                var bt, ct, Lt
                if (
                  (this.options.backtrack_lexer &&
                    ((Lt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (Lt.yylloc.range = this.yylloc.range.slice(0))),
                  (ct = Nt[0].match(/(?:\r\n?|\n).*/g)),
                  ct && (this.yylineno += ct.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: ct
                      ? ct[ct.length - 1].length - ct[ct.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + Nt[0].length,
                  }),
                  (this.yytext += Nt[0]),
                  (this.match += Nt[0]),
                  (this.matches = Nt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(Nt[0].length)),
                  (this.matched += Nt[0]),
                  (bt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    At,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  bt)
                )
                  return bt
                if (this._backtrack) {
                  for (var Z in Lt) this[Z] = Lt[Z]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var Nt, At, bt, ct
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var Lt = this._currentRules(), Z = 0; Z < Lt.length; Z++)
                  if (((bt = this._input.match(this.rules[Lt[Z]])), bt && (!At || bt[0].length > At[0].length))) {
                    if (((At = bt), (ct = Z), this.options.backtrack_lexer)) {
                      if (((Nt = this.test_match(bt, Lt[Z])), Nt !== !1)) return Nt
                      if (this._backtrack) {
                        At = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return At
                  ? ((Nt = this.test_match(At, Lt[ct])), Nt !== !1 ? Nt : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var At = this.next()
                return At || this.lex()
              }, 'lex'),
              begin: a(function (At) {
                this.conditionStack.push(At)
              }, 'begin'),
              popState: a(function () {
                var At = this.conditionStack.length - 1
                return At > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (At) {
                return (
                  (At = this.conditionStack.length - 1 - Math.abs(At || 0)),
                  At >= 0 ? this.conditionStack[At] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (At) {
                this.begin(At)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: {},
              performAction: a(function (At, bt, ct, Lt) {
                var Z = Lt
                switch (ct) {
                  case 0:
                    return 6
                  case 1:
                    return 7
                  case 2:
                    return 8
                  case 3:
                    return 9
                  case 4:
                    return 22
                  case 5:
                    return 23
                  case 6:
                    return this.begin('acc_title'), 24
                    break
                  case 7:
                    return this.popState(), 'acc_title_value'
                    break
                  case 8:
                    return this.begin('acc_descr'), 26
                    break
                  case 9:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 10:
                    this.begin('acc_descr_multiline')
                    break
                  case 11:
                    this.popState()
                    break
                  case 12:
                    return 'acc_descr_multiline_value'
                  case 13:
                    break
                  case 14:
                    c
                    break
                  case 15:
                    return 12
                  case 16:
                    break
                  case 17:
                    return 11
                  case 18:
                    return 15
                  case 19:
                    return 16
                  case 20:
                    return 17
                  case 21:
                    return 18
                  case 22:
                    return this.begin('person_ext'), 45
                    break
                  case 23:
                    return this.begin('person'), 44
                    break
                  case 24:
                    return this.begin('system_ext_queue'), 51
                    break
                  case 25:
                    return this.begin('system_ext_db'), 50
                    break
                  case 26:
                    return this.begin('system_ext'), 49
                    break
                  case 27:
                    return this.begin('system_queue'), 48
                    break
                  case 28:
                    return this.begin('system_db'), 47
                    break
                  case 29:
                    return this.begin('system'), 46
                    break
                  case 30:
                    return this.begin('boundary'), 37
                    break
                  case 31:
                    return this.begin('enterprise_boundary'), 34
                    break
                  case 32:
                    return this.begin('system_boundary'), 36
                    break
                  case 33:
                    return this.begin('container_ext_queue'), 57
                    break
                  case 34:
                    return this.begin('container_ext_db'), 56
                    break
                  case 35:
                    return this.begin('container_ext'), 55
                    break
                  case 36:
                    return this.begin('container_queue'), 54
                    break
                  case 37:
                    return this.begin('container_db'), 53
                    break
                  case 38:
                    return this.begin('container'), 52
                    break
                  case 39:
                    return this.begin('container_boundary'), 38
                    break
                  case 40:
                    return this.begin('component_ext_queue'), 63
                    break
                  case 41:
                    return this.begin('component_ext_db'), 62
                    break
                  case 42:
                    return this.begin('component_ext'), 61
                    break
                  case 43:
                    return this.begin('component_queue'), 60
                    break
                  case 44:
                    return this.begin('component_db'), 59
                    break
                  case 45:
                    return this.begin('component'), 58
                    break
                  case 46:
                    return this.begin('node'), 39
                    break
                  case 47:
                    return this.begin('node'), 39
                    break
                  case 48:
                    return this.begin('node_l'), 40
                    break
                  case 49:
                    return this.begin('node_r'), 41
                    break
                  case 50:
                    return this.begin('rel'), 64
                    break
                  case 51:
                    return this.begin('birel'), 65
                    break
                  case 52:
                    return this.begin('rel_u'), 66
                    break
                  case 53:
                    return this.begin('rel_u'), 66
                    break
                  case 54:
                    return this.begin('rel_d'), 67
                    break
                  case 55:
                    return this.begin('rel_d'), 67
                    break
                  case 56:
                    return this.begin('rel_l'), 68
                    break
                  case 57:
                    return this.begin('rel_l'), 68
                    break
                  case 58:
                    return this.begin('rel_r'), 69
                    break
                  case 59:
                    return this.begin('rel_r'), 69
                    break
                  case 60:
                    return this.begin('rel_b'), 70
                    break
                  case 61:
                    return this.begin('rel_index'), 71
                    break
                  case 62:
                    return this.begin('update_el_style'), 72
                    break
                  case 63:
                    return this.begin('update_rel_style'), 73
                    break
                  case 64:
                    return this.begin('update_layout_config'), 74
                    break
                  case 65:
                    return 'EOF_IN_STRUCT'
                  case 66:
                    return this.begin('attribute'), 'ATTRIBUTE_EMPTY'
                    break
                  case 67:
                    this.begin('attribute')
                    break
                  case 68:
                    this.popState(), this.popState()
                    break
                  case 69:
                    return 80
                  case 70:
                    break
                  case 71:
                    return 80
                  case 72:
                    this.begin('string')
                    break
                  case 73:
                    this.popState()
                    break
                  case 74:
                    return 'STR'
                  case 75:
                    this.begin('string_kv')
                    break
                  case 76:
                    return this.begin('string_kv_key'), 'STR_KEY'
                    break
                  case 77:
                    this.popState(), this.begin('string_kv_value')
                    break
                  case 78:
                    return 'STR_VALUE'
                  case 79:
                    this.popState(), this.popState()
                    break
                  case 80:
                    return 'STR'
                  case 81:
                    return 'LBRACE'
                  case 82:
                    return 'RBRACE'
                  case 83:
                    return 'SPACE'
                  case 84:
                    return 'EOL'
                  case 85:
                    return 14
                }
              }, 'anonymous'),
              rules: [
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:title\s[^#\n;]+)/,
                /^(?:accDescription\s[^#\n;]+)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
                /^(?:%%[^\n]*(\r?\n)*)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:C4Context\b)/,
                /^(?:C4Container\b)/,
                /^(?:C4Component\b)/,
                /^(?:C4Dynamic\b)/,
                /^(?:C4Deployment\b)/,
                /^(?:Person_Ext\b)/,
                /^(?:Person\b)/,
                /^(?:SystemQueue_Ext\b)/,
                /^(?:SystemDb_Ext\b)/,
                /^(?:System_Ext\b)/,
                /^(?:SystemQueue\b)/,
                /^(?:SystemDb\b)/,
                /^(?:System\b)/,
                /^(?:Boundary\b)/,
                /^(?:Enterprise_Boundary\b)/,
                /^(?:System_Boundary\b)/,
                /^(?:ContainerQueue_Ext\b)/,
                /^(?:ContainerDb_Ext\b)/,
                /^(?:Container_Ext\b)/,
                /^(?:ContainerQueue\b)/,
                /^(?:ContainerDb\b)/,
                /^(?:Container\b)/,
                /^(?:Container_Boundary\b)/,
                /^(?:ComponentQueue_Ext\b)/,
                /^(?:ComponentDb_Ext\b)/,
                /^(?:Component_Ext\b)/,
                /^(?:ComponentQueue\b)/,
                /^(?:ComponentDb\b)/,
                /^(?:Component\b)/,
                /^(?:Deployment_Node\b)/,
                /^(?:Node\b)/,
                /^(?:Node_L\b)/,
                /^(?:Node_R\b)/,
                /^(?:Rel\b)/,
                /^(?:BiRel\b)/,
                /^(?:Rel_Up\b)/,
                /^(?:Rel_U\b)/,
                /^(?:Rel_Down\b)/,
                /^(?:Rel_D\b)/,
                /^(?:Rel_Left\b)/,
                /^(?:Rel_L\b)/,
                /^(?:Rel_Right\b)/,
                /^(?:Rel_R\b)/,
                /^(?:Rel_Back\b)/,
                /^(?:RelIndex\b)/,
                /^(?:UpdateElementStyle\b)/,
                /^(?:UpdateRelStyle\b)/,
                /^(?:UpdateLayoutConfig\b)/,
                /^(?:$)/,
                /^(?:[(][ ]*[,])/,
                /^(?:[(])/,
                /^(?:[)])/,
                /^(?:,,)/,
                /^(?:,)/,
                /^(?:[ ]*["]["])/,
                /^(?:[ ]*["])/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:[ ]*[\$])/,
                /^(?:[^=]*)/,
                /^(?:[=][ ]*["])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:[^,]+)/,
                /^(?:\{)/,
                /^(?:\})/,
                /^(?:[\s]+)/,
                /^(?:[\n\r]+)/,
                /^(?:$)/,
              ],
              conditions: {
                acc_descr_multiline: { rules: [11, 12], inclusive: !1 },
                acc_descr: { rules: [9], inclusive: !1 },
                acc_title: { rules: [7], inclusive: !1 },
                string_kv_value: { rules: [78, 79], inclusive: !1 },
                string_kv_key: { rules: [77], inclusive: !1 },
                string_kv: { rules: [76], inclusive: !1 },
                string: { rules: [73, 74], inclusive: !1 },
                attribute: { rules: [68, 69, 70, 71, 72, 75, 80], inclusive: !1 },
                update_layout_config: { rules: [65, 66, 67, 68], inclusive: !1 },
                update_rel_style: { rules: [65, 66, 67, 68], inclusive: !1 },
                update_el_style: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_b: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_r: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_l: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_d: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_u: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_bi: { rules: [], inclusive: !1 },
                rel: { rules: [65, 66, 67, 68], inclusive: !1 },
                node_r: { rules: [65, 66, 67, 68], inclusive: !1 },
                node_l: { rules: [65, 66, 67, 68], inclusive: !1 },
                node: { rules: [65, 66, 67, 68], inclusive: !1 },
                index: { rules: [], inclusive: !1 },
                rel_index: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_ext_queue: { rules: [], inclusive: !1 },
                component_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                component: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                container: { rules: [65, 66, 67, 68], inclusive: !1 },
                birel: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                enterprise_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                system: { rules: [65, 66, 67, 68], inclusive: !1 },
                person_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                person: { rules: [65, 66, 67, 68], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
                    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                    56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83, 84, 85,
                  ],
                  inclusive: !0,
                },
              },
            }
            return se
          })()
        lt.lexer = jt
        function Me() {
          this.yy = {}
        }
        return a(Me, 'Parser'), (Me.prototype = lt), (lt.Parser = Me), new Me()
      })()
      sg.parser = sg
      wI = sg
    })
  var hut,
    fut,
    Ar,
    Kl,
    On = x(() => {
      'use strict'
      Vt()
      ;(hut = a(function (e, t) {
        for (let r of t) e.attr(r[0], r[1])
      }, 'd3Attrs')),
        (fut = a(function (e, t, r) {
          let n = new Map()
          return (
            r
              ? (n.set('width', '100%'), n.set('style', `max-width: ${t}px;`))
              : (n.set('height', e), n.set('width', t)),
            n
          )
        }, 'calculateSvgSizeAttrs')),
        (Ar = a(function (e, t, r, n) {
          let i = fut(t, r, n)
          hut(e, i)
        }, 'configureSvgSize')),
        (Kl = a(function (e, t, r, n) {
          let i = t.node().getBBox(),
            s = i.width,
            o = i.height
          B.info(`SVG bounds: ${s}x${o}`, i)
          let l = 0,
            u = 0
          B.info(`Graph bounds: ${l}x${u}`, e),
            (l = s + r * 2),
            (u = o + r * 2),
            B.info(`Calculated bounds: ${l}x${u}`),
            Ar(t, u, l, n)
          let h = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`
          t.attr('viewBox', h)
        }, 'setupGraphViewbox'))
    })
  var _x,
    dut,
    EI,
    vI,
    xw = x(() => {
      'use strict'
      Vt()
      ;(_x = {}),
        (dut = a((e, t, r) => {
          let n = ''
          return (
            e in _x && _x[e] ? (n = _x[e](r)) : B.warn(`No theme found for ${e}`),
            ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${t}
`
          )
        }, 'getStyles')),
        (EI = a((e, t) => {
          t !== void 0 && (_x[e] = t)
        }, 'addStylesForDiagram')),
        (vI = dut)
    })
  var ag = {}
  Oe(ag, {
    clear: () => Ye,
    getAccDescription: () => rr,
    getAccTitle: () => tr,
    getDiagramTitle: () => nr,
    setAccDescription: () => er,
    setAccTitle: () => Xe,
    setDiagramTitle: () => lr,
  })
  var bw,
    kw,
    Tw,
    Sw,
    Ye,
    Xe,
    tr,
    er,
    rr,
    lr,
    nr,
    bn = x(() => {
      'use strict'
      Be()
      fn()
      ;(bw = ''),
        (kw = ''),
        (Tw = ''),
        (Sw = a((e) => Ie(e, Te()), 'sanitizeText')),
        (Ye = a(() => {
          ;(bw = ''), (Tw = ''), (kw = '')
        }, 'clear')),
        (Xe = a((e) => {
          bw = Sw(e).replace(/^\s+/g, '')
        }, 'setAccTitle')),
        (tr = a(() => bw, 'getAccTitle')),
        (er = a((e) => {
          Tw = Sw(e).replace(
            /\n\s+/g,
            `
`,
          )
        }, 'setAccDescription')),
        (rr = a(() => Tw, 'getAccDescription')),
        (lr = a((e) => {
          kw = Sw(e)
        }, 'setDiagramTitle')),
        (nr = a(() => kw, 'getDiagramTitle'))
    })
  var AI,
    put,
    K,
    og,
    wx,
    lg,
    Cw,
    mut,
    Cx,
    Su,
    cg,
    _w,
    pe = x(() => {
      'use strict'
      Tu()
      Vt()
      fn()
      Be()
      On()
      xw()
      bn()
      ;(AI = B),
        (put = jm),
        (K = Te),
        (og = mx),
        (wx = Hl),
        (lg = a((e) => Ie(e, K()), 'sanitizeText')),
        (Cw = Kl),
        (mut = a(() => ag, 'getCommonDb')),
        (Cx = {}),
        (Su = a((e, t, r) => {
          Cx[e] && AI.warn(`Diagram with id ${e} already registered. Overwriting.`),
            (Cx[e] = t),
            r && gw(e, r),
            EI(e, t.styles),
            t.injectUtils?.(AI, put, K, lg, Cw, mut(), () => {})
        }, 'registerDiagram')),
        (cg = a((e) => {
          if (e in Cx) return Cx[e]
          throw new _w(e)
        }, 'getDiagram')),
        (_w = class extends Error {
          static {
            a(this, 'DiagramNotFoundError')
          }
          constructor(t) {
            super(`Diagram ${t} not found.`)
          }
        })
    })
  var _a,
    Ql,
    Bi,
    Sa,
    no,
    ug,
    ww,
    Ew,
    Ex,
    vx,
    LI,
    gut,
    yut,
    xut,
    but,
    kut,
    Tut,
    Sut,
    _ut,
    Cut,
    wut,
    Eut,
    vut,
    Aut,
    Lut,
    Rut,
    Dut,
    Nut,
    RI,
    Iut,
    Mut,
    DI,
    Out,
    Put,
    But,
    Fut,
    Zl,
    $ut,
    Gut,
    Vut,
    zut,
    Wut,
    hg,
    vw = x(() => {
      'use strict'
      pe()
      Be()
      bn()
      ;(_a = []),
        (Ql = ['']),
        (Bi = 'global'),
        (Sa = ''),
        (no = [
          {
            alias: 'global',
            label: { text: 'global' },
            type: { text: 'global' },
            tags: null,
            link: null,
            parentBoundary: '',
          },
        ]),
        (ug = []),
        (ww = ''),
        (Ew = !1),
        (Ex = 4),
        (vx = 2),
        (gut = a(function () {
          return LI
        }, 'getC4Type')),
        (yut = a(function (e) {
          LI = Ie(e, K())
        }, 'setC4Type')),
        (xut = a(function (e, t, r, n, i, s, o, l, u) {
          if (e == null || t === void 0 || t === null || r === void 0 || r === null || n === void 0 || n === null)
            return
          let h = {},
            f = ug.find((d) => d.from === t && d.to === r)
          if ((f ? (h = f) : ug.push(h), (h.type = e), (h.from = t), (h.to = r), (h.label = { text: n }), i == null))
            h.techn = { text: '' }
          else if (typeof i == 'object') {
            let [d, p] = Object.entries(i)[0]
            h[d] = { text: p }
          } else h.techn = { text: i }
          if (s == null) h.descr = { text: '' }
          else if (typeof s == 'object') {
            let [d, p] = Object.entries(s)[0]
            h[d] = { text: p }
          } else h.descr = { text: s }
          if (typeof o == 'object') {
            let [d, p] = Object.entries(o)[0]
            h[d] = p
          } else h.sprite = o
          if (typeof l == 'object') {
            let [d, p] = Object.entries(l)[0]
            h[d] = p
          } else h.tags = l
          if (typeof u == 'object') {
            let [d, p] = Object.entries(u)[0]
            h[d] = p
          } else h.link = u
          h.wrap = Zl()
        }, 'addRel')),
        (but = a(function (e, t, r, n, i, s, o) {
          if (t === null || r === null) return
          let l = {},
            u = _a.find((h) => h.alias === t)
          if (
            (u && t === u.alias ? (l = u) : ((l.alias = t), _a.push(l)),
            r == null ? (l.label = { text: '' }) : (l.label = { text: r }),
            n == null)
          )
            l.descr = { text: '' }
          else if (typeof n == 'object') {
            let [h, f] = Object.entries(n)[0]
            l[h] = { text: f }
          } else l.descr = { text: n }
          if (typeof i == 'object') {
            let [h, f] = Object.entries(i)[0]
            l[h] = f
          } else l.sprite = i
          if (typeof s == 'object') {
            let [h, f] = Object.entries(s)[0]
            l[h] = f
          } else l.tags = s
          if (typeof o == 'object') {
            let [h, f] = Object.entries(o)[0]
            l[h] = f
          } else l.link = o
          ;(l.typeC4Shape = { text: e }), (l.parentBoundary = Bi), (l.wrap = Zl())
        }, 'addPersonOrSystem')),
        (kut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return
          let u = {},
            h = _a.find((f) => f.alias === t)
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), _a.push(u)),
            r == null ? (u.label = { text: '' }) : (u.label = { text: r }),
            n == null)
          )
            u.techn = { text: '' }
          else if (typeof n == 'object') {
            let [f, d] = Object.entries(n)[0]
            u[f] = { text: d }
          } else u.techn = { text: n }
          if (i == null) u.descr = { text: '' }
          else if (typeof i == 'object') {
            let [f, d] = Object.entries(i)[0]
            u[f] = { text: d }
          } else u.descr = { text: i }
          if (typeof s == 'object') {
            let [f, d] = Object.entries(s)[0]
            u[f] = d
          } else u.sprite = s
          if (typeof o == 'object') {
            let [f, d] = Object.entries(o)[0]
            u[f] = d
          } else u.tags = o
          if (typeof l == 'object') {
            let [f, d] = Object.entries(l)[0]
            u[f] = d
          } else u.link = l
          ;(u.wrap = Zl()), (u.typeC4Shape = { text: e }), (u.parentBoundary = Bi)
        }, 'addContainer')),
        (Tut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return
          let u = {},
            h = _a.find((f) => f.alias === t)
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), _a.push(u)),
            r == null ? (u.label = { text: '' }) : (u.label = { text: r }),
            n == null)
          )
            u.techn = { text: '' }
          else if (typeof n == 'object') {
            let [f, d] = Object.entries(n)[0]
            u[f] = { text: d }
          } else u.techn = { text: n }
          if (i == null) u.descr = { text: '' }
          else if (typeof i == 'object') {
            let [f, d] = Object.entries(i)[0]
            u[f] = { text: d }
          } else u.descr = { text: i }
          if (typeof s == 'object') {
            let [f, d] = Object.entries(s)[0]
            u[f] = d
          } else u.sprite = s
          if (typeof o == 'object') {
            let [f, d] = Object.entries(o)[0]
            u[f] = d
          } else u.tags = o
          if (typeof l == 'object') {
            let [f, d] = Object.entries(l)[0]
            u[f] = d
          } else u.link = l
          ;(u.wrap = Zl()), (u.typeC4Shape = { text: e }), (u.parentBoundary = Bi)
        }, 'addComponent')),
        (Sut = a(function (e, t, r, n, i) {
          if (e === null || t === null) return
          let s = {},
            o = no.find((l) => l.alias === e)
          if (
            (o && e === o.alias ? (s = o) : ((s.alias = e), no.push(s)),
            t == null ? (s.label = { text: '' }) : (s.label = { text: t }),
            r == null)
          )
            s.type = { text: 'system' }
          else if (typeof r == 'object') {
            let [l, u] = Object.entries(r)[0]
            s[l] = { text: u }
          } else s.type = { text: r }
          if (typeof n == 'object') {
            let [l, u] = Object.entries(n)[0]
            s[l] = u
          } else s.tags = n
          if (typeof i == 'object') {
            let [l, u] = Object.entries(i)[0]
            s[l] = u
          } else s.link = i
          ;(s.parentBoundary = Bi), (s.wrap = Zl()), (Sa = Bi), (Bi = e), Ql.push(Sa)
        }, 'addPersonOrSystemBoundary')),
        (_ut = a(function (e, t, r, n, i) {
          if (e === null || t === null) return
          let s = {},
            o = no.find((l) => l.alias === e)
          if (
            (o && e === o.alias ? (s = o) : ((s.alias = e), no.push(s)),
            t == null ? (s.label = { text: '' }) : (s.label = { text: t }),
            r == null)
          )
            s.type = { text: 'container' }
          else if (typeof r == 'object') {
            let [l, u] = Object.entries(r)[0]
            s[l] = { text: u }
          } else s.type = { text: r }
          if (typeof n == 'object') {
            let [l, u] = Object.entries(n)[0]
            s[l] = u
          } else s.tags = n
          if (typeof i == 'object') {
            let [l, u] = Object.entries(i)[0]
            s[l] = u
          } else s.link = i
          ;(s.parentBoundary = Bi), (s.wrap = Zl()), (Sa = Bi), (Bi = e), Ql.push(Sa)
        }, 'addContainerBoundary')),
        (Cut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return
          let u = {},
            h = no.find((f) => f.alias === t)
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), no.push(u)),
            r == null ? (u.label = { text: '' }) : (u.label = { text: r }),
            n == null)
          )
            u.type = { text: 'node' }
          else if (typeof n == 'object') {
            let [f, d] = Object.entries(n)[0]
            u[f] = { text: d }
          } else u.type = { text: n }
          if (i == null) u.descr = { text: '' }
          else if (typeof i == 'object') {
            let [f, d] = Object.entries(i)[0]
            u[f] = { text: d }
          } else u.descr = { text: i }
          if (typeof o == 'object') {
            let [f, d] = Object.entries(o)[0]
            u[f] = d
          } else u.tags = o
          if (typeof l == 'object') {
            let [f, d] = Object.entries(l)[0]
            u[f] = d
          } else u.link = l
          ;(u.nodeType = e), (u.parentBoundary = Bi), (u.wrap = Zl()), (Sa = Bi), (Bi = t), Ql.push(Sa)
        }, 'addDeploymentNode')),
        (wut = a(function () {
          ;(Bi = Sa), Ql.pop(), (Sa = Ql.pop()), Ql.push(Sa)
        }, 'popBoundaryParseStack')),
        (Eut = a(function (e, t, r, n, i, s, o, l, u, h, f) {
          let d = _a.find((p) => p.alias === t)
          if (!(d === void 0 && ((d = no.find((p) => p.alias === t)), d === void 0))) {
            if (r != null)
              if (typeof r == 'object') {
                let [p, m] = Object.entries(r)[0]
                d[p] = m
              } else d.bgColor = r
            if (n != null)
              if (typeof n == 'object') {
                let [p, m] = Object.entries(n)[0]
                d[p] = m
              } else d.fontColor = n
            if (i != null)
              if (typeof i == 'object') {
                let [p, m] = Object.entries(i)[0]
                d[p] = m
              } else d.borderColor = i
            if (s != null)
              if (typeof s == 'object') {
                let [p, m] = Object.entries(s)[0]
                d[p] = m
              } else d.shadowing = s
            if (o != null)
              if (typeof o == 'object') {
                let [p, m] = Object.entries(o)[0]
                d[p] = m
              } else d.shape = o
            if (l != null)
              if (typeof l == 'object') {
                let [p, m] = Object.entries(l)[0]
                d[p] = m
              } else d.sprite = l
            if (u != null)
              if (typeof u == 'object') {
                let [p, m] = Object.entries(u)[0]
                d[p] = m
              } else d.techn = u
            if (h != null)
              if (typeof h == 'object') {
                let [p, m] = Object.entries(h)[0]
                d[p] = m
              } else d.legendText = h
            if (f != null)
              if (typeof f == 'object') {
                let [p, m] = Object.entries(f)[0]
                d[p] = m
              } else d.legendSprite = f
          }
        }, 'updateElStyle')),
        (vut = a(function (e, t, r, n, i, s, o) {
          let l = ug.find((u) => u.from === t && u.to === r)
          if (l !== void 0) {
            if (n != null)
              if (typeof n == 'object') {
                let [u, h] = Object.entries(n)[0]
                l[u] = h
              } else l.textColor = n
            if (i != null)
              if (typeof i == 'object') {
                let [u, h] = Object.entries(i)[0]
                l[u] = h
              } else l.lineColor = i
            if (s != null)
              if (typeof s == 'object') {
                let [u, h] = Object.entries(s)[0]
                l[u] = parseInt(h)
              } else l.offsetX = parseInt(s)
            if (o != null)
              if (typeof o == 'object') {
                let [u, h] = Object.entries(o)[0]
                l[u] = parseInt(h)
              } else l.offsetY = parseInt(o)
          }
        }, 'updateRelStyle')),
        (Aut = a(function (e, t, r) {
          let n = Ex,
            i = vx
          if (typeof t == 'object') {
            let s = Object.values(t)[0]
            n = parseInt(s)
          } else n = parseInt(t)
          if (typeof r == 'object') {
            let s = Object.values(r)[0]
            i = parseInt(s)
          } else i = parseInt(r)
          n >= 1 && (Ex = n), i >= 1 && (vx = i)
        }, 'updateLayoutConfig')),
        (Lut = a(function () {
          return Ex
        }, 'getC4ShapeInRow')),
        (Rut = a(function () {
          return vx
        }, 'getC4BoundaryInRow')),
        (Dut = a(function () {
          return Bi
        }, 'getCurrentBoundaryParse')),
        (Nut = a(function () {
          return Sa
        }, 'getParentBoundaryParse')),
        (RI = a(function (e) {
          return e == null ? _a : _a.filter((t) => t.parentBoundary === e)
        }, 'getC4ShapeArray')),
        (Iut = a(function (e) {
          return _a.find((t) => t.alias === e)
        }, 'getC4Shape')),
        (Mut = a(function (e) {
          return Object.keys(RI(e))
        }, 'getC4ShapeKeys')),
        (DI = a(function (e) {
          return e == null ? no : no.filter((t) => t.parentBoundary === e)
        }, 'getBoundaries')),
        (Out = DI),
        (Put = a(function () {
          return ug
        }, 'getRels')),
        (But = a(function () {
          return ww
        }, 'getTitle')),
        (Fut = a(function (e) {
          Ew = e
        }, 'setWrap')),
        (Zl = a(function () {
          return Ew
        }, 'autoWrap')),
        ($ut = a(function () {
          ;(_a = []),
            (no = [
              {
                alias: 'global',
                label: { text: 'global' },
                type: { text: 'global' },
                tags: null,
                link: null,
                parentBoundary: '',
              },
            ]),
            (Sa = ''),
            (Bi = 'global'),
            (Ql = ['']),
            (ug = []),
            (Ql = ['']),
            (ww = ''),
            (Ew = !1),
            (Ex = 4),
            (vx = 2)
        }, 'clear')),
        (Gut = {
          SOLID: 0,
          DOTTED: 1,
          NOTE: 2,
          SOLID_CROSS: 3,
          DOTTED_CROSS: 4,
          SOLID_OPEN: 5,
          DOTTED_OPEN: 6,
          LOOP_START: 10,
          LOOP_END: 11,
          ALT_START: 12,
          ALT_ELSE: 13,
          ALT_END: 14,
          OPT_START: 15,
          OPT_END: 16,
          ACTIVE_START: 17,
          ACTIVE_END: 18,
          PAR_START: 19,
          PAR_AND: 20,
          PAR_END: 21,
          RECT_START: 22,
          RECT_END: 23,
          SOLID_POINT: 24,
          DOTTED_POINT: 25,
        }),
        (Vut = { FILLED: 0, OPEN: 1 }),
        (zut = { LEFTOF: 0, RIGHTOF: 1, OVER: 2 }),
        (Wut = a(function (e) {
          ww = Ie(e, K())
        }, 'setTitle')),
        (hg = {
          addPersonOrSystem: but,
          addPersonOrSystemBoundary: Sut,
          addContainer: kut,
          addContainerBoundary: _ut,
          addComponent: Tut,
          addDeploymentNode: Cut,
          popBoundaryParseStack: wut,
          addRel: xut,
          updateElStyle: Eut,
          updateRelStyle: vut,
          updateLayoutConfig: Aut,
          autoWrap: Zl,
          setWrap: Fut,
          getC4ShapeArray: RI,
          getC4Shape: Iut,
          getC4ShapeKeys: Mut,
          getBoundaries: DI,
          getBoundarys: Out,
          getCurrentBoundaryParse: Dut,
          getParentBoundaryParse: Nut,
          getRels: Put,
          getTitle: But,
          getC4Type: gut,
          getC4ShapeInRow: Lut,
          getC4BoundaryInRow: Rut,
          setAccTitle: Xe,
          getAccTitle: tr,
          getAccDescription: rr,
          setAccDescription: er,
          getConfig: a(() => K().c4, 'getConfig'),
          clear: $ut,
          LINETYPE: Gut,
          ARROWTYPE: Vut,
          PLACEMENT: zut,
          setTitle: Wut,
          setC4Type: yut,
        })
    })
  function _u(e, t) {
    return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
  }
  var Aw = x(() => {
    'use strict'
    a(_u, 'ascending')
  })
  function Lw(e, t) {
    return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
  }
  var NI = x(() => {
    'use strict'
    a(Lw, 'descending')
  })
  function Cu(e) {
    let t, r, n
    e.length !== 2
      ? ((t = _u), (r = a((l, u) => _u(e(l), u), 'compare2')), (n = a((l, u) => e(l) - u, 'delta')))
      : ((t = e === _u || e === Lw ? e : Uut), (r = e), (n = e))
    function i(l, u, h = 0, f = l.length) {
      if (h < f) {
        if (t(u, u) !== 0) return f
        do {
          let d = (h + f) >>> 1
          r(l[d], u) < 0 ? (h = d + 1) : (f = d)
        } while (h < f)
      }
      return h
    }
    a(i, 'left')
    function s(l, u, h = 0, f = l.length) {
      if (h < f) {
        if (t(u, u) !== 0) return f
        do {
          let d = (h + f) >>> 1
          r(l[d], u) <= 0 ? (h = d + 1) : (f = d)
        } while (h < f)
      }
      return h
    }
    a(s, 'right')
    function o(l, u, h = 0, f = l.length) {
      let d = i(l, u, h, f - 1)
      return d > h && n(l[d - 1], u) > -n(l[d], u) ? d - 1 : d
    }
    return a(o, 'center'), { left: i, center: o, right: s }
  }
  function Uut() {
    return 0
  }
  var Rw = x(() => {
    'use strict'
    Aw()
    NI()
    a(Cu, 'bisector')
    a(Uut, 'zero')
  })
  function Dw(e) {
    return e === null ? NaN : +e
  }
  var II = x(() => {
    'use strict'
    a(Dw, 'number')
  })
  var MI,
    OI,
    jut,
    qut,
    Nw,
    PI = x(() => {
      'use strict'
      Aw()
      Rw()
      II()
      ;(MI = Cu(_u)), (OI = MI.right), (jut = MI.left), (qut = Cu(Dw).center), (Nw = OI)
    })
  function BI({ _intern: e, _key: t }, r) {
    let n = t(r)
    return e.has(n) ? e.get(n) : r
  }
  function Hut({ _intern: e, _key: t }, r) {
    let n = t(r)
    return e.has(n) ? e.get(n) : (e.set(n, r), r)
  }
  function Yut({ _intern: e, _key: t }, r) {
    let n = t(r)
    return e.has(n) && ((r = e.get(n)), e.delete(n)), r
  }
  function Xut(e) {
    return e !== null && typeof e == 'object' ? e.valueOf() : e
  }
  var mf,
    FI = x(() => {
      'use strict'
      mf = class extends Map {
        static {
          a(this, 'InternMap')
        }
        constructor(t, r = Xut) {
          if (
            (super(), Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: r } }), t != null)
          )
            for (let [n, i] of t) this.set(n, i)
        }
        get(t) {
          return super.get(BI(this, t))
        }
        has(t) {
          return super.has(BI(this, t))
        }
        set(t, r) {
          return super.set(Hut(this, t), r)
        }
        delete(t) {
          return super.delete(Yut(this, t))
        }
      }
      a(BI, 'intern_get')
      a(Hut, 'intern_set')
      a(Yut, 'intern_delete')
      a(Xut, 'keyof')
    })
  function Ax(e, t, r) {
    let n = (t - e) / Math.max(0, r),
      i = Math.floor(Math.log10(n)),
      s = n / Math.pow(10, i),
      o = s >= Kut ? 10 : s >= Qut ? 5 : s >= Zut ? 2 : 1,
      l,
      u,
      h
    return (
      i < 0
        ? ((h = Math.pow(10, -i) / o),
          (l = Math.round(e * h)),
          (u = Math.round(t * h)),
          l / h < e && ++l,
          u / h > t && --u,
          (h = -h))
        : ((h = Math.pow(10, i) * o),
          (l = Math.round(e / h)),
          (u = Math.round(t / h)),
          l * h < e && ++l,
          u * h > t && --u),
      u < l && 0.5 <= r && r < 2 ? Ax(e, t, r * 2) : [l, u, h]
    )
  }
  function Lx(e, t, r) {
    if (((t = +t), (e = +e), (r = +r), !(r > 0))) return []
    if (e === t) return [e]
    let n = t < e,
      [i, s, o] = n ? Ax(t, e, r) : Ax(e, t, r)
    if (!(s >= i)) return []
    let l = s - i + 1,
      u = new Array(l)
    if (n)
      if (o < 0) for (let h = 0; h < l; ++h) u[h] = (s - h) / -o
      else for (let h = 0; h < l; ++h) u[h] = (s - h) * o
    else if (o < 0) for (let h = 0; h < l; ++h) u[h] = (i + h) / -o
    else for (let h = 0; h < l; ++h) u[h] = (i + h) * o
    return u
  }
  function fg(e, t, r) {
    return (t = +t), (e = +e), (r = +r), Ax(e, t, r)[2]
  }
  function gf(e, t, r) {
    ;(t = +t), (e = +e), (r = +r)
    let n = t < e,
      i = n ? fg(t, e, r) : fg(e, t, r)
    return (n ? -1 : 1) * (i < 0 ? 1 / -i : i)
  }
  var Kut,
    Qut,
    Zut,
    $I = x(() => {
      'use strict'
      ;(Kut = Math.sqrt(50)), (Qut = Math.sqrt(10)), (Zut = Math.sqrt(2))
      a(Ax, 'tickSpec')
      a(Lx, 'ticks')
      a(fg, 'tickIncrement')
      a(gf, 'tickStep')
    })
  function Rx(e, t) {
    let r
    if (t === void 0) for (let n of e) n != null && (r < n || (r === void 0 && n >= n)) && (r = n)
    else {
      let n = -1
      for (let i of e) (i = t(i, ++n, e)) != null && (r < i || (r === void 0 && i >= i)) && (r = i)
    }
    return r
  }
  var GI = x(() => {
    'use strict'
    a(Rx, 'max')
  })
  function Dx(e, t) {
    let r
    if (t === void 0) for (let n of e) n != null && (r > n || (r === void 0 && n >= n)) && (r = n)
    else {
      let n = -1
      for (let i of e) (i = t(i, ++n, e)) != null && (r > i || (r === void 0 && i >= i)) && (r = i)
    }
    return r
  }
  var VI = x(() => {
    'use strict'
    a(Dx, 'min')
  })
  function Nx(e, t, r) {
    ;(e = +e), (t = +t), (r = (i = arguments.length) < 2 ? ((t = e), (e = 0), 1) : i < 3 ? 1 : +r)
    for (var n = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, s = new Array(i); ++n < i; ) s[n] = e + n * r
    return s
  }
  var zI = x(() => {
    'use strict'
    a(Nx, 'range')
  })
  var Jl = x(() => {
    'use strict'
    PI()
    Rw()
    GI()
    VI()
    zI()
    $I()
    FI()
  })
  function Iw(e) {
    return e
  }
  var WI = x(() => {
    'use strict'
    a(Iw, 'default')
  })
  function Jut(e) {
    return 'translate(' + e + ',0)'
  }
  function tht(e) {
    return 'translate(0,' + e + ')'
  }
  function eht(e) {
    return (t) => +e(t)
  }
  function rht(e, t) {
    return (t = Math.max(0, e.bandwidth() - t * 2) / 2), e.round() && (t = Math.round(t)), (r) => +e(r) + t
  }
  function nht() {
    return !this.__axis
  }
  function jI(e, t) {
    var r = [],
      n = null,
      i = null,
      s = 6,
      o = 6,
      l = 3,
      u = typeof window < 'u' && window.devicePixelRatio > 1 ? 0 : 0.5,
      h = e === Mx || e === Ix ? -1 : 1,
      f = e === Ix || e === Mw ? 'x' : 'y',
      d = e === Mx || e === Ow ? Jut : tht
    function p(m) {
      var g = n ?? (t.ticks ? t.ticks.apply(t, r) : t.domain()),
        y = i ?? (t.tickFormat ? t.tickFormat.apply(t, r) : Iw),
        b = Math.max(s, 0) + l,
        k = t.range(),
        T = +k[0] + u,
        C = +k[k.length - 1] + u,
        A = (t.bandwidth ? rht : eht)(t.copy(), u),
        w = m.selection ? m.selection() : m,
        D = w.selectAll('.domain').data([null]),
        G = w.selectAll('.tick').data(g, t).order(),
        v = G.exit(),
        R = G.enter().append('g').attr('class', 'tick'),
        F = G.select('line'),
        S = G.select('text')
      ;(D = D.merge(D.enter().insert('path', '.tick').attr('class', 'domain').attr('stroke', 'currentColor'))),
        (G = G.merge(R)),
        (F = F.merge(
          R.append('line')
            .attr('stroke', 'currentColor')
            .attr(f + '2', h * s),
        )),
        (S = S.merge(
          R.append('text')
            .attr('fill', 'currentColor')
            .attr(f, h * b)
            .attr('dy', e === Mx ? '0em' : e === Ow ? '0.71em' : '0.32em'),
        )),
        m !== w &&
          ((D = D.transition(m)),
          (G = G.transition(m)),
          (F = F.transition(m)),
          (S = S.transition(m)),
          (v = v
            .transition(m)
            .attr('opacity', UI)
            .attr('transform', function (O) {
              return isFinite((O = A(O))) ? d(O + u) : this.getAttribute('transform')
            })),
          R.attr('opacity', UI).attr('transform', function (O) {
            var E = this.parentNode.__axis
            return d((E && isFinite((E = E(O))) ? E : A(O)) + u)
          })),
        v.remove(),
        D.attr(
          'd',
          e === Ix || e === Mw
            ? o
              ? 'M' + h * o + ',' + T + 'H' + u + 'V' + C + 'H' + h * o
              : 'M' + u + ',' + T + 'V' + C
            : o
              ? 'M' + T + ',' + h * o + 'V' + u + 'H' + C + 'V' + h * o
              : 'M' + T + ',' + u + 'H' + C,
        ),
        G.attr('opacity', 1).attr('transform', function (O) {
          return d(A(O) + u)
        }),
        F.attr(f + '2', h * s),
        S.attr(f, h * b).text(y),
        w
          .filter(nht)
          .attr('fill', 'none')
          .attr('font-size', 10)
          .attr('font-family', 'sans-serif')
          .attr('text-anchor', e === Mw ? 'start' : e === Ix ? 'end' : 'middle'),
        w.each(function () {
          this.__axis = A
        })
    }
    return (
      a(p, 'axis'),
      (p.scale = function (m) {
        return arguments.length ? ((t = m), p) : t
      }),
      (p.ticks = function () {
        return (r = Array.from(arguments)), p
      }),
      (p.tickArguments = function (m) {
        return arguments.length ? ((r = m == null ? [] : Array.from(m)), p) : r.slice()
      }),
      (p.tickValues = function (m) {
        return arguments.length ? ((n = m == null ? null : Array.from(m)), p) : n && n.slice()
      }),
      (p.tickFormat = function (m) {
        return arguments.length ? ((i = m), p) : i
      }),
      (p.tickSize = function (m) {
        return arguments.length ? ((s = o = +m), p) : s
      }),
      (p.tickSizeInner = function (m) {
        return arguments.length ? ((s = +m), p) : s
      }),
      (p.tickSizeOuter = function (m) {
        return arguments.length ? ((o = +m), p) : o
      }),
      (p.tickPadding = function (m) {
        return arguments.length ? ((l = +m), p) : l
      }),
      (p.offset = function (m) {
        return arguments.length ? ((u = +m), p) : u
      }),
      p
    )
  }
  function Pw(e) {
    return jI(Mx, e)
  }
  function Bw(e) {
    return jI(Ow, e)
  }
  var Mx,
    Mw,
    Ow,
    Ix,
    UI,
    qI = x(() => {
      'use strict'
      WI()
      ;(Mx = 1), (Mw = 2), (Ow = 3), (Ix = 4), (UI = 1e-6)
      a(Jut, 'translateX')
      a(tht, 'translateY')
      a(eht, 'number')
      a(rht, 'center')
      a(nht, 'entering')
      a(jI, 'axis')
      a(Pw, 'axisTop')
      a(Bw, 'axisBottom')
    })
  var HI = x(() => {
    'use strict'
    qI()
  })
  function XI() {
    for (var e = 0, t = arguments.length, r = {}, n; e < t; ++e) {
      if (!(n = arguments[e] + '') || n in r || /[\s.]/.test(n)) throw new Error('illegal type: ' + n)
      r[n] = []
    }
    return new Ox(r)
  }
  function Ox(e) {
    this._ = e
  }
  function sht(e, t) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (r) {
        var n = '',
          i = r.indexOf('.')
        if ((i >= 0 && ((n = r.slice(i + 1)), (r = r.slice(0, i))), r && !t.hasOwnProperty(r)))
          throw new Error('unknown type: ' + r)
        return { type: r, name: n }
      })
  }
  function aht(e, t) {
    for (var r = 0, n = e.length, i; r < n; ++r) if ((i = e[r]).name === t) return i.value
  }
  function YI(e, t, r) {
    for (var n = 0, i = e.length; n < i; ++n)
      if (e[n].name === t) {
        ;(e[n] = iht), (e = e.slice(0, n).concat(e.slice(n + 1)))
        break
      }
    return r != null && e.push({ name: t, value: r }), e
  }
  var iht,
    Fw,
    KI = x(() => {
      'use strict'
      iht = { value: a(() => {}, 'value') }
      a(XI, 'dispatch')
      a(Ox, 'Dispatch')
      a(sht, 'parseTypenames')
      Ox.prototype = XI.prototype = {
        constructor: Ox,
        on: a(function (e, t) {
          var r = this._,
            n = sht(e + '', r),
            i,
            s = -1,
            o = n.length
          if (arguments.length < 2) {
            for (; ++s < o; ) if ((i = (e = n[s]).type) && (i = aht(r[i], e.name))) return i
            return
          }
          if (t != null && typeof t != 'function') throw new Error('invalid callback: ' + t)
          for (; ++s < o; )
            if ((i = (e = n[s]).type)) r[i] = YI(r[i], e.name, t)
            else if (t == null) for (i in r) r[i] = YI(r[i], e.name, null)
          return this
        }, 'on'),
        copy: a(function () {
          var e = {},
            t = this._
          for (var r in t) e[r] = t[r].slice()
          return new Ox(e)
        }, 'copy'),
        call: a(function (e, t) {
          if ((i = arguments.length - 2) > 0)
            for (var r = new Array(i), n = 0, i, s; n < i; ++n) r[n] = arguments[n + 2]
          if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
          for (s = this._[e], n = 0, i = s.length; n < i; ++n) s[n].value.apply(t, r)
        }, 'call'),
        apply: a(function (e, t, r) {
          if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
          for (var n = this._[e], i = 0, s = n.length; i < s; ++i) n[i].value.apply(t, r)
        }, 'apply'),
      }
      a(aht, 'get')
      a(YI, 'set')
      Fw = XI
    })
  var $w = x(() => {
    'use strict'
    KI()
  })
  var Px,
    Gw,
    Vw = x(() => {
      'use strict'
      ;(Px = 'http://www.w3.org/1999/xhtml'),
        (Gw = {
          svg: 'http://www.w3.org/2000/svg',
          xhtml: Px,
          xlink: 'http://www.w3.org/1999/xlink',
          xml: 'http://www.w3.org/XML/1998/namespace',
          xmlns: 'http://www.w3.org/2000/xmlns/',
        })
    })
  function io(e) {
    var t = (e += ''),
      r = t.indexOf(':')
    return (
      r >= 0 && (t = e.slice(0, r)) !== 'xmlns' && (e = e.slice(r + 1)),
      Gw.hasOwnProperty(t) ? { space: Gw[t], local: e } : e
    )
  }
  var Bx = x(() => {
    'use strict'
    Vw()
    a(io, 'default')
  })
  function oht(e) {
    return function () {
      var t = this.ownerDocument,
        r = this.namespaceURI
      return r === Px && t.documentElement.namespaceURI === Px ? t.createElement(e) : t.createElementNS(r, e)
    }
  }
  function lht(e) {
    return function () {
      return this.ownerDocument.createElementNS(e.space, e.local)
    }
  }
  function dg(e) {
    var t = io(e)
    return (t.local ? lht : oht)(t)
  }
  var zw = x(() => {
    'use strict'
    Bx()
    Vw()
    a(oht, 'creatorInherit')
    a(lht, 'creatorFixed')
    a(dg, 'default')
  })
  function cht() {}
  function tc(e) {
    return e == null
      ? cht
      : function () {
          return this.querySelector(e)
        }
  }
  var Fx = x(() => {
    'use strict'
    a(cht, 'none')
    a(tc, 'default')
  })
  function Ww(e) {
    typeof e != 'function' && (e = tc(e))
    for (var t = this._groups, r = t.length, n = new Array(r), i = 0; i < r; ++i)
      for (var s = t[i], o = s.length, l = (n[i] = new Array(o)), u, h, f = 0; f < o; ++f)
        (u = s[f]) && (h = e.call(u, u.__data__, f, s)) && ('__data__' in u && (h.__data__ = u.__data__), (l[f] = h))
    return new dn(n, this._parents)
  }
  var QI = x(() => {
    'use strict'
    Ca()
    Fx()
    a(Ww, 'default')
  })
  function Uw(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e)
  }
  var ZI = x(() => {
    'use strict'
    a(Uw, 'array')
  })
  function uht() {
    return []
  }
  function yf(e) {
    return e == null
      ? uht
      : function () {
          return this.querySelectorAll(e)
        }
  }
  var jw = x(() => {
    'use strict'
    a(uht, 'empty')
    a(yf, 'default')
  })
  function hht(e) {
    return function () {
      return Uw(e.apply(this, arguments))
    }
  }
  function qw(e) {
    typeof e == 'function' ? (e = hht(e)) : (e = yf(e))
    for (var t = this._groups, r = t.length, n = [], i = [], s = 0; s < r; ++s)
      for (var o = t[s], l = o.length, u, h = 0; h < l; ++h)
        (u = o[h]) && (n.push(e.call(u, u.__data__, h, o)), i.push(u))
    return new dn(n, i)
  }
  var JI = x(() => {
    'use strict'
    Ca()
    ZI()
    jw()
    a(hht, 'arrayAll')
    a(qw, 'default')
  })
  function xf(e) {
    return function () {
      return this.matches(e)
    }
  }
  function $x(e) {
    return function (t) {
      return t.matches(e)
    }
  }
  var pg = x(() => {
    'use strict'
    a(xf, 'default')
    a($x, 'childMatcher')
  })
  function dht(e) {
    return function () {
      return fht.call(this.children, e)
    }
  }
  function pht() {
    return this.firstElementChild
  }
  function Hw(e) {
    return this.select(e == null ? pht : dht(typeof e == 'function' ? e : $x(e)))
  }
  var fht,
    tM = x(() => {
      'use strict'
      pg()
      fht = Array.prototype.find
      a(dht, 'childFind')
      a(pht, 'childFirst')
      a(Hw, 'default')
    })
  function ght() {
    return Array.from(this.children)
  }
  function yht(e) {
    return function () {
      return mht.call(this.children, e)
    }
  }
  function Yw(e) {
    return this.selectAll(e == null ? ght : yht(typeof e == 'function' ? e : $x(e)))
  }
  var mht,
    eM = x(() => {
      'use strict'
      pg()
      mht = Array.prototype.filter
      a(ght, 'children')
      a(yht, 'childrenFilter')
      a(Yw, 'default')
    })
  function Xw(e) {
    typeof e != 'function' && (e = xf(e))
    for (var t = this._groups, r = t.length, n = new Array(r), i = 0; i < r; ++i)
      for (var s = t[i], o = s.length, l = (n[i] = []), u, h = 0; h < o; ++h)
        (u = s[h]) && e.call(u, u.__data__, h, s) && l.push(u)
    return new dn(n, this._parents)
  }
  var rM = x(() => {
    'use strict'
    Ca()
    pg()
    a(Xw, 'default')
  })
  function mg(e) {
    return new Array(e.length)
  }
  var Kw = x(() => {
    'use strict'
    a(mg, 'default')
  })
  function Qw() {
    return new dn(this._enter || this._groups.map(mg), this._parents)
  }
  function gg(e, t) {
    ;(this.ownerDocument = e.ownerDocument),
      (this.namespaceURI = e.namespaceURI),
      (this._next = null),
      (this._parent = e),
      (this.__data__ = t)
  }
  var Zw = x(() => {
    'use strict'
    Kw()
    Ca()
    a(Qw, 'default')
    a(gg, 'EnterNode')
    gg.prototype = {
      constructor: gg,
      appendChild: a(function (e) {
        return this._parent.insertBefore(e, this._next)
      }, 'appendChild'),
      insertBefore: a(function (e, t) {
        return this._parent.insertBefore(e, t)
      }, 'insertBefore'),
      querySelector: a(function (e) {
        return this._parent.querySelector(e)
      }, 'querySelector'),
      querySelectorAll: a(function (e) {
        return this._parent.querySelectorAll(e)
      }, 'querySelectorAll'),
    }
  })
  function Jw(e) {
    return function () {
      return e
    }
  }
  var nM = x(() => {
    'use strict'
    a(Jw, 'default')
  })
  function xht(e, t, r, n, i, s) {
    for (var o = 0, l, u = t.length, h = s.length; o < h; ++o)
      (l = t[o]) ? ((l.__data__ = s[o]), (n[o] = l)) : (r[o] = new gg(e, s[o]))
    for (; o < u; ++o) (l = t[o]) && (i[o] = l)
  }
  function bht(e, t, r, n, i, s, o) {
    var l,
      u,
      h = new Map(),
      f = t.length,
      d = s.length,
      p = new Array(f),
      m
    for (l = 0; l < f; ++l)
      (u = t[l]) && ((p[l] = m = o.call(u, u.__data__, l, t) + ''), h.has(m) ? (i[l] = u) : h.set(m, u))
    for (l = 0; l < d; ++l)
      (m = o.call(e, s[l], l, s) + ''),
        (u = h.get(m)) ? ((n[l] = u), (u.__data__ = s[l]), h.delete(m)) : (r[l] = new gg(e, s[l]))
    for (l = 0; l < f; ++l) (u = t[l]) && h.get(p[l]) === u && (i[l] = u)
  }
  function kht(e) {
    return e.__data__
  }
  function tE(e, t) {
    if (!arguments.length) return Array.from(this, kht)
    var r = t ? bht : xht,
      n = this._parents,
      i = this._groups
    typeof e != 'function' && (e = Jw(e))
    for (var s = i.length, o = new Array(s), l = new Array(s), u = new Array(s), h = 0; h < s; ++h) {
      var f = n[h],
        d = i[h],
        p = d.length,
        m = Tht(e.call(f, f && f.__data__, h, n)),
        g = m.length,
        y = (l[h] = new Array(g)),
        b = (o[h] = new Array(g)),
        k = (u[h] = new Array(p))
      r(f, d, y, b, k, m, t)
      for (var T = 0, C = 0, A, w; T < g; ++T)
        if ((A = y[T])) {
          for (T >= C && (C = T + 1); !(w = b[C]) && ++C < g; );
          A._next = w || null
        }
    }
    return (o = new dn(o, n)), (o._enter = l), (o._exit = u), o
  }
  function Tht(e) {
    return typeof e == 'object' && 'length' in e ? e : Array.from(e)
  }
  var iM = x(() => {
    'use strict'
    Ca()
    Zw()
    nM()
    a(xht, 'bindIndex')
    a(bht, 'bindKey')
    a(kht, 'datum')
    a(tE, 'default')
    a(Tht, 'arraylike')
  })
  function eE() {
    return new dn(this._exit || this._groups.map(mg), this._parents)
  }
  var sM = x(() => {
    'use strict'
    Kw()
    Ca()
    a(eE, 'default')
  })
  function rE(e, t, r) {
    var n = this.enter(),
      i = this,
      s = this.exit()
    return (
      typeof e == 'function' ? ((n = e(n)), n && (n = n.selection())) : (n = n.append(e + '')),
      t != null && ((i = t(i)), i && (i = i.selection())),
      r == null ? s.remove() : r(s),
      n && i ? n.merge(i).order() : i
    )
  }
  var aM = x(() => {
    'use strict'
    a(rE, 'default')
  })
  function nE(e) {
    for (
      var t = e.selection ? e.selection() : e,
        r = this._groups,
        n = t._groups,
        i = r.length,
        s = n.length,
        o = Math.min(i, s),
        l = new Array(i),
        u = 0;
      u < o;
      ++u
    )
      for (var h = r[u], f = n[u], d = h.length, p = (l[u] = new Array(d)), m, g = 0; g < d; ++g)
        (m = h[g] || f[g]) && (p[g] = m)
    for (; u < i; ++u) l[u] = r[u]
    return new dn(l, this._parents)
  }
  var oM = x(() => {
    'use strict'
    Ca()
    a(nE, 'default')
  })
  function iE() {
    for (var e = this._groups, t = -1, r = e.length; ++t < r; )
      for (var n = e[t], i = n.length - 1, s = n[i], o; --i >= 0; )
        (o = n[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), (s = o))
    return this
  }
  var lM = x(() => {
    'use strict'
    a(iE, 'default')
  })
  function sE(e) {
    e || (e = Sht)
    function t(d, p) {
      return d && p ? e(d.__data__, p.__data__) : !d - !p
    }
    a(t, 'compareNode')
    for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
      for (var o = r[s], l = o.length, u = (i[s] = new Array(l)), h, f = 0; f < l; ++f) (h = o[f]) && (u[f] = h)
      u.sort(t)
    }
    return new dn(i, this._parents).order()
  }
  function Sht(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
  }
  var cM = x(() => {
    'use strict'
    Ca()
    a(sE, 'default')
    a(Sht, 'ascending')
  })
  function aE() {
    var e = arguments[0]
    return (arguments[0] = this), e.apply(null, arguments), this
  }
  var uM = x(() => {
    'use strict'
    a(aE, 'default')
  })
  function oE() {
    return Array.from(this)
  }
  var hM = x(() => {
    'use strict'
    a(oE, 'default')
  })
  function lE() {
    for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
      for (var n = e[t], i = 0, s = n.length; i < s; ++i) {
        var o = n[i]
        if (o) return o
      }
    return null
  }
  var fM = x(() => {
    'use strict'
    a(lE, 'default')
  })
  function cE() {
    let e = 0
    for (let t of this) ++e
    return e
  }
  var dM = x(() => {
    'use strict'
    a(cE, 'default')
  })
  function uE() {
    return !this.node()
  }
  var pM = x(() => {
    'use strict'
    a(uE, 'default')
  })
  function hE(e) {
    for (var t = this._groups, r = 0, n = t.length; r < n; ++r)
      for (var i = t[r], s = 0, o = i.length, l; s < o; ++s) (l = i[s]) && e.call(l, l.__data__, s, i)
    return this
  }
  var mM = x(() => {
    'use strict'
    a(hE, 'default')
  })
  function _ht(e) {
    return function () {
      this.removeAttribute(e)
    }
  }
  function Cht(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local)
    }
  }
  function wht(e, t) {
    return function () {
      this.setAttribute(e, t)
    }
  }
  function Eht(e, t) {
    return function () {
      this.setAttributeNS(e.space, e.local, t)
    }
  }
  function vht(e, t) {
    return function () {
      var r = t.apply(this, arguments)
      r == null ? this.removeAttribute(e) : this.setAttribute(e, r)
    }
  }
  function Aht(e, t) {
    return function () {
      var r = t.apply(this, arguments)
      r == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, r)
    }
  }
  function fE(e, t) {
    var r = io(e)
    if (arguments.length < 2) {
      var n = this.node()
      return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r)
    }
    return this.each(
      (t == null ? (r.local ? Cht : _ht) : typeof t == 'function' ? (r.local ? Aht : vht) : r.local ? Eht : wht)(r, t),
    )
  }
  var gM = x(() => {
    'use strict'
    Bx()
    a(_ht, 'attrRemove')
    a(Cht, 'attrRemoveNS')
    a(wht, 'attrConstant')
    a(Eht, 'attrConstantNS')
    a(vht, 'attrFunction')
    a(Aht, 'attrFunctionNS')
    a(fE, 'default')
  })
  function yg(e) {
    return (e.ownerDocument && e.ownerDocument.defaultView) || (e.document && e) || e.defaultView
  }
  var dE = x(() => {
    'use strict'
    a(yg, 'default')
  })
  function Lht(e) {
    return function () {
      this.style.removeProperty(e)
    }
  }
  function Rht(e, t, r) {
    return function () {
      this.style.setProperty(e, t, r)
    }
  }
  function Dht(e, t, r) {
    return function () {
      var n = t.apply(this, arguments)
      n == null ? this.style.removeProperty(e) : this.style.setProperty(e, n, r)
    }
  }
  function pE(e, t, r) {
    return arguments.length > 1
      ? this.each((t == null ? Lht : typeof t == 'function' ? Dht : Rht)(e, t, r ?? ''))
      : ec(this.node(), e)
  }
  function ec(e, t) {
    return e.style.getPropertyValue(t) || yg(e).getComputedStyle(e, null).getPropertyValue(t)
  }
  var mE = x(() => {
    'use strict'
    dE()
    a(Lht, 'styleRemove')
    a(Rht, 'styleConstant')
    a(Dht, 'styleFunction')
    a(pE, 'default')
    a(ec, 'styleValue')
  })
  function Nht(e) {
    return function () {
      delete this[e]
    }
  }
  function Iht(e, t) {
    return function () {
      this[e] = t
    }
  }
  function Mht(e, t) {
    return function () {
      var r = t.apply(this, arguments)
      r == null ? delete this[e] : (this[e] = r)
    }
  }
  function gE(e, t) {
    return arguments.length > 1
      ? this.each((t == null ? Nht : typeof t == 'function' ? Mht : Iht)(e, t))
      : this.node()[e]
  }
  var yM = x(() => {
    'use strict'
    a(Nht, 'propertyRemove')
    a(Iht, 'propertyConstant')
    a(Mht, 'propertyFunction')
    a(gE, 'default')
  })
  function xM(e) {
    return e.trim().split(/^|\s+/)
  }
  function yE(e) {
    return e.classList || new bM(e)
  }
  function bM(e) {
    ;(this._node = e), (this._names = xM(e.getAttribute('class') || ''))
  }
  function kM(e, t) {
    for (var r = yE(e), n = -1, i = t.length; ++n < i; ) r.add(t[n])
  }
  function TM(e, t) {
    for (var r = yE(e), n = -1, i = t.length; ++n < i; ) r.remove(t[n])
  }
  function Oht(e) {
    return function () {
      kM(this, e)
    }
  }
  function Pht(e) {
    return function () {
      TM(this, e)
    }
  }
  function Bht(e, t) {
    return function () {
      ;(t.apply(this, arguments) ? kM : TM)(this, e)
    }
  }
  function xE(e, t) {
    var r = xM(e + '')
    if (arguments.length < 2) {
      for (var n = yE(this.node()), i = -1, s = r.length; ++i < s; ) if (!n.contains(r[i])) return !1
      return !0
    }
    return this.each((typeof t == 'function' ? Bht : t ? Oht : Pht)(r, t))
  }
  var SM = x(() => {
    'use strict'
    a(xM, 'classArray')
    a(yE, 'classList')
    a(bM, 'ClassList')
    bM.prototype = {
      add: a(function (e) {
        var t = this._names.indexOf(e)
        t < 0 && (this._names.push(e), this._node.setAttribute('class', this._names.join(' ')))
      }, 'add'),
      remove: a(function (e) {
        var t = this._names.indexOf(e)
        t >= 0 && (this._names.splice(t, 1), this._node.setAttribute('class', this._names.join(' ')))
      }, 'remove'),
      contains: a(function (e) {
        return this._names.indexOf(e) >= 0
      }, 'contains'),
    }
    a(kM, 'classedAdd')
    a(TM, 'classedRemove')
    a(Oht, 'classedTrue')
    a(Pht, 'classedFalse')
    a(Bht, 'classedFunction')
    a(xE, 'default')
  })
  function Fht() {
    this.textContent = ''
  }
  function $ht(e) {
    return function () {
      this.textContent = e
    }
  }
  function Ght(e) {
    return function () {
      var t = e.apply(this, arguments)
      this.textContent = t ?? ''
    }
  }
  function bE(e) {
    return arguments.length
      ? this.each(e == null ? Fht : (typeof e == 'function' ? Ght : $ht)(e))
      : this.node().textContent
  }
  var _M = x(() => {
    'use strict'
    a(Fht, 'textRemove')
    a($ht, 'textConstant')
    a(Ght, 'textFunction')
    a(bE, 'default')
  })
  function Vht() {
    this.innerHTML = ''
  }
  function zht(e) {
    return function () {
      this.innerHTML = e
    }
  }
  function Wht(e) {
    return function () {
      var t = e.apply(this, arguments)
      this.innerHTML = t ?? ''
    }
  }
  function kE(e) {
    return arguments.length
      ? this.each(e == null ? Vht : (typeof e == 'function' ? Wht : zht)(e))
      : this.node().innerHTML
  }
  var CM = x(() => {
    'use strict'
    a(Vht, 'htmlRemove')
    a(zht, 'htmlConstant')
    a(Wht, 'htmlFunction')
    a(kE, 'default')
  })
  function Uht() {
    this.nextSibling && this.parentNode.appendChild(this)
  }
  function TE() {
    return this.each(Uht)
  }
  var wM = x(() => {
    'use strict'
    a(Uht, 'raise')
    a(TE, 'default')
  })
  function jht() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
  }
  function SE() {
    return this.each(jht)
  }
  var EM = x(() => {
    'use strict'
    a(jht, 'lower')
    a(SE, 'default')
  })
  function _E(e) {
    var t = typeof e == 'function' ? e : dg(e)
    return this.select(function () {
      return this.appendChild(t.apply(this, arguments))
    })
  }
  var vM = x(() => {
    'use strict'
    zw()
    a(_E, 'default')
  })
  function qht() {
    return null
  }
  function CE(e, t) {
    var r = typeof e == 'function' ? e : dg(e),
      n = t == null ? qht : typeof t == 'function' ? t : tc(t)
    return this.select(function () {
      return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null)
    })
  }
  var AM = x(() => {
    'use strict'
    zw()
    Fx()
    a(qht, 'constantNull')
    a(CE, 'default')
  })
  function Hht() {
    var e = this.parentNode
    e && e.removeChild(this)
  }
  function wE() {
    return this.each(Hht)
  }
  var LM = x(() => {
    'use strict'
    a(Hht, 'remove')
    a(wE, 'default')
  })
  function Yht() {
    var e = this.cloneNode(!1),
      t = this.parentNode
    return t ? t.insertBefore(e, this.nextSibling) : e
  }
  function Xht() {
    var e = this.cloneNode(!0),
      t = this.parentNode
    return t ? t.insertBefore(e, this.nextSibling) : e
  }
  function EE(e) {
    return this.select(e ? Xht : Yht)
  }
  var RM = x(() => {
    'use strict'
    a(Yht, 'selection_cloneShallow')
    a(Xht, 'selection_cloneDeep')
    a(EE, 'default')
  })
  function vE(e) {
    return arguments.length ? this.property('__data__', e) : this.node().__data__
  }
  var DM = x(() => {
    'use strict'
    a(vE, 'default')
  })
  function Kht(e) {
    return function (t) {
      e.call(this, t, this.__data__)
    }
  }
  function Qht(e) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var r = '',
          n = t.indexOf('.')
        return n >= 0 && ((r = t.slice(n + 1)), (t = t.slice(0, n))), { type: t, name: r }
      })
  }
  function Zht(e) {
    return function () {
      var t = this.__on
      if (t) {
        for (var r = 0, n = -1, i = t.length, s; r < i; ++r)
          (s = t[r]),
            (!e.type || s.type === e.type) && s.name === e.name
              ? this.removeEventListener(s.type, s.listener, s.options)
              : (t[++n] = s)
        ++n ? (t.length = n) : delete this.__on
      }
    }
  }
  function Jht(e, t, r) {
    return function () {
      var n = this.__on,
        i,
        s = Kht(t)
      if (n) {
        for (var o = 0, l = n.length; o < l; ++o)
          if ((i = n[o]).type === e.type && i.name === e.name) {
            this.removeEventListener(i.type, i.listener, i.options),
              this.addEventListener(i.type, (i.listener = s), (i.options = r)),
              (i.value = t)
            return
          }
      }
      this.addEventListener(e.type, s, r),
        (i = { type: e.type, name: e.name, value: t, listener: s, options: r }),
        n ? n.push(i) : (this.__on = [i])
    }
  }
  function AE(e, t, r) {
    var n = Qht(e + ''),
      i,
      s = n.length,
      o
    if (arguments.length < 2) {
      var l = this.node().__on
      if (l) {
        for (var u = 0, h = l.length, f; u < h; ++u)
          for (i = 0, f = l[u]; i < s; ++i) if ((o = n[i]).type === f.type && o.name === f.name) return f.value
      }
      return
    }
    for (l = t ? Jht : Zht, i = 0; i < s; ++i) this.each(l(n[i], t, r))
    return this
  }
  var NM = x(() => {
    'use strict'
    a(Kht, 'contextListener')
    a(Qht, 'parseTypenames')
    a(Zht, 'onRemove')
    a(Jht, 'onAdd')
    a(AE, 'default')
  })
  function IM(e, t, r) {
    var n = yg(e),
      i = n.CustomEvent
    typeof i == 'function'
      ? (i = new i(t, r))
      : ((i = n.document.createEvent('Event')),
        r ? (i.initEvent(t, r.bubbles, r.cancelable), (i.detail = r.detail)) : i.initEvent(t, !1, !1)),
      e.dispatchEvent(i)
  }
  function tft(e, t) {
    return function () {
      return IM(this, e, t)
    }
  }
  function eft(e, t) {
    return function () {
      return IM(this, e, t.apply(this, arguments))
    }
  }
  function LE(e, t) {
    return this.each((typeof t == 'function' ? eft : tft)(e, t))
  }
  var MM = x(() => {
    'use strict'
    dE()
    a(IM, 'dispatchEvent')
    a(tft, 'dispatchConstant')
    a(eft, 'dispatchFunction')
    a(LE, 'default')
  })
  function* RE() {
    for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
      for (var n = e[t], i = 0, s = n.length, o; i < s; ++i) (o = n[i]) && (yield o)
  }
  var OM = x(() => {
    'use strict'
    a(RE, 'default')
  })
  function dn(e, t) {
    ;(this._groups = e), (this._parents = t)
  }
  function PM() {
    return new dn([[document.documentElement]], DE)
  }
  function rft() {
    return this
  }
  var DE,
    el,
    Ca = x(() => {
      'use strict'
      QI()
      JI()
      tM()
      eM()
      rM()
      iM()
      Zw()
      sM()
      aM()
      oM()
      lM()
      cM()
      uM()
      hM()
      fM()
      dM()
      pM()
      mM()
      gM()
      mE()
      yM()
      SM()
      _M()
      CM()
      wM()
      EM()
      vM()
      AM()
      LM()
      RM()
      DM()
      NM()
      MM()
      OM()
      DE = [null]
      a(dn, 'Selection')
      a(PM, 'selection')
      a(rft, 'selection_selection')
      dn.prototype = PM.prototype = {
        constructor: dn,
        select: Ww,
        selectAll: qw,
        selectChild: Hw,
        selectChildren: Yw,
        filter: Xw,
        data: tE,
        enter: Qw,
        exit: eE,
        join: rE,
        merge: nE,
        selection: rft,
        order: iE,
        sort: sE,
        call: aE,
        nodes: oE,
        node: lE,
        size: cE,
        empty: uE,
        each: hE,
        attr: fE,
        style: pE,
        property: gE,
        classed: xE,
        text: bE,
        html: kE,
        raise: TE,
        lower: SE,
        append: _E,
        insert: CE,
        remove: wE,
        clone: EE,
        datum: vE,
        on: AE,
        dispatch: LE,
        [Symbol.iterator]: RE,
      }
      el = PM
    })
  function xt(e) {
    return typeof e == 'string' ? new dn([[document.querySelector(e)]], [document.documentElement]) : new dn([[e]], DE)
  }
  var BM = x(() => {
    'use strict'
    Ca()
    a(xt, 'default')
  })
  var wa = x(() => {
    'use strict'
    pg()
    Bx()
    BM()
    Ca()
    Fx()
    jw()
    mE()
  })
  var FM = x(() => {
    'use strict'
  })
  function rc(e, t, r) {
    ;(e.prototype = t.prototype = r), (r.constructor = e)
  }
  function bf(e, t) {
    var r = Object.create(e.prototype)
    for (var n in t) r[n] = t[n]
    return r
  }
  var NE = x(() => {
    'use strict'
    a(rc, 'default')
    a(bf, 'extend')
  })
  function nc() {}
  function GM() {
    return this.rgb().formatHex()
  }
  function uft() {
    return this.rgb().formatHex8()
  }
  function hft() {
    return HM(this).formatHsl()
  }
  function VM() {
    return this.rgb().formatRgb()
  }
  function va(e) {
    var t, r
    return (
      (e = (e + '').trim().toLowerCase()),
      (t = nft.exec(e))
        ? ((r = t[1].length),
          (t = parseInt(t[1], 16)),
          r === 6
            ? zM(t)
            : r === 3
              ? new Jn(((t >> 8) & 15) | ((t >> 4) & 240), ((t >> 4) & 15) | (t & 240), ((t & 15) << 4) | (t & 15), 1)
              : r === 8
                ? Gx((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (t & 255) / 255)
                : r === 4
                  ? Gx(
                      ((t >> 12) & 15) | ((t >> 8) & 240),
                      ((t >> 8) & 15) | ((t >> 4) & 240),
                      ((t >> 4) & 15) | (t & 240),
                      (((t & 15) << 4) | (t & 15)) / 255,
                    )
                  : null)
        : (t = ift.exec(e))
          ? new Jn(t[1], t[2], t[3], 1)
          : (t = sft.exec(e))
            ? new Jn((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, 1)
            : (t = aft.exec(e))
              ? Gx(t[1], t[2], t[3], t[4])
              : (t = oft.exec(e))
                ? Gx((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, t[4])
                : (t = lft.exec(e))
                  ? jM(t[1], t[2] / 100, t[3] / 100, 1)
                  : (t = cft.exec(e))
                    ? jM(t[1], t[2] / 100, t[3] / 100, t[4])
                    : $M.hasOwnProperty(e)
                      ? zM($M[e])
                      : e === 'transparent'
                        ? new Jn(NaN, NaN, NaN, 0)
                        : null
    )
  }
  function zM(e) {
    return new Jn((e >> 16) & 255, (e >> 8) & 255, e & 255, 1)
  }
  function Gx(e, t, r, n) {
    return n <= 0 && (e = t = r = NaN), new Jn(e, t, r, n)
  }
  function ME(e) {
    return e instanceof nc || (e = va(e)), e ? ((e = e.rgb()), new Jn(e.r, e.g, e.b, e.opacity)) : new Jn()
  }
  function Tf(e, t, r, n) {
    return arguments.length === 1 ? ME(e) : new Jn(e, t, r, n ?? 1)
  }
  function Jn(e, t, r, n) {
    ;(this.r = +e), (this.g = +t), (this.b = +r), (this.opacity = +n)
  }
  function WM() {
    return `#${wu(this.r)}${wu(this.g)}${wu(this.b)}`
  }
  function fft() {
    return `#${wu(this.r)}${wu(this.g)}${wu(this.b)}${wu((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
  }
  function UM() {
    let e = Wx(this.opacity)
    return `${e === 1 ? 'rgb(' : 'rgba('}${Eu(this.r)}, ${Eu(this.g)}, ${Eu(this.b)}${e === 1 ? ')' : `, ${e})`}`
  }
  function Wx(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
  }
  function Eu(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0))
  }
  function wu(e) {
    return (e = Eu(e)), (e < 16 ? '0' : '') + e.toString(16)
  }
  function jM(e, t, r, n) {
    return n <= 0 ? (e = t = r = NaN) : r <= 0 || r >= 1 ? (e = t = NaN) : t <= 0 && (e = NaN), new Ea(e, t, r, n)
  }
  function HM(e) {
    if (e instanceof Ea) return new Ea(e.h, e.s, e.l, e.opacity)
    if ((e instanceof nc || (e = va(e)), !e)) return new Ea()
    if (e instanceof Ea) return e
    e = e.rgb()
    var t = e.r / 255,
      r = e.g / 255,
      n = e.b / 255,
      i = Math.min(t, r, n),
      s = Math.max(t, r, n),
      o = NaN,
      l = s - i,
      u = (s + i) / 2
    return (
      l
        ? (t === s ? (o = (r - n) / l + (r < n) * 6) : r === s ? (o = (n - t) / l + 2) : (o = (t - r) / l + 4),
          (l /= u < 0.5 ? s + i : 2 - s - i),
          (o *= 60))
        : (l = u > 0 && u < 1 ? 0 : o),
      new Ea(o, l, u, e.opacity)
    )
  }
  function YM(e, t, r, n) {
    return arguments.length === 1 ? HM(e) : new Ea(e, t, r, n ?? 1)
  }
  function Ea(e, t, r, n) {
    ;(this.h = +e), (this.s = +t), (this.l = +r), (this.opacity = +n)
  }
  function qM(e) {
    return (e = (e || 0) % 360), e < 0 ? e + 360 : e
  }
  function Vx(e) {
    return Math.max(0, Math.min(1, e || 0))
  }
  function IE(e, t, r) {
    return (e < 60 ? t + ((r - t) * e) / 60 : e < 180 ? r : e < 240 ? t + ((r - t) * (240 - e)) / 60 : t) * 255
  }
  var xg,
    zx,
    kf,
    bg,
    so,
    nft,
    ift,
    sft,
    aft,
    oft,
    lft,
    cft,
    $M,
    OE = x(() => {
      'use strict'
      NE()
      a(nc, 'Color')
      ;(xg = 0.7),
        (zx = 1 / xg),
        (kf = '\\s*([+-]?\\d+)\\s*'),
        (bg = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*'),
        (so = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*'),
        (nft = /^#([0-9a-f]{3,8})$/),
        (ift = new RegExp(`^rgb\\(${kf},${kf},${kf}\\)$`)),
        (sft = new RegExp(`^rgb\\(${so},${so},${so}\\)$`)),
        (aft = new RegExp(`^rgba\\(${kf},${kf},${kf},${bg}\\)$`)),
        (oft = new RegExp(`^rgba\\(${so},${so},${so},${bg}\\)$`)),
        (lft = new RegExp(`^hsl\\(${bg},${so},${so}\\)$`)),
        (cft = new RegExp(`^hsla\\(${bg},${so},${so},${bg}\\)$`)),
        ($M = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        })
      rc(nc, va, {
        copy(e) {
          return Object.assign(new this.constructor(), this, e)
        },
        displayable() {
          return this.rgb().displayable()
        },
        hex: GM,
        formatHex: GM,
        formatHex8: uft,
        formatHsl: hft,
        formatRgb: VM,
        toString: VM,
      })
      a(GM, 'color_formatHex')
      a(uft, 'color_formatHex8')
      a(hft, 'color_formatHsl')
      a(VM, 'color_formatRgb')
      a(va, 'color')
      a(zM, 'rgbn')
      a(Gx, 'rgba')
      a(ME, 'rgbConvert')
      a(Tf, 'rgb')
      a(Jn, 'Rgb')
      rc(
        Jn,
        Tf,
        bf(nc, {
          brighter(e) {
            return (e = e == null ? zx : Math.pow(zx, e)), new Jn(this.r * e, this.g * e, this.b * e, this.opacity)
          },
          darker(e) {
            return (e = e == null ? xg : Math.pow(xg, e)), new Jn(this.r * e, this.g * e, this.b * e, this.opacity)
          },
          rgb() {
            return this
          },
          clamp() {
            return new Jn(Eu(this.r), Eu(this.g), Eu(this.b), Wx(this.opacity))
          },
          displayable() {
            return (
              -0.5 <= this.r &&
              this.r < 255.5 &&
              -0.5 <= this.g &&
              this.g < 255.5 &&
              -0.5 <= this.b &&
              this.b < 255.5 &&
              0 <= this.opacity &&
              this.opacity <= 1
            )
          },
          hex: WM,
          formatHex: WM,
          formatHex8: fft,
          formatRgb: UM,
          toString: UM,
        }),
      )
      a(WM, 'rgb_formatHex')
      a(fft, 'rgb_formatHex8')
      a(UM, 'rgb_formatRgb')
      a(Wx, 'clampa')
      a(Eu, 'clampi')
      a(wu, 'hex')
      a(jM, 'hsla')
      a(HM, 'hslConvert')
      a(YM, 'hsl')
      a(Ea, 'Hsl')
      rc(
        Ea,
        YM,
        bf(nc, {
          brighter(e) {
            return (e = e == null ? zx : Math.pow(zx, e)), new Ea(this.h, this.s, this.l * e, this.opacity)
          },
          darker(e) {
            return (e = e == null ? xg : Math.pow(xg, e)), new Ea(this.h, this.s, this.l * e, this.opacity)
          },
          rgb() {
            var e = (this.h % 360) + (this.h < 0) * 360,
              t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
              r = this.l,
              n = r + (r < 0.5 ? r : 1 - r) * t,
              i = 2 * r - n
            return new Jn(
              IE(e >= 240 ? e - 240 : e + 120, i, n),
              IE(e, i, n),
              IE(e < 120 ? e + 240 : e - 120, i, n),
              this.opacity,
            )
          },
          clamp() {
            return new Ea(qM(this.h), Vx(this.s), Vx(this.l), Wx(this.opacity))
          },
          displayable() {
            return (
              ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
              0 <= this.l &&
              this.l <= 1 &&
              0 <= this.opacity &&
              this.opacity <= 1
            )
          },
          formatHsl() {
            let e = Wx(this.opacity)
            return `${e === 1 ? 'hsl(' : 'hsla('}${qM(this.h)}, ${Vx(this.s) * 100}%, ${Vx(this.l) * 100}%${e === 1 ? ')' : `, ${e})`}`
          },
        }),
      )
      a(qM, 'clamph')
      a(Vx, 'clampt')
      a(IE, 'hsl2rgb')
    })
  var XM,
    KM,
    QM = x(() => {
      'use strict'
      ;(XM = Math.PI / 180), (KM = 180 / Math.PI)
    })
  function nO(e) {
    if (e instanceof ao) return new ao(e.l, e.a, e.b, e.opacity)
    if (e instanceof rl) return iO(e)
    e instanceof Jn || (e = ME(e))
    var t = $E(e.r),
      r = $E(e.g),
      n = $E(e.b),
      i = PE((0.2225045 * t + 0.7168786 * r + 0.0606169 * n) / JM),
      s,
      o
    return (
      t === r && r === n
        ? (s = o = i)
        : ((s = PE((0.4360747 * t + 0.3850649 * r + 0.1430804 * n) / ZM)),
          (o = PE((0.0139322 * t + 0.0971045 * r + 0.7141733 * n) / tO))),
      new ao(116 * i - 16, 500 * (s - i), 200 * (i - o), e.opacity)
    )
  }
  function GE(e, t, r, n) {
    return arguments.length === 1 ? nO(e) : new ao(e, t, r, n ?? 1)
  }
  function ao(e, t, r, n) {
    ;(this.l = +e), (this.a = +t), (this.b = +r), (this.opacity = +n)
  }
  function PE(e) {
    return e > dft ? Math.pow(e, 1 / 3) : e / rO + eO
  }
  function BE(e) {
    return e > Sf ? e * e * e : rO * (e - eO)
  }
  function FE(e) {
    return 255 * (e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055)
  }
  function $E(e) {
    return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4)
  }
  function pft(e) {
    if (e instanceof rl) return new rl(e.h, e.c, e.l, e.opacity)
    if ((e instanceof ao || (e = nO(e)), e.a === 0 && e.b === 0))
      return new rl(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity)
    var t = Math.atan2(e.b, e.a) * KM
    return new rl(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity)
  }
  function kg(e, t, r, n) {
    return arguments.length === 1 ? pft(e) : new rl(e, t, r, n ?? 1)
  }
  function rl(e, t, r, n) {
    ;(this.h = +e), (this.c = +t), (this.l = +r), (this.opacity = +n)
  }
  function iO(e) {
    if (isNaN(e.h)) return new ao(e.l, 0, 0, e.opacity)
    var t = e.h * XM
    return new ao(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity)
  }
  var Ux,
    ZM,
    JM,
    tO,
    eO,
    Sf,
    rO,
    dft,
    sO = x(() => {
      'use strict'
      NE()
      OE()
      QM()
      ;(Ux = 18),
        (ZM = 0.96422),
        (JM = 1),
        (tO = 0.82521),
        (eO = 4 / 29),
        (Sf = 6 / 29),
        (rO = 3 * Sf * Sf),
        (dft = Sf * Sf * Sf)
      a(nO, 'labConvert')
      a(GE, 'lab')
      a(ao, 'Lab')
      rc(
        ao,
        GE,
        bf(nc, {
          brighter(e) {
            return new ao(this.l + Ux * (e ?? 1), this.a, this.b, this.opacity)
          },
          darker(e) {
            return new ao(this.l - Ux * (e ?? 1), this.a, this.b, this.opacity)
          },
          rgb() {
            var e = (this.l + 16) / 116,
              t = isNaN(this.a) ? e : e + this.a / 500,
              r = isNaN(this.b) ? e : e - this.b / 200
            return (
              (t = ZM * BE(t)),
              (e = JM * BE(e)),
              (r = tO * BE(r)),
              new Jn(
                FE(3.1338561 * t - 1.6168667 * e - 0.4906146 * r),
                FE(-0.9787684 * t + 1.9161415 * e + 0.033454 * r),
                FE(0.0719453 * t - 0.2289914 * e + 1.4052427 * r),
                this.opacity,
              )
            )
          },
        }),
      )
      a(PE, 'xyz2lab')
      a(BE, 'lab2xyz')
      a(FE, 'lrgb2rgb')
      a($E, 'rgb2lrgb')
      a(pft, 'hclConvert')
      a(kg, 'hcl')
      a(rl, 'Hcl')
      a(iO, 'hcl2lab')
      rc(
        rl,
        kg,
        bf(nc, {
          brighter(e) {
            return new rl(this.h, this.c, this.l + Ux * (e ?? 1), this.opacity)
          },
          darker(e) {
            return new rl(this.h, this.c, this.l - Ux * (e ?? 1), this.opacity)
          },
          rgb() {
            return iO(this).rgb()
          },
        }),
      )
    })
  var _f = x(() => {
    'use strict'
    OE()
    sO()
  })
  function VE(e, t, r, n, i) {
    var s = e * e,
      o = s * e
    return ((1 - 3 * e + 3 * s - o) * t + (4 - 6 * s + 3 * o) * r + (1 + 3 * e + 3 * s - 3 * o) * n + o * i) / 6
  }
  function zE(e) {
    var t = e.length - 1
    return function (r) {
      var n = r <= 0 ? (r = 0) : r >= 1 ? ((r = 1), t - 1) : Math.floor(r * t),
        i = e[n],
        s = e[n + 1],
        o = n > 0 ? e[n - 1] : 2 * i - s,
        l = n < t - 1 ? e[n + 2] : 2 * s - i
      return VE((r - n / t) * t, o, i, s, l)
    }
  }
  var WE = x(() => {
    'use strict'
    a(VE, 'basis')
    a(zE, 'default')
  })
  function UE(e) {
    var t = e.length
    return function (r) {
      var n = Math.floor(((r %= 1) < 0 ? ++r : r) * t),
        i = e[(n + t - 1) % t],
        s = e[n % t],
        o = e[(n + 1) % t],
        l = e[(n + 2) % t]
      return VE((r - n / t) * t, i, s, o, l)
    }
  }
  var aO = x(() => {
    'use strict'
    WE()
    a(UE, 'default')
  })
  var Cf,
    jE = x(() => {
      'use strict'
      Cf = a((e) => () => e, 'default')
    })
  function oO(e, t) {
    return function (r) {
      return e + r * t
    }
  }
  function mft(e, t, r) {
    return (
      (e = Math.pow(e, r)),
      (t = Math.pow(t, r) - e),
      (r = 1 / r),
      function (n) {
        return Math.pow(e + n * t, r)
      }
    )
  }
  function lO(e, t) {
    var r = t - e
    return r ? oO(e, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : Cf(isNaN(e) ? t : e)
  }
  function cO(e) {
    return (e = +e) == 1
      ? nl
      : function (t, r) {
          return r - t ? mft(t, r, e) : Cf(isNaN(t) ? r : t)
        }
  }
  function nl(e, t) {
    var r = t - e
    return r ? oO(e, r) : Cf(isNaN(e) ? t : e)
  }
  var qE = x(() => {
    'use strict'
    jE()
    a(oO, 'linear')
    a(mft, 'exponential')
    a(lO, 'hue')
    a(cO, 'gamma')
    a(nl, 'nogamma')
  })
  function uO(e) {
    return function (t) {
      var r = t.length,
        n = new Array(r),
        i = new Array(r),
        s = new Array(r),
        o,
        l
      for (o = 0; o < r; ++o) (l = Tf(t[o])), (n[o] = l.r || 0), (i[o] = l.g || 0), (s[o] = l.b || 0)
      return (
        (n = e(n)),
        (i = e(i)),
        (s = e(s)),
        (l.opacity = 1),
        function (u) {
          return (l.r = n(u)), (l.g = i(u)), (l.b = s(u)), l + ''
        }
      )
    }
  }
  var vu,
    gft,
    yft,
    HE = x(() => {
      'use strict'
      _f()
      WE()
      aO()
      qE()
      vu = a(function e(t) {
        var r = cO(t)
        function n(i, s) {
          var o = r((i = Tf(i)).r, (s = Tf(s)).r),
            l = r(i.g, s.g),
            u = r(i.b, s.b),
            h = nl(i.opacity, s.opacity)
          return function (f) {
            return (i.r = o(f)), (i.g = l(f)), (i.b = u(f)), (i.opacity = h(f)), i + ''
          }
        }
        return a(n, 'rgb'), (n.gamma = e), n
      }, 'rgbGamma')(1)
      a(uO, 'rgbSpline')
      ;(gft = uO(zE)), (yft = uO(UE))
    })
  function YE(e, t) {
    t || (t = [])
    var r = e ? Math.min(t.length, e.length) : 0,
      n = t.slice(),
      i
    return function (s) {
      for (i = 0; i < r; ++i) n[i] = e[i] * (1 - s) + t[i] * s
      return n
    }
  }
  function hO(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView)
  }
  var fO = x(() => {
    'use strict'
    a(YE, 'default')
    a(hO, 'isNumberArray')
  })
  function dO(e, t) {
    var r = t ? t.length : 0,
      n = e ? Math.min(r, e.length) : 0,
      i = new Array(n),
      s = new Array(r),
      o
    for (o = 0; o < n; ++o) i[o] = ic(e[o], t[o])
    for (; o < r; ++o) s[o] = t[o]
    return function (l) {
      for (o = 0; o < n; ++o) s[o] = i[o](l)
      return s
    }
  }
  var pO = x(() => {
    'use strict'
    jx()
    a(dO, 'genericArray')
  })
  function XE(e, t) {
    var r = new Date()
    return (
      (e = +e),
      (t = +t),
      function (n) {
        return r.setTime(e * (1 - n) + t * n), r
      }
    )
  }
  var mO = x(() => {
    'use strict'
    a(XE, 'default')
  })
  function zn(e, t) {
    return (
      (e = +e),
      (t = +t),
      function (r) {
        return e * (1 - r) + t * r
      }
    )
  }
  var Tg = x(() => {
    'use strict'
    a(zn, 'default')
  })
  function KE(e, t) {
    var r = {},
      n = {},
      i
    ;(e === null || typeof e != 'object') && (e = {}), (t === null || typeof t != 'object') && (t = {})
    for (i in t) i in e ? (r[i] = ic(e[i], t[i])) : (n[i] = t[i])
    return function (s) {
      for (i in r) n[i] = r[i](s)
      return n
    }
  }
  var gO = x(() => {
    'use strict'
    jx()
    a(KE, 'default')
  })
  function xft(e) {
    return function () {
      return e
    }
  }
  function bft(e) {
    return function (t) {
      return e(t) + ''
    }
  }
  function wf(e, t) {
    var r = (ZE.lastIndex = QE.lastIndex = 0),
      n,
      i,
      s,
      o = -1,
      l = [],
      u = []
    for (e = e + '', t = t + ''; (n = ZE.exec(e)) && (i = QE.exec(t)); )
      (s = i.index) > r && ((s = t.slice(r, s)), l[o] ? (l[o] += s) : (l[++o] = s)),
        (n = n[0]) === (i = i[0])
          ? l[o]
            ? (l[o] += i)
            : (l[++o] = i)
          : ((l[++o] = null), u.push({ i: o, x: zn(n, i) })),
        (r = QE.lastIndex)
    return (
      r < t.length && ((s = t.slice(r)), l[o] ? (l[o] += s) : (l[++o] = s)),
      l.length < 2
        ? u[0]
          ? bft(u[0].x)
          : xft(t)
        : ((t = u.length),
          function (h) {
            for (var f = 0, d; f < t; ++f) l[(d = u[f]).i] = d.x(h)
            return l.join('')
          })
    )
  }
  var ZE,
    QE,
    JE = x(() => {
      'use strict'
      Tg()
      ;(ZE = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g), (QE = new RegExp(ZE.source, 'g'))
      a(xft, 'zero')
      a(bft, 'one')
      a(wf, 'default')
    })
  function ic(e, t) {
    var r = typeof t,
      n
    return t == null || r === 'boolean'
      ? Cf(t)
      : (r === 'number'
          ? zn
          : r === 'string'
            ? (n = va(t))
              ? ((t = n), vu)
              : wf
            : t instanceof va
              ? vu
              : t instanceof Date
                ? XE
                : hO(t)
                  ? YE
                  : Array.isArray(t)
                    ? dO
                    : (typeof t.valueOf != 'function' && typeof t.toString != 'function') || isNaN(t)
                      ? KE
                      : zn)(e, t)
  }
  var jx = x(() => {
    'use strict'
    _f()
    HE()
    pO()
    mO()
    Tg()
    gO()
    JE()
    jE()
    fO()
    a(ic, 'default')
  })
  function qx(e, t) {
    return (
      (e = +e),
      (t = +t),
      function (r) {
        return Math.round(e * (1 - r) + t * r)
      }
    )
  }
  var yO = x(() => {
    'use strict'
    a(qx, 'default')
  })
  function Yx(e, t, r, n, i, s) {
    var o, l, u
    return (
      (o = Math.sqrt(e * e + t * t)) && ((e /= o), (t /= o)),
      (u = e * r + t * n) && ((r -= e * u), (n -= t * u)),
      (l = Math.sqrt(r * r + n * n)) && ((r /= l), (n /= l), (u /= l)),
      e * n < t * r && ((e = -e), (t = -t), (u = -u), (o = -o)),
      { translateX: i, translateY: s, rotate: Math.atan2(t, e) * xO, skewX: Math.atan(u) * xO, scaleX: o, scaleY: l }
    )
  }
  var xO,
    Hx,
    bO = x(() => {
      'use strict'
      ;(xO = 180 / Math.PI), (Hx = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 })
      a(Yx, 'default')
    })
  function kO(e) {
    let t = new (typeof DOMMatrix == 'function' ? DOMMatrix : WebKitCSSMatrix)(e + '')
    return t.isIdentity ? Hx : Yx(t.a, t.b, t.c, t.d, t.e, t.f)
  }
  function TO(e) {
    return e == null
      ? Hx
      : (Xx || (Xx = document.createElementNS('http://www.w3.org/2000/svg', 'g')),
        Xx.setAttribute('transform', e),
        (e = Xx.transform.baseVal.consolidate()) ? ((e = e.matrix), Yx(e.a, e.b, e.c, e.d, e.e, e.f)) : Hx)
  }
  var Xx,
    SO = x(() => {
      'use strict'
      bO()
      a(kO, 'parseCss')
      a(TO, 'parseSvg')
    })
  function _O(e, t, r, n) {
    function i(h) {
      return h.length ? h.pop() + ' ' : ''
    }
    a(i, 'pop')
    function s(h, f, d, p, m, g) {
      if (h !== d || f !== p) {
        var y = m.push('translate(', null, t, null, r)
        g.push({ i: y - 4, x: zn(h, d) }, { i: y - 2, x: zn(f, p) })
      } else (d || p) && m.push('translate(' + d + t + p + r)
    }
    a(s, 'translate')
    function o(h, f, d, p) {
      h !== f
        ? (h - f > 180 ? (f += 360) : f - h > 180 && (h += 360),
          p.push({ i: d.push(i(d) + 'rotate(', null, n) - 2, x: zn(h, f) }))
        : f && d.push(i(d) + 'rotate(' + f + n)
    }
    a(o, 'rotate')
    function l(h, f, d, p) {
      h !== f ? p.push({ i: d.push(i(d) + 'skewX(', null, n) - 2, x: zn(h, f) }) : f && d.push(i(d) + 'skewX(' + f + n)
    }
    a(l, 'skewX')
    function u(h, f, d, p, m, g) {
      if (h !== d || f !== p) {
        var y = m.push(i(m) + 'scale(', null, ',', null, ')')
        g.push({ i: y - 4, x: zn(h, d) }, { i: y - 2, x: zn(f, p) })
      } else (d !== 1 || p !== 1) && m.push(i(m) + 'scale(' + d + ',' + p + ')')
    }
    return (
      a(u, 'scale'),
      function (h, f) {
        var d = [],
          p = []
        return (
          (h = e(h)),
          (f = e(f)),
          s(h.translateX, h.translateY, f.translateX, f.translateY, d, p),
          o(h.rotate, f.rotate, d, p),
          l(h.skewX, f.skewX, d, p),
          u(h.scaleX, h.scaleY, f.scaleX, f.scaleY, d, p),
          (h = f = null),
          function (m) {
            for (var g = -1, y = p.length, b; ++g < y; ) d[(b = p[g]).i] = b.x(m)
            return d.join('')
          }
        )
      }
    )
  }
  var tv,
    ev,
    CO = x(() => {
      'use strict'
      Tg()
      SO()
      a(_O, 'interpolateTransform')
      ;(tv = _O(kO, 'px, ', 'px)', 'deg)')), (ev = _O(TO, ', ', ')', ')'))
    })
  function wO(e) {
    return function (t, r) {
      var n = e((t = kg(t)).h, (r = kg(r)).h),
        i = nl(t.c, r.c),
        s = nl(t.l, r.l),
        o = nl(t.opacity, r.opacity)
      return function (l) {
        return (t.h = n(l)), (t.c = i(l)), (t.l = s(l)), (t.opacity = o(l)), t + ''
      }
    }
  }
  var rv,
    kft,
    EO = x(() => {
      'use strict'
      _f()
      qE()
      a(wO, 'hcl')
      ;(rv = wO(lO)), (kft = wO(nl))
    })
  var Ef = x(() => {
    'use strict'
    jx()
    Tg()
    yO()
    JE()
    CO()
    HE()
    EO()
  })
  function vg() {
    return Au || (LO(Tft), (Au = wg.now() + Zx))
  }
  function Tft() {
    Au = 0
  }
  function Eg() {
    this._call = this._time = this._next = null
  }
  function Jx(e, t, r) {
    var n = new Eg()
    return n.restart(e, t, r), n
  }
  function RO() {
    vg(), ++vf
    for (var e = Kx, t; e; ) (t = Au - e._time) >= 0 && e._call.call(void 0, t), (e = e._next)
    --vf
  }
  function vO() {
    ;(Au = (Qx = wg.now()) + Zx), (vf = _g = 0)
    try {
      RO()
    } finally {
      ;(vf = 0), _ft(), (Au = 0)
    }
  }
  function Sft() {
    var e = wg.now(),
      t = e - Qx
    t > AO && ((Zx -= t), (Qx = e))
  }
  function _ft() {
    for (var e, t = Kx, r, n = 1 / 0; t; )
      t._call
        ? (n > t._time && (n = t._time), (e = t), (t = t._next))
        : ((r = t._next), (t._next = null), (t = e ? (e._next = r) : (Kx = r)))
    ;(Cg = e), nv(n)
  }
  function nv(e) {
    if (!vf) {
      _g && (_g = clearTimeout(_g))
      var t = e - Au
      t > 24
        ? (e < 1 / 0 && (_g = setTimeout(vO, e - wg.now() - Zx)), Sg && (Sg = clearInterval(Sg)))
        : (Sg || ((Qx = wg.now()), (Sg = setInterval(Sft, AO))), (vf = 1), LO(vO))
    }
  }
  var vf,
    _g,
    Sg,
    AO,
    Kx,
    Cg,
    Qx,
    Au,
    Zx,
    wg,
    LO,
    iv = x(() => {
      'use strict'
      ;(vf = 0),
        (_g = 0),
        (Sg = 0),
        (AO = 1e3),
        (Qx = 0),
        (Au = 0),
        (Zx = 0),
        (wg = typeof performance == 'object' && performance.now ? performance : Date),
        (LO =
          typeof window == 'object' && window.requestAnimationFrame
            ? window.requestAnimationFrame.bind(window)
            : function (e) {
                setTimeout(e, 17)
              })
      a(vg, 'now')
      a(Tft, 'clearNow')
      a(Eg, 'Timer')
      Eg.prototype = Jx.prototype = {
        constructor: Eg,
        restart: a(function (e, t, r) {
          if (typeof e != 'function') throw new TypeError('callback is not a function')
          ;(r = (r == null ? vg() : +r) + (t == null ? 0 : +t)),
            !this._next && Cg !== this && (Cg ? (Cg._next = this) : (Kx = this), (Cg = this)),
            (this._call = e),
            (this._time = r),
            nv()
        }, 'restart'),
        stop: a(function () {
          this._call && ((this._call = null), (this._time = 1 / 0), nv())
        }, 'stop'),
      }
      a(Jx, 'timer')
      a(RO, 'timerFlush')
      a(vO, 'wake')
      a(Sft, 'poke')
      a(_ft, 'nap')
      a(nv, 'sleep')
    })
  function Ag(e, t, r) {
    var n = new Eg()
    return (
      (t = t == null ? 0 : +t),
      n.restart(
        (i) => {
          n.stop(), e(i + t)
        },
        t,
        r,
      ),
      n
    )
  }
  var DO = x(() => {
    'use strict'
    iv()
    a(Ag, 'default')
  })
  var t2 = x(() => {
    'use strict'
    iv()
    DO()
  })
  function il(e, t, r, n, i, s) {
    var o = e.__transition
    if (!o) e.__transition = {}
    else if (r in o) return
    Eft(e, r, {
      name: t,
      index: n,
      group: i,
      on: Cft,
      tween: wft,
      time: s.time,
      delay: s.delay,
      duration: s.duration,
      ease: s.ease,
      timer: null,
      state: MO,
    })
  }
  function Rg(e, t) {
    var r = Pn(e, t)
    if (r.state > MO) throw new Error('too late; already scheduled')
    return r
  }
  function ti(e, t) {
    var r = Pn(e, t)
    if (r.state > e2) throw new Error('too late; already running')
    return r
  }
  function Pn(e, t) {
    var r = e.__transition
    if (!r || !(r = r[t])) throw new Error('transition not found')
    return r
  }
  function Eft(e, t, r) {
    var n = e.__transition,
      i
    ;(n[t] = r), (r.timer = Jx(s, 0, r.time))
    function s(h) {
      ;(r.state = NO), r.timer.restart(o, r.delay, r.time), r.delay <= h && o(h - r.delay)
    }
    a(s, 'schedule')
    function o(h) {
      var f, d, p, m
      if (r.state !== NO) return u()
      for (f in n)
        if (((m = n[f]), m.name === r.name)) {
          if (m.state === e2) return Ag(o)
          m.state === IO
            ? ((m.state = Lg), m.timer.stop(), m.on.call('interrupt', e, e.__data__, m.index, m.group), delete n[f])
            : +f < t &&
              ((m.state = Lg), m.timer.stop(), m.on.call('cancel', e, e.__data__, m.index, m.group), delete n[f])
        }
      if (
        (Ag(function () {
          r.state === e2 && ((r.state = IO), r.timer.restart(l, r.delay, r.time), l(h))
        }),
        (r.state = r2),
        r.on.call('start', e, e.__data__, r.index, r.group),
        r.state === r2)
      ) {
        for (r.state = e2, i = new Array((p = r.tween.length)), f = 0, d = -1; f < p; ++f)
          (m = r.tween[f].value.call(e, e.__data__, r.index, r.group)) && (i[++d] = m)
        i.length = d + 1
      }
    }
    a(o, 'start')
    function l(h) {
      for (
        var f = h < r.duration ? r.ease.call(null, h / r.duration) : (r.timer.restart(u), (r.state = n2), 1),
          d = -1,
          p = i.length;
        ++d < p;

      )
        i[d].call(e, f)
      r.state === n2 && (r.on.call('end', e, e.__data__, r.index, r.group), u())
    }
    a(l, 'tick')
    function u() {
      ;(r.state = Lg), r.timer.stop(), delete n[t]
      for (var h in n) return
      delete e.__transition
    }
    a(u, 'stop')
  }
  var Cft,
    wft,
    MO,
    NO,
    r2,
    e2,
    IO,
    n2,
    Lg,
    es = x(() => {
      'use strict'
      $w()
      t2()
      ;(Cft = Fw('start', 'end', 'cancel', 'interrupt')),
        (wft = []),
        (MO = 0),
        (NO = 1),
        (r2 = 2),
        (e2 = 3),
        (IO = 4),
        (n2 = 5),
        (Lg = 6)
      a(il, 'default')
      a(Rg, 'init')
      a(ti, 'set')
      a(Pn, 'get')
      a(Eft, 'create')
    })
  function Dg(e, t) {
    var r = e.__transition,
      n,
      i,
      s = !0,
      o
    if (r) {
      t = t == null ? null : t + ''
      for (o in r) {
        if ((n = r[o]).name !== t) {
          s = !1
          continue
        }
        ;(i = n.state > r2 && n.state < n2),
          (n.state = Lg),
          n.timer.stop(),
          n.on.call(i ? 'interrupt' : 'cancel', e, e.__data__, n.index, n.group),
          delete r[o]
      }
      s && delete e.__transition
    }
  }
  var OO = x(() => {
    'use strict'
    es()
    a(Dg, 'default')
  })
  function sv(e) {
    return this.each(function () {
      Dg(this, e)
    })
  }
  var PO = x(() => {
    'use strict'
    OO()
    a(sv, 'default')
  })
  function vft(e, t) {
    var r, n
    return function () {
      var i = ti(this, e),
        s = i.tween
      if (s !== r) {
        n = r = s
        for (var o = 0, l = n.length; o < l; ++o)
          if (n[o].name === t) {
            ;(n = n.slice()), n.splice(o, 1)
            break
          }
      }
      i.tween = n
    }
  }
  function Aft(e, t, r) {
    var n, i
    if (typeof r != 'function') throw new Error()
    return function () {
      var s = ti(this, e),
        o = s.tween
      if (o !== n) {
        i = (n = o).slice()
        for (var l = { name: t, value: r }, u = 0, h = i.length; u < h; ++u)
          if (i[u].name === t) {
            i[u] = l
            break
          }
        u === h && i.push(l)
      }
      s.tween = i
    }
  }
  function av(e, t) {
    var r = this._id
    if (((e += ''), arguments.length < 2)) {
      for (var n = Pn(this.node(), r).tween, i = 0, s = n.length, o; i < s; ++i)
        if ((o = n[i]).name === e) return o.value
      return null
    }
    return this.each((t == null ? vft : Aft)(r, e, t))
  }
  function Af(e, t, r) {
    var n = e._id
    return (
      e.each(function () {
        var i = ti(this, n)
        ;(i.value || (i.value = {}))[t] = r.apply(this, arguments)
      }),
      function (i) {
        return Pn(i, n).value[t]
      }
    )
  }
  var Ng = x(() => {
    'use strict'
    es()
    a(vft, 'tweenRemove')
    a(Aft, 'tweenFunction')
    a(av, 'default')
    a(Af, 'tweenValue')
  })
  function Ig(e, t) {
    var r
    return (typeof t == 'number' ? zn : t instanceof va ? vu : (r = va(t)) ? ((t = r), vu) : wf)(e, t)
  }
  var ov = x(() => {
    'use strict'
    _f()
    Ef()
    a(Ig, 'default')
  })
  function Lft(e) {
    return function () {
      this.removeAttribute(e)
    }
  }
  function Rft(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local)
    }
  }
  function Dft(e, t, r) {
    var n,
      i = r + '',
      s
    return function () {
      var o = this.getAttribute(e)
      return o === i ? null : o === n ? s : (s = t((n = o), r))
    }
  }
  function Nft(e, t, r) {
    var n,
      i = r + '',
      s
    return function () {
      var o = this.getAttributeNS(e.space, e.local)
      return o === i ? null : o === n ? s : (s = t((n = o), r))
    }
  }
  function Ift(e, t, r) {
    var n, i, s
    return function () {
      var o,
        l = r(this),
        u
      return l == null
        ? void this.removeAttribute(e)
        : ((o = this.getAttribute(e)),
          (u = l + ''),
          o === u ? null : o === n && u === i ? s : ((i = u), (s = t((n = o), l))))
    }
  }
  function Mft(e, t, r) {
    var n, i, s
    return function () {
      var o,
        l = r(this),
        u
      return l == null
        ? void this.removeAttributeNS(e.space, e.local)
        : ((o = this.getAttributeNS(e.space, e.local)),
          (u = l + ''),
          o === u ? null : o === n && u === i ? s : ((i = u), (s = t((n = o), l))))
    }
  }
  function lv(e, t) {
    var r = io(e),
      n = r === 'transform' ? ev : Ig
    return this.attrTween(
      e,
      typeof t == 'function'
        ? (r.local ? Mft : Ift)(r, n, Af(this, 'attr.' + e, t))
        : t == null
          ? (r.local ? Rft : Lft)(r)
          : (r.local ? Nft : Dft)(r, n, t),
    )
  }
  var BO = x(() => {
    'use strict'
    Ef()
    wa()
    Ng()
    ov()
    a(Lft, 'attrRemove')
    a(Rft, 'attrRemoveNS')
    a(Dft, 'attrConstant')
    a(Nft, 'attrConstantNS')
    a(Ift, 'attrFunction')
    a(Mft, 'attrFunctionNS')
    a(lv, 'default')
  })
  function Oft(e, t) {
    return function (r) {
      this.setAttribute(e, t.call(this, r))
    }
  }
  function Pft(e, t) {
    return function (r) {
      this.setAttributeNS(e.space, e.local, t.call(this, r))
    }
  }
  function Bft(e, t) {
    var r, n
    function i() {
      var s = t.apply(this, arguments)
      return s !== n && (r = (n = s) && Pft(e, s)), r
    }
    return a(i, 'tween'), (i._value = t), i
  }
  function Fft(e, t) {
    var r, n
    function i() {
      var s = t.apply(this, arguments)
      return s !== n && (r = (n = s) && Oft(e, s)), r
    }
    return a(i, 'tween'), (i._value = t), i
  }
  function cv(e, t) {
    var r = 'attr.' + e
    if (arguments.length < 2) return (r = this.tween(r)) && r._value
    if (t == null) return this.tween(r, null)
    if (typeof t != 'function') throw new Error()
    var n = io(e)
    return this.tween(r, (n.local ? Bft : Fft)(n, t))
  }
  var FO = x(() => {
    'use strict'
    wa()
    a(Oft, 'attrInterpolate')
    a(Pft, 'attrInterpolateNS')
    a(Bft, 'attrTweenNS')
    a(Fft, 'attrTween')
    a(cv, 'default')
  })
  function $ft(e, t) {
    return function () {
      Rg(this, e).delay = +t.apply(this, arguments)
    }
  }
  function Gft(e, t) {
    return (
      (t = +t),
      function () {
        Rg(this, e).delay = t
      }
    )
  }
  function uv(e) {
    var t = this._id
    return arguments.length ? this.each((typeof e == 'function' ? $ft : Gft)(t, e)) : Pn(this.node(), t).delay
  }
  var $O = x(() => {
    'use strict'
    es()
    a($ft, 'delayFunction')
    a(Gft, 'delayConstant')
    a(uv, 'default')
  })
  function Vft(e, t) {
    return function () {
      ti(this, e).duration = +t.apply(this, arguments)
    }
  }
  function zft(e, t) {
    return (
      (t = +t),
      function () {
        ti(this, e).duration = t
      }
    )
  }
  function hv(e) {
    var t = this._id
    return arguments.length ? this.each((typeof e == 'function' ? Vft : zft)(t, e)) : Pn(this.node(), t).duration
  }
  var GO = x(() => {
    'use strict'
    es()
    a(Vft, 'durationFunction')
    a(zft, 'durationConstant')
    a(hv, 'default')
  })
  function Wft(e, t) {
    if (typeof t != 'function') throw new Error()
    return function () {
      ti(this, e).ease = t
    }
  }
  function fv(e) {
    var t = this._id
    return arguments.length ? this.each(Wft(t, e)) : Pn(this.node(), t).ease
  }
  var VO = x(() => {
    'use strict'
    es()
    a(Wft, 'easeConstant')
    a(fv, 'default')
  })
  function Uft(e, t) {
    return function () {
      var r = t.apply(this, arguments)
      if (typeof r != 'function') throw new Error()
      ti(this, e).ease = r
    }
  }
  function dv(e) {
    if (typeof e != 'function') throw new Error()
    return this.each(Uft(this._id, e))
  }
  var zO = x(() => {
    'use strict'
    es()
    a(Uft, 'easeVarying')
    a(dv, 'default')
  })
  function pv(e) {
    typeof e != 'function' && (e = xf(e))
    for (var t = this._groups, r = t.length, n = new Array(r), i = 0; i < r; ++i)
      for (var s = t[i], o = s.length, l = (n[i] = []), u, h = 0; h < o; ++h)
        (u = s[h]) && e.call(u, u.__data__, h, s) && l.push(u)
    return new Fi(n, this._parents, this._name, this._id)
  }
  var WO = x(() => {
    'use strict'
    wa()
    Lu()
    a(pv, 'default')
  })
  function mv(e) {
    if (e._id !== this._id) throw new Error()
    for (
      var t = this._groups, r = e._groups, n = t.length, i = r.length, s = Math.min(n, i), o = new Array(n), l = 0;
      l < s;
      ++l
    )
      for (var u = t[l], h = r[l], f = u.length, d = (o[l] = new Array(f)), p, m = 0; m < f; ++m)
        (p = u[m] || h[m]) && (d[m] = p)
    for (; l < n; ++l) o[l] = t[l]
    return new Fi(o, this._parents, this._name, this._id)
  }
  var UO = x(() => {
    'use strict'
    Lu()
    a(mv, 'default')
  })
  function jft(e) {
    return (e + '')
      .trim()
      .split(/^|\s+/)
      .every(function (t) {
        var r = t.indexOf('.')
        return r >= 0 && (t = t.slice(0, r)), !t || t === 'start'
      })
  }
  function qft(e, t, r) {
    var n,
      i,
      s = jft(t) ? Rg : ti
    return function () {
      var o = s(this, e),
        l = o.on
      l !== n && (i = (n = l).copy()).on(t, r), (o.on = i)
    }
  }
  function gv(e, t) {
    var r = this._id
    return arguments.length < 2 ? Pn(this.node(), r).on.on(e) : this.each(qft(r, e, t))
  }
  var jO = x(() => {
    'use strict'
    es()
    a(jft, 'start')
    a(qft, 'onFunction')
    a(gv, 'default')
  })
  function Hft(e) {
    return function () {
      var t = this.parentNode
      for (var r in this.__transition) if (+r !== e) return
      t && t.removeChild(this)
    }
  }
  function yv() {
    return this.on('end.remove', Hft(this._id))
  }
  var qO = x(() => {
    'use strict'
    a(Hft, 'removeFunction')
    a(yv, 'default')
  })
  function xv(e) {
    var t = this._name,
      r = this._id
    typeof e != 'function' && (e = tc(e))
    for (var n = this._groups, i = n.length, s = new Array(i), o = 0; o < i; ++o)
      for (var l = n[o], u = l.length, h = (s[o] = new Array(u)), f, d, p = 0; p < u; ++p)
        (f = l[p]) &&
          (d = e.call(f, f.__data__, p, l)) &&
          ('__data__' in f && (d.__data__ = f.__data__), (h[p] = d), il(h[p], t, r, p, h, Pn(f, r)))
    return new Fi(s, this._parents, t, r)
  }
  var HO = x(() => {
    'use strict'
    wa()
    Lu()
    es()
    a(xv, 'default')
  })
  function bv(e) {
    var t = this._name,
      r = this._id
    typeof e != 'function' && (e = yf(e))
    for (var n = this._groups, i = n.length, s = [], o = [], l = 0; l < i; ++l)
      for (var u = n[l], h = u.length, f, d = 0; d < h; ++d)
        if ((f = u[d])) {
          for (var p = e.call(f, f.__data__, d, u), m, g = Pn(f, r), y = 0, b = p.length; y < b; ++y)
            (m = p[y]) && il(m, t, r, y, p, g)
          s.push(p), o.push(f)
        }
    return new Fi(s, o, t, r)
  }
  var YO = x(() => {
    'use strict'
    wa()
    Lu()
    es()
    a(bv, 'default')
  })
  function kv() {
    return new Yft(this._groups, this._parents)
  }
  var Yft,
    XO = x(() => {
      'use strict'
      wa()
      Yft = el.prototype.constructor
      a(kv, 'default')
    })
  function Xft(e, t) {
    var r, n, i
    return function () {
      var s = ec(this, e),
        o = (this.style.removeProperty(e), ec(this, e))
      return s === o ? null : s === r && o === n ? i : (i = t((r = s), (n = o)))
    }
  }
  function KO(e) {
    return function () {
      this.style.removeProperty(e)
    }
  }
  function Kft(e, t, r) {
    var n,
      i = r + '',
      s
    return function () {
      var o = ec(this, e)
      return o === i ? null : o === n ? s : (s = t((n = o), r))
    }
  }
  function Qft(e, t, r) {
    var n, i, s
    return function () {
      var o = ec(this, e),
        l = r(this),
        u = l + ''
      return (
        l == null && (u = l = (this.style.removeProperty(e), ec(this, e))),
        o === u ? null : o === n && u === i ? s : ((i = u), (s = t((n = o), l)))
      )
    }
  }
  function Zft(e, t) {
    var r,
      n,
      i,
      s = 'style.' + t,
      o = 'end.' + s,
      l
    return function () {
      var u = ti(this, e),
        h = u.on,
        f = u.value[s] == null ? l || (l = KO(t)) : void 0
      ;(h !== r || i !== f) && (n = (r = h).copy()).on(o, (i = f)), (u.on = n)
    }
  }
  function Tv(e, t, r) {
    var n = (e += '') == 'transform' ? tv : Ig
    return t == null
      ? this.styleTween(e, Xft(e, n)).on('end.style.' + e, KO(e))
      : typeof t == 'function'
        ? this.styleTween(e, Qft(e, n, Af(this, 'style.' + e, t))).each(Zft(this._id, e))
        : this.styleTween(e, Kft(e, n, t), r).on('end.style.' + e, null)
  }
  var QO = x(() => {
    'use strict'
    Ef()
    wa()
    es()
    Ng()
    ov()
    a(Xft, 'styleNull')
    a(KO, 'styleRemove')
    a(Kft, 'styleConstant')
    a(Qft, 'styleFunction')
    a(Zft, 'styleMaybeRemove')
    a(Tv, 'default')
  })
  function Jft(e, t, r) {
    return function (n) {
      this.style.setProperty(e, t.call(this, n), r)
    }
  }
  function tdt(e, t, r) {
    var n, i
    function s() {
      var o = t.apply(this, arguments)
      return o !== i && (n = (i = o) && Jft(e, o, r)), n
    }
    return a(s, 'tween'), (s._value = t), s
  }
  function Sv(e, t, r) {
    var n = 'style.' + (e += '')
    if (arguments.length < 2) return (n = this.tween(n)) && n._value
    if (t == null) return this.tween(n, null)
    if (typeof t != 'function') throw new Error()
    return this.tween(n, tdt(e, t, r ?? ''))
  }
  var ZO = x(() => {
    'use strict'
    a(Jft, 'styleInterpolate')
    a(tdt, 'styleTween')
    a(Sv, 'default')
  })
  function edt(e) {
    return function () {
      this.textContent = e
    }
  }
  function rdt(e) {
    return function () {
      var t = e(this)
      this.textContent = t ?? ''
    }
  }
  function _v(e) {
    return this.tween('text', typeof e == 'function' ? rdt(Af(this, 'text', e)) : edt(e == null ? '' : e + ''))
  }
  var JO = x(() => {
    'use strict'
    Ng()
    a(edt, 'textConstant')
    a(rdt, 'textFunction')
    a(_v, 'default')
  })
  function ndt(e) {
    return function (t) {
      this.textContent = e.call(this, t)
    }
  }
  function idt(e) {
    var t, r
    function n() {
      var i = e.apply(this, arguments)
      return i !== r && (t = (r = i) && ndt(i)), t
    }
    return a(n, 'tween'), (n._value = e), n
  }
  function Cv(e) {
    var t = 'text'
    if (arguments.length < 1) return (t = this.tween(t)) && t._value
    if (e == null) return this.tween(t, null)
    if (typeof e != 'function') throw new Error()
    return this.tween(t, idt(e))
  }
  var tP = x(() => {
    'use strict'
    a(ndt, 'textInterpolate')
    a(idt, 'textTween')
    a(Cv, 'default')
  })
  function wv() {
    for (var e = this._name, t = this._id, r = i2(), n = this._groups, i = n.length, s = 0; s < i; ++s)
      for (var o = n[s], l = o.length, u, h = 0; h < l; ++h)
        if ((u = o[h])) {
          var f = Pn(u, t)
          il(u, e, r, h, o, { time: f.time + f.delay + f.duration, delay: 0, duration: f.duration, ease: f.ease })
        }
    return new Fi(n, this._parents, e, r)
  }
  var eP = x(() => {
    'use strict'
    Lu()
    es()
    a(wv, 'default')
  })
  function Ev() {
    var e,
      t,
      r = this,
      n = r._id,
      i = r.size()
    return new Promise(function (s, o) {
      var l = { value: o },
        u = {
          value: a(function () {
            --i === 0 && s()
          }, 'value'),
        }
      r.each(function () {
        var h = ti(this, n),
          f = h.on
        f !== e && ((t = (e = f).copy()), t._.cancel.push(l), t._.interrupt.push(l), t._.end.push(u)), (h.on = t)
      }),
        i === 0 && s()
    })
  }
  var rP = x(() => {
    'use strict'
    es()
    a(Ev, 'default')
  })
  function Fi(e, t, r, n) {
    ;(this._groups = e), (this._parents = t), (this._name = r), (this._id = n)
  }
  function nP(e) {
    return el().transition(e)
  }
  function i2() {
    return ++sdt
  }
  var sdt,
    sl,
    Lu = x(() => {
      'use strict'
      wa()
      BO()
      FO()
      $O()
      GO()
      VO()
      zO()
      WO()
      UO()
      jO()
      qO()
      HO()
      YO()
      XO()
      QO()
      ZO()
      JO()
      tP()
      eP()
      Ng()
      rP()
      sdt = 0
      a(Fi, 'Transition')
      a(nP, 'transition')
      a(i2, 'newId')
      sl = el.prototype
      Fi.prototype = nP.prototype = {
        constructor: Fi,
        select: xv,
        selectAll: bv,
        selectChild: sl.selectChild,
        selectChildren: sl.selectChildren,
        filter: pv,
        merge: mv,
        selection: kv,
        transition: wv,
        call: sl.call,
        nodes: sl.nodes,
        node: sl.node,
        size: sl.size,
        empty: sl.empty,
        each: sl.each,
        on: gv,
        attr: lv,
        attrTween: cv,
        style: Tv,
        styleTween: Sv,
        text: _v,
        textTween: Cv,
        remove: yv,
        tween: av,
        delay: uv,
        duration: hv,
        ease: fv,
        easeVarying: dv,
        end: Ev,
        [Symbol.iterator]: sl[Symbol.iterator],
      }
    })
  function s2(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2
  }
  var iP = x(() => {
    'use strict'
    a(s2, 'cubicInOut')
  })
  var vv = x(() => {
    'use strict'
    iP()
  })
  function odt(e, t) {
    for (var r; !(r = e.__transition) || !(r = r[t]); )
      if (!(e = e.parentNode)) throw new Error(`transition ${t} not found`)
    return r
  }
  function Av(e) {
    var t, r
    e instanceof Fi
      ? ((t = e._id), (e = e._name))
      : ((t = i2()), ((r = adt).time = vg()), (e = e == null ? null : e + ''))
    for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
      for (var o = n[s], l = o.length, u, h = 0; h < l; ++h) (u = o[h]) && il(u, e, t, h, o, r || odt(u, t))
    return new Fi(n, this._parents, e, t)
  }
  var adt,
    sP = x(() => {
      'use strict'
      Lu()
      es()
      vv()
      t2()
      adt = { time: null, delay: 0, duration: 250, ease: s2 }
      a(odt, 'inherit')
      a(Av, 'default')
    })
  var aP = x(() => {
    'use strict'
    wa()
    PO()
    sP()
    el.prototype.interrupt = sv
    el.prototype.transition = Av
  })
  var a2 = x(() => {
    'use strict'
    aP()
  })
  var oP = x(() => {
    'use strict'
  })
  var lP = x(() => {
    'use strict'
  })
  var cP = x(() => {
    'use strict'
  })
  function uP(e) {
    return [+e[0], +e[1]]
  }
  function ldt(e) {
    return [uP(e[0]), uP(e[1])]
  }
  function Lv(e) {
    return { type: e }
  }
  var dqt,
    pqt,
    mqt,
    gqt,
    yqt,
    xqt,
    hP = x(() => {
      'use strict'
      a2()
      oP()
      lP()
      cP()
      ;({ abs: dqt, max: pqt, min: mqt } = Math)
      a(uP, 'number1')
      a(ldt, 'number2')
      ;(gqt = {
        name: 'x',
        handles: ['w', 'e'].map(Lv),
        input: a(function (e, t) {
          return e == null
            ? null
            : [
                [+e[0], t[0][1]],
                [+e[1], t[1][1]],
              ]
        }, 'input'),
        output: a(function (e) {
          return e && [e[0][0], e[1][0]]
        }, 'output'),
      }),
        (yqt = {
          name: 'y',
          handles: ['n', 's'].map(Lv),
          input: a(function (e, t) {
            return e == null
              ? null
              : [
                  [t[0][0], +e[0]],
                  [t[1][0], +e[1]],
                ]
          }, 'input'),
          output: a(function (e) {
            return e && [e[0][1], e[1][1]]
          }, 'output'),
        }),
        (xqt = {
          name: 'xy',
          handles: ['n', 'w', 'e', 's', 'nw', 'ne', 'sw', 'se'].map(Lv),
          input: a(function (e) {
            return e == null ? null : ldt(e)
          }, 'input'),
          output: a(function (e) {
            return e
          }, 'output'),
        })
      a(Lv, 'type')
    })
  var fP = x(() => {
    'use strict'
    hP()
  })
  function dP(e) {
    this._ += e[0]
    for (let t = 1, r = e.length; t < r; ++t) this._ += arguments[t] + e[t]
  }
  function udt(e) {
    let t = Math.floor(e)
    if (!(t >= 0)) throw new Error(`invalid digits: ${e}`)
    if (t > 15) return dP
    let r = 10 ** t
    return function (n) {
      this._ += n[0]
      for (let i = 1, s = n.length; i < s; ++i) this._ += Math.round(arguments[i] * r) / r + n[i]
    }
  }
  function pP() {
    return new Du()
  }
  var Rv,
    Dv,
    Ru,
    cdt,
    Du,
    mP = x(() => {
      'use strict'
      ;(Rv = Math.PI), (Dv = 2 * Rv), (Ru = 1e-6), (cdt = Dv - Ru)
      a(dP, 'append')
      a(udt, 'appendRound')
      Du = class {
        static {
          a(this, 'Path')
        }
        constructor(t) {
          ;(this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = ''), (this._append = t == null ? dP : udt(t))
        }
        moveTo(t, r) {
          this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +r)}`
        }
        closePath() {
          this._x1 !== null && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`)
        }
        lineTo(t, r) {
          this._append`L${(this._x1 = +t)},${(this._y1 = +r)}`
        }
        quadraticCurveTo(t, r, n, i) {
          this._append`Q${+t},${+r},${(this._x1 = +n)},${(this._y1 = +i)}`
        }
        bezierCurveTo(t, r, n, i, s, o) {
          this._append`C${+t},${+r},${+n},${+i},${(this._x1 = +s)},${(this._y1 = +o)}`
        }
        arcTo(t, r, n, i, s) {
          if (((t = +t), (r = +r), (n = +n), (i = +i), (s = +s), s < 0)) throw new Error(`negative radius: ${s}`)
          let o = this._x1,
            l = this._y1,
            u = n - t,
            h = i - r,
            f = o - t,
            d = l - r,
            p = f * f + d * d
          if (this._x1 === null) this._append`M${(this._x1 = t)},${(this._y1 = r)}`
          else if (p > Ru)
            if (!(Math.abs(d * u - h * f) > Ru) || !s) this._append`L${(this._x1 = t)},${(this._y1 = r)}`
            else {
              let m = n - o,
                g = i - l,
                y = u * u + h * h,
                b = m * m + g * g,
                k = Math.sqrt(y),
                T = Math.sqrt(p),
                C = s * Math.tan((Rv - Math.acos((y + p - b) / (2 * k * T))) / 2),
                A = C / T,
                w = C / k
              Math.abs(A - 1) > Ru && this._append`L${t + A * f},${r + A * d}`,
                this._append`A${s},${s},0,0,${+(d * m > f * g)},${(this._x1 = t + w * u)},${(this._y1 = r + w * h)}`
            }
        }
        arc(t, r, n, i, s, o) {
          if (((t = +t), (r = +r), (n = +n), (o = !!o), n < 0)) throw new Error(`negative radius: ${n}`)
          let l = n * Math.cos(i),
            u = n * Math.sin(i),
            h = t + l,
            f = r + u,
            d = 1 ^ o,
            p = o ? i - s : s - i
          this._x1 === null
            ? this._append`M${h},${f}`
            : (Math.abs(this._x1 - h) > Ru || Math.abs(this._y1 - f) > Ru) && this._append`L${h},${f}`,
            n &&
              (p < 0 && (p = (p % Dv) + Dv),
              p > cdt
                ? this
                    ._append`A${n},${n},0,1,${d},${t - l},${r - u}A${n},${n},0,1,${d},${(this._x1 = h)},${(this._y1 = f)}`
                : p > Ru &&
                  this
                    ._append`A${n},${n},0,${+(p >= Rv)},${d},${(this._x1 = t + n * Math.cos(s))},${(this._y1 = r + n * Math.sin(s))}`)
        }
        rect(t, r, n, i) {
          this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +r)}h${(n = +n)}v${+i}h${-n}Z`
        }
        toString() {
          return this._
        }
      }
      a(pP, 'path')
      pP.prototype = Du.prototype
    })
  var Nv = x(() => {
    'use strict'
    mP()
  })
  var gP = x(() => {
    'use strict'
  })
  var yP = x(() => {
    'use strict'
  })
  var xP = x(() => {
    'use strict'
  })
  var bP = x(() => {
    'use strict'
  })
  var kP = x(() => {
    'use strict'
  })
  var TP = x(() => {
    'use strict'
  })
  var SP = x(() => {
    'use strict'
  })
  function Iv(e) {
    return Math.abs((e = Math.round(e))) >= 1e21 ? e.toLocaleString('en').replace(/,/g, '') : e.toString(10)
  }
  function Nu(e, t) {
    if ((r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf('e')) < 0) return null
    var r,
      n = e.slice(0, r)
    return [n.length > 1 ? n[0] + n.slice(2) : n, +e.slice(r + 1)]
  }
  var Mg = x(() => {
    'use strict'
    a(Iv, 'default')
    a(Nu, 'formatDecimalParts')
  })
  function Aa(e) {
    return (e = Nu(Math.abs(e))), e ? e[1] : NaN
  }
  var Og = x(() => {
    'use strict'
    Mg()
    a(Aa, 'default')
  })
  function Mv(e, t) {
    return function (r, n) {
      for (
        var i = r.length, s = [], o = 0, l = e[0], u = 0;
        i > 0 &&
        l > 0 &&
        (u + l + 1 > n && (l = Math.max(1, n - u)), s.push(r.substring((i -= l), i + l)), !((u += l + 1) > n));

      )
        l = e[(o = (o + 1) % e.length)]
      return s.reverse().join(t)
    }
  }
  var _P = x(() => {
    'use strict'
    a(Mv, 'default')
  })
  function Ov(e) {
    return function (t) {
      return t.replace(/[0-9]/g, function (r) {
        return e[+r]
      })
    }
  }
  var CP = x(() => {
    'use strict'
    a(Ov, 'default')
  })
  function sc(e) {
    if (!(t = hdt.exec(e))) throw new Error('invalid format: ' + e)
    var t
    return new o2({
      fill: t[1],
      align: t[2],
      sign: t[3],
      symbol: t[4],
      zero: t[5],
      width: t[6],
      comma: t[7],
      precision: t[8] && t[8].slice(1),
      trim: t[9],
      type: t[10],
    })
  }
  function o2(e) {
    ;(this.fill = e.fill === void 0 ? ' ' : e.fill + ''),
      (this.align = e.align === void 0 ? '>' : e.align + ''),
      (this.sign = e.sign === void 0 ? '-' : e.sign + ''),
      (this.symbol = e.symbol === void 0 ? '' : e.symbol + ''),
      (this.zero = !!e.zero),
      (this.width = e.width === void 0 ? void 0 : +e.width),
      (this.comma = !!e.comma),
      (this.precision = e.precision === void 0 ? void 0 : +e.precision),
      (this.trim = !!e.trim),
      (this.type = e.type === void 0 ? '' : e.type + '')
  }
  var hdt,
    Pv = x(() => {
      'use strict'
      hdt = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
      a(sc, 'formatSpecifier')
      sc.prototype = o2.prototype
      a(o2, 'FormatSpecifier')
      o2.prototype.toString = function () {
        return (
          this.fill +
          this.align +
          this.sign +
          this.symbol +
          (this.zero ? '0' : '') +
          (this.width === void 0 ? '' : Math.max(1, this.width | 0)) +
          (this.comma ? ',' : '') +
          (this.precision === void 0 ? '' : '.' + Math.max(0, this.precision | 0)) +
          (this.trim ? '~' : '') +
          this.type
        )
      }
    })
  function Bv(e) {
    t: for (var t = e.length, r = 1, n = -1, i; r < t; ++r)
      switch (e[r]) {
        case '.':
          n = i = r
          break
        case '0':
          n === 0 && (n = r), (i = r)
          break
        default:
          if (!+e[r]) break t
          n > 0 && (n = 0)
          break
      }
    return n > 0 ? e.slice(0, n) + e.slice(i + 1) : e
  }
  var wP = x(() => {
    'use strict'
    a(Bv, 'default')
  })
  function $v(e, t) {
    var r = Nu(e, t)
    if (!r) return e + ''
    var n = r[0],
      i = r[1],
      s = i - (Fv = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
      o = n.length
    return s === o
      ? n
      : s > o
        ? n + new Array(s - o + 1).join('0')
        : s > 0
          ? n.slice(0, s) + '.' + n.slice(s)
          : '0.' + new Array(1 - s).join('0') + Nu(e, Math.max(0, t + s - 1))[0]
  }
  var Fv,
    Gv = x(() => {
      'use strict'
      Mg()
      a($v, 'default')
    })
  function l2(e, t) {
    var r = Nu(e, t)
    if (!r) return e + ''
    var n = r[0],
      i = r[1]
    return i < 0
      ? '0.' + new Array(-i).join('0') + n
      : n.length > i + 1
        ? n.slice(0, i + 1) + '.' + n.slice(i + 1)
        : n + new Array(i - n.length + 2).join('0')
  }
  var EP = x(() => {
    'use strict'
    Mg()
    a(l2, 'default')
  })
  var Vv,
    vP = x(() => {
      'use strict'
      Mg()
      Gv()
      EP()
      Vv = {
        '%': a((e, t) => (e * 100).toFixed(t), '%'),
        b: a((e) => Math.round(e).toString(2), 'b'),
        c: a((e) => e + '', 'c'),
        d: Iv,
        e: a((e, t) => e.toExponential(t), 'e'),
        f: a((e, t) => e.toFixed(t), 'f'),
        g: a((e, t) => e.toPrecision(t), 'g'),
        o: a((e) => Math.round(e).toString(8), 'o'),
        p: a((e, t) => l2(e * 100, t), 'p'),
        r: l2,
        s: $v,
        X: a((e) => Math.round(e).toString(16).toUpperCase(), 'X'),
        x: a((e) => Math.round(e).toString(16), 'x'),
      }
    })
  function c2(e) {
    return e
  }
  var AP = x(() => {
    'use strict'
    a(c2, 'default')
  })
  function zv(e) {
    var t = e.grouping === void 0 || e.thousands === void 0 ? c2 : Mv(LP.call(e.grouping, Number), e.thousands + ''),
      r = e.currency === void 0 ? '' : e.currency[0] + '',
      n = e.currency === void 0 ? '' : e.currency[1] + '',
      i = e.decimal === void 0 ? '.' : e.decimal + '',
      s = e.numerals === void 0 ? c2 : Ov(LP.call(e.numerals, String)),
      o = e.percent === void 0 ? '%' : e.percent + '',
      l = e.minus === void 0 ? '\u2212' : e.minus + '',
      u = e.nan === void 0 ? 'NaN' : e.nan + ''
    function h(d) {
      d = sc(d)
      var p = d.fill,
        m = d.align,
        g = d.sign,
        y = d.symbol,
        b = d.zero,
        k = d.width,
        T = d.comma,
        C = d.precision,
        A = d.trim,
        w = d.type
      w === 'n' ? ((T = !0), (w = 'g')) : Vv[w] || (C === void 0 && (C = 12), (A = !0), (w = 'g')),
        (b || (p === '0' && m === '=')) && ((b = !0), (p = '0'), (m = '='))
      var D = y === '$' ? r : y === '#' && /[boxX]/.test(w) ? '0' + w.toLowerCase() : '',
        G = y === '$' ? n : /[%p]/.test(w) ? o : '',
        v = Vv[w],
        R = /[defgprs%]/.test(w)
      C = C === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, C)) : Math.max(0, Math.min(20, C))
      function F(S) {
        var O = D,
          E = G,
          _,
          L,
          N
        if (w === 'c') (E = v(S) + E), (S = '')
        else {
          S = +S
          var P = S < 0 || 1 / S < 0
          if (
            ((S = isNaN(S) ? u : v(Math.abs(S), C)),
            A && (S = Bv(S)),
            P && +S == 0 && g !== '+' && (P = !1),
            (O = (P ? (g === '(' ? g : l) : g === '-' || g === '(' ? '' : g) + O),
            (E = (w === 's' ? RP[8 + Fv / 3] : '') + E + (P && g === '(' ? ')' : '')),
            R)
          ) {
            for (_ = -1, L = S.length; ++_ < L; )
              if (((N = S.charCodeAt(_)), 48 > N || N > 57)) {
                ;(E = (N === 46 ? i + S.slice(_ + 1) : S.slice(_)) + E), (S = S.slice(0, _))
                break
              }
          }
        }
        T && !b && (S = t(S, 1 / 0))
        var I = O.length + S.length + E.length,
          M = I < k ? new Array(k - I + 1).join(p) : ''
        switch ((T && b && ((S = t(M + S, M.length ? k - E.length : 1 / 0)), (M = '')), m)) {
          case '<':
            S = O + S + E + M
            break
          case '=':
            S = O + M + S + E
            break
          case '^':
            S = M.slice(0, (I = M.length >> 1)) + O + S + E + M.slice(I)
            break
          default:
            S = M + O + S + E
            break
        }
        return s(S)
      }
      return (
        a(F, 'format'),
        (F.toString = function () {
          return d + ''
        }),
        F
      )
    }
    a(h, 'newFormat')
    function f(d, p) {
      var m = h(((d = sc(d)), (d.type = 'f'), d)),
        g = Math.max(-8, Math.min(8, Math.floor(Aa(p) / 3))) * 3,
        y = Math.pow(10, -g),
        b = RP[8 + g / 3]
      return function (k) {
        return m(y * k) + b
      }
    }
    return a(f, 'formatPrefix'), { format: h, formatPrefix: f }
  }
  var LP,
    RP,
    DP = x(() => {
      'use strict'
      Og()
      _P()
      CP()
      Pv()
      wP()
      vP()
      Gv()
      AP()
      ;(LP = Array.prototype.map),
        (RP = ['y', 'z', 'a', 'f', 'p', 'n', '\xB5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'])
      a(zv, 'default')
    })
  function Wv(e) {
    return (u2 = zv(e)), (oo = u2.format), (h2 = u2.formatPrefix), u2
  }
  var u2,
    oo,
    h2,
    NP = x(() => {
      'use strict'
      DP()
      Wv({ thousands: ',', grouping: [3], currency: ['$', ''] })
      a(Wv, 'defaultLocale')
    })
  function f2(e) {
    return Math.max(0, -Aa(Math.abs(e)))
  }
  var IP = x(() => {
    'use strict'
    Og()
    a(f2, 'default')
  })
  function d2(e, t) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Aa(t) / 3))) * 3 - Aa(Math.abs(e)))
  }
  var MP = x(() => {
    'use strict'
    Og()
    a(d2, 'default')
  })
  function p2(e, t) {
    return (e = Math.abs(e)), (t = Math.abs(t) - e), Math.max(0, Aa(t) - Aa(e)) + 1
  }
  var OP = x(() => {
    'use strict'
    Og()
    a(p2, 'default')
  })
  var Uv = x(() => {
    'use strict'
    NP()
    Pv()
    IP()
    MP()
    OP()
  })
  var PP = x(() => {
    'use strict'
  })
  function fdt(e) {
    var t = 0,
      r = e.children,
      n = r && r.length
    if (!n) t = 1
    else for (; --n >= 0; ) t += r[n].value
    e.value = t
  }
  function jv() {
    return this.eachAfter(fdt)
  }
  var BP = x(() => {
    'use strict'
    a(fdt, 'count')
    a(jv, 'default')
  })
  function qv(e, t) {
    let r = -1
    for (let n of this) e.call(t, n, ++r, this)
    return this
  }
  var FP = x(() => {
    'use strict'
    a(qv, 'default')
  })
  function Hv(e, t) {
    for (var r = this, n = [r], i, s, o = -1; (r = n.pop()); )
      if ((e.call(t, r, ++o, this), (i = r.children))) for (s = i.length - 1; s >= 0; --s) n.push(i[s])
    return this
  }
  var $P = x(() => {
    'use strict'
    a(Hv, 'default')
  })
  function Yv(e, t) {
    for (var r = this, n = [r], i = [], s, o, l, u = -1; (r = n.pop()); )
      if ((i.push(r), (s = r.children))) for (o = 0, l = s.length; o < l; ++o) n.push(s[o])
    for (; (r = i.pop()); ) e.call(t, r, ++u, this)
    return this
  }
  var GP = x(() => {
    'use strict'
    a(Yv, 'default')
  })
  function Xv(e, t) {
    let r = -1
    for (let n of this) if (e.call(t, n, ++r, this)) return n
  }
  var VP = x(() => {
    'use strict'
    a(Xv, 'default')
  })
  function Kv(e) {
    return this.eachAfter(function (t) {
      for (var r = +e(t.data) || 0, n = t.children, i = n && n.length; --i >= 0; ) r += n[i].value
      t.value = r
    })
  }
  var zP = x(() => {
    'use strict'
    a(Kv, 'default')
  })
  function Qv(e) {
    return this.eachBefore(function (t) {
      t.children && t.children.sort(e)
    })
  }
  var WP = x(() => {
    'use strict'
    a(Qv, 'default')
  })
  function Zv(e) {
    for (var t = this, r = ddt(t, e), n = [t]; t !== r; ) (t = t.parent), n.push(t)
    for (var i = n.length; e !== r; ) n.splice(i, 0, e), (e = e.parent)
    return n
  }
  function ddt(e, t) {
    if (e === t) return e
    var r = e.ancestors(),
      n = t.ancestors(),
      i = null
    for (e = r.pop(), t = n.pop(); e === t; ) (i = e), (e = r.pop()), (t = n.pop())
    return i
  }
  var UP = x(() => {
    'use strict'
    a(Zv, 'default')
    a(ddt, 'leastCommonAncestor')
  })
  function Jv() {
    for (var e = this, t = [e]; (e = e.parent); ) t.push(e)
    return t
  }
  var jP = x(() => {
    'use strict'
    a(Jv, 'default')
  })
  function t3() {
    return Array.from(this)
  }
  var qP = x(() => {
    'use strict'
    a(t3, 'default')
  })
  function e3() {
    var e = []
    return (
      this.eachBefore(function (t) {
        t.children || e.push(t)
      }),
      e
    )
  }
  var HP = x(() => {
    'use strict'
    a(e3, 'default')
  })
  function r3() {
    var e = this,
      t = []
    return (
      e.each(function (r) {
        r !== e && t.push({ source: r.parent, target: r })
      }),
      t
    )
  }
  var YP = x(() => {
    'use strict'
    a(r3, 'default')
  })
  function* n3() {
    var e = this,
      t,
      r = [e],
      n,
      i,
      s
    do
      for (t = r.reverse(), r = []; (e = t.pop()); )
        if ((yield e, (n = e.children))) for (i = 0, s = n.length; i < s; ++i) r.push(n[i])
    while (r.length)
  }
  var XP = x(() => {
    'use strict'
    a(n3, 'default')
  })
  function Lf(e, t) {
    e instanceof Map ? ((e = [void 0, e]), t === void 0 && (t = gdt)) : t === void 0 && (t = mdt)
    for (var r = new Pg(e), n, i = [r], s, o, l, u; (n = i.pop()); )
      if ((o = t(n.data)) && (u = (o = Array.from(o)).length))
        for (n.children = o, l = u - 1; l >= 0; --l)
          i.push((s = o[l] = new Pg(o[l]))), (s.parent = n), (s.depth = n.depth + 1)
    return r.eachBefore(xdt)
  }
  function pdt() {
    return Lf(this).eachBefore(ydt)
  }
  function mdt(e) {
    return e.children
  }
  function gdt(e) {
    return Array.isArray(e) ? e[1] : null
  }
  function ydt(e) {
    e.data.value !== void 0 && (e.value = e.data.value), (e.data = e.data.data)
  }
  function xdt(e) {
    var t = 0
    do e.height = t
    while ((e = e.parent) && e.height < ++t)
  }
  function Pg(e) {
    ;(this.data = e), (this.depth = this.height = 0), (this.parent = null)
  }
  var KP = x(() => {
    'use strict'
    BP()
    FP()
    $P()
    GP()
    VP()
    zP()
    WP()
    UP()
    jP()
    qP()
    HP()
    YP()
    XP()
    a(Lf, 'hierarchy')
    a(pdt, 'node_copy')
    a(mdt, 'objectChildren')
    a(gdt, 'mapChildren')
    a(ydt, 'copyData')
    a(xdt, 'computeHeight')
    a(Pg, 'Node')
    Pg.prototype = Lf.prototype = {
      constructor: Pg,
      count: jv,
      each: qv,
      eachAfter: Yv,
      eachBefore: Hv,
      find: Xv,
      sum: Kv,
      sort: Qv,
      path: Zv,
      ancestors: Jv,
      descendants: t3,
      leaves: e3,
      links: r3,
      copy: pdt,
      [Symbol.iterator]: n3,
    }
  })
  function QP(e) {
    if (typeof e != 'function') throw new Error()
    return e
  }
  var ZP = x(() => {
    'use strict'
    a(QP, 'required')
  })
  function Rf() {
    return 0
  }
  function Iu(e) {
    return function () {
      return e
    }
  }
  var JP = x(() => {
    'use strict'
    a(Rf, 'constantZero')
    a(Iu, 'default')
  })
  function i3(e) {
    ;(e.x0 = Math.round(e.x0)), (e.y0 = Math.round(e.y0)), (e.x1 = Math.round(e.x1)), (e.y1 = Math.round(e.y1))
  }
  var t9 = x(() => {
    'use strict'
    a(i3, 'default')
  })
  function s3(e, t, r, n, i) {
    for (var s = e.children, o, l = -1, u = s.length, h = e.value && (n - t) / e.value; ++l < u; )
      (o = s[l]), (o.y0 = r), (o.y1 = i), (o.x0 = t), (o.x1 = t += o.value * h)
  }
  var e9 = x(() => {
    'use strict'
    a(s3, 'default')
  })
  function a3(e, t, r, n, i) {
    for (var s = e.children, o, l = -1, u = s.length, h = e.value && (i - r) / e.value; ++l < u; )
      (o = s[l]), (o.x0 = t), (o.x1 = n), (o.y0 = r), (o.y1 = r += o.value * h)
  }
  var r9 = x(() => {
    'use strict'
    a(a3, 'default')
  })
  function kdt(e, t, r, n, i, s) {
    for (
      var o = [], l = t.children, u, h, f = 0, d = 0, p = l.length, m, g, y = t.value, b, k, T, C, A, w, D;
      f < p;

    ) {
      ;(m = i - r), (g = s - n)
      do b = l[d++].value
      while (!b && d < p)
      for (k = T = b, w = Math.max(g / m, m / g) / (y * e), D = b * b * w, A = Math.max(T / D, D / k); d < p; ++d) {
        if (
          ((b += h = l[d].value),
          h < k && (k = h),
          h > T && (T = h),
          (D = b * b * w),
          (C = Math.max(T / D, D / k)),
          C > A)
        ) {
          b -= h
          break
        }
        A = C
      }
      o.push((u = { value: b, dice: m < g, children: l.slice(f, d) })),
        u.dice ? s3(u, r, n, i, y ? (n += (g * b) / y) : s) : a3(u, r, n, y ? (r += (m * b) / y) : i, s),
        (y -= b),
        (f = d)
    }
    return o
  }
  var bdt,
    n9,
    i9 = x(() => {
      'use strict'
      e9()
      r9()
      bdt = (1 + Math.sqrt(5)) / 2
      a(kdt, 'squarifyRatio')
      n9 = a(function e(t) {
        function r(n, i, s, o, l) {
          kdt(t, n, i, s, o, l)
        }
        return (
          a(r, 'squarify'),
          (r.ratio = function (n) {
            return e((n = +n) > 1 ? n : 1)
          }),
          r
        )
      }, 'custom')(bdt)
    })
  function m2() {
    var e = n9,
      t = !1,
      r = 1,
      n = 1,
      i = [0],
      s = Rf,
      o = Rf,
      l = Rf,
      u = Rf,
      h = Rf
    function f(p) {
      return (p.x0 = p.y0 = 0), (p.x1 = r), (p.y1 = n), p.eachBefore(d), (i = [0]), t && p.eachBefore(i3), p
    }
    a(f, 'treemap')
    function d(p) {
      var m = i[p.depth],
        g = p.x0 + m,
        y = p.y0 + m,
        b = p.x1 - m,
        k = p.y1 - m
      b < g && (g = b = (g + b) / 2),
        k < y && (y = k = (y + k) / 2),
        (p.x0 = g),
        (p.y0 = y),
        (p.x1 = b),
        (p.y1 = k),
        p.children &&
          ((m = i[p.depth + 1] = s(p) / 2),
          (g += h(p) - m),
          (y += o(p) - m),
          (b -= l(p) - m),
          (k -= u(p) - m),
          b < g && (g = b = (g + b) / 2),
          k < y && (y = k = (y + k) / 2),
          e(p, g, y, b, k))
    }
    return (
      a(d, 'positionNode'),
      (f.round = function (p) {
        return arguments.length ? ((t = !!p), f) : t
      }),
      (f.size = function (p) {
        return arguments.length ? ((r = +p[0]), (n = +p[1]), f) : [r, n]
      }),
      (f.tile = function (p) {
        return arguments.length ? ((e = QP(p)), f) : e
      }),
      (f.padding = function (p) {
        return arguments.length ? f.paddingInner(p).paddingOuter(p) : f.paddingInner()
      }),
      (f.paddingInner = function (p) {
        return arguments.length ? ((s = typeof p == 'function' ? p : Iu(+p)), f) : s
      }),
      (f.paddingOuter = function (p) {
        return arguments.length ? f.paddingTop(p).paddingRight(p).paddingBottom(p).paddingLeft(p) : f.paddingTop()
      }),
      (f.paddingTop = function (p) {
        return arguments.length ? ((o = typeof p == 'function' ? p : Iu(+p)), f) : o
      }),
      (f.paddingRight = function (p) {
        return arguments.length ? ((l = typeof p == 'function' ? p : Iu(+p)), f) : l
      }),
      (f.paddingBottom = function (p) {
        return arguments.length ? ((u = typeof p == 'function' ? p : Iu(+p)), f) : u
      }),
      (f.paddingLeft = function (p) {
        return arguments.length ? ((h = typeof p == 'function' ? p : Iu(+p)), f) : h
      }),
      f
    )
  }
  var s9 = x(() => {
    'use strict'
    t9()
    i9()
    ZP()
    JP()
    a(m2, 'default')
  })
  var a9 = x(() => {
    'use strict'
    KP()
    s9()
  })
  var o9 = x(() => {
    'use strict'
  })
  var l9 = x(() => {
    'use strict'
  })
  function ac(e, t) {
    switch (arguments.length) {
      case 0:
        break
      case 1:
        this.range(e)
        break
      default:
        this.range(t).domain(e)
        break
    }
    return this
  }
  var Bg = x(() => {
    'use strict'
    a(ac, 'initRange')
  })
  function Cs() {
    var e = new mf(),
      t = [],
      r = [],
      n = o3
    function i(s) {
      let o = e.get(s)
      if (o === void 0) {
        if (n !== o3) return n
        e.set(s, (o = t.push(s) - 1))
      }
      return r[o % r.length]
    }
    return (
      a(i, 'scale'),
      (i.domain = function (s) {
        if (!arguments.length) return t.slice()
        ;(t = []), (e = new mf())
        for (let o of s) e.has(o) || e.set(o, t.push(o) - 1)
        return i
      }),
      (i.range = function (s) {
        return arguments.length ? ((r = Array.from(s)), i) : r.slice()
      }),
      (i.unknown = function (s) {
        return arguments.length ? ((n = s), i) : n
      }),
      (i.copy = function () {
        return Cs(t, r).unknown(n)
      }),
      ac.apply(i, arguments),
      i
    )
  }
  var o3,
    l3 = x(() => {
      'use strict'
      Jl()
      Bg()
      o3 = Symbol('implicit')
      a(Cs, 'ordinal')
    })
  function Df() {
    var e = Cs().unknown(void 0),
      t = e.domain,
      r = e.range,
      n = 0,
      i = 1,
      s,
      o,
      l = !1,
      u = 0,
      h = 0,
      f = 0.5
    delete e.unknown
    function d() {
      var p = t().length,
        m = i < n,
        g = m ? i : n,
        y = m ? n : i
      ;(s = (y - g) / Math.max(1, p - u + h * 2)),
        l && (s = Math.floor(s)),
        (g += (y - g - s * (p - u)) * f),
        (o = s * (1 - u)),
        l && ((g = Math.round(g)), (o = Math.round(o)))
      var b = Nx(p).map(function (k) {
        return g + s * k
      })
      return r(m ? b.reverse() : b)
    }
    return (
      a(d, 'rescale'),
      (e.domain = function (p) {
        return arguments.length ? (t(p), d()) : t()
      }),
      (e.range = function (p) {
        return arguments.length ? (([n, i] = p), (n = +n), (i = +i), d()) : [n, i]
      }),
      (e.rangeRound = function (p) {
        return ([n, i] = p), (n = +n), (i = +i), (l = !0), d()
      }),
      (e.bandwidth = function () {
        return o
      }),
      (e.step = function () {
        return s
      }),
      (e.round = function (p) {
        return arguments.length ? ((l = !!p), d()) : l
      }),
      (e.padding = function (p) {
        return arguments.length ? ((u = Math.min(1, (h = +p))), d()) : u
      }),
      (e.paddingInner = function (p) {
        return arguments.length ? ((u = Math.min(1, p)), d()) : u
      }),
      (e.paddingOuter = function (p) {
        return arguments.length ? ((h = +p), d()) : h
      }),
      (e.align = function (p) {
        return arguments.length ? ((f = Math.max(0, Math.min(1, p))), d()) : f
      }),
      (e.copy = function () {
        return Df(t(), [n, i]).round(l).paddingInner(u).paddingOuter(h).align(f)
      }),
      ac.apply(d(), arguments)
    )
  }
  var c9 = x(() => {
    'use strict'
    Jl()
    Bg()
    l3()
    a(Df, 'band')
  })
  function c3(e) {
    return function () {
      return e
    }
  }
  var u9 = x(() => {
    'use strict'
    a(c3, 'constants')
  })
  function u3(e) {
    return +e
  }
  var h9 = x(() => {
    'use strict'
    a(u3, 'number')
  })
  function Nf(e) {
    return e
  }
  function h3(e, t) {
    return (t -= e = +e)
      ? function (r) {
          return (r - e) / t
        }
      : c3(isNaN(t) ? NaN : 0.5)
  }
  function Tdt(e, t) {
    var r
    return (
      e > t && ((r = e), (e = t), (t = r)),
      function (n) {
        return Math.max(e, Math.min(t, n))
      }
    )
  }
  function Sdt(e, t, r) {
    var n = e[0],
      i = e[1],
      s = t[0],
      o = t[1]
    return (
      i < n ? ((n = h3(i, n)), (s = r(o, s))) : ((n = h3(n, i)), (s = r(s, o))),
      function (l) {
        return s(n(l))
      }
    )
  }
  function _dt(e, t, r) {
    var n = Math.min(e.length, t.length) - 1,
      i = new Array(n),
      s = new Array(n),
      o = -1
    for (e[n] < e[0] && ((e = e.slice().reverse()), (t = t.slice().reverse())); ++o < n; )
      (i[o] = h3(e[o], e[o + 1])), (s[o] = r(t[o], t[o + 1]))
    return function (l) {
      var u = Nw(e, l, 1, n) - 1
      return s[u](i[u](l))
    }
  }
  function g2(e, t) {
    return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())
  }
  function Cdt() {
    var e = f9,
      t = f9,
      r = ic,
      n,
      i,
      s,
      o = Nf,
      l,
      u,
      h
    function f() {
      var p = Math.min(e.length, t.length)
      return o !== Nf && (o = Tdt(e[0], e[p - 1])), (l = p > 2 ? _dt : Sdt), (u = h = null), d
    }
    a(f, 'rescale')
    function d(p) {
      return p == null || isNaN((p = +p)) ? s : (u || (u = l(e.map(n), t, r)))(n(o(p)))
    }
    return (
      a(d, 'scale'),
      (d.invert = function (p) {
        return o(i((h || (h = l(t, e.map(n), zn)))(p)))
      }),
      (d.domain = function (p) {
        return arguments.length ? ((e = Array.from(p, u3)), f()) : e.slice()
      }),
      (d.range = function (p) {
        return arguments.length ? ((t = Array.from(p)), f()) : t.slice()
      }),
      (d.rangeRound = function (p) {
        return (t = Array.from(p)), (r = qx), f()
      }),
      (d.clamp = function (p) {
        return arguments.length ? ((o = p ? !0 : Nf), f()) : o !== Nf
      }),
      (d.interpolate = function (p) {
        return arguments.length ? ((r = p), f()) : r
      }),
      (d.unknown = function (p) {
        return arguments.length ? ((s = p), d) : s
      }),
      function (p, m) {
        return (n = p), (i = m), f()
      }
    )
  }
  function Fg() {
    return Cdt()(Nf, Nf)
  }
  var f9,
    f3 = x(() => {
      'use strict'
      Jl()
      Ef()
      u9()
      h9()
      f9 = [0, 1]
      a(Nf, 'identity')
      a(h3, 'normalize')
      a(Tdt, 'clamper')
      a(Sdt, 'bimap')
      a(_dt, 'polymap')
      a(g2, 'copy')
      a(Cdt, 'transformer')
      a(Fg, 'continuous')
    })
  function d3(e, t, r, n) {
    var i = gf(e, t, r),
      s
    switch (((n = sc(n ?? ',f')), n.type)) {
      case 's': {
        var o = Math.max(Math.abs(e), Math.abs(t))
        return n.precision == null && !isNaN((s = d2(i, o))) && (n.precision = s), h2(n, o)
      }
      case '':
      case 'e':
      case 'g':
      case 'p':
      case 'r': {
        n.precision == null &&
          !isNaN((s = p2(i, Math.max(Math.abs(e), Math.abs(t))))) &&
          (n.precision = s - (n.type === 'e'))
        break
      }
      case 'f':
      case '%': {
        n.precision == null && !isNaN((s = f2(i))) && (n.precision = s - (n.type === '%') * 2)
        break
      }
    }
    return oo(n)
  }
  var d9 = x(() => {
    'use strict'
    Jl()
    Uv()
    a(d3, 'tickFormat')
  })
  function wdt(e) {
    var t = e.domain
    return (
      (e.ticks = function (r) {
        var n = t()
        return Lx(n[0], n[n.length - 1], r ?? 10)
      }),
      (e.tickFormat = function (r, n) {
        var i = t()
        return d3(i[0], i[i.length - 1], r ?? 10, n)
      }),
      (e.nice = function (r) {
        r == null && (r = 10)
        var n = t(),
          i = 0,
          s = n.length - 1,
          o = n[i],
          l = n[s],
          u,
          h,
          f = 10
        for (l < o && ((h = o), (o = l), (l = h), (h = i), (i = s), (s = h)); f-- > 0; ) {
          if (((h = fg(o, l, r)), h === u)) return (n[i] = o), (n[s] = l), t(n)
          if (h > 0) (o = Math.floor(o / h) * h), (l = Math.ceil(l / h) * h)
          else if (h < 0) (o = Math.ceil(o * h) / h), (l = Math.floor(l * h) / h)
          else break
          u = h
        }
        return e
      }),
      e
    )
  }
  function La() {
    var e = Fg()
    return (
      (e.copy = function () {
        return g2(e, La())
      }),
      ac.apply(e, arguments),
      wdt(e)
    )
  }
  var p9 = x(() => {
    'use strict'
    Jl()
    f3()
    Bg()
    d9()
    a(wdt, 'linearish')
    a(La, 'linear')
  })
  function p3(e, t) {
    e = e.slice()
    var r = 0,
      n = e.length - 1,
      i = e[r],
      s = e[n],
      o
    return s < i && ((o = r), (r = n), (n = o), (o = i), (i = s), (s = o)), (e[r] = t.floor(i)), (e[n] = t.ceil(s)), e
  }
  var m9 = x(() => {
    'use strict'
    a(p3, 'nice')
  })
  function Dr(e, t, r, n) {
    function i(s) {
      return e((s = arguments.length === 0 ? new Date() : new Date(+s))), s
    }
    return (
      a(i, 'interval'),
      (i.floor = (s) => (e((s = new Date(+s))), s)),
      (i.ceil = (s) => (e((s = new Date(s - 1))), t(s, 1), e(s), s)),
      (i.round = (s) => {
        let o = i(s),
          l = i.ceil(s)
        return s - o < l - s ? o : l
      }),
      (i.offset = (s, o) => (t((s = new Date(+s)), o == null ? 1 : Math.floor(o)), s)),
      (i.range = (s, o, l) => {
        let u = []
        if (((s = i.ceil(s)), (l = l == null ? 1 : Math.floor(l)), !(s < o) || !(l > 0))) return u
        let h
        do u.push((h = new Date(+s))), t(s, l), e(s)
        while (h < s && s < o)
        return u
      }),
      (i.filter = (s) =>
        Dr(
          (o) => {
            if (o >= o) for (; e(o), !s(o); ) o.setTime(o - 1)
          },
          (o, l) => {
            if (o >= o)
              if (l < 0) for (; ++l <= 0; ) for (; t(o, -1), !s(o); );
              else for (; --l >= 0; ) for (; t(o, 1), !s(o); );
          },
        )),
      r &&
        ((i.count = (s, o) => (m3.setTime(+s), g3.setTime(+o), e(m3), e(g3), Math.floor(r(m3, g3)))),
        (i.every = (s) => (
          (s = Math.floor(s)),
          !isFinite(s) || !(s > 0)
            ? null
            : s > 1
              ? i.filter(n ? (o) => n(o) % s === 0 : (o) => i.count(0, o) % s === 0)
              : i
        ))),
      i
    )
  }
  var m3,
    g3,
    al = x(() => {
      'use strict'
      ;(m3 = new Date()), (g3 = new Date())
      a(Dr, 'timeInterval')
    })
  var lo,
    g9,
    y3 = x(() => {
      'use strict'
      al()
      lo = Dr(
        () => {},
        (e, t) => {
          e.setTime(+e + t)
        },
        (e, t) => t - e,
      )
      lo.every = (e) => (
        (e = Math.floor(e)),
        !isFinite(e) || !(e > 0)
          ? null
          : e > 1
            ? Dr(
                (t) => {
                  t.setTime(Math.floor(t / e) * e)
                },
                (t, r) => {
                  t.setTime(+t + r * e)
                },
                (t, r) => (r - t) / e,
              )
            : lo
      )
      g9 = lo.range
    })
  var ws,
    y9,
    x3 = x(() => {
      'use strict'
      al()
      ;(ws = Dr(
        (e) => {
          e.setTime(e - e.getMilliseconds())
        },
        (e, t) => {
          e.setTime(+e + t * 1e3)
        },
        (e, t) => (t - e) / 1e3,
        (e) => e.getUTCSeconds(),
      )),
        (y9 = ws.range)
    })
  var ol,
    Edt,
    y2,
    vdt,
    b3 = x(() => {
      'use strict'
      al()
      ;(ol = Dr(
        (e) => {
          e.setTime(e - e.getMilliseconds() - e.getSeconds() * 1e3)
        },
        (e, t) => {
          e.setTime(+e + t * 6e4)
        },
        (e, t) => (t - e) / 6e4,
        (e) => e.getMinutes(),
      )),
        (Edt = ol.range),
        (y2 = Dr(
          (e) => {
            e.setUTCSeconds(0, 0)
          },
          (e, t) => {
            e.setTime(+e + t * 6e4)
          },
          (e, t) => (t - e) / 6e4,
          (e) => e.getUTCMinutes(),
        )),
        (vdt = y2.range)
    })
  var ll,
    Adt,
    x2,
    Ldt,
    k3 = x(() => {
      'use strict'
      al()
      ;(ll = Dr(
        (e) => {
          e.setTime(e - e.getMilliseconds() - e.getSeconds() * 1e3 - e.getMinutes() * 6e4)
        },
        (e, t) => {
          e.setTime(+e + t * 36e5)
        },
        (e, t) => (t - e) / 36e5,
        (e) => e.getHours(),
      )),
        (Adt = ll.range),
        (x2 = Dr(
          (e) => {
            e.setUTCMinutes(0, 0, 0)
          },
          (e, t) => {
            e.setTime(+e + t * 36e5)
          },
          (e, t) => (t - e) / 36e5,
          (e) => e.getUTCHours(),
        )),
        (Ldt = x2.range)
    })
  var Ys,
    Rdt,
    Gg,
    Ddt,
    b2,
    Ndt,
    T3 = x(() => {
      'use strict'
      al()
      ;(Ys = Dr(
        (e) => e.setHours(0, 0, 0, 0),
        (e, t) => e.setDate(e.getDate() + t),
        (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4) / 864e5,
        (e) => e.getDate() - 1,
      )),
        (Rdt = Ys.range),
        (Gg = Dr(
          (e) => {
            e.setUTCHours(0, 0, 0, 0)
          },
          (e, t) => {
            e.setUTCDate(e.getUTCDate() + t)
          },
          (e, t) => (t - e) / 864e5,
          (e) => e.getUTCDate() - 1,
        )),
        (Ddt = Gg.range),
        (b2 = Dr(
          (e) => {
            e.setUTCHours(0, 0, 0, 0)
          },
          (e, t) => {
            e.setUTCDate(e.getUTCDate() + t)
          },
          (e, t) => (t - e) / 864e5,
          (e) => Math.floor(e / 864e5),
        )),
        (Ndt = b2.range)
    })
  function Pu(e) {
    return Dr(
      (t) => {
        t.setDate(t.getDate() - ((t.getDay() + 7 - e) % 7)), t.setHours(0, 0, 0, 0)
      },
      (t, r) => {
        t.setDate(t.getDate() + r * 7)
      },
      (t, r) => (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * 6e4) / 6048e5,
    )
  }
  function Bu(e) {
    return Dr(
      (t) => {
        t.setUTCDate(t.getUTCDate() - ((t.getUTCDay() + 7 - e) % 7)), t.setUTCHours(0, 0, 0, 0)
      },
      (t, r) => {
        t.setUTCDate(t.getUTCDate() + r * 7)
      },
      (t, r) => (r - t) / 6048e5,
    )
  }
  var Ra,
    oc,
    k2,
    T2,
    uo,
    S2,
    _2,
    b9,
    Idt,
    Mdt,
    Odt,
    Pdt,
    Bdt,
    Fdt,
    Fu,
    If,
    k9,
    T9,
    lc,
    S9,
    _9,
    C9,
    $dt,
    Gdt,
    Vdt,
    zdt,
    Wdt,
    Udt,
    S3 = x(() => {
      'use strict'
      al()
      a(Pu, 'timeWeekday')
      ;(Ra = Pu(0)),
        (oc = Pu(1)),
        (k2 = Pu(2)),
        (T2 = Pu(3)),
        (uo = Pu(4)),
        (S2 = Pu(5)),
        (_2 = Pu(6)),
        (b9 = Ra.range),
        (Idt = oc.range),
        (Mdt = k2.range),
        (Odt = T2.range),
        (Pdt = uo.range),
        (Bdt = S2.range),
        (Fdt = _2.range)
      a(Bu, 'utcWeekday')
      ;(Fu = Bu(0)),
        (If = Bu(1)),
        (k9 = Bu(2)),
        (T9 = Bu(3)),
        (lc = Bu(4)),
        (S9 = Bu(5)),
        (_9 = Bu(6)),
        (C9 = Fu.range),
        ($dt = If.range),
        (Gdt = k9.range),
        (Vdt = T9.range),
        (zdt = lc.range),
        (Wdt = S9.range),
        (Udt = _9.range)
    })
  var cl,
    jdt,
    C2,
    qdt,
    _3 = x(() => {
      'use strict'
      al()
      ;(cl = Dr(
        (e) => {
          e.setDate(1), e.setHours(0, 0, 0, 0)
        },
        (e, t) => {
          e.setMonth(e.getMonth() + t)
        },
        (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12,
        (e) => e.getMonth(),
      )),
        (jdt = cl.range),
        (C2 = Dr(
          (e) => {
            e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
          },
          (e, t) => {
            e.setUTCMonth(e.getUTCMonth() + t)
          },
          (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12,
          (e) => e.getUTCMonth(),
        )),
        (qdt = C2.range)
    })
  var Es,
    Hdt,
    Da,
    Ydt,
    C3 = x(() => {
      'use strict'
      al()
      Es = Dr(
        (e) => {
          e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
        },
        (e, t) => {
          e.setFullYear(e.getFullYear() + t)
        },
        (e, t) => t.getFullYear() - e.getFullYear(),
        (e) => e.getFullYear(),
      )
      Es.every = (e) =>
        !isFinite((e = Math.floor(e))) || !(e > 0)
          ? null
          : Dr(
              (t) => {
                t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
              },
              (t, r) => {
                t.setFullYear(t.getFullYear() + r * e)
              },
            )
      ;(Hdt = Es.range),
        (Da = Dr(
          (e) => {
            e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
          },
          (e, t) => {
            e.setUTCFullYear(e.getUTCFullYear() + t)
          },
          (e, t) => t.getUTCFullYear() - e.getUTCFullYear(),
          (e) => e.getUTCFullYear(),
        ))
      Da.every = (e) =>
        !isFinite((e = Math.floor(e))) || !(e > 0)
          ? null
          : Dr(
              (t) => {
                t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
              },
              (t, r) => {
                t.setUTCFullYear(t.getUTCFullYear() + r * e)
              },
            )
      Ydt = Da.range
    })
  function E9(e, t, r, n, i, s) {
    let o = [
      [ws, 1, 1e3],
      [ws, 5, 5 * 1e3],
      [ws, 15, 15 * 1e3],
      [ws, 30, 30 * 1e3],
      [s, 1, 6e4],
      [s, 5, 5 * 6e4],
      [s, 15, 15 * 6e4],
      [s, 30, 30 * 6e4],
      [i, 1, 36e5],
      [i, 3, 3 * 36e5],
      [i, 6, 6 * 36e5],
      [i, 12, 12 * 36e5],
      [n, 1, 864e5],
      [n, 2, 2 * 864e5],
      [r, 1, 6048e5],
      [t, 1, 2592e6],
      [t, 3, 3 * 2592e6],
      [e, 1, 31536e6],
    ]
    function l(h, f, d) {
      let p = f < h
      p && ([h, f] = [f, h])
      let m = d && typeof d.range == 'function' ? d : u(h, f, d),
        g = m ? m.range(h, +f + 1) : []
      return p ? g.reverse() : g
    }
    a(l, 'ticks')
    function u(h, f, d) {
      let p = Math.abs(f - h) / d,
        m = Cu(([, , b]) => b).right(o, p)
      if (m === o.length) return e.every(gf(h / 31536e6, f / 31536e6, d))
      if (m === 0) return lo.every(Math.max(gf(h, f, d), 1))
      let [g, y] = o[p / o[m - 1][2] < o[m][2] / p ? m - 1 : m]
      return g.every(y)
    }
    return a(u, 'tickInterval'), [l, u]
  }
  var Kdt,
    Qdt,
    w3,
    E3,
    v9 = x(() => {
      'use strict'
      Jl()
      y3()
      x3()
      b3()
      k3()
      T3()
      S3()
      _3()
      C3()
      a(E9, 'ticker')
      ;([Kdt, Qdt] = E9(Da, C2, Fu, b2, x2, y2)), ([w3, E3] = E9(Es, cl, Ra, Ys, ll, ol))
    })
  var w2 = x(() => {
    'use strict'
    y3()
    x3()
    b3()
    k3()
    T3()
    S3()
    _3()
    C3()
    v9()
  })
  function v3(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L)
      return t.setFullYear(e.y), t
    }
    return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
  }
  function A3(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L))
      return t.setUTCFullYear(e.y), t
    }
    return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
  }
  function Vg(e, t, r) {
    return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 }
  }
  function L3(e) {
    var t = e.dateTime,
      r = e.date,
      n = e.time,
      i = e.periods,
      s = e.days,
      o = e.shortDays,
      l = e.months,
      u = e.shortMonths,
      h = zg(i),
      f = Wg(i),
      d = zg(s),
      p = Wg(s),
      m = zg(o),
      g = Wg(o),
      y = zg(l),
      b = Wg(l),
      k = zg(u),
      T = Wg(u),
      C = {
        a: P,
        A: I,
        b: M,
        B: V,
        c: null,
        d: I9,
        e: I9,
        f: kpt,
        g: Rpt,
        G: Npt,
        H: ypt,
        I: xpt,
        j: bpt,
        L: F9,
        m: Tpt,
        M: Spt,
        p: $,
        q,
        Q: P9,
        s: B9,
        S: _pt,
        u: Cpt,
        U: wpt,
        V: Ept,
        w: vpt,
        W: Apt,
        x: null,
        X: null,
        y: Lpt,
        Y: Dpt,
        Z: Ipt,
        '%': O9,
      },
      A = {
        a: tt,
        A: ft,
        b: H,
        B: kt,
        c: null,
        d: M9,
        e: M9,
        f: Bpt,
        g: Hpt,
        G: Xpt,
        H: Mpt,
        I: Opt,
        j: Ppt,
        L: G9,
        m: Fpt,
        M: $pt,
        p: ht,
        q: yt,
        Q: P9,
        s: B9,
        S: Gpt,
        u: Vpt,
        U: zpt,
        V: Wpt,
        w: Upt,
        W: jpt,
        x: null,
        X: null,
        y: qpt,
        Y: Ypt,
        Z: Kpt,
        '%': O9,
      },
      w = {
        a: F,
        A: S,
        b: O,
        B: E,
        c: _,
        d: D9,
        e: D9,
        f: dpt,
        g: R9,
        G: L9,
        H: N9,
        I: N9,
        j: cpt,
        L: fpt,
        m: lpt,
        M: upt,
        p: R,
        q: opt,
        Q: mpt,
        s: gpt,
        S: hpt,
        u: rpt,
        U: npt,
        V: ipt,
        w: ept,
        W: spt,
        x: L,
        X: N,
        y: R9,
        Y: L9,
        Z: apt,
        '%': ppt,
      }
    ;(C.x = D(r, C)), (C.X = D(n, C)), (C.c = D(t, C)), (A.x = D(r, A)), (A.X = D(n, A)), (A.c = D(t, A))
    function D(ot, dt) {
      return function (it) {
        var Q = [],
          et = -1,
          X = 0,
          st = ot.length,
          U,
          gt,
          z
        for (it instanceof Date || (it = new Date(+it)); ++et < st; )
          ot.charCodeAt(et) === 37 &&
            (Q.push(ot.slice(X, et)),
            (gt = A9[(U = ot.charAt(++et))]) != null ? (U = ot.charAt(++et)) : (gt = U === 'e' ? ' ' : '0'),
            (z = dt[U]) && (U = z(it, gt)),
            Q.push(U),
            (X = et + 1))
        return Q.push(ot.slice(X, et)), Q.join('')
      }
    }
    a(D, 'newFormat')
    function G(ot, dt) {
      return function (it) {
        var Q = Vg(1900, void 0, 1),
          et = v(Q, ot, (it += ''), 0),
          X,
          st
        if (et != it.length) return null
        if ('Q' in Q) return new Date(Q.Q)
        if ('s' in Q) return new Date(Q.s * 1e3 + ('L' in Q ? Q.L : 0))
        if (
          (dt && !('Z' in Q) && (Q.Z = 0),
          'p' in Q && (Q.H = (Q.H % 12) + Q.p * 12),
          Q.m === void 0 && (Q.m = 'q' in Q ? Q.q : 0),
          'V' in Q)
        ) {
          if (Q.V < 1 || Q.V > 53) return null
          'w' in Q || (Q.w = 1),
            'Z' in Q
              ? ((X = A3(Vg(Q.y, 0, 1))),
                (st = X.getUTCDay()),
                (X = st > 4 || st === 0 ? If.ceil(X) : If(X)),
                (X = Gg.offset(X, (Q.V - 1) * 7)),
                (Q.y = X.getUTCFullYear()),
                (Q.m = X.getUTCMonth()),
                (Q.d = X.getUTCDate() + ((Q.w + 6) % 7)))
              : ((X = v3(Vg(Q.y, 0, 1))),
                (st = X.getDay()),
                (X = st > 4 || st === 0 ? oc.ceil(X) : oc(X)),
                (X = Ys.offset(X, (Q.V - 1) * 7)),
                (Q.y = X.getFullYear()),
                (Q.m = X.getMonth()),
                (Q.d = X.getDate() + ((Q.w + 6) % 7)))
        } else
          ('W' in Q || 'U' in Q) &&
            ('w' in Q || (Q.w = 'u' in Q ? Q.u % 7 : 'W' in Q ? 1 : 0),
            (st = 'Z' in Q ? A3(Vg(Q.y, 0, 1)).getUTCDay() : v3(Vg(Q.y, 0, 1)).getDay()),
            (Q.m = 0),
            (Q.d = 'W' in Q ? ((Q.w + 6) % 7) + Q.W * 7 - ((st + 5) % 7) : Q.w + Q.U * 7 - ((st + 6) % 7)))
        return 'Z' in Q ? ((Q.H += (Q.Z / 100) | 0), (Q.M += Q.Z % 100), A3(Q)) : v3(Q)
      }
    }
    a(G, 'newParse')
    function v(ot, dt, it, Q) {
      for (var et = 0, X = dt.length, st = it.length, U, gt; et < X; ) {
        if (Q >= st) return -1
        if (((U = dt.charCodeAt(et++)), U === 37)) {
          if (((U = dt.charAt(et++)), (gt = w[U in A9 ? dt.charAt(et++) : U]), !gt || (Q = gt(ot, it, Q)) < 0))
            return -1
        } else if (U != it.charCodeAt(Q++)) return -1
      }
      return Q
    }
    a(v, 'parseSpecifier')
    function R(ot, dt, it) {
      var Q = h.exec(dt.slice(it))
      return Q ? ((ot.p = f.get(Q[0].toLowerCase())), it + Q[0].length) : -1
    }
    a(R, 'parsePeriod')
    function F(ot, dt, it) {
      var Q = m.exec(dt.slice(it))
      return Q ? ((ot.w = g.get(Q[0].toLowerCase())), it + Q[0].length) : -1
    }
    a(F, 'parseShortWeekday')
    function S(ot, dt, it) {
      var Q = d.exec(dt.slice(it))
      return Q ? ((ot.w = p.get(Q[0].toLowerCase())), it + Q[0].length) : -1
    }
    a(S, 'parseWeekday')
    function O(ot, dt, it) {
      var Q = k.exec(dt.slice(it))
      return Q ? ((ot.m = T.get(Q[0].toLowerCase())), it + Q[0].length) : -1
    }
    a(O, 'parseShortMonth')
    function E(ot, dt, it) {
      var Q = y.exec(dt.slice(it))
      return Q ? ((ot.m = b.get(Q[0].toLowerCase())), it + Q[0].length) : -1
    }
    a(E, 'parseMonth')
    function _(ot, dt, it) {
      return v(ot, t, dt, it)
    }
    a(_, 'parseLocaleDateTime')
    function L(ot, dt, it) {
      return v(ot, r, dt, it)
    }
    a(L, 'parseLocaleDate')
    function N(ot, dt, it) {
      return v(ot, n, dt, it)
    }
    a(N, 'parseLocaleTime')
    function P(ot) {
      return o[ot.getDay()]
    }
    a(P, 'formatShortWeekday')
    function I(ot) {
      return s[ot.getDay()]
    }
    a(I, 'formatWeekday')
    function M(ot) {
      return u[ot.getMonth()]
    }
    a(M, 'formatShortMonth')
    function V(ot) {
      return l[ot.getMonth()]
    }
    a(V, 'formatMonth')
    function $(ot) {
      return i[+(ot.getHours() >= 12)]
    }
    a($, 'formatPeriod')
    function q(ot) {
      return 1 + ~~(ot.getMonth() / 3)
    }
    a(q, 'formatQuarter')
    function tt(ot) {
      return o[ot.getUTCDay()]
    }
    a(tt, 'formatUTCShortWeekday')
    function ft(ot) {
      return s[ot.getUTCDay()]
    }
    a(ft, 'formatUTCWeekday')
    function H(ot) {
      return u[ot.getUTCMonth()]
    }
    a(H, 'formatUTCShortMonth')
    function kt(ot) {
      return l[ot.getUTCMonth()]
    }
    a(kt, 'formatUTCMonth')
    function ht(ot) {
      return i[+(ot.getUTCHours() >= 12)]
    }
    a(ht, 'formatUTCPeriod')
    function yt(ot) {
      return 1 + ~~(ot.getUTCMonth() / 3)
    }
    return (
      a(yt, 'formatUTCQuarter'),
      {
        format: a(function (ot) {
          var dt = D((ot += ''), C)
          return (
            (dt.toString = function () {
              return ot
            }),
            dt
          )
        }, 'format'),
        parse: a(function (ot) {
          var dt = G((ot += ''), !1)
          return (
            (dt.toString = function () {
              return ot
            }),
            dt
          )
        }, 'parse'),
        utcFormat: a(function (ot) {
          var dt = D((ot += ''), A)
          return (
            (dt.toString = function () {
              return ot
            }),
            dt
          )
        }, 'utcFormat'),
        utcParse: a(function (ot) {
          var dt = G((ot += ''), !0)
          return (
            (dt.toString = function () {
              return ot
            }),
            dt
          )
        }, 'utcParse'),
      }
    )
  }
  function fr(e, t, r) {
    var n = e < 0 ? '-' : '',
      i = (n ? -e : e) + '',
      s = i.length
    return n + (s < r ? new Array(r - s + 1).join(t) + i : i)
  }
  function tpt(e) {
    return e.replace(Jdt, '\\$&')
  }
  function zg(e) {
    return new RegExp('^(?:' + e.map(tpt).join('|') + ')', 'i')
  }
  function Wg(e) {
    return new Map(e.map((t, r) => [t.toLowerCase(), r]))
  }
  function ept(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1))
    return n ? ((e.w = +n[0]), r + n[0].length) : -1
  }
  function rpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1))
    return n ? ((e.u = +n[0]), r + n[0].length) : -1
  }
  function npt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.U = +n[0]), r + n[0].length) : -1
  }
  function ipt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.V = +n[0]), r + n[0].length) : -1
  }
  function spt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.W = +n[0]), r + n[0].length) : -1
  }
  function L9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 4))
    return n ? ((e.y = +n[0]), r + n[0].length) : -1
  }
  function R9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3)), r + n[0].length) : -1
  }
  function apt(e, t, r) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6))
    return n ? ((e.Z = n[1] ? 0 : -(n[2] + (n[3] || '00'))), r + n[0].length) : -1
  }
  function opt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1))
    return n ? ((e.q = n[0] * 3 - 3), r + n[0].length) : -1
  }
  function lpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.m = n[0] - 1), r + n[0].length) : -1
  }
  function D9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.d = +n[0]), r + n[0].length) : -1
  }
  function cpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 3))
    return n ? ((e.m = 0), (e.d = +n[0]), r + n[0].length) : -1
  }
  function N9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.H = +n[0]), r + n[0].length) : -1
  }
  function upt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.M = +n[0]), r + n[0].length) : -1
  }
  function hpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2))
    return n ? ((e.S = +n[0]), r + n[0].length) : -1
  }
  function fpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 3))
    return n ? ((e.L = +n[0]), r + n[0].length) : -1
  }
  function dpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 6))
    return n ? ((e.L = Math.floor(n[0] / 1e3)), r + n[0].length) : -1
  }
  function ppt(e, t, r) {
    var n = Zdt.exec(t.slice(r, r + 1))
    return n ? r + n[0].length : -1
  }
  function mpt(e, t, r) {
    var n = Wn.exec(t.slice(r))
    return n ? ((e.Q = +n[0]), r + n[0].length) : -1
  }
  function gpt(e, t, r) {
    var n = Wn.exec(t.slice(r))
    return n ? ((e.s = +n[0]), r + n[0].length) : -1
  }
  function I9(e, t) {
    return fr(e.getDate(), t, 2)
  }
  function ypt(e, t) {
    return fr(e.getHours(), t, 2)
  }
  function xpt(e, t) {
    return fr(e.getHours() % 12 || 12, t, 2)
  }
  function bpt(e, t) {
    return fr(1 + Ys.count(Es(e), e), t, 3)
  }
  function F9(e, t) {
    return fr(e.getMilliseconds(), t, 3)
  }
  function kpt(e, t) {
    return F9(e, t) + '000'
  }
  function Tpt(e, t) {
    return fr(e.getMonth() + 1, t, 2)
  }
  function Spt(e, t) {
    return fr(e.getMinutes(), t, 2)
  }
  function _pt(e, t) {
    return fr(e.getSeconds(), t, 2)
  }
  function Cpt(e) {
    var t = e.getDay()
    return t === 0 ? 7 : t
  }
  function wpt(e, t) {
    return fr(Ra.count(Es(e) - 1, e), t, 2)
  }
  function $9(e) {
    var t = e.getDay()
    return t >= 4 || t === 0 ? uo(e) : uo.ceil(e)
  }
  function Ept(e, t) {
    return (e = $9(e)), fr(uo.count(Es(e), e) + (Es(e).getDay() === 4), t, 2)
  }
  function vpt(e) {
    return e.getDay()
  }
  function Apt(e, t) {
    return fr(oc.count(Es(e) - 1, e), t, 2)
  }
  function Lpt(e, t) {
    return fr(e.getFullYear() % 100, t, 2)
  }
  function Rpt(e, t) {
    return (e = $9(e)), fr(e.getFullYear() % 100, t, 2)
  }
  function Dpt(e, t) {
    return fr(e.getFullYear() % 1e4, t, 4)
  }
  function Npt(e, t) {
    var r = e.getDay()
    return (e = r >= 4 || r === 0 ? uo(e) : uo.ceil(e)), fr(e.getFullYear() % 1e4, t, 4)
  }
  function Ipt(e) {
    var t = e.getTimezoneOffset()
    return (t > 0 ? '-' : ((t *= -1), '+')) + fr((t / 60) | 0, '0', 2) + fr(t % 60, '0', 2)
  }
  function M9(e, t) {
    return fr(e.getUTCDate(), t, 2)
  }
  function Mpt(e, t) {
    return fr(e.getUTCHours(), t, 2)
  }
  function Opt(e, t) {
    return fr(e.getUTCHours() % 12 || 12, t, 2)
  }
  function Ppt(e, t) {
    return fr(1 + Gg.count(Da(e), e), t, 3)
  }
  function G9(e, t) {
    return fr(e.getUTCMilliseconds(), t, 3)
  }
  function Bpt(e, t) {
    return G9(e, t) + '000'
  }
  function Fpt(e, t) {
    return fr(e.getUTCMonth() + 1, t, 2)
  }
  function $pt(e, t) {
    return fr(e.getUTCMinutes(), t, 2)
  }
  function Gpt(e, t) {
    return fr(e.getUTCSeconds(), t, 2)
  }
  function Vpt(e) {
    var t = e.getUTCDay()
    return t === 0 ? 7 : t
  }
  function zpt(e, t) {
    return fr(Fu.count(Da(e) - 1, e), t, 2)
  }
  function V9(e) {
    var t = e.getUTCDay()
    return t >= 4 || t === 0 ? lc(e) : lc.ceil(e)
  }
  function Wpt(e, t) {
    return (e = V9(e)), fr(lc.count(Da(e), e) + (Da(e).getUTCDay() === 4), t, 2)
  }
  function Upt(e) {
    return e.getUTCDay()
  }
  function jpt(e, t) {
    return fr(If.count(Da(e) - 1, e), t, 2)
  }
  function qpt(e, t) {
    return fr(e.getUTCFullYear() % 100, t, 2)
  }
  function Hpt(e, t) {
    return (e = V9(e)), fr(e.getUTCFullYear() % 100, t, 2)
  }
  function Ypt(e, t) {
    return fr(e.getUTCFullYear() % 1e4, t, 4)
  }
  function Xpt(e, t) {
    var r = e.getUTCDay()
    return (e = r >= 4 || r === 0 ? lc(e) : lc.ceil(e)), fr(e.getUTCFullYear() % 1e4, t, 4)
  }
  function Kpt() {
    return '+0000'
  }
  function O9() {
    return '%'
  }
  function P9(e) {
    return +e
  }
  function B9(e) {
    return Math.floor(+e / 1e3)
  }
  var A9,
    Wn,
    Zdt,
    Jdt,
    z9 = x(() => {
      'use strict'
      w2()
      a(v3, 'localDate')
      a(A3, 'utcDate')
      a(Vg, 'newDate')
      a(L3, 'formatLocale')
      ;(A9 = { '-': '', _: ' ', 0: '0' }), (Wn = /^\s*\d+/), (Zdt = /^%/), (Jdt = /[\\^$*+?|[\]().{}]/g)
      a(fr, 'pad')
      a(tpt, 'requote')
      a(zg, 'formatRe')
      a(Wg, 'formatLookup')
      a(ept, 'parseWeekdayNumberSunday')
      a(rpt, 'parseWeekdayNumberMonday')
      a(npt, 'parseWeekNumberSunday')
      a(ipt, 'parseWeekNumberISO')
      a(spt, 'parseWeekNumberMonday')
      a(L9, 'parseFullYear')
      a(R9, 'parseYear')
      a(apt, 'parseZone')
      a(opt, 'parseQuarter')
      a(lpt, 'parseMonthNumber')
      a(D9, 'parseDayOfMonth')
      a(cpt, 'parseDayOfYear')
      a(N9, 'parseHour24')
      a(upt, 'parseMinutes')
      a(hpt, 'parseSeconds')
      a(fpt, 'parseMilliseconds')
      a(dpt, 'parseMicroseconds')
      a(ppt, 'parseLiteralPercent')
      a(mpt, 'parseUnixTimestamp')
      a(gpt, 'parseUnixTimestampSeconds')
      a(I9, 'formatDayOfMonth')
      a(ypt, 'formatHour24')
      a(xpt, 'formatHour12')
      a(bpt, 'formatDayOfYear')
      a(F9, 'formatMilliseconds')
      a(kpt, 'formatMicroseconds')
      a(Tpt, 'formatMonthNumber')
      a(Spt, 'formatMinutes')
      a(_pt, 'formatSeconds')
      a(Cpt, 'formatWeekdayNumberMonday')
      a(wpt, 'formatWeekNumberSunday')
      a($9, 'dISO')
      a(Ept, 'formatWeekNumberISO')
      a(vpt, 'formatWeekdayNumberSunday')
      a(Apt, 'formatWeekNumberMonday')
      a(Lpt, 'formatYear')
      a(Rpt, 'formatYearISO')
      a(Dpt, 'formatFullYear')
      a(Npt, 'formatFullYearISO')
      a(Ipt, 'formatZone')
      a(M9, 'formatUTCDayOfMonth')
      a(Mpt, 'formatUTCHour24')
      a(Opt, 'formatUTCHour12')
      a(Ppt, 'formatUTCDayOfYear')
      a(G9, 'formatUTCMilliseconds')
      a(Bpt, 'formatUTCMicroseconds')
      a(Fpt, 'formatUTCMonthNumber')
      a($pt, 'formatUTCMinutes')
      a(Gpt, 'formatUTCSeconds')
      a(Vpt, 'formatUTCWeekdayNumberMonday')
      a(zpt, 'formatUTCWeekNumberSunday')
      a(V9, 'UTCdISO')
      a(Wpt, 'formatUTCWeekNumberISO')
      a(Upt, 'formatUTCWeekdayNumberSunday')
      a(jpt, 'formatUTCWeekNumberMonday')
      a(qpt, 'formatUTCYear')
      a(Hpt, 'formatUTCYearISO')
      a(Ypt, 'formatUTCFullYear')
      a(Xpt, 'formatUTCFullYearISO')
      a(Kpt, 'formatUTCZone')
      a(O9, 'formatLiteralPercent')
      a(P9, 'formatUnixTimestamp')
      a(B9, 'formatUnixTimestampSeconds')
    })
  function R3(e) {
    return (Mf = L3(e)), ($u = Mf.format), (W9 = Mf.parse), (U9 = Mf.utcFormat), (j9 = Mf.utcParse), Mf
  }
  var Mf,
    $u,
    W9,
    U9,
    j9,
    q9 = x(() => {
      'use strict'
      z9()
      R3({
        dateTime: '%x, %X',
        date: '%-m/%-d/%Y',
        time: '%-I:%M:%S %p',
        periods: ['AM', 'PM'],
        days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        months: [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December',
        ],
        shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      })
      a(R3, 'defaultLocale')
    })
  var D3 = x(() => {
    'use strict'
    q9()
  })
  function Qpt(e) {
    return new Date(e)
  }
  function Zpt(e) {
    return e instanceof Date ? +e : +new Date(+e)
  }
  function H9(e, t, r, n, i, s, o, l, u, h) {
    var f = Fg(),
      d = f.invert,
      p = f.domain,
      m = h('.%L'),
      g = h(':%S'),
      y = h('%I:%M'),
      b = h('%I %p'),
      k = h('%a %d'),
      T = h('%b %d'),
      C = h('%B'),
      A = h('%Y')
    function w(D) {
      return (
        u(D) < D ? m : l(D) < D ? g : o(D) < D ? y : s(D) < D ? b : n(D) < D ? (i(D) < D ? k : T) : r(D) < D ? C : A
      )(D)
    }
    return (
      a(w, 'tickFormat'),
      (f.invert = function (D) {
        return new Date(d(D))
      }),
      (f.domain = function (D) {
        return arguments.length ? p(Array.from(D, Zpt)) : p().map(Qpt)
      }),
      (f.ticks = function (D) {
        var G = p()
        return e(G[0], G[G.length - 1], D ?? 10)
      }),
      (f.tickFormat = function (D, G) {
        return G == null ? w : h(G)
      }),
      (f.nice = function (D) {
        var G = p()
        return (!D || typeof D.range != 'function') && (D = t(G[0], G[G.length - 1], D ?? 10)), D ? p(p3(G, D)) : f
      }),
      (f.copy = function () {
        return g2(f, H9(e, t, r, n, i, s, o, l, u, h))
      }),
      f
    )
  }
  function E2() {
    return ac.apply(
      H9(w3, E3, Es, cl, Ra, Ys, ll, ol, ws, $u).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),
      arguments,
    )
  }
  var Y9 = x(() => {
    'use strict'
    w2()
    D3()
    f3()
    Bg()
    m9()
    a(Qpt, 'date')
    a(Zpt, 'number')
    a(H9, 'calendar')
    a(E2, 'time')
  })
  var X9 = x(() => {
    'use strict'
    c9()
    p9()
    l3()
    Y9()
  })
  function N3(e) {
    for (var t = (e.length / 6) | 0, r = new Array(t), n = 0; n < t; ) r[n] = '#' + e.slice(n * 6, ++n * 6)
    return r
  }
  var K9 = x(() => {
    'use strict'
    a(N3, 'default')
  })
  var I3,
    Q9 = x(() => {
      'use strict'
      K9()
      I3 = N3('4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab')
    })
  var Z9 = x(() => {
    'use strict'
    Q9()
  })
  function Hr(e) {
    return a(function () {
      return e
    }, 'constant')
  }
  var v2 = x(() => {
    'use strict'
    a(Hr, 'default')
  })
  function tB(e) {
    return e > 1 ? 0 : e < -1 ? Of : Math.acos(e)
  }
  function O3(e) {
    return e >= 1 ? Ug : e <= -1 ? -Ug : Math.asin(e)
  }
  var M3,
    ei,
    cc,
    J9,
    A2,
    Na,
    Gu,
    Un,
    Of,
    Ug,
    Pf,
    L2 = x(() => {
      'use strict'
      ;(M3 = Math.abs),
        (ei = Math.atan2),
        (cc = Math.cos),
        (J9 = Math.max),
        (A2 = Math.min),
        (Na = Math.sin),
        (Gu = Math.sqrt),
        (Un = 1e-12),
        (Of = Math.PI),
        (Ug = Of / 2),
        (Pf = 2 * Of)
      a(tB, 'acos')
      a(O3, 'asin')
    })
  function R2(e) {
    let t = 3
    return (
      (e.digits = function (r) {
        if (!arguments.length) return t
        if (r == null) t = null
        else {
          let n = Math.floor(r)
          if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`)
          t = n
        }
        return e
      }),
      () => new Du(t)
    )
  }
  var P3 = x(() => {
    'use strict'
    Nv()
    a(R2, 'withPath')
  })
  function Jpt(e) {
    return e.innerRadius
  }
  function tmt(e) {
    return e.outerRadius
  }
  function emt(e) {
    return e.startAngle
  }
  function rmt(e) {
    return e.endAngle
  }
  function nmt(e) {
    return e && e.padAngle
  }
  function imt(e, t, r, n, i, s, o, l) {
    var u = r - e,
      h = n - t,
      f = o - i,
      d = l - s,
      p = d * u - f * h
    if (!(p * p < Un)) return (p = (f * (t - s) - d * (e - i)) / p), [e + p * u, t + p * h]
  }
  function D2(e, t, r, n, i, s, o) {
    var l = e - r,
      u = t - n,
      h = (o ? s : -s) / Gu(l * l + u * u),
      f = h * u,
      d = -h * l,
      p = e + f,
      m = t + d,
      g = r + f,
      y = n + d,
      b = (p + g) / 2,
      k = (m + y) / 2,
      T = g - p,
      C = y - m,
      A = T * T + C * C,
      w = i - s,
      D = p * y - g * m,
      G = (C < 0 ? -1 : 1) * Gu(J9(0, w * w * A - D * D)),
      v = (D * C - T * G) / A,
      R = (-D * T - C * G) / A,
      F = (D * C + T * G) / A,
      S = (-D * T + C * G) / A,
      O = v - b,
      E = R - k,
      _ = F - b,
      L = S - k
    return (
      O * O + E * E > _ * _ + L * L && ((v = F), (R = S)),
      { cx: v, cy: R, x01: -f, y01: -d, x11: v * (i / w - 1), y11: R * (i / w - 1) }
    )
  }
  function Ia() {
    var e = Jpt,
      t = tmt,
      r = Hr(0),
      n = null,
      i = emt,
      s = rmt,
      o = nmt,
      l = null,
      u = R2(h)
    function h() {
      var f,
        d,
        p = +e.apply(this, arguments),
        m = +t.apply(this, arguments),
        g = i.apply(this, arguments) - Ug,
        y = s.apply(this, arguments) - Ug,
        b = M3(y - g),
        k = y > g
      if ((l || (l = f = u()), m < p && ((d = m), (m = p), (p = d)), !(m > Un))) l.moveTo(0, 0)
      else if (b > Pf - Un)
        l.moveTo(m * cc(g), m * Na(g)),
          l.arc(0, 0, m, g, y, !k),
          p > Un && (l.moveTo(p * cc(y), p * Na(y)), l.arc(0, 0, p, y, g, k))
      else {
        var T = g,
          C = y,
          A = g,
          w = y,
          D = b,
          G = b,
          v = o.apply(this, arguments) / 2,
          R = v > Un && (n ? +n.apply(this, arguments) : Gu(p * p + m * m)),
          F = A2(M3(m - p) / 2, +r.apply(this, arguments)),
          S = F,
          O = F,
          E,
          _
        if (R > Un) {
          var L = O3((R / p) * Na(v)),
            N = O3((R / m) * Na(v))
          ;(D -= L * 2) > Un ? ((L *= k ? 1 : -1), (A += L), (w -= L)) : ((D = 0), (A = w = (g + y) / 2)),
            (G -= N * 2) > Un ? ((N *= k ? 1 : -1), (T += N), (C -= N)) : ((G = 0), (T = C = (g + y) / 2))
        }
        var P = m * cc(T),
          I = m * Na(T),
          M = p * cc(w),
          V = p * Na(w)
        if (F > Un) {
          var $ = m * cc(C),
            q = m * Na(C),
            tt = p * cc(A),
            ft = p * Na(A),
            H
          if (b < Of)
            if ((H = imt(P, I, tt, ft, $, q, M, V))) {
              var kt = P - H[0],
                ht = I - H[1],
                yt = $ - H[0],
                ot = q - H[1],
                dt = 1 / Na(tB((kt * yt + ht * ot) / (Gu(kt * kt + ht * ht) * Gu(yt * yt + ot * ot))) / 2),
                it = Gu(H[0] * H[0] + H[1] * H[1])
              ;(S = A2(F, (p - it) / (dt - 1))), (O = A2(F, (m - it) / (dt + 1)))
            } else S = O = 0
        }
        G > Un
          ? O > Un
            ? ((E = D2(tt, ft, P, I, m, O, k)),
              (_ = D2($, q, M, V, m, O, k)),
              l.moveTo(E.cx + E.x01, E.cy + E.y01),
              O < F
                ? l.arc(E.cx, E.cy, O, ei(E.y01, E.x01), ei(_.y01, _.x01), !k)
                : (l.arc(E.cx, E.cy, O, ei(E.y01, E.x01), ei(E.y11, E.x11), !k),
                  l.arc(0, 0, m, ei(E.cy + E.y11, E.cx + E.x11), ei(_.cy + _.y11, _.cx + _.x11), !k),
                  l.arc(_.cx, _.cy, O, ei(_.y11, _.x11), ei(_.y01, _.x01), !k)))
            : (l.moveTo(P, I), l.arc(0, 0, m, T, C, !k))
          : l.moveTo(P, I),
          !(p > Un) || !(D > Un)
            ? l.lineTo(M, V)
            : S > Un
              ? ((E = D2(M, V, $, q, p, -S, k)),
                (_ = D2(P, I, tt, ft, p, -S, k)),
                l.lineTo(E.cx + E.x01, E.cy + E.y01),
                S < F
                  ? l.arc(E.cx, E.cy, S, ei(E.y01, E.x01), ei(_.y01, _.x01), !k)
                  : (l.arc(E.cx, E.cy, S, ei(E.y01, E.x01), ei(E.y11, E.x11), !k),
                    l.arc(0, 0, p, ei(E.cy + E.y11, E.cx + E.x11), ei(_.cy + _.y11, _.cx + _.x11), k),
                    l.arc(_.cx, _.cy, S, ei(_.y11, _.x11), ei(_.y01, _.x01), !k)))
              : l.arc(0, 0, p, w, A, k)
      }
      if ((l.closePath(), f)) return (l = null), f + '' || null
    }
    return (
      a(h, 'arc'),
      (h.centroid = function () {
        var f = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
          d = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Of / 2
        return [cc(d) * f, Na(d) * f]
      }),
      (h.innerRadius = function (f) {
        return arguments.length ? ((e = typeof f == 'function' ? f : Hr(+f)), h) : e
      }),
      (h.outerRadius = function (f) {
        return arguments.length ? ((t = typeof f == 'function' ? f : Hr(+f)), h) : t
      }),
      (h.cornerRadius = function (f) {
        return arguments.length ? ((r = typeof f == 'function' ? f : Hr(+f)), h) : r
      }),
      (h.padRadius = function (f) {
        return arguments.length ? ((n = f == null ? null : typeof f == 'function' ? f : Hr(+f)), h) : n
      }),
      (h.startAngle = function (f) {
        return arguments.length ? ((i = typeof f == 'function' ? f : Hr(+f)), h) : i
      }),
      (h.endAngle = function (f) {
        return arguments.length ? ((s = typeof f == 'function' ? f : Hr(+f)), h) : s
      }),
      (h.padAngle = function (f) {
        return arguments.length ? ((o = typeof f == 'function' ? f : Hr(+f)), h) : o
      }),
      (h.context = function (f) {
        return arguments.length ? ((l = f ?? null), h) : l
      }),
      h
    )
  }
  var eB = x(() => {
    'use strict'
    v2()
    L2()
    P3()
    a(Jpt, 'arcInnerRadius')
    a(tmt, 'arcOuterRadius')
    a(emt, 'arcStartAngle')
    a(rmt, 'arcEndAngle')
    a(nmt, 'arcPadAngle')
    a(imt, 'intersect')
    a(D2, 'cornerTangents')
    a(Ia, 'default')
  })
  function jg(e) {
    return typeof e == 'object' && 'length' in e ? e : Array.from(e)
  }
  var rQt,
    B3 = x(() => {
      'use strict'
      rQt = Array.prototype.slice
      a(jg, 'default')
    })
  function rB(e) {
    this._context = e
  }
  function ul(e) {
    return new rB(e)
  }
  var F3 = x(() => {
    'use strict'
    a(rB, 'Linear')
    rB.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        this._point = 0
      }, 'lineStart'),
      lineEnd: a(function () {
        ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
          (this._line = 1 - this._line)
      }, 'lineEnd'),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
            break
          case 1:
            this._point = 2
          default:
            this._context.lineTo(e, t)
            break
        }
      }, 'point'),
    }
    a(ul, 'default')
  })
  function nB(e) {
    return e[0]
  }
  function iB(e) {
    return e[1]
  }
  var sB = x(() => {
    'use strict'
    a(nB, 'x')
    a(iB, 'y')
  })
  function Ma(e, t) {
    var r = Hr(!0),
      n = null,
      i = ul,
      s = null,
      o = R2(l)
    ;(e = typeof e == 'function' ? e : e === void 0 ? nB : Hr(e)),
      (t = typeof t == 'function' ? t : t === void 0 ? iB : Hr(t))
    function l(u) {
      var h,
        f = (u = jg(u)).length,
        d,
        p = !1,
        m
      for (n == null && (s = i((m = o()))), h = 0; h <= f; ++h)
        !(h < f && r((d = u[h]), h, u)) === p && ((p = !p) ? s.lineStart() : s.lineEnd()),
          p && s.point(+e(d, h, u), +t(d, h, u))
      if (m) return (s = null), m + '' || null
    }
    return (
      a(l, 'line'),
      (l.x = function (u) {
        return arguments.length ? ((e = typeof u == 'function' ? u : Hr(+u)), l) : e
      }),
      (l.y = function (u) {
        return arguments.length ? ((t = typeof u == 'function' ? u : Hr(+u)), l) : t
      }),
      (l.defined = function (u) {
        return arguments.length ? ((r = typeof u == 'function' ? u : Hr(!!u)), l) : r
      }),
      (l.curve = function (u) {
        return arguments.length ? ((i = u), n != null && (s = i(n)), l) : i
      }),
      (l.context = function (u) {
        return arguments.length ? (u == null ? (n = s = null) : (s = i((n = u))), l) : n
      }),
      l
    )
  }
  var aB = x(() => {
    'use strict'
    B3()
    v2()
    F3()
    P3()
    sB()
    a(Ma, 'default')
  })
  function $3(e, t) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
  }
  var oB = x(() => {
    'use strict'
    a($3, 'default')
  })
  function G3(e) {
    return e
  }
  var lB = x(() => {
    'use strict'
    a(G3, 'default')
  })
  function N2() {
    var e = G3,
      t = $3,
      r = null,
      n = Hr(0),
      i = Hr(Pf),
      s = Hr(0)
    function o(l) {
      var u,
        h = (l = jg(l)).length,
        f,
        d,
        p = 0,
        m = new Array(h),
        g = new Array(h),
        y = +n.apply(this, arguments),
        b = Math.min(Pf, Math.max(-Pf, i.apply(this, arguments) - y)),
        k,
        T = Math.min(Math.abs(b) / h, s.apply(this, arguments)),
        C = T * (b < 0 ? -1 : 1),
        A
      for (u = 0; u < h; ++u) (A = g[(m[u] = u)] = +e(l[u], u, l)) > 0 && (p += A)
      for (
        t != null
          ? m.sort(function (w, D) {
              return t(g[w], g[D])
            })
          : r != null &&
            m.sort(function (w, D) {
              return r(l[w], l[D])
            }),
          u = 0,
          d = p ? (b - h * C) / p : 0;
        u < h;
        ++u, y = k
      )
        (f = m[u]),
          (A = g[f]),
          (k = y + (A > 0 ? A * d : 0) + C),
          (g[f] = { data: l[f], index: u, value: A, startAngle: y, endAngle: k, padAngle: T })
      return g
    }
    return (
      a(o, 'pie'),
      (o.value = function (l) {
        return arguments.length ? ((e = typeof l == 'function' ? l : Hr(+l)), o) : e
      }),
      (o.sortValues = function (l) {
        return arguments.length ? ((t = l), (r = null), o) : t
      }),
      (o.sort = function (l) {
        return arguments.length ? ((r = l), (t = null), o) : r
      }),
      (o.startAngle = function (l) {
        return arguments.length ? ((n = typeof l == 'function' ? l : Hr(+l)), o) : n
      }),
      (o.endAngle = function (l) {
        return arguments.length ? ((i = typeof l == 'function' ? l : Hr(+l)), o) : i
      }),
      (o.padAngle = function (l) {
        return arguments.length ? ((s = typeof l == 'function' ? l : Hr(+l)), o) : s
      }),
      o
    )
  }
  var cB = x(() => {
    'use strict'
    B3()
    v2()
    oB()
    lB()
    L2()
    a(N2, 'default')
  })
  function qg(e) {
    return new I2(e, !0)
  }
  function Hg(e) {
    return new I2(e, !1)
  }
  var I2,
    uB = x(() => {
      'use strict'
      I2 = class {
        static {
          a(this, 'Bump')
        }
        constructor(t, r) {
          ;(this._context = t), (this._x = r)
        }
        areaStart() {
          this._line = 0
        }
        areaEnd() {
          this._line = NaN
        }
        lineStart() {
          this._point = 0
        }
        lineEnd() {
          ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
            (this._line = 1 - this._line)
        }
        point(t, r) {
          switch (((t = +t), (r = +r), this._point)) {
            case 0: {
              ;(this._point = 1), this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r)
              break
            }
            case 1:
              this._point = 2
            default: {
              this._x
                ? this._context.bezierCurveTo((this._x0 = (this._x0 + t) / 2), this._y0, this._x0, r, t, r)
                : this._context.bezierCurveTo(this._x0, (this._y0 = (this._y0 + r) / 2), t, this._y0, t, r)
              break
            }
          }
          ;(this._x0 = t), (this._y0 = r)
        }
      }
      a(qg, 'bumpX')
      a(Hg, 'bumpY')
    })
  function vs() {}
  var Yg = x(() => {
    'use strict'
    a(vs, 'default')
  })
  function Bf(e, t, r) {
    e._context.bezierCurveTo(
      (2 * e._x0 + e._x1) / 3,
      (2 * e._y0 + e._y1) / 3,
      (e._x0 + 2 * e._x1) / 3,
      (e._y0 + 2 * e._y1) / 3,
      (e._x0 + 4 * e._x1 + t) / 6,
      (e._y0 + 4 * e._y1 + r) / 6,
    )
  }
  function Xg(e) {
    this._context = e
  }
  function Xs(e) {
    return new Xg(e)
  }
  var Kg = x(() => {
    'use strict'
    a(Bf, 'point')
    a(Xg, 'Basis')
    Xg.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)
      }, 'lineStart'),
      lineEnd: a(function () {
        switch (this._point) {
          case 3:
            Bf(this, this._x1, this._y1)
          case 2:
            this._context.lineTo(this._x1, this._y1)
            break
        }
        ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
          (this._line = 1 - this._line)
      }, 'lineEnd'),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
            break
          case 1:
            this._point = 2
            break
          case 2:
            ;(this._point = 3), this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6)
          default:
            Bf(this, e, t)
            break
        }
        ;(this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t)
      }, 'point'),
    }
    a(Xs, 'default')
  })
  function hB(e) {
    this._context = e
  }
  function M2(e) {
    return new hB(e)
  }
  var fB = x(() => {
    'use strict'
    Yg()
    Kg()
    a(hB, 'BasisClosed')
    hB.prototype = {
      areaStart: vs,
      areaEnd: vs,
      lineStart: a(function () {
        ;(this._x0 =
          this._x1 =
          this._x2 =
          this._x3 =
          this._x4 =
          this._y0 =
          this._y1 =
          this._y2 =
          this._y3 =
          this._y4 =
            NaN),
          (this._point = 0)
      }, 'lineStart'),
      lineEnd: a(function () {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2), this._context.closePath()
            break
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
              this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),
              this._context.closePath()
            break
          }
          case 3: {
            this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4)
            break
          }
        }
      }, 'lineEnd'),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ;(this._point = 1), (this._x2 = e), (this._y2 = t)
            break
          case 1:
            ;(this._point = 2), (this._x3 = e), (this._y3 = t)
            break
          case 2:
            ;(this._point = 3),
              (this._x4 = e),
              (this._y4 = t),
              this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6)
            break
          default:
            Bf(this, e, t)
            break
        }
        ;(this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t)
      }, 'point'),
    }
    a(M2, 'default')
  })
  function dB(e) {
    this._context = e
  }
  function O2(e) {
    return new dB(e)
  }
  var pB = x(() => {
    'use strict'
    Kg()
    a(dB, 'BasisOpen')
    dB.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)
      }, 'lineStart'),
      lineEnd: a(function () {
        ;(this._line || (this._line !== 0 && this._point === 3)) && this._context.closePath(),
          (this._line = 1 - this._line)
      }, 'lineEnd'),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            this._point = 1
            break
          case 1:
            this._point = 2
            break
          case 2:
            this._point = 3
            var r = (this._x0 + 4 * this._x1 + e) / 6,
              n = (this._y0 + 4 * this._y1 + t) / 6
            this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n)
            break
          case 3:
            this._point = 4
          default:
            Bf(this, e, t)
            break
        }
        ;(this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t)
      }, 'point'),
    }
    a(O2, 'default')
  })
  function mB(e, t) {
    ;(this._basis = new Xg(e)), (this._beta = t)
  }
  var V3,
    gB = x(() => {
      'use strict'
      Kg()
      a(mB, 'Bundle')
      mB.prototype = {
        lineStart: a(function () {
          ;(this._x = []), (this._y = []), this._basis.lineStart()
        }, 'lineStart'),
        lineEnd: a(function () {
          var e = this._x,
            t = this._y,
            r = e.length - 1
          if (r > 0)
            for (var n = e[0], i = t[0], s = e[r] - n, o = t[r] - i, l = -1, u; ++l <= r; )
              (u = l / r),
                this._basis.point(
                  this._beta * e[l] + (1 - this._beta) * (n + u * s),
                  this._beta * t[l] + (1 - this._beta) * (i + u * o),
                )
          ;(this._x = this._y = null), this._basis.lineEnd()
        }, 'lineEnd'),
        point: a(function (e, t) {
          this._x.push(+e), this._y.push(+t)
        }, 'point'),
      }
      V3 = a(function e(t) {
        function r(n) {
          return t === 1 ? new Xg(n) : new mB(n, t)
        }
        return (
          a(r, 'bundle'),
          (r.beta = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0.85)
    })
  function Ff(e, t, r) {
    e._context.bezierCurveTo(
      e._x1 + e._k * (e._x2 - e._x0),
      e._y1 + e._k * (e._y2 - e._y0),
      e._x2 + e._k * (e._x1 - t),
      e._y2 + e._k * (e._y1 - r),
      e._x2,
      e._y2,
    )
  }
  function P2(e, t) {
    ;(this._context = e), (this._k = (1 - t) / 6)
  }
  var Qg,
    Zg = x(() => {
      'use strict'
      a(Ff, 'point')
      a(P2, 'Cardinal')
      P2.prototype = {
        areaStart: a(function () {
          this._line = 0
        }, 'areaStart'),
        areaEnd: a(function () {
          this._line = NaN
        }, 'areaEnd'),
        lineStart: a(function () {
          ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2)
              break
            case 3:
              Ff(this, this._x1, this._y1)
              break
          }
          ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
            (this._line = 1 - this._line)
        }, 'lineEnd'),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
              break
            case 1:
              ;(this._point = 2), (this._x1 = e), (this._y1 = t)
              break
            case 2:
              this._point = 3
            default:
              Ff(this, e, t)
              break
          }
          ;(this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      Qg = a(function e(t) {
        function r(n) {
          return new P2(n, t)
        }
        return (
          a(r, 'cardinal'),
          (r.tension = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0)
    })
  function B2(e, t) {
    ;(this._context = e), (this._k = (1 - t) / 6)
  }
  var z3,
    W3 = x(() => {
      'use strict'
      Yg()
      Zg()
      a(B2, 'CardinalClosed')
      B2.prototype = {
        areaStart: vs,
        areaEnd: vs,
        lineStart: a(function () {
          ;(this._x0 =
            this._x1 =
            this._x2 =
            this._x3 =
            this._x4 =
            this._x5 =
            this._y0 =
            this._y1 =
            this._y2 =
            this._y3 =
            this._y4 =
            this._y5 =
              NaN),
            (this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          switch (this._point) {
            case 1: {
              this._context.moveTo(this._x3, this._y3), this._context.closePath()
              break
            }
            case 2: {
              this._context.lineTo(this._x3, this._y3), this._context.closePath()
              break
            }
            case 3: {
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)
              break
            }
          }
        }, 'lineEnd'),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              ;(this._point = 1), (this._x3 = e), (this._y3 = t)
              break
            case 1:
              ;(this._point = 2), this._context.moveTo((this._x4 = e), (this._y4 = t))
              break
            case 2:
              ;(this._point = 3), (this._x5 = e), (this._y5 = t)
              break
            default:
              Ff(this, e, t)
              break
          }
          ;(this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      z3 = a(function e(t) {
        function r(n) {
          return new B2(n, t)
        }
        return (
          a(r, 'cardinal'),
          (r.tension = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0)
    })
  function F2(e, t) {
    ;(this._context = e), (this._k = (1 - t) / 6)
  }
  var U3,
    j3 = x(() => {
      'use strict'
      Zg()
      a(F2, 'CardinalOpen')
      F2.prototype = {
        areaStart: a(function () {
          this._line = 0
        }, 'areaStart'),
        areaEnd: a(function () {
          this._line = NaN
        }, 'areaEnd'),
        lineStart: a(function () {
          ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          ;(this._line || (this._line !== 0 && this._point === 3)) && this._context.closePath(),
            (this._line = 1 - this._line)
        }, 'lineEnd'),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              this._point = 1
              break
            case 1:
              this._point = 2
              break
            case 2:
              ;(this._point = 3),
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)
              break
            case 3:
              this._point = 4
            default:
              Ff(this, e, t)
              break
          }
          ;(this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      U3 = a(function e(t) {
        function r(n) {
          return new F2(n, t)
        }
        return (
          a(r, 'cardinal'),
          (r.tension = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0)
    })
  function Jg(e, t, r) {
    var n = e._x1,
      i = e._y1,
      s = e._x2,
      o = e._y2
    if (e._l01_a > Un) {
      var l = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
        u = 3 * e._l01_a * (e._l01_a + e._l12_a)
      ;(n = (n * l - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u),
        (i = (i * l - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u)
    }
    if (e._l23_a > Un) {
      var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
        f = 3 * e._l23_a * (e._l23_a + e._l12_a)
      ;(s = (s * h + e._x1 * e._l23_2a - t * e._l12_2a) / f), (o = (o * h + e._y1 * e._l23_2a - r * e._l12_2a) / f)
    }
    e._context.bezierCurveTo(n, i, s, o, e._x2, e._y2)
  }
  function yB(e, t) {
    ;(this._context = e), (this._alpha = t)
  }
  var t0,
    $2 = x(() => {
      'use strict'
      L2()
      Zg()
      a(Jg, 'point')
      a(yB, 'CatmullRom')
      yB.prototype = {
        areaStart: a(function () {
          this._line = 0
        }, 'areaStart'),
        areaEnd: a(function () {
          this._line = NaN
        }, 'areaEnd'),
        lineStart: a(function () {
          ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
            (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2)
              break
            case 3:
              this.point(this._x2, this._y2)
              break
          }
          ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
            (this._line = 1 - this._line)
        }, 'lineEnd'),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t
            this._l23_a = Math.sqrt((this._l23_2a = Math.pow(r * r + n * n, this._alpha)))
          }
          switch (this._point) {
            case 0:
              ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
              break
            case 1:
              this._point = 2
              break
            case 2:
              this._point = 3
            default:
              Jg(this, e, t)
              break
          }
          ;(this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      t0 = a(function e(t) {
        function r(n) {
          return t ? new yB(n, t) : new P2(n, 0)
        }
        return (
          a(r, 'catmullRom'),
          (r.alpha = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0.5)
    })
  function xB(e, t) {
    ;(this._context = e), (this._alpha = t)
  }
  var q3,
    bB = x(() => {
      'use strict'
      W3()
      Yg()
      $2()
      a(xB, 'CatmullRomClosed')
      xB.prototype = {
        areaStart: vs,
        areaEnd: vs,
        lineStart: a(function () {
          ;(this._x0 =
            this._x1 =
            this._x2 =
            this._x3 =
            this._x4 =
            this._x5 =
            this._y0 =
            this._y1 =
            this._y2 =
            this._y3 =
            this._y4 =
            this._y5 =
              NaN),
            (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          switch (this._point) {
            case 1: {
              this._context.moveTo(this._x3, this._y3), this._context.closePath()
              break
            }
            case 2: {
              this._context.lineTo(this._x3, this._y3), this._context.closePath()
              break
            }
            case 3: {
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)
              break
            }
          }
        }, 'lineEnd'),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t
            this._l23_a = Math.sqrt((this._l23_2a = Math.pow(r * r + n * n, this._alpha)))
          }
          switch (this._point) {
            case 0:
              ;(this._point = 1), (this._x3 = e), (this._y3 = t)
              break
            case 1:
              ;(this._point = 2), this._context.moveTo((this._x4 = e), (this._y4 = t))
              break
            case 2:
              ;(this._point = 3), (this._x5 = e), (this._y5 = t)
              break
            default:
              Jg(this, e, t)
              break
          }
          ;(this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      q3 = a(function e(t) {
        function r(n) {
          return t ? new xB(n, t) : new B2(n, 0)
        }
        return (
          a(r, 'catmullRom'),
          (r.alpha = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0.5)
    })
  function kB(e, t) {
    ;(this._context = e), (this._alpha = t)
  }
  var H3,
    TB = x(() => {
      'use strict'
      j3()
      $2()
      a(kB, 'CatmullRomOpen')
      kB.prototype = {
        areaStart: a(function () {
          this._line = 0
        }, 'areaStart'),
        areaEnd: a(function () {
          this._line = NaN
        }, 'areaEnd'),
        lineStart: a(function () {
          ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
            (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)
        }, 'lineStart'),
        lineEnd: a(function () {
          ;(this._line || (this._line !== 0 && this._point === 3)) && this._context.closePath(),
            (this._line = 1 - this._line)
        }, 'lineEnd'),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t
            this._l23_a = Math.sqrt((this._l23_2a = Math.pow(r * r + n * n, this._alpha)))
          }
          switch (this._point) {
            case 0:
              this._point = 1
              break
            case 1:
              this._point = 2
              break
            case 2:
              ;(this._point = 3),
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)
              break
            case 3:
              this._point = 4
            default:
              Jg(this, e, t)
              break
          }
          ;(this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t)
        }, 'point'),
      }
      H3 = a(function e(t) {
        function r(n) {
          return t ? new kB(n, t) : new F2(n, 0)
        }
        return (
          a(r, 'catmullRom'),
          (r.alpha = function (n) {
            return e(+n)
          }),
          r
        )
      }, 'custom')(0.5)
    })
  function SB(e) {
    this._context = e
  }
  function G2(e) {
    return new SB(e)
  }
  var _B = x(() => {
    'use strict'
    Yg()
    a(SB, 'LinearClosed')
    SB.prototype = {
      areaStart: vs,
      areaEnd: vs,
      lineStart: a(function () {
        this._point = 0
      }, 'lineStart'),
      lineEnd: a(function () {
        this._point && this._context.closePath()
      }, 'lineEnd'),
      point: a(function (e, t) {
        ;(e = +e), (t = +t), this._point ? this._context.lineTo(e, t) : ((this._point = 1), this._context.moveTo(e, t))
      }, 'point'),
    }
    a(G2, 'default')
  })
  function CB(e) {
    return e < 0 ? -1 : 1
  }
  function wB(e, t, r) {
    var n = e._x1 - e._x0,
      i = t - e._x1,
      s = (e._y1 - e._y0) / (n || (i < 0 && -0)),
      o = (r - e._y1) / (i || (n < 0 && -0)),
      l = (s * i + o * n) / (n + i)
    return (CB(s) + CB(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(l)) || 0
  }
  function EB(e, t) {
    var r = e._x1 - e._x0
    return r ? ((3 * (e._y1 - e._y0)) / r - t) / 2 : t
  }
  function Y3(e, t, r) {
    var n = e._x0,
      i = e._y0,
      s = e._x1,
      o = e._y1,
      l = (s - n) / 3
    e._context.bezierCurveTo(n + l, i + l * t, s - l, o - l * r, s, o)
  }
  function V2(e) {
    this._context = e
  }
  function vB(e) {
    this._context = new AB(e)
  }
  function AB(e) {
    this._context = e
  }
  function e0(e) {
    return new V2(e)
  }
  function r0(e) {
    return new vB(e)
  }
  var LB = x(() => {
    'use strict'
    a(CB, 'sign')
    a(wB, 'slope3')
    a(EB, 'slope2')
    a(Y3, 'point')
    a(V2, 'MonotoneX')
    V2.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        ;(this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0)
      }, 'lineStart'),
      lineEnd: a(function () {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1)
            break
          case 3:
            Y3(this, this._t0, EB(this, this._t0))
            break
        }
        ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
          (this._line = 1 - this._line)
      }, 'lineEnd'),
      point: a(function (e, t) {
        var r = NaN
        if (((e = +e), (t = +t), !(e === this._x1 && t === this._y1))) {
          switch (this._point) {
            case 0:
              ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
              break
            case 1:
              this._point = 2
              break
            case 2:
              ;(this._point = 3), Y3(this, EB(this, (r = wB(this, e, t))), r)
              break
            default:
              Y3(this, this._t0, (r = wB(this, e, t)))
              break
          }
          ;(this._x0 = this._x1), (this._x1 = e), (this._y0 = this._y1), (this._y1 = t), (this._t0 = r)
        }
      }, 'point'),
    }
    a(vB, 'MonotoneY')
    ;(vB.prototype = Object.create(V2.prototype)).point = function (e, t) {
      V2.prototype.point.call(this, t, e)
    }
    a(AB, 'ReflectContext')
    AB.prototype = {
      moveTo: a(function (e, t) {
        this._context.moveTo(t, e)
      }, 'moveTo'),
      closePath: a(function () {
        this._context.closePath()
      }, 'closePath'),
      lineTo: a(function (e, t) {
        this._context.lineTo(t, e)
      }, 'lineTo'),
      bezierCurveTo: a(function (e, t, r, n, i, s) {
        this._context.bezierCurveTo(t, e, n, r, s, i)
      }, 'bezierCurveTo'),
    }
    a(e0, 'monotoneX')
    a(r0, 'monotoneY')
  })
  function DB(e) {
    this._context = e
  }
  function RB(e) {
    var t,
      r = e.length - 1,
      n,
      i = new Array(r),
      s = new Array(r),
      o = new Array(r)
    for (i[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
      (i[t] = 1), (s[t] = 4), (o[t] = 4 * e[t] + 2 * e[t + 1])
    for (i[r - 1] = 2, s[r - 1] = 7, o[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
      (n = i[t] / s[t - 1]), (s[t] -= n), (o[t] -= n * o[t - 1])
    for (i[r - 1] = o[r - 1] / s[r - 1], t = r - 2; t >= 0; --t) i[t] = (o[t] - i[t + 1]) / s[t]
    for (s[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t) s[t] = 2 * e[t + 1] - i[t + 1]
    return [i, s]
  }
  function $f(e) {
    return new DB(e)
  }
  var NB = x(() => {
    'use strict'
    a(DB, 'Natural')
    DB.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        ;(this._x = []), (this._y = [])
      }, 'lineStart'),
      lineEnd: a(function () {
        var e = this._x,
          t = this._y,
          r = e.length
        if (r)
          if ((this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2))
            this._context.lineTo(e[1], t[1])
          else
            for (var n = RB(e), i = RB(t), s = 0, o = 1; o < r; ++s, ++o)
              this._context.bezierCurveTo(n[0][s], i[0][s], n[1][s], i[1][s], e[o], t[o])
        ;(this._line || (this._line !== 0 && r === 1)) && this._context.closePath(),
          (this._line = 1 - this._line),
          (this._x = this._y = null)
      }, 'lineEnd'),
      point: a(function (e, t) {
        this._x.push(+e), this._y.push(+t)
      }, 'point'),
    }
    a(RB, 'controlPoints')
    a($f, 'default')
  })
  function z2(e, t) {
    ;(this._context = e), (this._t = t)
  }
  function Gf(e) {
    return new z2(e, 0.5)
  }
  function n0(e) {
    return new z2(e, 0)
  }
  function i0(e) {
    return new z2(e, 1)
  }
  var IB = x(() => {
    'use strict'
    a(z2, 'Step')
    z2.prototype = {
      areaStart: a(function () {
        this._line = 0
      }, 'areaStart'),
      areaEnd: a(function () {
        this._line = NaN
      }, 'areaEnd'),
      lineStart: a(function () {
        ;(this._x = this._y = NaN), (this._point = 0)
      }, 'lineStart'),
      lineEnd: a(function () {
        0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y),
          (this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
          this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line))
      }, 'lineEnd'),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ;(this._point = 1), this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
            break
          case 1:
            this._point = 2
          default: {
            if (this._t <= 0) this._context.lineTo(this._x, t), this._context.lineTo(e, t)
            else {
              var r = this._x * (1 - this._t) + e * this._t
              this._context.lineTo(r, this._y), this._context.lineTo(r, t)
            }
            break
          }
        }
        ;(this._x = e), (this._y = t)
      }, 'point'),
    }
    a(Gf, 'default')
    a(n0, 'stepBefore')
    a(i0, 'stepAfter')
  })
  var MB = x(() => {
    'use strict'
    eB()
    aB()
    cB()
    fB()
    pB()
    Kg()
    uB()
    gB()
    W3()
    j3()
    Zg()
    bB()
    TB()
    $2()
    _B()
    F3()
    LB()
    NB()
    IB()
  })
  var OB = x(() => {
    'use strict'
  })
  var PB = x(() => {
    'use strict'
  })
  function uc(e, t, r) {
    ;(this.k = e), (this.x = t), (this.y = r)
  }
  function K3(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return X3
    return e.__zoom
  }
  var X3,
    Q3 = x(() => {
      'use strict'
      a(uc, 'Transform')
      uc.prototype = {
        constructor: uc,
        scale: a(function (e) {
          return e === 1 ? this : new uc(this.k * e, this.x, this.y)
        }, 'scale'),
        translate: a(function (e, t) {
          return (e === 0) & (t === 0) ? this : new uc(this.k, this.x + this.k * e, this.y + this.k * t)
        }, 'translate'),
        apply: a(function (e) {
          return [e[0] * this.k + this.x, e[1] * this.k + this.y]
        }, 'apply'),
        applyX: a(function (e) {
          return e * this.k + this.x
        }, 'applyX'),
        applyY: a(function (e) {
          return e * this.k + this.y
        }, 'applyY'),
        invert: a(function (e) {
          return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
        }, 'invert'),
        invertX: a(function (e) {
          return (e - this.x) / this.k
        }, 'invertX'),
        invertY: a(function (e) {
          return (e - this.y) / this.k
        }, 'invertY'),
        rescaleX: a(function (e) {
          return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
        }, 'rescaleX'),
        rescaleY: a(function (e) {
          return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
        }, 'rescaleY'),
        toString: a(function () {
          return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'
        }, 'toString'),
      }
      X3 = new uc(1, 0, 0)
      K3.prototype = uc.prototype
      a(K3, 'transform')
    })
  var BB = x(() => {
    'use strict'
  })
  var FB = x(() => {
    'use strict'
    a2()
    OB()
    PB()
    Q3()
    BB()
  })
  var $B = x(() => {
    'use strict'
    FB()
    Q3()
  })
  var Ge = x(() => {
    'use strict'
    Jl()
    HI()
    fP()
    gP()
    _f()
    yP()
    xP()
    $w()
    FM()
    bP()
    vv()
    kP()
    SP()
    Uv()
    PP()
    a9()
    Ef()
    Nv()
    o9()
    TP()
    l9()
    X9()
    Z9()
    wa()
    MB()
    w2()
    D3()
    t2()
    a2()
    $B()
  })
  var GB = Ja((jn) => {
    'use strict'
    Object.defineProperty(jn, '__esModule', { value: !0 })
    jn.BLANK_URL =
      jn.relativeFirstCharacters =
      jn.whitespaceEscapeCharsRegex =
      jn.urlSchemeRegex =
      jn.ctrlCharactersRegex =
      jn.htmlCtrlEntityRegex =
      jn.htmlEntitiesRegex =
      jn.invalidProtocolRegex =
        void 0
    jn.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im
    jn.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g
    jn.htmlCtrlEntityRegex = /&(newline|tab);/gi
    jn.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim
    jn.urlSchemeRegex = /^.+(:|&colon;)/gim
    jn.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g
    jn.relativeFirstCharacters = ['.', '/']
    jn.BLANK_URL = 'about:blank'
  })
  var Vf = Ja((W2) => {
    'use strict'
    Object.defineProperty(W2, '__esModule', { value: !0 })
    W2.sanitizeUrl = void 0
    var gi = GB()
    function smt(e) {
      return gi.relativeFirstCharacters.indexOf(e[0]) > -1
    }
    a(smt, 'isRelativeUrlWithoutProtocol')
    function amt(e) {
      var t = e.replace(gi.ctrlCharactersRegex, '')
      return t.replace(gi.htmlEntitiesRegex, function (r, n) {
        return String.fromCharCode(n)
      })
    }
    a(amt, 'decodeHtmlCharacters')
    function omt(e) {
      return URL.canParse(e)
    }
    a(omt, 'isValidUrl')
    function VB(e) {
      try {
        return decodeURIComponent(e)
      } catch {
        return e
      }
    }
    a(VB, 'decodeURI')
    function lmt(e) {
      if (!e) return gi.BLANK_URL
      var t,
        r = VB(e.trim())
      do
        (r = amt(r)
          .replace(gi.htmlCtrlEntityRegex, '')
          .replace(gi.ctrlCharactersRegex, '')
          .replace(gi.whitespaceEscapeCharsRegex, '')
          .trim()),
          (r = VB(r)),
          (t =
            r.match(gi.ctrlCharactersRegex) ||
            r.match(gi.htmlEntitiesRegex) ||
            r.match(gi.htmlCtrlEntityRegex) ||
            r.match(gi.whitespaceEscapeCharsRegex))
      while (t && t.length > 0)
      var n = r
      if (!n) return gi.BLANK_URL
      if (smt(n)) return n
      var i = n.trimStart(),
        s = i.match(gi.urlSchemeRegex)
      if (!s) return n
      var o = s[0].toLowerCase().trim()
      if (gi.invalidProtocolRegex.test(o)) return gi.BLANK_URL
      var l = i.replace(/\\/g, '/')
      if (o === 'mailto:' || o.includes('://')) return l
      if (o === 'http:' || o === 'https:') {
        if (!omt(l)) return gi.BLANK_URL
        var u = new URL(l)
        return (u.protocol = u.protocol.toLowerCase()), (u.hostname = u.hostname.toLowerCase()), u.toString()
      }
      return l
    }
    a(lmt, 'sanitizeUrl')
    W2.sanitizeUrl = lmt
  })
  var Z3,
    Vu,
    U2,
    zB,
    j2,
    q2,
    ri,
    s0,
    a0 = x(() => {
      'use strict'
      Z3 = Ss(Vf(), 1)
      Be()
      ;(Vu = a((e, t) => {
        let r = e.append('rect')
        if (
          (r.attr('x', t.x),
          r.attr('y', t.y),
          r.attr('fill', t.fill),
          r.attr('stroke', t.stroke),
          r.attr('width', t.width),
          r.attr('height', t.height),
          t.name && r.attr('name', t.name),
          t.rx && r.attr('rx', t.rx),
          t.ry && r.attr('ry', t.ry),
          t.attrs !== void 0)
        )
          for (let n in t.attrs) r.attr(n, t.attrs[n])
        return t.class && r.attr('class', t.class), r
      }, 'drawRect')),
        (U2 = a((e, t) => {
          let r = {
            x: t.startx,
            y: t.starty,
            width: t.stopx - t.startx,
            height: t.stopy - t.starty,
            fill: t.fill,
            stroke: t.stroke,
            class: 'rect',
          }
          Vu(e, r).lower()
        }, 'drawBackgroundRect')),
        (zB = a((e, t) => {
          let r = t.text.replace(ff, ' '),
            n = e.append('text')
          n.attr('x', t.x),
            n.attr('y', t.y),
            n.attr('class', 'legend'),
            n.style('text-anchor', t.anchor),
            t.class && n.attr('class', t.class)
          let i = n.append('tspan')
          return i.attr('x', t.x + t.textMargin * 2), i.text(r), n
        }, 'drawText')),
        (j2 = a((e, t, r, n) => {
          let i = e.append('image')
          i.attr('x', t), i.attr('y', r)
          let s = (0, Z3.sanitizeUrl)(n)
          i.attr('xlink:href', s)
        }, 'drawImage')),
        (q2 = a((e, t, r, n) => {
          let i = e.append('use')
          i.attr('x', t), i.attr('y', r)
          let s = (0, Z3.sanitizeUrl)(n)
          i.attr('xlink:href', `#${s}`)
        }, 'drawEmbeddedImage')),
        (ri = a(
          () => ({
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            fill: '#EDF2AE',
            stroke: '#666',
            anchor: 'start',
            rx: 0,
            ry: 0,
          }),
          'getNoteRect',
        )),
        (s0 = a(
          () => ({
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            'text-anchor': 'start',
            style: '#666',
            textMargin: 0,
            rx: 0,
            ry: 0,
            tspan: !0,
          }),
          'getTextObj',
        ))
    })
  var WB,
    J3,
    UB,
    cmt,
    umt,
    hmt,
    fmt,
    dmt,
    pmt,
    mmt,
    gmt,
    ymt,
    xmt,
    bmt,
    kmt,
    hl,
    Oa,
    jB = x(() => {
      'use strict'
      Be()
      a0()
      ;(WB = Ss(Vf(), 1)),
        (J3 = a(function (e, t) {
          return Vu(e, t)
        }, 'drawRect')),
        (UB = a(function (e, t, r, n, i, s) {
          let o = e.append('image')
          o.attr('width', t), o.attr('height', r), o.attr('x', n), o.attr('y', i)
          let l = s.startsWith('data:image/png;base64') ? s : (0, WB.sanitizeUrl)(s)
          o.attr('xlink:href', l)
        }, 'drawImage')),
        (cmt = a((e, t, r) => {
          let n = e.append('g'),
            i = 0
          for (let s of t) {
            let o = s.textColor ? s.textColor : '#444444',
              l = s.lineColor ? s.lineColor : '#444444',
              u = s.offsetX ? parseInt(s.offsetX) : 0,
              h = s.offsetY ? parseInt(s.offsetY) : 0,
              f = ''
            if (i === 0) {
              let p = n.append('line')
              p.attr('x1', s.startPoint.x),
                p.attr('y1', s.startPoint.y),
                p.attr('x2', s.endPoint.x),
                p.attr('y2', s.endPoint.y),
                p.attr('stroke-width', '1'),
                p.attr('stroke', l),
                p.style('fill', 'none'),
                s.type !== 'rel_b' && p.attr('marker-end', 'url(' + f + '#arrowhead)'),
                (s.type === 'birel' || s.type === 'rel_b') && p.attr('marker-start', 'url(' + f + '#arrowend)'),
                (i = -1)
            } else {
              let p = n.append('path')
              p
                .attr('fill', 'none')
                .attr('stroke-width', '1')
                .attr('stroke', l)
                .attr(
                  'd',
                  'Mstartx,starty Qcontrolx,controly stopx,stopy '
                    .replaceAll('startx', s.startPoint.x)
                    .replaceAll('starty', s.startPoint.y)
                    .replaceAll(
                      'controlx',
                      s.startPoint.x + (s.endPoint.x - s.startPoint.x) / 2 - (s.endPoint.x - s.startPoint.x) / 4,
                    )
                    .replaceAll('controly', s.startPoint.y + (s.endPoint.y - s.startPoint.y) / 2)
                    .replaceAll('stopx', s.endPoint.x)
                    .replaceAll('stopy', s.endPoint.y),
                ),
                s.type !== 'rel_b' && p.attr('marker-end', 'url(' + f + '#arrowhead)'),
                (s.type === 'birel' || s.type === 'rel_b') && p.attr('marker-start', 'url(' + f + '#arrowend)')
            }
            let d = r.messageFont()
            hl(r)(
              s.label.text,
              n,
              Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + u,
              Math.min(s.startPoint.y, s.endPoint.y) + Math.abs(s.endPoint.y - s.startPoint.y) / 2 + h,
              s.label.width,
              s.label.height,
              { fill: o },
              d,
            ),
              s.techn &&
                s.techn.text !== '' &&
                ((d = r.messageFont()),
                hl(r)(
                  '[' + s.techn.text + ']',
                  n,
                  Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + u,
                  Math.min(s.startPoint.y, s.endPoint.y) +
                    Math.abs(s.endPoint.y - s.startPoint.y) / 2 +
                    r.messageFontSize +
                    5 +
                    h,
                  Math.max(s.label.width, s.techn.width),
                  s.techn.height,
                  { fill: o, 'font-style': 'italic' },
                  d,
                ))
          }
        }, 'drawRels')),
        (umt = a(function (e, t, r) {
          let n = e.append('g'),
            i = t.bgColor ? t.bgColor : 'none',
            s = t.borderColor ? t.borderColor : '#444444',
            o = t.fontColor ? t.fontColor : 'black',
            l = { 'stroke-width': 1, 'stroke-dasharray': '7.0,7.0' }
          t.nodeType && (l = { 'stroke-width': 1 })
          let u = { x: t.x, y: t.y, fill: i, stroke: s, width: t.width, height: t.height, rx: 2.5, ry: 2.5, attrs: l }
          J3(n, u)
          let h = r.boundaryFont()
          ;(h.fontWeight = 'bold'),
            (h.fontSize = h.fontSize + 2),
            (h.fontColor = o),
            hl(r)(t.label.text, n, t.x, t.y + t.label.Y, t.width, t.height, { fill: '#444444' }, h),
            t.type &&
              t.type.text !== '' &&
              ((h = r.boundaryFont()),
              (h.fontColor = o),
              hl(r)(t.type.text, n, t.x, t.y + t.type.Y, t.width, t.height, { fill: '#444444' }, h)),
            t.descr &&
              t.descr.text !== '' &&
              ((h = r.boundaryFont()),
              (h.fontSize = h.fontSize - 2),
              (h.fontColor = o),
              hl(r)(t.descr.text, n, t.x, t.y + t.descr.Y, t.width, t.height, { fill: '#444444' }, h))
        }, 'drawBoundary')),
        (hmt = a(function (e, t, r) {
          let n = t.bgColor ? t.bgColor : r[t.typeC4Shape.text + '_bg_color'],
            i = t.borderColor ? t.borderColor : r[t.typeC4Shape.text + '_border_color'],
            s = t.fontColor ? t.fontColor : '#FFFFFF',
            o =
              'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII='
          switch (t.typeC4Shape.text) {
            case 'person':
              o =
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII='
              break
            case 'external_person':
              o =
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII='
              break
          }
          let l = e.append('g')
          l.attr('class', 'person-man')
          let u = ri()
          switch (t.typeC4Shape.text) {
            case 'person':
            case 'external_person':
            case 'system':
            case 'external_system':
            case 'container':
            case 'external_container':
            case 'component':
            case 'external_component':
              ;(u.x = t.x),
                (u.y = t.y),
                (u.fill = n),
                (u.width = t.width),
                (u.height = t.height),
                (u.stroke = i),
                (u.rx = 2.5),
                (u.ry = 2.5),
                (u.attrs = { 'stroke-width': 0.5 }),
                J3(l, u)
              break
            case 'system_db':
            case 'external_system_db':
            case 'container_db':
            case 'external_container_db':
            case 'component_db':
            case 'external_component_db':
              l
                .append('path')
                .attr('fill', n)
                .attr('stroke-width', '0.5')
                .attr('stroke', i)
                .attr(
                  'd',
                  'Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height'
                    .replaceAll('startx', t.x)
                    .replaceAll('starty', t.y)
                    .replaceAll('half', t.width / 2)
                    .replaceAll('height', t.height),
                ),
                l
                  .append('path')
                  .attr('fill', 'none')
                  .attr('stroke-width', '0.5')
                  .attr('stroke', i)
                  .attr(
                    'd',
                    'Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10'
                      .replaceAll('startx', t.x)
                      .replaceAll('starty', t.y)
                      .replaceAll('half', t.width / 2),
                  )
              break
            case 'system_queue':
            case 'external_system_queue':
            case 'container_queue':
            case 'external_container_queue':
            case 'component_queue':
            case 'external_component_queue':
              l
                .append('path')
                .attr('fill', n)
                .attr('stroke-width', '0.5')
                .attr('stroke', i)
                .attr(
                  'd',
                  'Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half'
                    .replaceAll('startx', t.x)
                    .replaceAll('starty', t.y)
                    .replaceAll('width', t.width)
                    .replaceAll('half', t.height / 2),
                ),
                l
                  .append('path')
                  .attr('fill', 'none')
                  .attr('stroke-width', '0.5')
                  .attr('stroke', i)
                  .attr(
                    'd',
                    'Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half'
                      .replaceAll('startx', t.x + t.width)
                      .replaceAll('starty', t.y)
                      .replaceAll('half', t.height / 2),
                  )
              break
          }
          let h = kmt(r, t.typeC4Shape.text)
          switch (
            (l
              .append('text')
              .attr('fill', s)
              .attr('font-family', h.fontFamily)
              .attr('font-size', h.fontSize - 2)
              .attr('font-style', 'italic')
              .attr('lengthAdjust', 'spacing')
              .attr('textLength', t.typeC4Shape.width)
              .attr('x', t.x + t.width / 2 - t.typeC4Shape.width / 2)
              .attr('y', t.y + t.typeC4Shape.Y)
              .text('<<' + t.typeC4Shape.text + '>>'),
            t.typeC4Shape.text)
          ) {
            case 'person':
            case 'external_person':
              UB(l, 48, 48, t.x + t.width / 2 - 24, t.y + t.image.Y, o)
              break
          }
          let f = r[t.typeC4Shape.text + 'Font']()
          return (
            (f.fontWeight = 'bold'),
            (f.fontSize = f.fontSize + 2),
            (f.fontColor = s),
            hl(r)(t.label.text, l, t.x, t.y + t.label.Y, t.width, t.height, { fill: s }, f),
            (f = r[t.typeC4Shape.text + 'Font']()),
            (f.fontColor = s),
            t.techn && t.techn?.text !== ''
              ? hl(r)(t.techn.text, l, t.x, t.y + t.techn.Y, t.width, t.height, { fill: s, 'font-style': 'italic' }, f)
              : t.type &&
                t.type.text !== '' &&
                hl(r)(t.type.text, l, t.x, t.y + t.type.Y, t.width, t.height, { fill: s, 'font-style': 'italic' }, f),
            t.descr &&
              t.descr.text !== '' &&
              ((f = r.personFont()),
              (f.fontColor = s),
              hl(r)(t.descr.text, l, t.x, t.y + t.descr.Y, t.width, t.height, { fill: s }, f)),
            t.height
          )
        }, 'drawC4Shape')),
        (fmt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'database')
            .attr('fill-rule', 'evenodd')
            .attr('clip-rule', 'evenodd')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z',
            )
        }, 'insertDatabaseIcon')),
        (dmt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'computer')
            .attr('width', '24')
            .attr('height', '24')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z',
            )
        }, 'insertComputerIcon')),
        (pmt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'clock')
            .attr('width', '24')
            .attr('height', '24')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z',
            )
        }, 'insertClockIcon')),
        (mmt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'arrowhead')
            .attr('refX', 9)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 12)
            .attr('markerHeight', 12)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z')
        }, 'insertArrowHead')),
        (gmt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'arrowend')
            .attr('refX', 1)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 12)
            .attr('markerHeight', 12)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 10 0 L 0 5 L 10 10 z')
        }, 'insertArrowEnd')),
        (ymt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'filled-head')
            .attr('refX', 18)
            .attr('refY', 7)
            .attr('markerWidth', 20)
            .attr('markerHeight', 28)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z')
        }, 'insertArrowFilledHead')),
        (xmt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'sequencenumber')
            .attr('refX', 15)
            .attr('refY', 15)
            .attr('markerWidth', 60)
            .attr('markerHeight', 40)
            .attr('orient', 'auto')
            .append('circle')
            .attr('cx', 15)
            .attr('cy', 15)
            .attr('r', 6)
        }, 'insertDynamicNumber')),
        (bmt = a(function (e) {
          let r = e
            .append('defs')
            .append('marker')
            .attr('id', 'crosshead')
            .attr('markerWidth', 15)
            .attr('markerHeight', 8)
            .attr('orient', 'auto')
            .attr('refX', 16)
            .attr('refY', 4)
          r
            .append('path')
            .attr('fill', 'black')
            .attr('stroke', '#000000')
            .style('stroke-dasharray', '0, 0')
            .attr('stroke-width', '1px')
            .attr('d', 'M 9,2 V 6 L16,4 Z'),
            r
              .append('path')
              .attr('fill', 'none')
              .attr('stroke', '#000000')
              .style('stroke-dasharray', '0, 0')
              .attr('stroke-width', '1px')
              .attr('d', 'M 0,1 L 6,7 M 6,1 L 0,7')
        }, 'insertArrowCrossHead')),
        (kmt = a(
          (e, t) => ({ fontFamily: e[t + 'FontFamily'], fontSize: e[t + 'FontSize'], fontWeight: e[t + 'FontWeight'] }),
          'getC4ShapeFont',
        )),
        (hl = (function () {
          function e(i, s, o, l, u, h, f) {
            let d = s
              .append('text')
              .attr('x', o + u / 2)
              .attr('y', l + h / 2 + 5)
              .style('text-anchor', 'middle')
              .text(i)
            n(d, f)
          }
          a(e, 'byText')
          function t(i, s, o, l, u, h, f, d) {
            let { fontSize: p, fontFamily: m, fontWeight: g } = d,
              y = i.split(Rt.lineBreakRegex)
            for (let b = 0; b < y.length; b++) {
              let k = b * p - (p * (y.length - 1)) / 2,
                T = s
                  .append('text')
                  .attr('x', o + u / 2)
                  .attr('y', l)
                  .style('text-anchor', 'middle')
                  .attr('dominant-baseline', 'middle')
                  .style('font-size', p)
                  .style('font-weight', g)
                  .style('font-family', m)
              T.append('tspan').attr('dy', k).text(y[b]).attr('alignment-baseline', 'mathematical'), n(T, f)
            }
          }
          a(t, 'byTspan')
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append('switch'),
              g = p
                .append('foreignObject')
                .attr('x', o)
                .attr('y', l)
                .attr('width', u)
                .attr('height', h)
                .append('xhtml:div')
                .style('display', 'table')
                .style('height', '100%')
                .style('width', '100%')
            g
              .append('div')
              .style('display', 'table-cell')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f)
          }
          a(r, 'byFo')
          function n(i, s) {
            for (let o in s) s.hasOwnProperty(o) && i.attr(o, s[o])
          }
          return (
            a(n, '_setTextAttrs'),
            function (i) {
              return i.textPlacement === 'fo' ? r : i.textPlacement === 'old' ? e : t
            }
          )
        })()),
        (Oa = {
          drawRect: J3,
          drawBoundary: umt,
          drawC4Shape: hmt,
          drawRels: cmt,
          drawImage: UB,
          insertArrowHead: mmt,
          insertArrowEnd: gmt,
          insertArrowFilledHead: ymt,
          insertDynamicNumber: xmt,
          insertArrowCrossHead: bmt,
          insertDatabaseIcon: fmt,
          insertComputerIcon: dmt,
          insertClockIcon: pmt,
        })
    })
  var Tmt,
    Y2,
    t4 = x(() => {
      'use strict'
      ;(Tmt = typeof global == 'object' && global && global.Object === Object && global), (Y2 = Tmt)
    })
  var Smt,
    _mt,
    pn,
    Ks = x(() => {
      'use strict'
      t4()
      ;(Smt = typeof self == 'object' && self && self.Object === Object && self),
        (_mt = Y2 || Smt || Function('return this')()),
        (pn = _mt)
    })
  var Cmt,
    qn,
    zu = x(() => {
      'use strict'
      Ks()
      ;(Cmt = pn.Symbol), (qn = Cmt)
    })
  function vmt(e) {
    var t = wmt.call(e, o0),
      r = e[o0]
    try {
      e[o0] = void 0
      var n = !0
    } catch {}
    var i = Emt.call(e)
    return n && (t ? (e[o0] = r) : delete e[o0]), i
  }
  var qB,
    wmt,
    Emt,
    o0,
    HB,
    YB = x(() => {
      'use strict'
      zu()
      ;(qB = Object.prototype), (wmt = qB.hasOwnProperty), (Emt = qB.toString), (o0 = qn ? qn.toStringTag : void 0)
      a(vmt, 'getRawTag')
      HB = vmt
    })
  function Rmt(e) {
    return Lmt.call(e)
  }
  var Amt,
    Lmt,
    XB,
    KB = x(() => {
      'use strict'
      ;(Amt = Object.prototype), (Lmt = Amt.toString)
      a(Rmt, 'objectToString')
      XB = Rmt
    })
  function Imt(e) {
    return e == null ? (e === void 0 ? Nmt : Dmt) : QB && QB in Object(e) ? HB(e) : XB(e)
  }
  var Dmt,
    Nmt,
    QB,
    ni,
    fl = x(() => {
      'use strict'
      zu()
      YB()
      KB()
      ;(Dmt = '[object Null]'), (Nmt = '[object Undefined]'), (QB = qn ? qn.toStringTag : void 0)
      a(Imt, 'baseGetTag')
      ni = Imt
    })
  function Mmt(e) {
    var t = typeof e
    return e != null && (t == 'object' || t == 'function')
  }
  var Nr,
    As = x(() => {
      'use strict'
      a(Mmt, 'isObject')
      Nr = Mmt
    })
  function $mt(e) {
    if (!Nr(e)) return !1
    var t = ni(e)
    return t == Pmt || t == Bmt || t == Omt || t == Fmt
  }
  var Omt,
    Pmt,
    Bmt,
    Fmt,
    vn,
    l0 = x(() => {
      'use strict'
      fl()
      As()
      ;(Omt = '[object AsyncFunction]'),
        (Pmt = '[object Function]'),
        (Bmt = '[object GeneratorFunction]'),
        (Fmt = '[object Proxy]')
      a($mt, 'isFunction')
      vn = $mt
    })
  var Gmt,
    X2,
    ZB = x(() => {
      'use strict'
      Ks()
      ;(Gmt = pn['__core-js_shared__']), (X2 = Gmt)
    })
  function Vmt(e) {
    return !!JB && JB in e
  }
  var JB,
    tF,
    eF = x(() => {
      'use strict'
      ZB()
      JB = (function () {
        var e = /[^.]+$/.exec((X2 && X2.keys && X2.keys.IE_PROTO) || '')
        return e ? 'Symbol(src)_1.' + e : ''
      })()
      a(Vmt, 'isMasked')
      tF = Vmt
    })
  function Umt(e) {
    if (e != null) {
      try {
        return Wmt.call(e)
      } catch {}
      try {
        return e + ''
      } catch {}
    }
    return ''
  }
  var zmt,
    Wmt,
    dl,
    e4 = x(() => {
      'use strict'
      ;(zmt = Function.prototype), (Wmt = zmt.toString)
      a(Umt, 'toSource')
      dl = Umt
    })
  function Zmt(e) {
    if (!Nr(e) || tF(e)) return !1
    var t = vn(e) ? Qmt : qmt
    return t.test(dl(e))
  }
  var jmt,
    qmt,
    Hmt,
    Ymt,
    Xmt,
    Kmt,
    Qmt,
    rF,
    nF = x(() => {
      'use strict'
      l0()
      eF()
      As()
      e4()
      ;(jmt = /[\\^$.*+?()[\]{}|]/g),
        (qmt = /^\[object .+?Constructor\]$/),
        (Hmt = Function.prototype),
        (Ymt = Object.prototype),
        (Xmt = Hmt.toString),
        (Kmt = Ymt.hasOwnProperty),
        (Qmt = RegExp(
          '^' +
            Xmt.call(Kmt)
              .replace(jmt, '\\$&')
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
            '$',
        ))
      a(Zmt, 'baseIsNative')
      rF = Zmt
    })
  function Jmt(e, t) {
    return e?.[t]
  }
  var iF,
    sF = x(() => {
      'use strict'
      a(Jmt, 'getValue')
      iF = Jmt
    })
  function tgt(e, t) {
    var r = iF(e, t)
    return rF(r) ? r : void 0
  }
  var rs,
    hc = x(() => {
      'use strict'
      nF()
      sF()
      a(tgt, 'getNative')
      rs = tgt
    })
  var egt,
    pl,
    c0 = x(() => {
      'use strict'
      hc()
      ;(egt = rs(Object, 'create')), (pl = egt)
    })
  function rgt() {
    ;(this.__data__ = pl ? pl(null) : {}), (this.size = 0)
  }
  var aF,
    oF = x(() => {
      'use strict'
      c0()
      a(rgt, 'hashClear')
      aF = rgt
    })
  function ngt(e) {
    var t = this.has(e) && delete this.__data__[e]
    return (this.size -= t ? 1 : 0), t
  }
  var lF,
    cF = x(() => {
      'use strict'
      a(ngt, 'hashDelete')
      lF = ngt
    })
  function ogt(e) {
    var t = this.__data__
    if (pl) {
      var r = t[e]
      return r === igt ? void 0 : r
    }
    return agt.call(t, e) ? t[e] : void 0
  }
  var igt,
    sgt,
    agt,
    uF,
    hF = x(() => {
      'use strict'
      c0()
      ;(igt = '__lodash_hash_undefined__'), (sgt = Object.prototype), (agt = sgt.hasOwnProperty)
      a(ogt, 'hashGet')
      uF = ogt
    })
  function ugt(e) {
    var t = this.__data__
    return pl ? t[e] !== void 0 : cgt.call(t, e)
  }
  var lgt,
    cgt,
    fF,
    dF = x(() => {
      'use strict'
      c0()
      ;(lgt = Object.prototype), (cgt = lgt.hasOwnProperty)
      a(ugt, 'hashHas')
      fF = ugt
    })
  function fgt(e, t) {
    var r = this.__data__
    return (this.size += this.has(e) ? 0 : 1), (r[e] = pl && t === void 0 ? hgt : t), this
  }
  var hgt,
    pF,
    mF = x(() => {
      'use strict'
      c0()
      hgt = '__lodash_hash_undefined__'
      a(fgt, 'hashSet')
      pF = fgt
    })
  function zf(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  var r4,
    gF = x(() => {
      'use strict'
      oF()
      cF()
      hF()
      dF()
      mF()
      a(zf, 'Hash')
      zf.prototype.clear = aF
      zf.prototype.delete = lF
      zf.prototype.get = uF
      zf.prototype.has = fF
      zf.prototype.set = pF
      r4 = zf
    })
  function dgt() {
    ;(this.__data__ = []), (this.size = 0)
  }
  var yF,
    xF = x(() => {
      'use strict'
      a(dgt, 'listCacheClear')
      yF = dgt
    })
  function pgt(e, t) {
    return e === t || (e !== e && t !== t)
  }
  var Qs,
    Wu = x(() => {
      'use strict'
      a(pgt, 'eq')
      Qs = pgt
    })
  function mgt(e, t) {
    for (var r = e.length; r--; ) if (Qs(e[r][0], t)) return r
    return -1
  }
  var fc,
    u0 = x(() => {
      'use strict'
      Wu()
      a(mgt, 'assocIndexOf')
      fc = mgt
    })
  function xgt(e) {
    var t = this.__data__,
      r = fc(t, e)
    if (r < 0) return !1
    var n = t.length - 1
    return r == n ? t.pop() : ygt.call(t, r, 1), --this.size, !0
  }
  var ggt,
    ygt,
    bF,
    kF = x(() => {
      'use strict'
      u0()
      ;(ggt = Array.prototype), (ygt = ggt.splice)
      a(xgt, 'listCacheDelete')
      bF = xgt
    })
  function bgt(e) {
    var t = this.__data__,
      r = fc(t, e)
    return r < 0 ? void 0 : t[r][1]
  }
  var TF,
    SF = x(() => {
      'use strict'
      u0()
      a(bgt, 'listCacheGet')
      TF = bgt
    })
  function kgt(e) {
    return fc(this.__data__, e) > -1
  }
  var _F,
    CF = x(() => {
      'use strict'
      u0()
      a(kgt, 'listCacheHas')
      _F = kgt
    })
  function Tgt(e, t) {
    var r = this.__data__,
      n = fc(r, e)
    return n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this
  }
  var wF,
    EF = x(() => {
      'use strict'
      u0()
      a(Tgt, 'listCacheSet')
      wF = Tgt
    })
  function Wf(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  var dc,
    h0 = x(() => {
      'use strict'
      xF()
      kF()
      SF()
      CF()
      EF()
      a(Wf, 'ListCache')
      Wf.prototype.clear = yF
      Wf.prototype.delete = bF
      Wf.prototype.get = TF
      Wf.prototype.has = _F
      Wf.prototype.set = wF
      dc = Wf
    })
  var Sgt,
    pc,
    K2 = x(() => {
      'use strict'
      hc()
      Ks()
      ;(Sgt = rs(pn, 'Map')), (pc = Sgt)
    })
  function _gt() {
    ;(this.size = 0), (this.__data__ = { hash: new r4(), map: new (pc || dc)(), string: new r4() })
  }
  var vF,
    AF = x(() => {
      'use strict'
      gF()
      h0()
      K2()
      a(_gt, 'mapCacheClear')
      vF = _gt
    })
  function Cgt(e) {
    var t = typeof e
    return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean' ? e !== '__proto__' : e === null
  }
  var LF,
    RF = x(() => {
      'use strict'
      a(Cgt, 'isKeyable')
      LF = Cgt
    })
  function wgt(e, t) {
    var r = e.__data__
    return LF(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map
  }
  var mc,
    f0 = x(() => {
      'use strict'
      RF()
      a(wgt, 'getMapData')
      mc = wgt
    })
  function Egt(e) {
    var t = mc(this, e).delete(e)
    return (this.size -= t ? 1 : 0), t
  }
  var DF,
    NF = x(() => {
      'use strict'
      f0()
      a(Egt, 'mapCacheDelete')
      DF = Egt
    })
  function vgt(e) {
    return mc(this, e).get(e)
  }
  var IF,
    MF = x(() => {
      'use strict'
      f0()
      a(vgt, 'mapCacheGet')
      IF = vgt
    })
  function Agt(e) {
    return mc(this, e).has(e)
  }
  var OF,
    PF = x(() => {
      'use strict'
      f0()
      a(Agt, 'mapCacheHas')
      OF = Agt
    })
  function Lgt(e, t) {
    var r = mc(this, e),
      n = r.size
    return r.set(e, t), (this.size += r.size == n ? 0 : 1), this
  }
  var BF,
    FF = x(() => {
      'use strict'
      f0()
      a(Lgt, 'mapCacheSet')
      BF = Lgt
    })
  function Uf(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  var Uu,
    Q2 = x(() => {
      'use strict'
      AF()
      NF()
      MF()
      PF()
      FF()
      a(Uf, 'MapCache')
      Uf.prototype.clear = vF
      Uf.prototype.delete = DF
      Uf.prototype.get = IF
      Uf.prototype.has = OF
      Uf.prototype.set = BF
      Uu = Uf
    })
  function n4(e, t) {
    if (typeof e != 'function' || (t != null && typeof t != 'function')) throw new TypeError(Rgt)
    var r = a(function () {
      var n = arguments,
        i = t ? t.apply(this, n) : n[0],
        s = r.cache
      if (s.has(i)) return s.get(i)
      var o = e.apply(this, n)
      return (r.cache = s.set(i, o) || s), o
    }, 'memoized')
    return (r.cache = new (n4.Cache || Uu)()), r
  }
  var Rgt,
    jf,
    i4 = x(() => {
      'use strict'
      Q2()
      Rgt = 'Expected a function'
      a(n4, 'memoize')
      n4.Cache = Uu
      jf = n4
    })
  function Dgt() {
    ;(this.__data__ = new dc()), (this.size = 0)
  }
  var $F,
    GF = x(() => {
      'use strict'
      h0()
      a(Dgt, 'stackClear')
      $F = Dgt
    })
  function Ngt(e) {
    var t = this.__data__,
      r = t.delete(e)
    return (this.size = t.size), r
  }
  var VF,
    zF = x(() => {
      'use strict'
      a(Ngt, 'stackDelete')
      VF = Ngt
    })
  function Igt(e) {
    return this.__data__.get(e)
  }
  var WF,
    UF = x(() => {
      'use strict'
      a(Igt, 'stackGet')
      WF = Igt
    })
  function Mgt(e) {
    return this.__data__.has(e)
  }
  var jF,
    qF = x(() => {
      'use strict'
      a(Mgt, 'stackHas')
      jF = Mgt
    })
  function Pgt(e, t) {
    var r = this.__data__
    if (r instanceof dc) {
      var n = r.__data__
      if (!pc || n.length < Ogt - 1) return n.push([e, t]), (this.size = ++r.size), this
      r = this.__data__ = new Uu(n)
    }
    return r.set(e, t), (this.size = r.size), this
  }
  var Ogt,
    HF,
    YF = x(() => {
      'use strict'
      h0()
      K2()
      Q2()
      Ogt = 200
      a(Pgt, 'stackSet')
      HF = Pgt
    })
  function qf(e) {
    var t = (this.__data__ = new dc(e))
    this.size = t.size
  }
  var ho,
    d0 = x(() => {
      'use strict'
      h0()
      GF()
      zF()
      UF()
      qF()
      YF()
      a(qf, 'Stack')
      qf.prototype.clear = $F
      qf.prototype.delete = VF
      qf.prototype.get = WF
      qf.prototype.has = jF
      qf.prototype.set = HF
      ho = qf
    })
  var Bgt,
    Hf,
    s4 = x(() => {
      'use strict'
      hc()
      ;(Bgt = (function () {
        try {
          var e = rs(Object, 'defineProperty')
          return e({}, '', {}), e
        } catch {}
      })()),
        (Hf = Bgt)
    })
  function Fgt(e, t, r) {
    t == '__proto__' && Hf ? Hf(e, t, { configurable: !0, enumerable: !0, value: r, writable: !0 }) : (e[t] = r)
  }
  var fo,
    Yf = x(() => {
      'use strict'
      s4()
      a(Fgt, 'baseAssignValue')
      fo = Fgt
    })
  function $gt(e, t, r) {
    ;((r !== void 0 && !Qs(e[t], r)) || (r === void 0 && !(t in e))) && fo(e, t, r)
  }
  var p0,
    a4 = x(() => {
      'use strict'
      Yf()
      Wu()
      a($gt, 'assignMergeValue')
      p0 = $gt
    })
  function Ggt(e) {
    return function (t, r, n) {
      for (var i = -1, s = Object(t), o = n(t), l = o.length; l--; ) {
        var u = o[e ? l : ++i]
        if (r(s[u], u, s) === !1) break
      }
      return t
    }
  }
  var XF,
    KF = x(() => {
      'use strict'
      a(Ggt, 'createBaseFor')
      XF = Ggt
    })
  var Vgt,
    Xf,
    Z2 = x(() => {
      'use strict'
      KF()
      ;(Vgt = XF()), (Xf = Vgt)
    })
  function Wgt(e, t) {
    if (t) return e.slice()
    var r = e.length,
      n = JF ? JF(r) : new e.constructor(r)
    return e.copy(n), n
  }
  var t$,
    QF,
    zgt,
    ZF,
    JF,
    J2,
    o4 = x(() => {
      'use strict'
      Ks()
      ;(t$ = typeof exports == 'object' && exports && !exports.nodeType && exports),
        (QF = t$ && typeof module == 'object' && module && !module.nodeType && module),
        (zgt = QF && QF.exports === t$),
        (ZF = zgt ? pn.Buffer : void 0),
        (JF = ZF ? ZF.allocUnsafe : void 0)
      a(Wgt, 'cloneBuffer')
      J2 = Wgt
    })
  var Ugt,
    Kf,
    l4 = x(() => {
      'use strict'
      Ks()
      ;(Ugt = pn.Uint8Array), (Kf = Ugt)
    })
  function jgt(e) {
    var t = new e.constructor(e.byteLength)
    return new Kf(t).set(new Kf(e)), t
  }
  var Qf,
    tb = x(() => {
      'use strict'
      l4()
      a(jgt, 'cloneArrayBuffer')
      Qf = jgt
    })
  function qgt(e, t) {
    var r = t ? Qf(e.buffer) : e.buffer
    return new e.constructor(r, e.byteOffset, e.length)
  }
  var eb,
    c4 = x(() => {
      'use strict'
      tb()
      a(qgt, 'cloneTypedArray')
      eb = qgt
    })
  function Hgt(e, t) {
    var r = -1,
      n = e.length
    for (t || (t = Array(n)); ++r < n; ) t[r] = e[r]
    return t
  }
  var rb,
    u4 = x(() => {
      'use strict'
      a(Hgt, 'copyArray')
      rb = Hgt
    })
  var e$,
    Ygt,
    r$,
    n$ = x(() => {
      'use strict'
      As()
      ;(e$ = Object.create),
        (Ygt = (function () {
          function e() {}
          return (
            a(e, 'object'),
            function (t) {
              if (!Nr(t)) return {}
              if (e$) return e$(t)
              e.prototype = t
              var r = new e()
              return (e.prototype = void 0), r
            }
          )
        })()),
        (r$ = Ygt)
    })
  function Xgt(e, t) {
    return function (r) {
      return e(t(r))
    }
  }
  var nb,
    h4 = x(() => {
      'use strict'
      a(Xgt, 'overArg')
      nb = Xgt
    })
  var Kgt,
    Zf,
    ib = x(() => {
      'use strict'
      h4()
      ;(Kgt = nb(Object.getPrototypeOf, Object)), (Zf = Kgt)
    })
  function Zgt(e) {
    var t = e && e.constructor,
      r = (typeof t == 'function' && t.prototype) || Qgt
    return e === r
  }
  var Qgt,
    po,
    Jf = x(() => {
      'use strict'
      Qgt = Object.prototype
      a(Zgt, 'isPrototype')
      po = Zgt
    })
  function Jgt(e) {
    return typeof e.constructor == 'function' && !po(e) ? r$(Zf(e)) : {}
  }
  var sb,
    f4 = x(() => {
      'use strict'
      n$()
      ib()
      Jf()
      a(Jgt, 'initCloneObject')
      sb = Jgt
    })
  function t0t(e) {
    return e != null && typeof e == 'object'
  }
  var on,
    Zs = x(() => {
      'use strict'
      a(t0t, 'isObjectLike')
      on = t0t
    })
  function r0t(e) {
    return on(e) && ni(e) == e0t
  }
  var e0t,
    d4,
    i$ = x(() => {
      'use strict'
      fl()
      Zs()
      e0t = '[object Arguments]'
      a(r0t, 'baseIsArguments')
      d4 = r0t
    })
  var s$,
    n0t,
    i0t,
    s0t,
    Pa,
    td = x(() => {
      'use strict'
      i$()
      Zs()
      ;(s$ = Object.prototype),
        (n0t = s$.hasOwnProperty),
        (i0t = s$.propertyIsEnumerable),
        (s0t = d4(
          (function () {
            return arguments
          })(),
        )
          ? d4
          : function (e) {
              return on(e) && n0t.call(e, 'callee') && !i0t.call(e, 'callee')
            }),
        (Pa = s0t)
    })
  var a0t,
    Jt,
    Qr = x(() => {
      'use strict'
      ;(a0t = Array.isArray), (Jt = a0t)
    })
  function l0t(e) {
    return typeof e == 'number' && e > -1 && e % 1 == 0 && e <= o0t
  }
  var o0t,
    ed,
    ab = x(() => {
      'use strict'
      o0t = 9007199254740991
      a(l0t, 'isLength')
      ed = l0t
    })
  function c0t(e) {
    return e != null && ed(e.length) && !vn(e)
  }
  var mn,
    Js = x(() => {
      'use strict'
      l0()
      ab()
      a(c0t, 'isArrayLike')
      mn = c0t
    })
  function u0t(e) {
    return on(e) && mn(e)
  }
  var ju,
    ob = x(() => {
      'use strict'
      Js()
      Zs()
      a(u0t, 'isArrayLikeObject')
      ju = u0t
    })
  function h0t() {
    return !1
  }
  var a$,
    o$ = x(() => {
      'use strict'
      a(h0t, 'stubFalse')
      a$ = h0t
    })
  var u$,
    l$,
    f0t,
    c$,
    d0t,
    p0t,
    Ba,
    rd = x(() => {
      'use strict'
      Ks()
      o$()
      ;(u$ = typeof exports == 'object' && exports && !exports.nodeType && exports),
        (l$ = u$ && typeof module == 'object' && module && !module.nodeType && module),
        (f0t = l$ && l$.exports === u$),
        (c$ = f0t ? pn.Buffer : void 0),
        (d0t = c$ ? c$.isBuffer : void 0),
        (p0t = d0t || a$),
        (Ba = p0t)
    })
  function k0t(e) {
    if (!on(e) || ni(e) != m0t) return !1
    var t = Zf(e)
    if (t === null) return !0
    var r = x0t.call(t, 'constructor') && t.constructor
    return typeof r == 'function' && r instanceof r && h$.call(r) == b0t
  }
  var m0t,
    g0t,
    y0t,
    h$,
    x0t,
    b0t,
    f$,
    d$ = x(() => {
      'use strict'
      fl()
      ib()
      Zs()
      ;(m0t = '[object Object]'),
        (g0t = Function.prototype),
        (y0t = Object.prototype),
        (h$ = g0t.toString),
        (x0t = y0t.hasOwnProperty),
        (b0t = h$.call(Object))
      a(k0t, 'isPlainObject')
      f$ = k0t
    })
  function j0t(e) {
    return on(e) && ed(e.length) && !!Yr[ni(e)]
  }
  var T0t,
    S0t,
    _0t,
    C0t,
    w0t,
    E0t,
    v0t,
    A0t,
    L0t,
    R0t,
    D0t,
    N0t,
    I0t,
    M0t,
    O0t,
    P0t,
    B0t,
    F0t,
    $0t,
    G0t,
    V0t,
    z0t,
    W0t,
    U0t,
    Yr,
    p$,
    m$ = x(() => {
      'use strict'
      fl()
      ab()
      Zs()
      ;(T0t = '[object Arguments]'),
        (S0t = '[object Array]'),
        (_0t = '[object Boolean]'),
        (C0t = '[object Date]'),
        (w0t = '[object Error]'),
        (E0t = '[object Function]'),
        (v0t = '[object Map]'),
        (A0t = '[object Number]'),
        (L0t = '[object Object]'),
        (R0t = '[object RegExp]'),
        (D0t = '[object Set]'),
        (N0t = '[object String]'),
        (I0t = '[object WeakMap]'),
        (M0t = '[object ArrayBuffer]'),
        (O0t = '[object DataView]'),
        (P0t = '[object Float32Array]'),
        (B0t = '[object Float64Array]'),
        (F0t = '[object Int8Array]'),
        ($0t = '[object Int16Array]'),
        (G0t = '[object Int32Array]'),
        (V0t = '[object Uint8Array]'),
        (z0t = '[object Uint8ClampedArray]'),
        (W0t = '[object Uint16Array]'),
        (U0t = '[object Uint32Array]'),
        (Yr = {})
      Yr[P0t] = Yr[B0t] = Yr[F0t] = Yr[$0t] = Yr[G0t] = Yr[V0t] = Yr[z0t] = Yr[W0t] = Yr[U0t] = !0
      Yr[T0t] =
        Yr[S0t] =
        Yr[M0t] =
        Yr[_0t] =
        Yr[O0t] =
        Yr[C0t] =
        Yr[w0t] =
        Yr[E0t] =
        Yr[v0t] =
        Yr[A0t] =
        Yr[L0t] =
        Yr[R0t] =
        Yr[D0t] =
        Yr[N0t] =
        Yr[I0t] =
          !1
      a(j0t, 'baseIsTypedArray')
      p$ = j0t
    })
  function q0t(e) {
    return function (t) {
      return e(t)
    }
  }
  var ta,
    qu = x(() => {
      'use strict'
      a(q0t, 'baseUnary')
      ta = q0t
    })
  var g$,
    m0,
    H0t,
    p4,
    Y0t,
    ea,
    g0 = x(() => {
      'use strict'
      t4()
      ;(g$ = typeof exports == 'object' && exports && !exports.nodeType && exports),
        (m0 = g$ && typeof module == 'object' && module && !module.nodeType && module),
        (H0t = m0 && m0.exports === g$),
        (p4 = H0t && Y2.process),
        (Y0t = (function () {
          try {
            var e = m0 && m0.require && m0.require('util').types
            return e || (p4 && p4.binding && p4.binding('util'))
          } catch {}
        })()),
        (ea = Y0t)
    })
  var y$,
    X0t,
    gc,
    y0 = x(() => {
      'use strict'
      m$()
      qu()
      g0()
      ;(y$ = ea && ea.isTypedArray), (X0t = y$ ? ta(y$) : p$), (gc = X0t)
    })
  function K0t(e, t) {
    if (!(t === 'constructor' && typeof e[t] == 'function') && t != '__proto__') return e[t]
  }
  var x0,
    m4 = x(() => {
      'use strict'
      a(K0t, 'safeGet')
      x0 = K0t
    })
  function J0t(e, t, r) {
    var n = e[t]
    ;(!(Z0t.call(e, t) && Qs(n, r)) || (r === void 0 && !(t in e))) && fo(e, t, r)
  }
  var Q0t,
    Z0t,
    mo,
    nd = x(() => {
      'use strict'
      Yf()
      Wu()
      ;(Q0t = Object.prototype), (Z0t = Q0t.hasOwnProperty)
      a(J0t, 'assignValue')
      mo = J0t
    })
  function t1t(e, t, r, n) {
    var i = !r
    r || (r = {})
    for (var s = -1, o = t.length; ++s < o; ) {
      var l = t[s],
        u = n ? n(r[l], e[l], l, r, e) : void 0
      u === void 0 && (u = e[l]), i ? fo(r, l, u) : mo(r, l, u)
    }
    return r
  }
  var ra,
    Hu = x(() => {
      'use strict'
      nd()
      Yf()
      a(t1t, 'copyObject')
      ra = t1t
    })
  function e1t(e, t) {
    for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r)
    return n
  }
  var x$,
    b$ = x(() => {
      'use strict'
      a(e1t, 'baseTimes')
      x$ = e1t
    })
  function i1t(e, t) {
    var r = typeof e
    return (t = t ?? r1t), !!t && (r == 'number' || (r != 'symbol' && n1t.test(e))) && e > -1 && e % 1 == 0 && e < t
  }
  var r1t,
    n1t,
    yc,
    b0 = x(() => {
      'use strict'
      ;(r1t = 9007199254740991), (n1t = /^(?:0|[1-9]\d*)$/)
      a(i1t, 'isIndex')
      yc = i1t
    })
  function o1t(e, t) {
    var r = Jt(e),
      n = !r && Pa(e),
      i = !r && !n && Ba(e),
      s = !r && !n && !i && gc(e),
      o = r || n || i || s,
      l = o ? x$(e.length, String) : [],
      u = l.length
    for (var h in e)
      (t || a1t.call(e, h)) &&
        !(
          o &&
          (h == 'length' ||
            (i && (h == 'offset' || h == 'parent')) ||
            (s && (h == 'buffer' || h == 'byteLength' || h == 'byteOffset')) ||
            yc(h, u))
        ) &&
        l.push(h)
    return l
  }
  var s1t,
    a1t,
    lb,
    g4 = x(() => {
      'use strict'
      b$()
      td()
      Qr()
      rd()
      b0()
      y0()
      ;(s1t = Object.prototype), (a1t = s1t.hasOwnProperty)
      a(o1t, 'arrayLikeKeys')
      lb = o1t
    })
  function l1t(e) {
    var t = []
    if (e != null) for (var r in Object(e)) t.push(r)
    return t
  }
  var k$,
    T$ = x(() => {
      'use strict'
      a(l1t, 'nativeKeysIn')
      k$ = l1t
    })
  function h1t(e) {
    if (!Nr(e)) return k$(e)
    var t = po(e),
      r = []
    for (var n in e) (n == 'constructor' && (t || !u1t.call(e, n))) || r.push(n)
    return r
  }
  var c1t,
    u1t,
    S$,
    _$ = x(() => {
      'use strict'
      As()
      Jf()
      T$()
      ;(c1t = Object.prototype), (u1t = c1t.hasOwnProperty)
      a(h1t, 'baseKeysIn')
      S$ = h1t
    })
  function f1t(e) {
    return mn(e) ? lb(e, !0) : S$(e)
  }
  var ns,
    xc = x(() => {
      'use strict'
      g4()
      _$()
      Js()
      a(f1t, 'keysIn')
      ns = f1t
    })
  function d1t(e) {
    return ra(e, ns(e))
  }
  var C$,
    w$ = x(() => {
      'use strict'
      Hu()
      xc()
      a(d1t, 'toPlainObject')
      C$ = d1t
    })
  function p1t(e, t, r, n, i, s, o) {
    var l = x0(e, r),
      u = x0(t, r),
      h = o.get(u)
    if (h) {
      p0(e, r, h)
      return
    }
    var f = s ? s(l, u, r + '', e, t, o) : void 0,
      d = f === void 0
    if (d) {
      var p = Jt(u),
        m = !p && Ba(u),
        g = !p && !m && gc(u)
      ;(f = u),
        p || m || g
          ? Jt(l)
            ? (f = l)
            : ju(l)
              ? (f = rb(l))
              : m
                ? ((d = !1), (f = J2(u, !0)))
                : g
                  ? ((d = !1), (f = eb(u, !0)))
                  : (f = [])
          : f$(u) || Pa(u)
            ? ((f = l), Pa(l) ? (f = C$(l)) : (!Nr(l) || vn(l)) && (f = sb(u)))
            : (d = !1)
    }
    d && (o.set(u, f), i(f, u, n, s, o), o.delete(u)), p0(e, r, f)
  }
  var E$,
    v$ = x(() => {
      'use strict'
      a4()
      o4()
      c4()
      u4()
      f4()
      td()
      Qr()
      ob()
      rd()
      l0()
      As()
      d$()
      y0()
      m4()
      w$()
      a(p1t, 'baseMergeDeep')
      E$ = p1t
    })
  function A$(e, t, r, n, i) {
    e !== t &&
      Xf(
        t,
        function (s, o) {
          if ((i || (i = new ho()), Nr(s))) E$(e, t, o, r, A$, n, i)
          else {
            var l = n ? n(x0(e, o), s, o + '', e, t, i) : void 0
            l === void 0 && (l = s), p0(e, o, l)
          }
        },
        ns,
      )
  }
  var L$,
    R$ = x(() => {
      'use strict'
      d0()
      a4()
      Z2()
      v$()
      As()
      xc()
      m4()
      a(A$, 'baseMerge')
      L$ = A$
    })
  function m1t(e) {
    return e
  }
  var Hn,
    ml = x(() => {
      'use strict'
      a(m1t, 'identity')
      Hn = m1t
    })
  function g1t(e, t, r) {
    switch (r.length) {
      case 0:
        return e.call(t)
      case 1:
        return e.call(t, r[0])
      case 2:
        return e.call(t, r[0], r[1])
      case 3:
        return e.call(t, r[0], r[1], r[2])
    }
    return e.apply(t, r)
  }
  var D$,
    N$ = x(() => {
      'use strict'
      a(g1t, 'apply')
      D$ = g1t
    })
  function y1t(e, t, r) {
    return (
      (t = I$(t === void 0 ? e.length - 1 : t, 0)),
      function () {
        for (var n = arguments, i = -1, s = I$(n.length - t, 0), o = Array(s); ++i < s; ) o[i] = n[t + i]
        i = -1
        for (var l = Array(t + 1); ++i < t; ) l[i] = n[i]
        return (l[t] = r(o)), D$(e, this, l)
      }
    )
  }
  var I$,
    cb,
    y4 = x(() => {
      'use strict'
      N$()
      I$ = Math.max
      a(y1t, 'overRest')
      cb = y1t
    })
  function x1t(e) {
    return function () {
      return e
    }
  }
  var is,
    x4 = x(() => {
      'use strict'
      a(x1t, 'constant')
      is = x1t
    })
  var b1t,
    M$,
    O$ = x(() => {
      'use strict'
      x4()
      s4()
      ml()
      ;(b1t = Hf
        ? function (e, t) {
            return Hf(e, 'toString', { configurable: !0, enumerable: !1, value: is(t), writable: !0 })
          }
        : Hn),
        (M$ = b1t)
    })
  function _1t(e) {
    var t = 0,
      r = 0
    return function () {
      var n = S1t(),
        i = T1t - (n - r)
      if (((r = n), i > 0)) {
        if (++t >= k1t) return arguments[0]
      } else t = 0
      return e.apply(void 0, arguments)
    }
  }
  var k1t,
    T1t,
    S1t,
    P$,
    B$ = x(() => {
      'use strict'
      ;(k1t = 800), (T1t = 16), (S1t = Date.now)
      a(_1t, 'shortOut')
      P$ = _1t
    })
  var C1t,
    ub,
    b4 = x(() => {
      'use strict'
      O$()
      B$()
      ;(C1t = P$(M$)), (ub = C1t)
    })
  function w1t(e, t) {
    return ub(cb(e, t, Hn), e + '')
  }
  var go,
    id = x(() => {
      'use strict'
      ml()
      y4()
      b4()
      a(w1t, 'baseRest')
      go = w1t
    })
  function E1t(e, t, r) {
    if (!Nr(r)) return !1
    var n = typeof t
    return (n == 'number' ? mn(r) && yc(t, r.length) : n == 'string' && t in r) ? Qs(r[t], e) : !1
  }
  var Ls,
    Yu = x(() => {
      'use strict'
      Wu()
      Js()
      b0()
      As()
      a(E1t, 'isIterateeCall')
      Ls = E1t
    })
  function v1t(e) {
    return go(function (t, r) {
      var n = -1,
        i = r.length,
        s = i > 1 ? r[i - 1] : void 0,
        o = i > 2 ? r[2] : void 0
      for (
        s = e.length > 3 && typeof s == 'function' ? (i--, s) : void 0,
          o && Ls(r[0], r[1], o) && ((s = i < 3 ? void 0 : s), (i = 1)),
          t = Object(t);
        ++n < i;

      ) {
        var l = r[n]
        l && e(t, l, n, s)
      }
      return t
    })
  }
  var hb,
    k4 = x(() => {
      'use strict'
      id()
      Yu()
      a(v1t, 'createAssigner')
      hb = v1t
    })
  var A1t,
    bc,
    T4 = x(() => {
      'use strict'
      R$()
      k4()
      ;(A1t = hb(function (e, t, r) {
        L$(e, t, r)
      })),
        (bc = A1t)
    })
  function C4(e, t) {
    if (!e) return t
    let r = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`
    return L1t[r] ?? t
  }
  function I1t(e, t) {
    let r = e.trim()
    if (r) return t.securityLevel !== 'loose' ? (0, G$.sanitizeUrl)(r) : r
  }
  function W$(e, t) {
    return !e || !t ? 0 : Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
  }
  function O1t(e) {
    let t,
      r = 0
    e.forEach((i) => {
      ;(r += W$(i, t)), (t = i)
    })
    let n = r / 2
    return w4(e, n)
  }
  function P1t(e) {
    return e.length === 1 ? e[0] : O1t(e)
  }
  function F1t(e, t, r) {
    let n = structuredClone(r)
    B.info('our points', n), t !== 'start_left' && t !== 'start_right' && n.reverse()
    let i = 25 + e,
      s = w4(n, i),
      o = 10 + e * 0.5,
      l = Math.atan2(n[0].y - s.y, n[0].x - s.x),
      u = { x: 0, y: 0 }
    return (
      t === 'start_left'
        ? ((u.x = Math.sin(l + Math.PI) * o + (n[0].x + s.x) / 2),
          (u.y = -Math.cos(l + Math.PI) * o + (n[0].y + s.y) / 2))
        : t === 'end_right'
          ? ((u.x = Math.sin(l - Math.PI) * o + (n[0].x + s.x) / 2 - 5),
            (u.y = -Math.cos(l - Math.PI) * o + (n[0].y + s.y) / 2 - 5))
          : t === 'end_left'
            ? ((u.x = Math.sin(l) * o + (n[0].x + s.x) / 2 - 5), (u.y = -Math.cos(l) * o + (n[0].y + s.y) / 2 - 5))
            : ((u.x = Math.sin(l) * o + (n[0].x + s.x) / 2), (u.y = -Math.cos(l) * o + (n[0].y + s.y) / 2)),
      u
    )
  }
  function E4(e) {
    let t = '',
      r = ''
    for (let n of e)
      n !== void 0 && (n.startsWith('color:') || n.startsWith('text-align:') ? (r = r + n + ';') : (t = t + n + ';'))
    return { style: t, labelStyle: r }
  }
  function $1t(e) {
    let t = '',
      r = '0123456789abcdef',
      n = r.length
    for (let i = 0; i < e; i++) t += r.charAt(Math.floor(Math.random() * n))
    return t
  }
  function db(e, t) {
    return R4(e, t).height
  }
  function Yn(e, t) {
    return R4(e, t).width
  }
  function D4(e) {
    return 'str' in e
  }
  function ln(e, t) {
    return bc({}, e, t)
  }
  function Ir(e) {
    return e ?? null
  }
  function j1t(e, t) {
    let r = Math.round(e.x),
      n = Math.round(e.y),
      i = t.replace(/(\d+\.\d+)/g, (s) => Math.round(parseFloat(s)).toString())
    return i.includes(r.toString()) || i.includes(n.toString())
  }
  var G$,
    _4,
    L1t,
    R1t,
    D1t,
    V$,
    z$,
    N1t,
    M1t,
    F$,
    w4,
    B1t,
    $$,
    v4,
    A4,
    G1t,
    V1t,
    L4,
    z1t,
    R4,
    S4,
    fb,
    W1t,
    U1t,
    yo,
    le,
    U$,
    Xn,
    kc,
    Ce = x(() => {
      'use strict'
      G$ = Ss(Vf(), 1)
      Ge()
      Be()
      tw()
      Vt()
      Tu()
      of()
      i4()
      T4()
      Tx()
      ;(_4 = '\u200B'),
        (L1t = {
          curveBasis: Xs,
          curveBasisClosed: M2,
          curveBasisOpen: O2,
          curveBumpX: qg,
          curveBumpY: Hg,
          curveBundle: V3,
          curveCardinalClosed: z3,
          curveCardinalOpen: U3,
          curveCardinal: Qg,
          curveCatmullRomClosed: q3,
          curveCatmullRomOpen: H3,
          curveCatmullRom: t0,
          curveLinear: ul,
          curveLinearClosed: G2,
          curveMonotoneX: e0,
          curveMonotoneY: r0,
          curveNatural: $f,
          curveStep: Gf,
          curveStepAfter: i0,
          curveStepBefore: n0,
        }),
        (R1t = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi),
        (D1t = a(function (e, t) {
          let r = V$(e, /(?:init\b)|(?:initialize\b)/),
            n = {}
          if (Array.isArray(r)) {
            let o = r.map((l) => l.args)
            cf(o), (n = Kr(n, [...o]))
          } else n = r.args
          if (!n) return
          let i = pf(e, t),
            s = 'config'
          return n[s] !== void 0 && (i === 'flowchart-v2' && (i = 'flowchart'), (n[i] = n[s]), delete n[s]), n
        }, 'detectInit')),
        (V$ = a(function (e, t = null) {
          try {
            let r = new RegExp(
              `[%]{2}(?![{]${R1t.source})(?=[}][%]{2}).*
`,
              'ig',
            )
            ;(e = e.trim().replace(r, '').replace(/'/gm, '"')),
              B.debug(`Detecting diagram directive${t !== null ? ' type:' + t : ''} based on the text:${e}`)
            let n,
              i = []
            for (; (n = ku.exec(e)) !== null; )
              if (
                (n.index === ku.lastIndex && ku.lastIndex++,
                (n && !t) || (t && n[1]?.match(t)) || (t && n[2]?.match(t)))
              ) {
                let s = n[1] ? n[1] : n[2],
                  o = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null
                i.push({ type: s, args: o })
              }
            return i.length === 0 ? { type: e, args: null } : i.length === 1 ? i[0] : i
          } catch (r) {
            return (
              B.error(`ERROR: ${r.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`),
              { type: void 0, args: null }
            )
          }
        }, 'detectDirective')),
        (z$ = a(function (e) {
          return e.replace(ku, '')
        }, 'removeDirectives')),
        (N1t = a(function (e, t) {
          for (let [r, n] of t.entries()) if (n.match(e)) return r
          return -1
        }, 'isSubstringInArray'))
      a(C4, 'interpolateToCurve')
      a(I1t, 'formatUrl')
      M1t = a((e, ...t) => {
        let r = e.split('.'),
          n = r.length - 1,
          i = r[n],
          s = window
        for (let o = 0; o < n; o++)
          if (((s = s[r[o]]), !s)) {
            B.error(`Function name: ${e} not found in window`)
            return
          }
        s[i](...t)
      }, 'runFunc')
      a(W$, 'distance')
      a(O1t, 'traverseEdge')
      a(P1t, 'calcLabelPosition')
      ;(F$ = a((e, t = 2) => {
        let r = Math.pow(10, t)
        return Math.round(e * r) / r
      }, 'roundNumber')),
        (w4 = a((e, t) => {
          let r,
            n = t
          for (let i of e) {
            if (r) {
              let s = W$(i, r)
              if (s === 0) return r
              if (s < n) n -= s
              else {
                let o = n / s
                if (o <= 0) return r
                if (o >= 1) return { x: i.x, y: i.y }
                if (o > 0 && o < 1) return { x: F$((1 - o) * r.x + o * i.x, 5), y: F$((1 - o) * r.y + o * i.y, 5) }
              }
            }
            r = i
          }
          throw new Error('Could not find a suitable point for the given distance')
        }, 'calculatePoint')),
        (B1t = a((e, t, r) => {
          B.info(`our points ${JSON.stringify(t)}`), t[0] !== r && (t = t.reverse())
          let i = w4(t, 25),
            s = e ? 10 : 5,
            o = Math.atan2(t[0].y - i.y, t[0].x - i.x),
            l = { x: 0, y: 0 }
          return (l.x = Math.sin(o) * s + (t[0].x + i.x) / 2), (l.y = -Math.cos(o) * s + (t[0].y + i.y) / 2), l
        }, 'calcCardinalityPosition'))
      a(F1t, 'calcTerminalLabelPosition')
      a(E4, 'getStylesFromArray')
      ;($$ = 0), (v4 = a(() => ($$++, 'id-' + Math.random().toString(36).substr(2, 12) + '-' + $$), 'generateId'))
      a($1t, 'makeRandomHex')
      ;(A4 = a((e) => $1t(e.length), 'random')),
        (G1t = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            anchor: 'start',
            style: '#666',
            width: 100,
            height: 100,
            textMargin: 0,
            rx: 0,
            ry: 0,
            valign: void 0,
            text: '',
          }
        }, 'getTextObj')),
        (V1t = a(function (e, t) {
          let r = t.text.replace(Rt.lineBreakRegex, ' '),
            [, n] = yo(t.fontSize),
            i = e.append('text')
          i.attr('x', t.x),
            i.attr('y', t.y),
            i.style('text-anchor', t.anchor),
            i.style('font-family', t.fontFamily),
            i.style('font-size', n),
            i.style('font-weight', t.fontWeight),
            i.attr('fill', t.fill),
            t.class !== void 0 && i.attr('class', t.class)
          let s = i.append('tspan')
          return s.attr('x', t.x + t.textMargin * 2), s.attr('fill', t.fill), s.text(r), i
        }, 'drawSimpleText')),
        (L4 = jf(
          (e, t, r) => {
            if (
              !e ||
              ((r = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial', joinWith: '<br/>' }, r)),
              Rt.lineBreakRegex.test(e))
            )
              return e
            let n = e.split(' ').filter(Boolean),
              i = [],
              s = ''
            return (
              n.forEach((o, l) => {
                let u = Yn(`${o} `, r),
                  h = Yn(s, r)
                if (u > t) {
                  let { hyphenatedStrings: p, remainingWord: m } = z1t(o, t, '-', r)
                  i.push(s, ...p), (s = m)
                } else h + u >= t ? (i.push(s), (s = o)) : (s = [s, o].filter(Boolean).join(' '))
                l + 1 === n.length && i.push(s)
              }),
              i.filter((o) => o !== '').join(r.joinWith)
            )
          },
          (e, t, r) => `${e}${t}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`,
        )),
        (z1t = jf(
          (e, t, r = '-', n) => {
            n = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial', margin: 0 }, n)
            let i = [...e],
              s = [],
              o = ''
            return (
              i.forEach((l, u) => {
                let h = `${o}${l}`
                if (Yn(h, n) >= t) {
                  let d = u + 1,
                    p = i.length === d,
                    m = `${h}${r}`
                  s.push(p ? h : m), (o = '')
                } else o = h
              }),
              { hyphenatedStrings: s, remainingWord: o }
            )
          },
          (e, t, r = '-', n) => `${e}${t}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`,
        ))
      a(db, 'calculateTextHeight')
      a(Yn, 'calculateTextWidth')
      ;(R4 = jf(
        (e, t) => {
          let { fontSize: r = 12, fontFamily: n = 'Arial', fontWeight: i = 400 } = t
          if (!e) return { width: 0, height: 0 }
          let [, s] = yo(r),
            o = ['sans-serif', n],
            l = e.split(Rt.lineBreakRegex),
            u = [],
            h = xt('body')
          if (!h.remove) return { width: 0, height: 0, lineHeight: 0 }
          let f = h.append('svg')
          for (let p of o) {
            let m = 0,
              g = { width: 0, height: 0, lineHeight: 0 }
            for (let y of l) {
              let b = G1t()
              b.text = y || _4
              let k = V1t(f, b).style('font-size', s).style('font-weight', i).style('font-family', p),
                T = (k._groups || k)[0][0].getBBox()
              if (T.width === 0 && T.height === 0) throw new Error('svg element not in render tree')
              ;(g.width = Math.round(Math.max(g.width, T.width))),
                (m = Math.round(T.height)),
                (g.height += m),
                (g.lineHeight = Math.round(Math.max(g.lineHeight, m)))
            }
            u.push(g)
          }
          f.remove()
          let d =
            isNaN(u[1].height) ||
            isNaN(u[1].width) ||
            isNaN(u[1].lineHeight) ||
            (u[0].height > u[1].height && u[0].width > u[1].width && u[0].lineHeight > u[1].lineHeight)
              ? 0
              : 1
          return u[d]
        },
        (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`,
      )),
        (S4 = class {
          constructor(t = !1, r) {
            this.count = 0
            ;(this.count = r ? r.length : 0), (this.next = t ? () => this.count++ : () => Date.now())
          }
          static {
            a(this, 'InitIDGenerator')
          }
        }),
        (W1t = a(function (e) {
          return (
            (fb = fb || document.createElement('div')),
            (e = escape(e).replace(/%26/g, '&').replace(/%23/g, '#').replace(/%3B/g, ';')),
            (fb.innerHTML = e),
            unescape(fb.textContent)
          )
        }, 'entityDecode'))
      a(D4, 'isDetailedError')
      ;(U1t = a((e, t, r, n) => {
        if (!n) return
        let i = e.node()?.getBBox()
        i &&
          e
            .append('text')
            .text(n)
            .attr('text-anchor', 'middle')
            .attr('x', i.x + i.width / 2)
            .attr('y', -r)
            .attr('class', t)
      }, 'insertTitle')),
        (yo = a((e) => {
          if (typeof e == 'number') return [e, e + 'px']
          let t = parseInt(e ?? '', 10)
          return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + 'px'] : [t, e]
        }, 'parseFontSize'))
      a(ln, 'cleanAndMerge')
      ;(le = {
        assignWithDepth: Kr,
        wrapLabel: L4,
        calculateTextHeight: db,
        calculateTextWidth: Yn,
        calculateTextDimensions: R4,
        cleanAndMerge: ln,
        detectInit: D1t,
        detectDirective: V$,
        isSubstringInArray: N1t,
        interpolateToCurve: C4,
        calcLabelPosition: P1t,
        calcCardinalityPosition: B1t,
        calcTerminalLabelPosition: F1t,
        formatUrl: I1t,
        getStylesFromArray: E4,
        generateId: v4,
        random: A4,
        runFunc: M1t,
        entityDecode: W1t,
        insertTitle: U1t,
        isLabelCoordinateInPath: j1t,
        parseFontSize: yo,
        InitIDGenerator: S4,
      }),
        (U$ = a(function (e) {
          let t = e
          return (
            (t = t.replace(/style.*:\S*#.*;/g, function (r) {
              return r.substring(0, r.length - 1)
            })),
            (t = t.replace(/classDef.*:\S*#.*;/g, function (r) {
              return r.substring(0, r.length - 1)
            })),
            (t = t.replace(/#\w+;/g, function (r) {
              let n = r.substring(1, r.length - 1)
              return /^\+?\d+$/.test(n) ? '\uFB02\xB0\xB0' + n + '\xB6\xDF' : '\uFB02\xB0' + n + '\xB6\xDF'
            })),
            t
          )
        }, 'encodeEntities')),
        (Xn = a(function (e) {
          return e.replace(//g, '&#').replace(//g, '&').replace(//g, ';')
        }, 'decodeEntities')),
        (kc = a(
          (e, t, { counter: r = 0, prefix: n, suffix: i }, s) =>
            s || `${n ? `${n}_` : ''}${e}_${t}_${r}${i ? `_${i}` : ''}`,
          'getEdgeId',
        ))
      a(Ir, 'handleUndefinedAttr')
      a(j1t, 'isLabelCoordinateInPath')
    })
  function Fa(e, t, r, n, i) {
    if (!t[e].width)
      if (r)
        (t[e].text = L4(t[e].text, i, n)),
          (t[e].textLines = t[e].text.split(Rt.lineBreakRegex).length),
          (t[e].width = i),
          (t[e].height = db(t[e].text, n))
      else {
        let s = t[e].text.split(Rt.lineBreakRegex)
        t[e].textLines = s.length
        let o = 0
        ;(t[e].height = 0), (t[e].width = 0)
        for (let l of s) (t[e].width = Math.max(Yn(l, n), t[e].width)), (o = db(l, n)), (t[e].height = t[e].height + o)
      }
  }
  function X$(e, t, r, n, i) {
    let s = new yb(i)
    s.data.widthLimit = r.data.widthLimit / Math.min(N4, n.length)
    for (let [o, l] of n.entries()) {
      let u = 0
      ;(l.image = { width: 0, height: 0, Y: 0 }),
        l.sprite && ((l.image.width = 48), (l.image.height = 48), (l.image.Y = u), (u = l.image.Y + l.image.height))
      let h = l.wrap && he.wrap,
        f = pb(he)
      if (
        ((f.fontSize = f.fontSize + 2),
        (f.fontWeight = 'bold'),
        Fa('label', l, h, f, s.data.widthLimit),
        (l.label.Y = u + 8),
        (u = l.label.Y + l.label.height),
        l.type && l.type.text !== '')
      ) {
        l.type.text = '[' + l.type.text + ']'
        let g = pb(he)
        Fa('type', l, h, g, s.data.widthLimit), (l.type.Y = u + 5), (u = l.type.Y + l.type.height)
      }
      if (l.descr && l.descr.text !== '') {
        let g = pb(he)
        ;(g.fontSize = g.fontSize - 2),
          Fa('descr', l, h, g, s.data.widthLimit),
          (l.descr.Y = u + 20),
          (u = l.descr.Y + l.descr.height)
      }
      if (o == 0 || o % N4 === 0) {
        let g = r.data.startx + he.diagramMarginX,
          y = r.data.stopy + he.diagramMarginY + u
        s.setData(g, g, y, y)
      } else {
        let g = s.data.stopx !== s.data.startx ? s.data.stopx + he.diagramMarginX : s.data.startx,
          y = s.data.starty
        s.setData(g, g, y, y)
      }
      s.name = l.alias
      let d = i.db.getC4ShapeArray(l.alias),
        p = i.db.getC4ShapeKeys(l.alias)
      p.length > 0 && Y$(s, e, d, p), (t = l.alias)
      let m = i.db.getBoundaries(t)
      m.length > 0 && X$(e, t, s, m, i),
        l.alias !== 'global' && H$(e, l, s),
        (r.data.stopy = Math.max(s.data.stopy + he.c4ShapeMargin, r.data.stopy)),
        (r.data.stopx = Math.max(s.data.stopx + he.c4ShapeMargin, r.data.stopx)),
        (mb = Math.max(mb, r.data.stopx)),
        (gb = Math.max(gb, r.data.stopy))
    }
  }
  var mb,
    gb,
    q$,
    N4,
    he,
    yb,
    I4,
    k0,
    pb,
    q1t,
    H$,
    Y$,
    ss,
    j$,
    H1t,
    Y1t,
    X1t,
    M4,
    K$ = x(() => {
      'use strict'
      Ge()
      jB()
      Vt()
      yw()
      Be()
      vw()
      pe()
      of()
      Ce()
      On()
      ;(mb = 0), (gb = 0), (q$ = 4), (N4 = 2)
      sg.yy = hg
      ;(he = {}),
        (yb = class {
          static {
            a(this, 'Bounds')
          }
          constructor(t) {
            ;(this.name = ''),
              (this.data = {}),
              (this.data.startx = void 0),
              (this.data.stopx = void 0),
              (this.data.starty = void 0),
              (this.data.stopy = void 0),
              (this.data.widthLimit = void 0),
              (this.nextData = {}),
              (this.nextData.startx = void 0),
              (this.nextData.stopx = void 0),
              (this.nextData.starty = void 0),
              (this.nextData.stopy = void 0),
              (this.nextData.cnt = 0),
              I4(t.db.getConfig())
          }
          setData(t, r, n, i) {
            ;(this.nextData.startx = this.data.startx = t),
              (this.nextData.stopx = this.data.stopx = r),
              (this.nextData.starty = this.data.starty = n),
              (this.nextData.stopy = this.data.stopy = i)
          }
          updateVal(t, r, n, i) {
            t[r] === void 0 ? (t[r] = n) : (t[r] = i(n, t[r]))
          }
          insert(t) {
            this.nextData.cnt = this.nextData.cnt + 1
            let r =
                this.nextData.startx === this.nextData.stopx
                  ? this.nextData.stopx + t.margin
                  : this.nextData.stopx + t.margin * 2,
              n = r + t.width,
              i = this.nextData.starty + t.margin * 2,
              s = i + t.height
            ;(r >= this.data.widthLimit || n >= this.data.widthLimit || this.nextData.cnt > q$) &&
              ((r = this.nextData.startx + t.margin + he.nextLinePaddingX),
              (i = this.nextData.stopy + t.margin * 2),
              (this.nextData.stopx = n = r + t.width),
              (this.nextData.starty = this.nextData.stopy),
              (this.nextData.stopy = s = i + t.height),
              (this.nextData.cnt = 1)),
              (t.x = r),
              (t.y = i),
              this.updateVal(this.data, 'startx', r, Math.min),
              this.updateVal(this.data, 'starty', i, Math.min),
              this.updateVal(this.data, 'stopx', n, Math.max),
              this.updateVal(this.data, 'stopy', s, Math.max),
              this.updateVal(this.nextData, 'startx', r, Math.min),
              this.updateVal(this.nextData, 'starty', i, Math.min),
              this.updateVal(this.nextData, 'stopx', n, Math.max),
              this.updateVal(this.nextData, 'stopy', s, Math.max)
          }
          init(t) {
            ;(this.name = ''),
              (this.data = { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0, widthLimit: void 0 }),
              (this.nextData = { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0, cnt: 0 }),
              I4(t.db.getConfig())
          }
          bumpLastMargin(t) {
            ;(this.data.stopx += t), (this.data.stopy += t)
          }
        }),
        (I4 = a(function (e) {
          Kr(he, e),
            e.fontFamily && (he.personFontFamily = he.systemFontFamily = he.messageFontFamily = e.fontFamily),
            e.fontSize && (he.personFontSize = he.systemFontSize = he.messageFontSize = e.fontSize),
            e.fontWeight && (he.personFontWeight = he.systemFontWeight = he.messageFontWeight = e.fontWeight)
        }, 'setConf')),
        (k0 = a(
          (e, t) => ({ fontFamily: e[t + 'FontFamily'], fontSize: e[t + 'FontSize'], fontWeight: e[t + 'FontWeight'] }),
          'c4ShapeFont',
        )),
        (pb = a(
          (e) => ({ fontFamily: e.boundaryFontFamily, fontSize: e.boundaryFontSize, fontWeight: e.boundaryFontWeight }),
          'boundaryFont',
        )),
        (q1t = a(
          (e) => ({ fontFamily: e.messageFontFamily, fontSize: e.messageFontSize, fontWeight: e.messageFontWeight }),
          'messageFont',
        ))
      a(Fa, 'calcC4ShapeTextWH')
      ;(H$ = a(function (e, t, r) {
        ;(t.x = r.data.startx),
          (t.y = r.data.starty),
          (t.width = r.data.stopx - r.data.startx),
          (t.height = r.data.stopy - r.data.starty),
          (t.label.y = he.c4ShapeMargin - 35)
        let n = t.wrap && he.wrap,
          i = pb(he)
        ;(i.fontSize = i.fontSize + 2), (i.fontWeight = 'bold')
        let s = Yn(t.label.text, i)
        Fa('label', t, n, i, s), Oa.drawBoundary(e, t, he)
      }, 'drawBoundary')),
        (Y$ = a(function (e, t, r, n) {
          let i = 0
          for (let s of n) {
            i = 0
            let o = r[s],
              l = k0(he, o.typeC4Shape.text)
            switch (
              ((l.fontSize = l.fontSize - 2),
              (o.typeC4Shape.width = Yn('\xAB' + o.typeC4Shape.text + '\xBB', l)),
              (o.typeC4Shape.height = l.fontSize + 2),
              (o.typeC4Shape.Y = he.c4ShapePadding),
              (i = o.typeC4Shape.Y + o.typeC4Shape.height - 4),
              (o.image = { width: 0, height: 0, Y: 0 }),
              o.typeC4Shape.text)
            ) {
              case 'person':
              case 'external_person':
                ;(o.image.width = 48), (o.image.height = 48), (o.image.Y = i), (i = o.image.Y + o.image.height)
                break
            }
            o.sprite && ((o.image.width = 48), (o.image.height = 48), (o.image.Y = i), (i = o.image.Y + o.image.height))
            let u = o.wrap && he.wrap,
              h = he.width - he.c4ShapePadding * 2,
              f = k0(he, o.typeC4Shape.text)
            if (
              ((f.fontSize = f.fontSize + 2),
              (f.fontWeight = 'bold'),
              Fa('label', o, u, f, h),
              (o.label.Y = i + 8),
              (i = o.label.Y + o.label.height),
              o.type && o.type.text !== '')
            ) {
              o.type.text = '[' + o.type.text + ']'
              let m = k0(he, o.typeC4Shape.text)
              Fa('type', o, u, m, h), (o.type.Y = i + 5), (i = o.type.Y + o.type.height)
            } else if (o.techn && o.techn.text !== '') {
              o.techn.text = '[' + o.techn.text + ']'
              let m = k0(he, o.techn.text)
              Fa('techn', o, u, m, h), (o.techn.Y = i + 5), (i = o.techn.Y + o.techn.height)
            }
            let d = i,
              p = o.label.width
            if (o.descr && o.descr.text !== '') {
              let m = k0(he, o.typeC4Shape.text)
              Fa('descr', o, u, m, h),
                (o.descr.Y = i + 20),
                (i = o.descr.Y + o.descr.height),
                (p = Math.max(o.label.width, o.descr.width)),
                (d = i - o.descr.textLines * 5)
            }
            ;(p = p + he.c4ShapePadding),
              (o.width = Math.max(o.width || he.width, p, he.width)),
              (o.height = Math.max(o.height || he.height, d, he.height)),
              (o.margin = o.margin || he.c4ShapeMargin),
              e.insert(o),
              Oa.drawC4Shape(t, o, he)
          }
          e.bumpLastMargin(he.c4ShapeMargin)
        }, 'drawC4ShapeArray')),
        (ss = class {
          static {
            a(this, 'Point')
          }
          constructor(t, r) {
            ;(this.x = t), (this.y = r)
          }
        }),
        (j$ = a(function (e, t) {
          let r = e.x,
            n = e.y,
            i = t.x,
            s = t.y,
            o = r + e.width / 2,
            l = n + e.height / 2,
            u = Math.abs(r - i),
            h = Math.abs(n - s),
            f = h / u,
            d = e.height / e.width,
            p = null
          return (
            n == s && r < i
              ? (p = new ss(r + e.width, l))
              : n == s && r > i
                ? (p = new ss(r, l))
                : r == i && n < s
                  ? (p = new ss(o, n + e.height))
                  : r == i && n > s && (p = new ss(o, n)),
            r > i && n < s
              ? d >= f
                ? (p = new ss(r, l + (f * e.width) / 2))
                : (p = new ss(o - ((u / h) * e.height) / 2, n + e.height))
              : r < i && n < s
                ? d >= f
                  ? (p = new ss(r + e.width, l + (f * e.width) / 2))
                  : (p = new ss(o + ((u / h) * e.height) / 2, n + e.height))
                : r < i && n > s
                  ? d >= f
                    ? (p = new ss(r + e.width, l - (f * e.width) / 2))
                    : (p = new ss(o + ((e.height / 2) * u) / h, n))
                  : r > i &&
                    n > s &&
                    (d >= f ? (p = new ss(r, l - (e.width / 2) * f)) : (p = new ss(o - ((e.height / 2) * u) / h, n))),
            p
          )
        }, 'getIntersectPoint')),
        (H1t = a(function (e, t) {
          let r = { x: 0, y: 0 }
          ;(r.x = t.x + t.width / 2), (r.y = t.y + t.height / 2)
          let n = j$(e, r)
          ;(r.x = e.x + e.width / 2), (r.y = e.y + e.height / 2)
          let i = j$(t, r)
          return { startPoint: n, endPoint: i }
        }, 'getIntersectPoints')),
        (Y1t = a(function (e, t, r, n) {
          let i = 0
          for (let s of t) {
            i = i + 1
            let o = s.wrap && he.wrap,
              l = q1t(he)
            n.db.getC4Type() === 'C4Dynamic' && (s.label.text = i + ': ' + s.label.text)
            let h = Yn(s.label.text, l)
            Fa('label', s, o, l, h),
              s.techn && s.techn.text !== '' && ((h = Yn(s.techn.text, l)), Fa('techn', s, o, l, h)),
              s.descr && s.descr.text !== '' && ((h = Yn(s.descr.text, l)), Fa('descr', s, o, l, h))
            let f = r(s.from),
              d = r(s.to),
              p = H1t(f, d)
            ;(s.startPoint = p.startPoint), (s.endPoint = p.endPoint)
          }
          Oa.drawRels(e, t, he)
        }, 'drawRels'))
      a(X$, 'drawInsideBoundary')
      ;(X1t = a(function (e, t, r, n) {
        he = K().c4
        let i = K().securityLevel,
          s
        i === 'sandbox' && (s = xt('#i' + t))
        let o = i === 'sandbox' ? xt(s.nodes()[0].contentDocument.body) : xt('body'),
          l = n.db
        n.db.setWrap(he.wrap),
          (q$ = l.getC4ShapeInRow()),
          (N4 = l.getC4BoundaryInRow()),
          B.debug(`C:${JSON.stringify(he, null, 2)}`)
        let u = i === 'sandbox' ? o.select(`[id="${t}"]`) : xt(`[id="${t}"]`)
        Oa.insertComputerIcon(u), Oa.insertDatabaseIcon(u), Oa.insertClockIcon(u)
        let h = new yb(n)
        h.setData(he.diagramMarginX, he.diagramMarginX, he.diagramMarginY, he.diagramMarginY),
          (h.data.widthLimit = screen.availWidth),
          (mb = he.diagramMarginX),
          (gb = he.diagramMarginY)
        let f = n.db.getTitle(),
          d = n.db.getBoundaries('')
        X$(u, '', h, d, n),
          Oa.insertArrowHead(u),
          Oa.insertArrowEnd(u),
          Oa.insertArrowCrossHead(u),
          Oa.insertArrowFilledHead(u),
          Y1t(u, n.db.getRels(), n.db.getC4Shape, n),
          (h.data.stopx = mb),
          (h.data.stopy = gb)
        let p = h.data,
          g = p.stopy - p.starty + 2 * he.diagramMarginY,
          b = p.stopx - p.startx + 2 * he.diagramMarginX
        f &&
          u
            .append('text')
            .text(f)
            .attr('x', (p.stopx - p.startx) / 2 - 4 * he.diagramMarginX)
            .attr('y', p.starty + he.diagramMarginY),
          Ar(u, g, b, he.useMaxWidth)
        let k = f ? 60 : 0
        u.attr('viewBox', p.startx - he.diagramMarginX + ' -' + (he.diagramMarginY + k) + ' ' + b + ' ' + (g + k)),
          B.debug('models:', p)
      }, 'draw')),
        (M4 = { drawPersonOrSystemArray: Y$, drawBoundary: H$, setConf: I4, draw: X1t })
    })
  var K1t,
    Q$,
    Z$ = x(() => {
      'use strict'
      ;(K1t = a(
        (e) => `.person {
    stroke: ${e.personBorder};
    fill: ${e.personBkg};
  }
`,
        'getStyles',
      )),
        (Q$ = K1t)
    })
  var J$ = {}
  Oe(J$, { diagram: () => Q1t })
  var Q1t,
    tG = x(() => {
      'use strict'
      yw()
      vw()
      K$()
      Z$()
      Q1t = {
        parser: wI,
        db: hg,
        renderer: M4,
        styles: Q$,
        init: a(({ c4: e, wrap: t }) => {
          M4.setConf(e), hg.setWrap(t)
        }, 'init'),
      }
    })
  function yG(e) {
    return typeof e > 'u' || e === null
  }
  function eyt(e) {
    return typeof e == 'object' && e !== null
  }
  function ryt(e) {
    return Array.isArray(e) ? e : yG(e) ? [] : [e]
  }
  function nyt(e, t) {
    var r, n, i, s
    if (t) for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1) (i = s[r]), (e[i] = t[i])
    return e
  }
  function iyt(e, t) {
    var r = '',
      n
    for (n = 0; n < t; n += 1) r += e
    return r
  }
  function syt(e) {
    return e === 0 && Number.NEGATIVE_INFINITY === 1 / e
  }
  function xG(e, t) {
    var r = '',
      n = e.reason || '(unknown reason)'
    return e.mark
      ? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
        (r += '(' + (e.mark.line + 1) + ':' + (e.mark.column + 1) + ')'),
        !t &&
          e.mark.snippet &&
          (r +=
            `

` + e.mark.snippet),
        n + ' ' + r)
      : n
  }
  function S0(e, t) {
    Error.call(this),
      (this.name = 'YAMLException'),
      (this.reason = e),
      (this.mark = t),
      (this.message = xG(this, !1)),
      Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error().stack || '')
  }
  function O4(e, t, r, n, i) {
    var s = '',
      o = '',
      l = Math.floor(i / 2) - 1
    return (
      n - t > l && ((s = ' ... '), (t = n - l + s.length)),
      r - n > l && ((o = ' ...'), (r = n + l - o.length)),
      { str: s + e.slice(t, r).replace(/\t/g, '\u2192') + o, pos: n - t + s.length }
    )
  }
  function P4(e, t) {
    return Bn.repeat(' ', t - e.length) + e
  }
  function fyt(e, t) {
    if (((t = Object.create(t || null)), !e.buffer)) return null
    t.maxLength || (t.maxLength = 79),
      typeof t.indent != 'number' && (t.indent = 1),
      typeof t.linesBefore != 'number' && (t.linesBefore = 3),
      typeof t.linesAfter != 'number' && (t.linesAfter = 2)
    for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1; (s = r.exec(e.buffer)); )
      i.push(s.index), n.push(s.index + s[0].length), e.position <= s.index && o < 0 && (o = n.length - 2)
    o < 0 && (o = n.length - 1)
    var l = '',
      u,
      h,
      f = Math.min(e.line + t.linesAfter, i.length).toString().length,
      d = t.maxLength - (t.indent + f + 3)
    for (u = 1; u <= t.linesBefore && !(o - u < 0); u++)
      (h = O4(e.buffer, n[o - u], i[o - u], e.position - (n[o] - n[o - u]), d)),
        (l =
          Bn.repeat(' ', t.indent) +
          P4((e.line - u + 1).toString(), f) +
          ' | ' +
          h.str +
          `
` +
          l)
    for (
      h = O4(e.buffer, n[o], i[o], e.position, d),
        l +=
          Bn.repeat(' ', t.indent) +
          P4((e.line + 1).toString(), f) +
          ' | ' +
          h.str +
          `
`,
        l +=
          Bn.repeat('-', t.indent + f + 3 + h.pos) +
          `^
`,
        u = 1;
      u <= t.linesAfter && !(o + u >= i.length);
      u++
    )
      (h = O4(e.buffer, n[o + u], i[o + u], e.position - (n[o] - n[o + u]), d)),
        (l +=
          Bn.repeat(' ', t.indent) +
          P4((e.line + u + 1).toString(), f) +
          ' | ' +
          h.str +
          `
`)
    return l.replace(/\n$/, '')
  }
  function gyt(e) {
    var t = {}
    return (
      e !== null &&
        Object.keys(e).forEach(function (r) {
          e[r].forEach(function (n) {
            t[String(n)] = r
          })
        }),
      t
    )
  }
  function yyt(e, t) {
    if (
      ((t = t || {}),
      Object.keys(t).forEach(function (r) {
        if (pyt.indexOf(r) === -1)
          throw new as('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.')
      }),
      (this.options = t),
      (this.tag = e),
      (this.kind = t.kind || null),
      (this.resolve =
        t.resolve ||
        function () {
          return !0
        }),
      (this.construct =
        t.construct ||
        function (r) {
          return r
        }),
      (this.instanceOf = t.instanceOf || null),
      (this.predicate = t.predicate || null),
      (this.represent = t.represent || null),
      (this.representName = t.representName || null),
      (this.defaultStyle = t.defaultStyle || null),
      (this.multi = t.multi || !1),
      (this.styleAliases = gyt(t.styleAliases || null)),
      myt.indexOf(this.kind) === -1)
    )
      throw new as('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.')
  }
  function rG(e, t) {
    var r = []
    return (
      e[t].forEach(function (n) {
        var i = r.length
        r.forEach(function (s, o) {
          s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o)
        }),
          (r[i] = n)
      }),
      r
    )
  }
  function xyt() {
    var e = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
      },
      t,
      r
    function n(i) {
      i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : (e[i.kind][i.tag] = e.fallback[i.tag] = i)
    }
    for (a(n, 'collectType'), t = 0, r = arguments.length; t < r; t += 1) arguments[t].forEach(n)
    return e
  }
  function F4(e) {
    return this.extend(e)
  }
  function Cyt(e) {
    if (e === null) return !0
    var t = e.length
    return (t === 1 && e === '~') || (t === 4 && (e === 'null' || e === 'Null' || e === 'NULL'))
  }
  function wyt() {
    return null
  }
  function Eyt(e) {
    return e === null
  }
  function Ayt(e) {
    if (e === null) return !1
    var t = e.length
    return (
      (t === 4 && (e === 'true' || e === 'True' || e === 'TRUE')) ||
      (t === 5 && (e === 'false' || e === 'False' || e === 'FALSE'))
    )
  }
  function Lyt(e) {
    return e === 'true' || e === 'True' || e === 'TRUE'
  }
  function Ryt(e) {
    return Object.prototype.toString.call(e) === '[object Boolean]'
  }
  function Nyt(e) {
    return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102)
  }
  function Iyt(e) {
    return 48 <= e && e <= 55
  }
  function Myt(e) {
    return 48 <= e && e <= 57
  }
  function Oyt(e) {
    if (e === null) return !1
    var t = e.length,
      r = 0,
      n = !1,
      i
    if (!t) return !1
    if (((i = e[r]), (i === '-' || i === '+') && (i = e[++r]), i === '0')) {
      if (r + 1 === t) return !0
      if (((i = e[++r]), i === 'b')) {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== '_')) {
            if (i !== '0' && i !== '1') return !1
            n = !0
          }
        return n && i !== '_'
      }
      if (i === 'x') {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== '_')) {
            if (!Nyt(e.charCodeAt(r))) return !1
            n = !0
          }
        return n && i !== '_'
      }
      if (i === 'o') {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== '_')) {
            if (!Iyt(e.charCodeAt(r))) return !1
            n = !0
          }
        return n && i !== '_'
      }
    }
    if (i === '_') return !1
    for (; r < t; r++)
      if (((i = e[r]), i !== '_')) {
        if (!Myt(e.charCodeAt(r))) return !1
        n = !0
      }
    return !(!n || i === '_')
  }
  function Pyt(e) {
    var t = e,
      r = 1,
      n
    if (
      (t.indexOf('_') !== -1 && (t = t.replace(/_/g, '')),
      (n = t[0]),
      (n === '-' || n === '+') && (n === '-' && (r = -1), (t = t.slice(1)), (n = t[0])),
      t === '0')
    )
      return 0
    if (n === '0') {
      if (t[1] === 'b') return r * parseInt(t.slice(2), 2)
      if (t[1] === 'x') return r * parseInt(t.slice(2), 16)
      if (t[1] === 'o') return r * parseInt(t.slice(2), 8)
    }
    return r * parseInt(t, 10)
  }
  function Byt(e) {
    return Object.prototype.toString.call(e) === '[object Number]' && e % 1 === 0 && !Bn.isNegativeZero(e)
  }
  function Gyt(e) {
    return !(e === null || !$yt.test(e) || e[e.length - 1] === '_')
  }
  function Vyt(e) {
    var t, r
    return (
      (t = e.replace(/_/g, '').toLowerCase()),
      (r = t[0] === '-' ? -1 : 1),
      '+-'.indexOf(t[0]) >= 0 && (t = t.slice(1)),
      t === '.inf'
        ? r === 1
          ? Number.POSITIVE_INFINITY
          : Number.NEGATIVE_INFINITY
        : t === '.nan'
          ? NaN
          : r * parseFloat(t, 10)
    )
  }
  function Wyt(e, t) {
    var r
    if (isNaN(e))
      switch (t) {
        case 'lowercase':
          return '.nan'
        case 'uppercase':
          return '.NAN'
        case 'camelcase':
          return '.NaN'
      }
    else if (Number.POSITIVE_INFINITY === e)
      switch (t) {
        case 'lowercase':
          return '.inf'
        case 'uppercase':
          return '.INF'
        case 'camelcase':
          return '.Inf'
      }
    else if (Number.NEGATIVE_INFINITY === e)
      switch (t) {
        case 'lowercase':
          return '-.inf'
        case 'uppercase':
          return '-.INF'
        case 'camelcase':
          return '-.Inf'
      }
    else if (Bn.isNegativeZero(e)) return '-0.0'
    return (r = e.toString(10)), zyt.test(r) ? r.replace('e', '.e') : r
  }
  function Uyt(e) {
    return Object.prototype.toString.call(e) === '[object Number]' && (e % 1 !== 0 || Bn.isNegativeZero(e))
  }
  function Hyt(e) {
    return e === null ? !1 : kG.exec(e) !== null || TG.exec(e) !== null
  }
  function Yyt(e) {
    var t,
      r,
      n,
      i,
      s,
      o,
      l,
      u = 0,
      h = null,
      f,
      d,
      p
    if (((t = kG.exec(e)), t === null && (t = TG.exec(e)), t === null)) throw new Error('Date resolve error')
    if (((r = +t[1]), (n = +t[2] - 1), (i = +t[3]), !t[4])) return new Date(Date.UTC(r, n, i))
    if (((s = +t[4]), (o = +t[5]), (l = +t[6]), t[7])) {
      for (u = t[7].slice(0, 3); u.length < 3; ) u += '0'
      u = +u
    }
    return (
      t[9] && ((f = +t[10]), (d = +(t[11] || 0)), (h = (f * 60 + d) * 6e4), t[9] === '-' && (h = -h)),
      (p = new Date(Date.UTC(r, n, i, s, o, l, u))),
      h && p.setTime(p.getTime() - h),
      p
    )
  }
  function Xyt(e) {
    return e.toISOString()
  }
  function Qyt(e) {
    return e === '<<' || e === null
  }
  function Jyt(e) {
    if (e === null) return !1
    var t,
      r,
      n = 0,
      i = e.length,
      s = W4
    for (r = 0; r < i; r++)
      if (((t = s.indexOf(e.charAt(r))), !(t > 64))) {
        if (t < 0) return !1
        n += 6
      }
    return n % 8 === 0
  }
  function txt(e) {
    var t,
      r,
      n = e.replace(/[\r\n=]/g, ''),
      i = n.length,
      s = W4,
      o = 0,
      l = []
    for (t = 0; t < i; t++)
      t % 4 === 0 && t && (l.push((o >> 16) & 255), l.push((o >> 8) & 255), l.push(o & 255)),
        (o = (o << 6) | s.indexOf(n.charAt(t)))
    return (
      (r = (i % 4) * 6),
      r === 0
        ? (l.push((o >> 16) & 255), l.push((o >> 8) & 255), l.push(o & 255))
        : r === 18
          ? (l.push((o >> 10) & 255), l.push((o >> 2) & 255))
          : r === 12 && l.push((o >> 4) & 255),
      new Uint8Array(l)
    )
  }
  function ext(e) {
    var t = '',
      r = 0,
      n,
      i,
      s = e.length,
      o = W4
    for (n = 0; n < s; n++)
      n % 3 === 0 &&
        n &&
        ((t += o[(r >> 18) & 63]), (t += o[(r >> 12) & 63]), (t += o[(r >> 6) & 63]), (t += o[r & 63])),
        (r = (r << 8) + e[n])
    return (
      (i = s % 3),
      i === 0
        ? ((t += o[(r >> 18) & 63]), (t += o[(r >> 12) & 63]), (t += o[(r >> 6) & 63]), (t += o[r & 63]))
        : i === 2
          ? ((t += o[(r >> 10) & 63]), (t += o[(r >> 4) & 63]), (t += o[(r << 2) & 63]), (t += o[64]))
          : i === 1 && ((t += o[(r >> 2) & 63]), (t += o[(r << 4) & 63]), (t += o[64]), (t += o[64])),
      t
    )
  }
  function rxt(e) {
    return Object.prototype.toString.call(e) === '[object Uint8Array]'
  }
  function axt(e) {
    if (e === null) return !0
    var t = [],
      r,
      n,
      i,
      s,
      o,
      l = e
    for (r = 0, n = l.length; r < n; r += 1) {
      if (((i = l[r]), (o = !1), sxt.call(i) !== '[object Object]')) return !1
      for (s in i)
        if (ixt.call(i, s))
          if (!o) o = !0
          else return !1
      if (!o) return !1
      if (t.indexOf(s) === -1) t.push(s)
      else return !1
    }
    return !0
  }
  function oxt(e) {
    return e !== null ? e : []
  }
  function uxt(e) {
    if (e === null) return !0
    var t,
      r,
      n,
      i,
      s,
      o = e
    for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
      if (((n = o[t]), cxt.call(n) !== '[object Object]' || ((i = Object.keys(n)), i.length !== 1))) return !1
      s[t] = [i[0], n[i[0]]]
    }
    return !0
  }
  function hxt(e) {
    if (e === null) return []
    var t,
      r,
      n,
      i,
      s,
      o = e
    for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
      (n = o[t]), (i = Object.keys(n)), (s[t] = [i[0], n[i[0]]])
    return s
  }
  function pxt(e) {
    if (e === null) return !0
    var t,
      r = e
    for (t in r) if (dxt.call(r, t) && r[t] !== null) return !1
    return !0
  }
  function mxt(e) {
    return e !== null ? e : {}
  }
  function iG(e) {
    return Object.prototype.toString.call(e)
  }
  function xo(e) {
    return e === 10 || e === 13
  }
  function Ku(e) {
    return e === 9 || e === 32
  }
  function os(e) {
    return e === 9 || e === 32 || e === 10 || e === 13
  }
  function ad(e) {
    return e === 44 || e === 91 || e === 93 || e === 123 || e === 125
  }
  function Txt(e) {
    var t
    return 48 <= e && e <= 57 ? e - 48 : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1)
  }
  function Sxt(e) {
    return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0
  }
  function _xt(e) {
    return 48 <= e && e <= 57 ? e - 48 : -1
  }
  function sG(e) {
    return e === 48
      ? '\0'
      : e === 97
        ? '\x07'
        : e === 98
          ? '\b'
          : e === 116 || e === 9
            ? '	'
            : e === 110
              ? `
`
              : e === 118
                ? '\v'
                : e === 102
                  ? '\f'
                  : e === 114
                    ? '\r'
                    : e === 101
                      ? '\x1B'
                      : e === 32
                        ? ' '
                        : e === 34
                          ? '"'
                          : e === 47
                            ? '/'
                            : e === 92
                              ? '\\'
                              : e === 78
                                ? '\x85'
                                : e === 95
                                  ? '\xA0'
                                  : e === 76
                                    ? '\u2028'
                                    : e === 80
                                      ? '\u2029'
                                      : ''
  }
  function Cxt(e) {
    return e <= 65535
      ? String.fromCharCode(e)
      : String.fromCharCode(((e - 65536) >> 10) + 55296, ((e - 65536) & 1023) + 56320)
  }
  function wxt(e, t) {
    ;(this.input = e),
      (this.filename = t.filename || null),
      (this.schema = t.schema || SG),
      (this.onWarning = t.onWarning || null),
      (this.legacy = t.legacy || !1),
      (this.json = t.json || !1),
      (this.listener = t.listener || null),
      (this.implicitTypes = this.schema.compiledImplicit),
      (this.typeMap = this.schema.compiledTypeMap),
      (this.length = e.length),
      (this.position = 0),
      (this.line = 0),
      (this.lineStart = 0),
      (this.lineIndent = 0),
      (this.firstTabInLine = -1),
      (this.documents = [])
  }
  function LG(e, t) {
    var r = {
      name: e.filename,
      buffer: e.input.slice(0, -1),
      position: e.position,
      line: e.line,
      column: e.position - e.lineStart,
    }
    return (r.snippet = dyt(r)), new as(t, r)
  }
  function me(e, t) {
    throw LG(e, t)
  }
  function kb(e, t) {
    e.onWarning && e.onWarning.call(null, LG(e, t))
  }
  function Tc(e, t, r, n) {
    var i, s, o, l
    if (t < r) {
      if (((l = e.input.slice(t, r)), n))
        for (i = 0, s = l.length; i < s; i += 1)
          (o = l.charCodeAt(i)), o === 9 || (32 <= o && o <= 1114111) || me(e, 'expected valid JSON character')
      else xxt.test(l) && me(e, 'the stream contains non-printable characters')
      e.result += l
    }
  }
  function oG(e, t, r, n) {
    var i, s, o, l
    for (
      Bn.isObject(r) || me(e, 'cannot merge mappings; the provided source object is unacceptable'),
        i = Object.keys(r),
        o = 0,
        l = i.length;
      o < l;
      o += 1
    )
      (s = i[o]), Sc.call(t, s) || ((t[s] = r[s]), (n[s] = !0))
  }
  function od(e, t, r, n, i, s, o, l, u) {
    var h, f
    if (Array.isArray(i))
      for (i = Array.prototype.slice.call(i), h = 0, f = i.length; h < f; h += 1)
        Array.isArray(i[h]) && me(e, 'nested arrays are not supported inside keys'),
          typeof i == 'object' && iG(i[h]) === '[object Object]' && (i[h] = '[object Object]')
    if (
      (typeof i == 'object' && iG(i) === '[object Object]' && (i = '[object Object]'),
      (i = String(i)),
      t === null && (t = {}),
      n === 'tag:yaml.org,2002:merge')
    )
      if (Array.isArray(s)) for (h = 0, f = s.length; h < f; h += 1) oG(e, t, s[h], r)
      else oG(e, t, s, r)
    else
      !e.json &&
        !Sc.call(r, i) &&
        Sc.call(t, i) &&
        ((e.line = o || e.line),
        (e.lineStart = l || e.lineStart),
        (e.position = u || e.position),
        me(e, 'duplicated mapping key')),
        i === '__proto__'
          ? Object.defineProperty(t, i, { configurable: !0, enumerable: !0, writable: !0, value: s })
          : (t[i] = s),
        delete r[i]
    return t
  }
  function U4(e) {
    var t
    ;(t = e.input.charCodeAt(e.position)),
      t === 10
        ? e.position++
        : t === 13
          ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
          : me(e, 'a line break is expected'),
      (e.line += 1),
      (e.lineStart = e.position),
      (e.firstTabInLine = -1)
  }
  function An(e, t, r) {
    for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
      for (; Ku(i); )
        i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), (i = e.input.charCodeAt(++e.position))
      if (t && i === 35)
        do i = e.input.charCodeAt(++e.position)
        while (i !== 10 && i !== 13 && i !== 0)
      if (xo(i))
        for (U4(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; i === 32; )
          e.lineIndent++, (i = e.input.charCodeAt(++e.position))
      else break
    }
    return r !== -1 && n !== 0 && e.lineIndent < r && kb(e, 'deficient indentation'), n
  }
  function _b(e) {
    var t = e.position,
      r
    return (
      (r = e.input.charCodeAt(t)),
      !!(
        (r === 45 || r === 46) &&
        r === e.input.charCodeAt(t + 1) &&
        r === e.input.charCodeAt(t + 2) &&
        ((t += 3), (r = e.input.charCodeAt(t)), r === 0 || os(r))
      )
    )
  }
  function j4(e, t) {
    t === 1
      ? (e.result += ' ')
      : t > 1 &&
        (e.result += Bn.repeat(
          `
`,
          t - 1,
        ))
  }
  function Ext(e, t, r) {
    var n,
      i,
      s,
      o,
      l,
      u,
      h,
      f,
      d = e.kind,
      p = e.result,
      m
    if (
      ((m = e.input.charCodeAt(e.position)),
      os(m) ||
        ad(m) ||
        m === 35 ||
        m === 38 ||
        m === 42 ||
        m === 33 ||
        m === 124 ||
        m === 62 ||
        m === 39 ||
        m === 34 ||
        m === 37 ||
        m === 64 ||
        m === 96 ||
        ((m === 63 || m === 45) && ((i = e.input.charCodeAt(e.position + 1)), os(i) || (r && ad(i)))))
    )
      return !1
    for (e.kind = 'scalar', e.result = '', s = o = e.position, l = !1; m !== 0; ) {
      if (m === 58) {
        if (((i = e.input.charCodeAt(e.position + 1)), os(i) || (r && ad(i)))) break
      } else if (m === 35) {
        if (((n = e.input.charCodeAt(e.position - 1)), os(n))) break
      } else {
        if ((e.position === e.lineStart && _b(e)) || (r && ad(m))) break
        if (xo(m))
          if (((u = e.line), (h = e.lineStart), (f = e.lineIndent), An(e, !1, -1), e.lineIndent >= t)) {
            ;(l = !0), (m = e.input.charCodeAt(e.position))
            continue
          } else {
            ;(e.position = o), (e.line = u), (e.lineStart = h), (e.lineIndent = f)
            break
          }
      }
      l && (Tc(e, s, o, !1), j4(e, e.line - u), (s = o = e.position), (l = !1)),
        Ku(m) || (o = e.position + 1),
        (m = e.input.charCodeAt(++e.position))
    }
    return Tc(e, s, o, !1), e.result ? !0 : ((e.kind = d), (e.result = p), !1)
  }
  function vxt(e, t) {
    var r, n, i
    if (((r = e.input.charCodeAt(e.position)), r !== 39)) return !1
    for (
      e.kind = 'scalar', e.result = '', e.position++, n = i = e.position;
      (r = e.input.charCodeAt(e.position)) !== 0;

    )
      if (r === 39)
        if ((Tc(e, n, e.position, !0), (r = e.input.charCodeAt(++e.position)), r === 39))
          (n = e.position), e.position++, (i = e.position)
        else return !0
      else
        xo(r)
          ? (Tc(e, n, i, !0), j4(e, An(e, !1, t)), (n = i = e.position))
          : e.position === e.lineStart && _b(e)
            ? me(e, 'unexpected end of the document within a single quoted scalar')
            : (e.position++, (i = e.position))
    me(e, 'unexpected end of the stream within a single quoted scalar')
  }
  function Axt(e, t) {
    var r, n, i, s, o, l
    if (((l = e.input.charCodeAt(e.position)), l !== 34)) return !1
    for (
      e.kind = 'scalar', e.result = '', e.position++, r = n = e.position;
      (l = e.input.charCodeAt(e.position)) !== 0;

    ) {
      if (l === 34) return Tc(e, r, e.position, !0), e.position++, !0
      if (l === 92) {
        if ((Tc(e, r, e.position, !0), (l = e.input.charCodeAt(++e.position)), xo(l))) An(e, !1, t)
        else if (l < 256 && vG[l]) (e.result += AG[l]), e.position++
        else if ((o = Sxt(l)) > 0) {
          for (i = o, s = 0; i > 0; i--)
            (l = e.input.charCodeAt(++e.position)),
              (o = Txt(l)) >= 0 ? (s = (s << 4) + o) : me(e, 'expected hexadecimal character')
          ;(e.result += Cxt(s)), e.position++
        } else me(e, 'unknown escape sequence')
        r = n = e.position
      } else
        xo(l)
          ? (Tc(e, r, n, !0), j4(e, An(e, !1, t)), (r = n = e.position))
          : e.position === e.lineStart && _b(e)
            ? me(e, 'unexpected end of the document within a double quoted scalar')
            : (e.position++, (n = e.position))
    }
    me(e, 'unexpected end of the stream within a double quoted scalar')
  }
  function Lxt(e, t) {
    var r = !0,
      n,
      i,
      s,
      o = e.tag,
      l,
      u = e.anchor,
      h,
      f,
      d,
      p,
      m,
      g = Object.create(null),
      y,
      b,
      k,
      T
    if (((T = e.input.charCodeAt(e.position)), T === 91)) (f = 93), (m = !1), (l = [])
    else if (T === 123) (f = 125), (m = !0), (l = {})
    else return !1
    for (e.anchor !== null && (e.anchorMap[e.anchor] = l), T = e.input.charCodeAt(++e.position); T !== 0; ) {
      if ((An(e, !0, t), (T = e.input.charCodeAt(e.position)), T === f))
        return e.position++, (e.tag = o), (e.anchor = u), (e.kind = m ? 'mapping' : 'sequence'), (e.result = l), !0
      r
        ? T === 44 && me(e, "expected the node content, but found ','")
        : me(e, 'missed comma between flow collection entries'),
        (b = y = k = null),
        (d = p = !1),
        T === 63 && ((h = e.input.charCodeAt(e.position + 1)), os(h) && ((d = p = !0), e.position++, An(e, !0, t))),
        (n = e.line),
        (i = e.lineStart),
        (s = e.position),
        ld(e, t, xb, !1, !0),
        (b = e.tag),
        (y = e.result),
        An(e, !0, t),
        (T = e.input.charCodeAt(e.position)),
        (p || e.line === n) &&
          T === 58 &&
          ((d = !0), (T = e.input.charCodeAt(++e.position)), An(e, !0, t), ld(e, t, xb, !1, !0), (k = e.result)),
        m ? od(e, l, g, b, y, k, n, i, s) : d ? l.push(od(e, null, g, b, y, k, n, i, s)) : l.push(y),
        An(e, !0, t),
        (T = e.input.charCodeAt(e.position)),
        T === 44 ? ((r = !0), (T = e.input.charCodeAt(++e.position))) : (r = !1)
    }
    me(e, 'unexpected end of the stream within a flow collection')
  }
  function Rxt(e, t) {
    var r,
      n,
      i = B4,
      s = !1,
      o = !1,
      l = t,
      u = 0,
      h = !1,
      f,
      d
    if (((d = e.input.charCodeAt(e.position)), d === 124)) n = !1
    else if (d === 62) n = !0
    else return !1
    for (e.kind = 'scalar', e.result = ''; d !== 0; )
      if (((d = e.input.charCodeAt(++e.position)), d === 43 || d === 45))
        B4 === i ? (i = d === 43 ? nG : yxt) : me(e, 'repeat of a chomping mode identifier')
      else if ((f = _xt(d)) >= 0)
        f === 0
          ? me(e, 'bad explicit indentation width of a block scalar; it cannot be less than one')
          : o
            ? me(e, 'repeat of an indentation width identifier')
            : ((l = t + f - 1), (o = !0))
      else break
    if (Ku(d)) {
      do d = e.input.charCodeAt(++e.position)
      while (Ku(d))
      if (d === 35)
        do d = e.input.charCodeAt(++e.position)
        while (!xo(d) && d !== 0)
    }
    for (; d !== 0; ) {
      for (U4(e), e.lineIndent = 0, d = e.input.charCodeAt(e.position); (!o || e.lineIndent < l) && d === 32; )
        e.lineIndent++, (d = e.input.charCodeAt(++e.position))
      if ((!o && e.lineIndent > l && (l = e.lineIndent), xo(d))) {
        u++
        continue
      }
      if (e.lineIndent < l) {
        i === nG
          ? (e.result += Bn.repeat(
              `
`,
              s ? 1 + u : u,
            ))
          : i === B4 &&
            s &&
            (e.result += `
`)
        break
      }
      for (
        n
          ? Ku(d)
            ? ((h = !0),
              (e.result += Bn.repeat(
                `
`,
                s ? 1 + u : u,
              )))
            : h
              ? ((h = !1),
                (e.result += Bn.repeat(
                  `
`,
                  u + 1,
                )))
              : u === 0
                ? s && (e.result += ' ')
                : (e.result += Bn.repeat(
                    `
`,
                    u,
                  ))
          : (e.result += Bn.repeat(
              `
`,
              s ? 1 + u : u,
            )),
          s = !0,
          o = !0,
          u = 0,
          r = e.position;
        !xo(d) && d !== 0;

      )
        d = e.input.charCodeAt(++e.position)
      Tc(e, r, e.position, !1)
    }
    return !0
  }
  function lG(e, t) {
    var r,
      n = e.tag,
      i = e.anchor,
      s = [],
      o,
      l = !1,
      u
    if (e.firstTabInLine !== -1) return !1
    for (
      e.anchor !== null && (e.anchorMap[e.anchor] = s), u = e.input.charCodeAt(e.position);
      u !== 0 &&
      (e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine), me(e, 'tab characters must not be used in indentation')),
      !(u !== 45 || ((o = e.input.charCodeAt(e.position + 1)), !os(o))));

    ) {
      if (((l = !0), e.position++, An(e, !0, -1) && e.lineIndent <= t)) {
        s.push(null), (u = e.input.charCodeAt(e.position))
        continue
      }
      if (
        ((r = e.line),
        ld(e, t, CG, !1, !0),
        s.push(e.result),
        An(e, !0, -1),
        (u = e.input.charCodeAt(e.position)),
        (e.line === r || e.lineIndent > t) && u !== 0)
      )
        me(e, 'bad indentation of a sequence entry')
      else if (e.lineIndent < t) break
    }
    return l ? ((e.tag = n), (e.anchor = i), (e.kind = 'sequence'), (e.result = s), !0) : !1
  }
  function Dxt(e, t, r) {
    var n,
      i,
      s,
      o,
      l,
      u,
      h = e.tag,
      f = e.anchor,
      d = {},
      p = Object.create(null),
      m = null,
      g = null,
      y = null,
      b = !1,
      k = !1,
      T
    if (e.firstTabInLine !== -1) return !1
    for (e.anchor !== null && (e.anchorMap[e.anchor] = d), T = e.input.charCodeAt(e.position); T !== 0; ) {
      if (
        (!b &&
          e.firstTabInLine !== -1 &&
          ((e.position = e.firstTabInLine), me(e, 'tab characters must not be used in indentation')),
        (n = e.input.charCodeAt(e.position + 1)),
        (s = e.line),
        (T === 63 || T === 58) && os(n))
      )
        T === 63
          ? (b && (od(e, d, p, m, g, null, o, l, u), (m = g = y = null)), (k = !0), (b = !0), (i = !0))
          : b
            ? ((b = !1), (i = !0))
            : me(
                e,
                'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line',
              ),
          (e.position += 1),
          (T = n)
      else {
        if (((o = e.line), (l = e.lineStart), (u = e.position), !ld(e, r, _G, !1, !0))) break
        if (e.line === s) {
          for (T = e.input.charCodeAt(e.position); Ku(T); ) T = e.input.charCodeAt(++e.position)
          if (T === 58)
            (T = e.input.charCodeAt(++e.position)),
              os(T) || me(e, 'a whitespace character is expected after the key-value separator within a block mapping'),
              b && (od(e, d, p, m, g, null, o, l, u), (m = g = y = null)),
              (k = !0),
              (b = !1),
              (i = !1),
              (m = e.tag),
              (g = e.result)
          else if (k) me(e, 'can not read an implicit mapping pair; a colon is missed')
          else return (e.tag = h), (e.anchor = f), !0
        } else if (k) me(e, 'can not read a block mapping entry; a multiline key may not be an implicit key')
        else return (e.tag = h), (e.anchor = f), !0
      }
      if (
        ((e.line === s || e.lineIndent > t) &&
          (b && ((o = e.line), (l = e.lineStart), (u = e.position)),
          ld(e, t, bb, !0, i) && (b ? (g = e.result) : (y = e.result)),
          b || (od(e, d, p, m, g, y, o, l, u), (m = g = y = null)),
          An(e, !0, -1),
          (T = e.input.charCodeAt(e.position))),
        (e.line === s || e.lineIndent > t) && T !== 0)
      )
        me(e, 'bad indentation of a mapping entry')
      else if (e.lineIndent < t) break
    }
    return (
      b && od(e, d, p, m, g, null, o, l, u), k && ((e.tag = h), (e.anchor = f), (e.kind = 'mapping'), (e.result = d)), k
    )
  }
  function Nxt(e) {
    var t,
      r = !1,
      n = !1,
      i,
      s,
      o
    if (((o = e.input.charCodeAt(e.position)), o !== 33)) return !1
    if (
      (e.tag !== null && me(e, 'duplication of a tag property'),
      (o = e.input.charCodeAt(++e.position)),
      o === 60
        ? ((r = !0), (o = e.input.charCodeAt(++e.position)))
        : o === 33
          ? ((n = !0), (i = '!!'), (o = e.input.charCodeAt(++e.position)))
          : (i = '!'),
      (t = e.position),
      r)
    ) {
      do o = e.input.charCodeAt(++e.position)
      while (o !== 0 && o !== 62)
      e.position < e.length
        ? ((s = e.input.slice(t, e.position)), (o = e.input.charCodeAt(++e.position)))
        : me(e, 'unexpected end of the stream within a verbatim tag')
    } else {
      for (; o !== 0 && !os(o); )
        o === 33 &&
          (n
            ? me(e, 'tag suffix cannot contain exclamation marks')
            : ((i = e.input.slice(t - 1, e.position + 1)),
              wG.test(i) || me(e, 'named tag handle cannot contain such characters'),
              (n = !0),
              (t = e.position + 1))),
          (o = e.input.charCodeAt(++e.position))
      ;(s = e.input.slice(t, e.position)), kxt.test(s) && me(e, 'tag suffix cannot contain flow indicator characters')
    }
    s && !EG.test(s) && me(e, 'tag name cannot contain such characters: ' + s)
    try {
      s = decodeURIComponent(s)
    } catch {
      me(e, 'tag name is malformed: ' + s)
    }
    return (
      r
        ? (e.tag = s)
        : Sc.call(e.tagMap, i)
          ? (e.tag = e.tagMap[i] + s)
          : i === '!'
            ? (e.tag = '!' + s)
            : i === '!!'
              ? (e.tag = 'tag:yaml.org,2002:' + s)
              : me(e, 'undeclared tag handle "' + i + '"'),
      !0
    )
  }
  function Ixt(e) {
    var t, r
    if (((r = e.input.charCodeAt(e.position)), r !== 38)) return !1
    for (
      e.anchor !== null && me(e, 'duplication of an anchor property'),
        r = e.input.charCodeAt(++e.position),
        t = e.position;
      r !== 0 && !os(r) && !ad(r);

    )
      r = e.input.charCodeAt(++e.position)
    return (
      e.position === t && me(e, 'name of an anchor node must contain at least one character'),
      (e.anchor = e.input.slice(t, e.position)),
      !0
    )
  }
  function Mxt(e) {
    var t, r, n
    if (((n = e.input.charCodeAt(e.position)), n !== 42)) return !1
    for (n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !os(n) && !ad(n); )
      n = e.input.charCodeAt(++e.position)
    return (
      e.position === t && me(e, 'name of an alias node must contain at least one character'),
      (r = e.input.slice(t, e.position)),
      Sc.call(e.anchorMap, r) || me(e, 'unidentified alias "' + r + '"'),
      (e.result = e.anchorMap[r]),
      An(e, !0, -1),
      !0
    )
  }
  function ld(e, t, r, n, i) {
    var s,
      o,
      l,
      u = 1,
      h = !1,
      f = !1,
      d,
      p,
      m,
      g,
      y,
      b
    if (
      (e.listener !== null && e.listener('open', e),
      (e.tag = null),
      (e.anchor = null),
      (e.kind = null),
      (e.result = null),
      (s = o = l = bb === r || CG === r),
      n &&
        An(e, !0, -1) &&
        ((h = !0), e.lineIndent > t ? (u = 1) : e.lineIndent === t ? (u = 0) : e.lineIndent < t && (u = -1)),
      u === 1)
    )
      for (; Nxt(e) || Ixt(e); )
        An(e, !0, -1)
          ? ((h = !0),
            (l = s),
            e.lineIndent > t ? (u = 1) : e.lineIndent === t ? (u = 0) : e.lineIndent < t && (u = -1))
          : (l = !1)
    if (
      (l && (l = h || i),
      (u === 1 || bb === r) &&
        (xb === r || _G === r ? (y = t) : (y = t + 1),
        (b = e.position - e.lineStart),
        u === 1
          ? (l && (lG(e, b) || Dxt(e, b, y))) || Lxt(e, y)
            ? (f = !0)
            : ((o && Rxt(e, y)) || vxt(e, y) || Axt(e, y)
                ? (f = !0)
                : Mxt(e)
                  ? ((f = !0),
                    (e.tag !== null || e.anchor !== null) && me(e, 'alias node should not have any properties'))
                  : Ext(e, y, xb === r) && ((f = !0), e.tag === null && (e.tag = '?')),
              e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
          : u === 0 && (f = l && lG(e, b))),
      e.tag === null)
    )
      e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
    else if (e.tag === '?') {
      for (
        e.result !== null &&
          e.kind !== 'scalar' &&
          me(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'),
          d = 0,
          p = e.implicitTypes.length;
        d < p;
        d += 1
      )
        if (((g = e.implicitTypes[d]), g.resolve(e.result))) {
          ;(e.result = g.construct(e.result)), (e.tag = g.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
          break
        }
    } else if (e.tag !== '!') {
      if (Sc.call(e.typeMap[e.kind || 'fallback'], e.tag)) g = e.typeMap[e.kind || 'fallback'][e.tag]
      else
        for (g = null, m = e.typeMap.multi[e.kind || 'fallback'], d = 0, p = m.length; d < p; d += 1)
          if (e.tag.slice(0, m[d].tag.length) === m[d].tag) {
            g = m[d]
            break
          }
      g || me(e, 'unknown tag !<' + e.tag + '>'),
        e.result !== null &&
          g.kind !== e.kind &&
          me(e, 'unacceptable node kind for !<' + e.tag + '> tag; it should be "' + g.kind + '", not "' + e.kind + '"'),
        g.resolve(e.result, e.tag)
          ? ((e.result = g.construct(e.result, e.tag)), e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
          : me(e, 'cannot resolve a node with !<' + e.tag + '> explicit tag')
    }
    return e.listener !== null && e.listener('close', e), e.tag !== null || e.anchor !== null || f
  }
  function Oxt(e) {
    var t = e.position,
      r,
      n,
      i,
      s = !1,
      o
    for (
      e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = Object.create(null), e.anchorMap = Object.create(null);
      (o = e.input.charCodeAt(e.position)) !== 0 &&
      (An(e, !0, -1), (o = e.input.charCodeAt(e.position)), !(e.lineIndent > 0 || o !== 37));

    ) {
      for (s = !0, o = e.input.charCodeAt(++e.position), r = e.position; o !== 0 && !os(o); )
        o = e.input.charCodeAt(++e.position)
      for (
        n = e.input.slice(r, e.position),
          i = [],
          n.length < 1 && me(e, 'directive name must not be less than one character in length');
        o !== 0;

      ) {
        for (; Ku(o); ) o = e.input.charCodeAt(++e.position)
        if (o === 35) {
          do o = e.input.charCodeAt(++e.position)
          while (o !== 0 && !xo(o))
          break
        }
        if (xo(o)) break
        for (r = e.position; o !== 0 && !os(o); ) o = e.input.charCodeAt(++e.position)
        i.push(e.input.slice(r, e.position))
      }
      o !== 0 && U4(e), Sc.call(aG, n) ? aG[n](e, n, i) : kb(e, 'unknown document directive "' + n + '"')
    }
    if (
      (An(e, !0, -1),
      e.lineIndent === 0 &&
      e.input.charCodeAt(e.position) === 45 &&
      e.input.charCodeAt(e.position + 1) === 45 &&
      e.input.charCodeAt(e.position + 2) === 45
        ? ((e.position += 3), An(e, !0, -1))
        : s && me(e, 'directives end mark is expected'),
      ld(e, e.lineIndent - 1, bb, !1, !0),
      An(e, !0, -1),
      e.checkLineBreaks &&
        bxt.test(e.input.slice(t, e.position)) &&
        kb(e, 'non-ASCII line breaks are interpreted as content'),
      e.documents.push(e.result),
      e.position === e.lineStart && _b(e))
    ) {
      e.input.charCodeAt(e.position) === 46 && ((e.position += 3), An(e, !0, -1))
      return
    }
    if (e.position < e.length - 1) me(e, 'end of the stream or a document separator is expected')
    else return
  }
  function RG(e, t) {
    ;(e = String(e)),
      (t = t || {}),
      e.length !== 0 &&
        (e.charCodeAt(e.length - 1) !== 10 &&
          e.charCodeAt(e.length - 1) !== 13 &&
          (e += `
`),
        e.charCodeAt(0) === 65279 && (e = e.slice(1)))
    var r = new wxt(e, t),
      n = e.indexOf('\0')
    for (
      n !== -1 && ((r.position = n), me(r, 'null byte is not allowed in input')), r.input += '\0';
      r.input.charCodeAt(r.position) === 32;

    )
      (r.lineIndent += 1), (r.position += 1)
    for (; r.position < r.length - 1; ) Oxt(r)
    return r.documents
  }
  function Pxt(e, t, r) {
    t !== null && typeof t == 'object' && typeof r > 'u' && ((r = t), (t = null))
    var n = RG(e, r)
    if (typeof t != 'function') return n
    for (var i = 0, s = n.length; i < s; i += 1) t(n[i])
  }
  function Bxt(e, t) {
    var r = RG(e, t)
    if (r.length !== 0) {
      if (r.length === 1) return r[0]
      throw new as('expected a single document in the stream, but found more')
    }
  }
  function i2t(e, t) {
    var r, n, i, s, o, l, u
    if (t === null) return {}
    for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
      (o = n[i]),
        (l = String(t[o])),
        o.slice(0, 2) === '!!' && (o = 'tag:yaml.org,2002:' + o.slice(2)),
        (u = e.compiledTypeMap.fallback[o]),
        u && IG.call(u.styleAliases, l) && (l = u.styleAliases[l]),
        (r[o] = l)
    return r
  }
  function s2t(e) {
    var t, r, n
    if (((t = e.toString(16).toUpperCase()), e <= 255)) (r = 'x'), (n = 2)
    else if (e <= 65535) (r = 'u'), (n = 4)
    else if (e <= 4294967295) (r = 'U'), (n = 8)
    else throw new as('code point within a string may not be greater than 0xFFFFFFFF')
    return '\\' + r + Bn.repeat('0', n - t.length) + t
  }
  function o2t(e) {
    ;(this.schema = e.schema || SG),
      (this.indent = Math.max(1, e.indent || 2)),
      (this.noArrayIndent = e.noArrayIndent || !1),
      (this.skipInvalid = e.skipInvalid || !1),
      (this.flowLevel = Bn.isNothing(e.flowLevel) ? -1 : e.flowLevel),
      (this.styleMap = i2t(this.schema, e.styles || null)),
      (this.sortKeys = e.sortKeys || !1),
      (this.lineWidth = e.lineWidth || 80),
      (this.noRefs = e.noRefs || !1),
      (this.noCompatMode = e.noCompatMode || !1),
      (this.condenseFlow = e.condenseFlow || !1),
      (this.quotingType = e.quotingType === '"' ? C0 : a2t),
      (this.forceQuotes = e.forceQuotes || !1),
      (this.replacer = typeof e.replacer == 'function' ? e.replacer : null),
      (this.implicitTypes = this.schema.compiledImplicit),
      (this.explicitTypes = this.schema.compiledExplicit),
      (this.tag = null),
      (this.result = ''),
      (this.duplicates = []),
      (this.usedDuplicates = null)
  }
  function cG(e, t) {
    for (var r = Bn.repeat(' ', t), n = 0, i = -1, s = '', o, l = e.length; n < l; )
      (i = e.indexOf(
        `
`,
        n,
      )),
        i === -1 ? ((o = e.slice(n)), (n = l)) : ((o = e.slice(n, i + 1)), (n = i + 1)),
        o.length &&
          o !==
            `
` &&
          (s += r),
        (s += o)
    return s
  }
  function G4(e, t) {
    return (
      `
` + Bn.repeat(' ', e.indent * t)
    )
  }
  function l2t(e, t) {
    var r, n, i
    for (r = 0, n = e.implicitTypes.length; r < n; r += 1) if (((i = e.implicitTypes[r]), i.resolve(t))) return !0
    return !1
  }
  function Sb(e) {
    return e === zxt || e === Gxt
  }
  function w0(e) {
    return (
      (32 <= e && e <= 126) ||
      (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
      (57344 <= e && e <= 65533 && e !== q4) ||
      (65536 <= e && e <= 1114111)
    )
  }
  function uG(e) {
    return w0(e) && e !== q4 && e !== Vxt && e !== _0
  }
  function hG(e, t, r) {
    var n = uG(e),
      i = n && !Sb(e)
    return (
      ((r ? n : n && e !== MG && e !== OG && e !== PG && e !== BG && e !== FG) && e !== $4 && !(t === Tb && !i)) ||
      (uG(t) && !Sb(t) && e === $4) ||
      (t === Tb && i)
    )
  }
  function c2t(e) {
    return (
      w0(e) &&
      e !== q4 &&
      !Sb(e) &&
      e !== Xxt &&
      e !== Zxt &&
      e !== Tb &&
      e !== MG &&
      e !== OG &&
      e !== PG &&
      e !== BG &&
      e !== FG &&
      e !== $4 &&
      e !== qxt &&
      e !== Yxt &&
      e !== Wxt &&
      e !== e2t &&
      e !== Kxt &&
      e !== Qxt &&
      e !== Hxt &&
      e !== Uxt &&
      e !== jxt &&
      e !== Jxt &&
      e !== t2t
    )
  }
  function u2t(e) {
    return !Sb(e) && e !== Tb
  }
  function T0(e, t) {
    var r = e.charCodeAt(t),
      n
    return r >= 55296 && r <= 56319 && t + 1 < e.length && ((n = e.charCodeAt(t + 1)), n >= 56320 && n <= 57343)
      ? (r - 55296) * 1024 + n - 56320 + 65536
      : r
  }
  function $G(e) {
    var t = /^\n* /
    return t.test(e)
  }
  function h2t(e, t, r, n, i, s, o, l) {
    var u,
      h = 0,
      f = null,
      d = !1,
      p = !1,
      m = n !== -1,
      g = -1,
      y = c2t(T0(e, 0)) && u2t(T0(e, e.length - 1))
    if (t || o)
      for (u = 0; u < e.length; h >= 65536 ? (u += 2) : u++) {
        if (((h = T0(e, u)), !w0(h))) return sd
        ;(y = y && hG(h, f, l)), (f = h)
      }
    else {
      for (u = 0; u < e.length; h >= 65536 ? (u += 2) : u++) {
        if (((h = T0(e, u)), h === _0)) (d = !0), m && ((p = p || (u - g - 1 > n && e[g + 1] !== ' ')), (g = u))
        else if (!w0(h)) return sd
        ;(y = y && hG(h, f, l)), (f = h)
      }
      p = p || (m && u - g - 1 > n && e[g + 1] !== ' ')
    }
    return !d && !p
      ? y && !o && !i(e)
        ? GG
        : s === C0
          ? sd
          : V4
      : r > 9 && $G(e)
        ? sd
        : o
          ? s === C0
            ? sd
            : V4
          : p
            ? zG
            : VG
  }
  function f2t(e, t, r, n, i) {
    e.dump = (function () {
      if (t.length === 0) return e.quotingType === C0 ? '""' : "''"
      if (!e.noCompatMode && (r2t.indexOf(t) !== -1 || n2t.test(t)))
        return e.quotingType === C0 ? '"' + t + '"' : "'" + t + "'"
      var s = e.indent * Math.max(1, r),
        o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s),
        l = n || (e.flowLevel > -1 && r >= e.flowLevel)
      function u(h) {
        return l2t(e, h)
      }
      switch ((a(u, 'testAmbiguity'), h2t(t, l, e.indent, o, u, e.quotingType, e.forceQuotes && !n, i))) {
        case GG:
          return t
        case V4:
          return "'" + t.replace(/'/g, "''") + "'"
        case VG:
          return '|' + fG(t, e.indent) + dG(cG(t, s))
        case zG:
          return '>' + fG(t, e.indent) + dG(cG(d2t(t, o), s))
        case sd:
          return '"' + p2t(t) + '"'
        default:
          throw new as('impossible error: invalid scalar style')
      }
    })()
  }
  function fG(e, t) {
    var r = $G(e) ? String(t) : '',
      n =
        e[e.length - 1] ===
        `
`,
      i =
        n &&
        (e[e.length - 2] ===
          `
` ||
          e ===
            `
`),
      s = i ? '+' : n ? '' : '-'
    return (
      r +
      s +
      `
`
    )
  }
  function dG(e) {
    return e[e.length - 1] ===
      `
`
      ? e.slice(0, -1)
      : e
  }
  function d2t(e, t) {
    for (
      var r = /(\n+)([^\n]*)/g,
        n = (function () {
          var h = e.indexOf(`
`)
          return (h = h !== -1 ? h : e.length), (r.lastIndex = h), pG(e.slice(0, h), t)
        })(),
        i =
          e[0] ===
            `
` || e[0] === ' ',
        s,
        o;
      (o = r.exec(e));

    ) {
      var l = o[1],
        u = o[2]
      ;(s = u[0] === ' '),
        (n +=
          l +
          (!i && !s && u !== ''
            ? `
`
            : '') +
          pG(u, t)),
        (i = s)
    }
    return n
  }
  function pG(e, t) {
    if (e === '' || e[0] === ' ') return e
    for (var r = / [^ ]/g, n, i = 0, s, o = 0, l = 0, u = ''; (n = r.exec(e)); )
      (l = n.index),
        l - i > t &&
          ((s = o > i ? o : l),
          (u +=
            `
` + e.slice(i, s)),
          (i = s + 1)),
        (o = l)
    return (
      (u += `
`),
      e.length - i > t && o > i
        ? (u +=
            e.slice(i, o) +
            `
` +
            e.slice(o + 1))
        : (u += e.slice(i)),
      u.slice(1)
    )
  }
  function p2t(e) {
    for (var t = '', r = 0, n, i = 0; i < e.length; r >= 65536 ? (i += 2) : i++)
      (r = T0(e, i)), (n = xi[r]), !n && w0(r) ? ((t += e[i]), r >= 65536 && (t += e[i + 1])) : (t += n || s2t(r))
    return t
  }
  function m2t(e, t, r) {
    var n = '',
      i = e.tag,
      s,
      o,
      l
    for (s = 0, o = r.length; s < o; s += 1)
      (l = r[s]),
        e.replacer && (l = e.replacer.call(r, String(s), l)),
        (gl(e, t, l, !1, !1) || (typeof l > 'u' && gl(e, t, null, !1, !1))) &&
          (n !== '' && (n += ',' + (e.condenseFlow ? '' : ' ')), (n += e.dump))
    ;(e.tag = i), (e.dump = '[' + n + ']')
  }
  function mG(e, t, r, n) {
    var i = '',
      s = e.tag,
      o,
      l,
      u
    for (o = 0, l = r.length; o < l; o += 1)
      (u = r[o]),
        e.replacer && (u = e.replacer.call(r, String(o), u)),
        (gl(e, t + 1, u, !0, !0, !1, !0) || (typeof u > 'u' && gl(e, t + 1, null, !0, !0, !1, !0))) &&
          ((!n || i !== '') && (i += G4(e, t)),
          e.dump && _0 === e.dump.charCodeAt(0) ? (i += '-') : (i += '- '),
          (i += e.dump))
    ;(e.tag = s), (e.dump = i || '[]')
  }
  function g2t(e, t, r) {
    var n = '',
      i = e.tag,
      s = Object.keys(r),
      o,
      l,
      u,
      h,
      f
    for (o = 0, l = s.length; o < l; o += 1)
      (f = ''),
        n !== '' && (f += ', '),
        e.condenseFlow && (f += '"'),
        (u = s[o]),
        (h = r[u]),
        e.replacer && (h = e.replacer.call(r, u, h)),
        gl(e, t, u, !1, !1) &&
          (e.dump.length > 1024 && (f += '? '),
          (f += e.dump + (e.condenseFlow ? '"' : '') + ':' + (e.condenseFlow ? '' : ' ')),
          gl(e, t, h, !1, !1) && ((f += e.dump), (n += f)))
    ;(e.tag = i), (e.dump = '{' + n + '}')
  }
  function y2t(e, t, r, n) {
    var i = '',
      s = e.tag,
      o = Object.keys(r),
      l,
      u,
      h,
      f,
      d,
      p
    if (e.sortKeys === !0) o.sort()
    else if (typeof e.sortKeys == 'function') o.sort(e.sortKeys)
    else if (e.sortKeys) throw new as('sortKeys must be a boolean or a function')
    for (l = 0, u = o.length; l < u; l += 1)
      (p = ''),
        (!n || i !== '') && (p += G4(e, t)),
        (h = o[l]),
        (f = r[h]),
        e.replacer && (f = e.replacer.call(r, h, f)),
        gl(e, t + 1, h, !0, !0, !0) &&
          ((d = (e.tag !== null && e.tag !== '?') || (e.dump && e.dump.length > 1024)),
          d && (e.dump && _0 === e.dump.charCodeAt(0) ? (p += '?') : (p += '? ')),
          (p += e.dump),
          d && (p += G4(e, t)),
          gl(e, t + 1, f, !0, d) &&
            (e.dump && _0 === e.dump.charCodeAt(0) ? (p += ':') : (p += ': '), (p += e.dump), (i += p)))
    ;(e.tag = s), (e.dump = i || '{}')
  }
  function gG(e, t, r) {
    var n, i, s, o, l, u
    for (i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length; s < o; s += 1)
      if (
        ((l = i[s]),
        (l.instanceOf || l.predicate) &&
          (!l.instanceOf || (typeof t == 'object' && t instanceof l.instanceOf)) &&
          (!l.predicate || l.predicate(t)))
      ) {
        if (
          (r ? (l.multi && l.representName ? (e.tag = l.representName(t)) : (e.tag = l.tag)) : (e.tag = '?'),
          l.represent)
        ) {
          if (((u = e.styleMap[l.tag] || l.defaultStyle), NG.call(l.represent) === '[object Function]'))
            n = l.represent(t, u)
          else if (IG.call(l.represent, u)) n = l.represent[u](t, u)
          else throw new as('!<' + l.tag + '> tag resolver accepts not "' + u + '" style')
          e.dump = n
        }
        return !0
      }
    return !1
  }
  function gl(e, t, r, n, i, s, o) {
    ;(e.tag = null), (e.dump = r), gG(e, r, !1) || gG(e, r, !0)
    var l = NG.call(e.dump),
      u = n,
      h
    n && (n = e.flowLevel < 0 || e.flowLevel > t)
    var f = l === '[object Object]' || l === '[object Array]',
      d,
      p
    if (
      (f && ((d = e.duplicates.indexOf(r)), (p = d !== -1)),
      ((e.tag !== null && e.tag !== '?') || p || (e.indent !== 2 && t > 0)) && (i = !1),
      p && e.usedDuplicates[d])
    )
      e.dump = '*ref_' + d
    else {
      if ((f && p && !e.usedDuplicates[d] && (e.usedDuplicates[d] = !0), l === '[object Object]'))
        n && Object.keys(e.dump).length !== 0
          ? (y2t(e, t, e.dump, i), p && (e.dump = '&ref_' + d + e.dump))
          : (g2t(e, t, e.dump), p && (e.dump = '&ref_' + d + ' ' + e.dump))
      else if (l === '[object Array]')
        n && e.dump.length !== 0
          ? (e.noArrayIndent && !o && t > 0 ? mG(e, t - 1, e.dump, i) : mG(e, t, e.dump, i),
            p && (e.dump = '&ref_' + d + e.dump))
          : (m2t(e, t, e.dump), p && (e.dump = '&ref_' + d + ' ' + e.dump))
      else if (l === '[object String]') e.tag !== '?' && f2t(e, e.dump, t, s, u)
      else {
        if (l === '[object Undefined]') return !1
        if (e.skipInvalid) return !1
        throw new as('unacceptable kind of an object to dump ' + l)
      }
      e.tag !== null &&
        e.tag !== '?' &&
        ((h = encodeURI(e.tag[0] === '!' ? e.tag.slice(1) : e.tag).replace(/!/g, '%21')),
        e.tag[0] === '!'
          ? (h = '!' + h)
          : h.slice(0, 18) === 'tag:yaml.org,2002:'
            ? (h = '!!' + h.slice(18))
            : (h = '!<' + h + '>'),
        (e.dump = h + ' ' + e.dump))
    }
    return !0
  }
  function x2t(e, t) {
    var r = [],
      n = [],
      i,
      s
    for (z4(e, r, n), i = 0, s = n.length; i < s; i += 1) t.duplicates.push(r[n[i]])
    t.usedDuplicates = new Array(s)
  }
  function z4(e, t, r) {
    var n, i, s
    if (e !== null && typeof e == 'object')
      if (((i = t.indexOf(e)), i !== -1)) r.indexOf(i) === -1 && r.push(i)
      else if ((t.push(e), Array.isArray(e))) for (i = 0, s = e.length; i < s; i += 1) z4(e[i], t, r)
      else for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1) z4(e[n[i]], t, r)
  }
  function b2t(e, t) {
    t = t || {}
    var r = new o2t(t)
    r.noRefs || x2t(e, r)
    var n = e
    return (
      r.replacer && (n = r.replacer.call({ '': n }, '', n)),
      gl(r, 0, n, !0, !0)
        ? r.dump +
          `
`
        : ''
    )
  }
  function H4(e, t) {
    return function () {
      throw new Error(
        'Function yaml.' + e + ' is removed in js-yaml 4. Use yaml.' + t + ' instead, which is now safe by default.',
      )
    }
  }
  var ayt,
    oyt,
    lyt,
    cyt,
    uyt,
    hyt,
    Bn,
    as,
    dyt,
    pyt,
    myt,
    yi,
    byt,
    kyt,
    Tyt,
    Syt,
    _yt,
    vyt,
    Dyt,
    Fyt,
    $yt,
    zyt,
    jyt,
    bG,
    qyt,
    kG,
    TG,
    Kyt,
    Zyt,
    W4,
    nxt,
    ixt,
    sxt,
    lxt,
    cxt,
    fxt,
    dxt,
    gxt,
    SG,
    Sc,
    xb,
    _G,
    CG,
    bb,
    B4,
    yxt,
    nG,
    xxt,
    bxt,
    kxt,
    wG,
    EG,
    vG,
    AG,
    Xu,
    aG,
    Fxt,
    $xt,
    DG,
    NG,
    IG,
    q4,
    Gxt,
    _0,
    Vxt,
    zxt,
    Wxt,
    Uxt,
    $4,
    jxt,
    qxt,
    Hxt,
    Yxt,
    MG,
    Xxt,
    Tb,
    Kxt,
    Qxt,
    Zxt,
    Jxt,
    OG,
    PG,
    t2t,
    BG,
    e2t,
    FG,
    xi,
    r2t,
    n2t,
    a2t,
    C0,
    GG,
    V4,
    VG,
    zG,
    sd,
    k2t,
    T2t,
    _c,
    Cc,
    Dae,
    Nae,
    Iae,
    Mae,
    Oae,
    E0 = x(() => {
      'use strict'
      a(yG, 'isNothing')
      a(eyt, 'isObject')
      a(ryt, 'toArray')
      a(nyt, 'extend')
      a(iyt, 'repeat')
      a(syt, 'isNegativeZero')
      ;(ayt = yG),
        (oyt = eyt),
        (lyt = ryt),
        (cyt = iyt),
        (uyt = syt),
        (hyt = nyt),
        (Bn = { isNothing: ayt, isObject: oyt, toArray: lyt, repeat: cyt, isNegativeZero: uyt, extend: hyt })
      a(xG, 'formatError')
      a(S0, 'YAMLException$1')
      S0.prototype = Object.create(Error.prototype)
      S0.prototype.constructor = S0
      S0.prototype.toString = a(function (t) {
        return this.name + ': ' + xG(this, t)
      }, 'toString')
      as = S0
      a(O4, 'getLine')
      a(P4, 'padStart')
      a(fyt, 'makeSnippet')
      ;(dyt = fyt),
        (pyt = [
          'kind',
          'multi',
          'resolve',
          'construct',
          'instanceOf',
          'predicate',
          'represent',
          'representName',
          'defaultStyle',
          'styleAliases',
        ]),
        (myt = ['scalar', 'sequence', 'mapping'])
      a(gyt, 'compileStyleAliases')
      a(yyt, 'Type$1')
      yi = yyt
      a(rG, 'compileList')
      a(xyt, 'compileMap')
      a(F4, 'Schema$1')
      F4.prototype.extend = a(function (t) {
        var r = [],
          n = []
        if (t instanceof yi) n.push(t)
        else if (Array.isArray(t)) n = n.concat(t)
        else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
          t.implicit && (r = r.concat(t.implicit)), t.explicit && (n = n.concat(t.explicit))
        else
          throw new as(
            'Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })',
          )
        r.forEach(function (s) {
          if (!(s instanceof yi))
            throw new as('Specified list of YAML types (or a single Type object) contains a non-Type object.')
          if (s.loadKind && s.loadKind !== 'scalar')
            throw new as(
              'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.',
            )
          if (s.multi)
            throw new as(
              'There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.',
            )
        }),
          n.forEach(function (s) {
            if (!(s instanceof yi))
              throw new as('Specified list of YAML types (or a single Type object) contains a non-Type object.')
          })
        var i = Object.create(F4.prototype)
        return (
          (i.implicit = (this.implicit || []).concat(r)),
          (i.explicit = (this.explicit || []).concat(n)),
          (i.compiledImplicit = rG(i, 'implicit')),
          (i.compiledExplicit = rG(i, 'explicit')),
          (i.compiledTypeMap = xyt(i.compiledImplicit, i.compiledExplicit)),
          i
        )
      }, 'extend')
      ;(byt = F4),
        (kyt = new yi('tag:yaml.org,2002:str', {
          kind: 'scalar',
          construct: a(function (e) {
            return e !== null ? e : ''
          }, 'construct'),
        })),
        (Tyt = new yi('tag:yaml.org,2002:seq', {
          kind: 'sequence',
          construct: a(function (e) {
            return e !== null ? e : []
          }, 'construct'),
        })),
        (Syt = new yi('tag:yaml.org,2002:map', {
          kind: 'mapping',
          construct: a(function (e) {
            return e !== null ? e : {}
          }, 'construct'),
        })),
        (_yt = new byt({ explicit: [kyt, Tyt, Syt] }))
      a(Cyt, 'resolveYamlNull')
      a(wyt, 'constructYamlNull')
      a(Eyt, 'isNull')
      vyt = new yi('tag:yaml.org,2002:null', {
        kind: 'scalar',
        resolve: Cyt,
        construct: wyt,
        predicate: Eyt,
        represent: {
          canonical: a(function () {
            return '~'
          }, 'canonical'),
          lowercase: a(function () {
            return 'null'
          }, 'lowercase'),
          uppercase: a(function () {
            return 'NULL'
          }, 'uppercase'),
          camelcase: a(function () {
            return 'Null'
          }, 'camelcase'),
          empty: a(function () {
            return ''
          }, 'empty'),
        },
        defaultStyle: 'lowercase',
      })
      a(Ayt, 'resolveYamlBoolean')
      a(Lyt, 'constructYamlBoolean')
      a(Ryt, 'isBoolean')
      Dyt = new yi('tag:yaml.org,2002:bool', {
        kind: 'scalar',
        resolve: Ayt,
        construct: Lyt,
        predicate: Ryt,
        represent: {
          lowercase: a(function (e) {
            return e ? 'true' : 'false'
          }, 'lowercase'),
          uppercase: a(function (e) {
            return e ? 'TRUE' : 'FALSE'
          }, 'uppercase'),
          camelcase: a(function (e) {
            return e ? 'True' : 'False'
          }, 'camelcase'),
        },
        defaultStyle: 'lowercase',
      })
      a(Nyt, 'isHexCode')
      a(Iyt, 'isOctCode')
      a(Myt, 'isDecCode')
      a(Oyt, 'resolveYamlInteger')
      a(Pyt, 'constructYamlInteger')
      a(Byt, 'isInteger')
      ;(Fyt = new yi('tag:yaml.org,2002:int', {
        kind: 'scalar',
        resolve: Oyt,
        construct: Pyt,
        predicate: Byt,
        represent: {
          binary: a(function (e) {
            return e >= 0 ? '0b' + e.toString(2) : '-0b' + e.toString(2).slice(1)
          }, 'binary'),
          octal: a(function (e) {
            return e >= 0 ? '0o' + e.toString(8) : '-0o' + e.toString(8).slice(1)
          }, 'octal'),
          decimal: a(function (e) {
            return e.toString(10)
          }, 'decimal'),
          hexadecimal: a(function (e) {
            return e >= 0 ? '0x' + e.toString(16).toUpperCase() : '-0x' + e.toString(16).toUpperCase().slice(1)
          }, 'hexadecimal'),
        },
        defaultStyle: 'decimal',
        styleAliases: { binary: [2, 'bin'], octal: [8, 'oct'], decimal: [10, 'dec'], hexadecimal: [16, 'hex'] },
      })),
        ($yt = new RegExp(
          '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$',
        ))
      a(Gyt, 'resolveYamlFloat')
      a(Vyt, 'constructYamlFloat')
      zyt = /^[-+]?[0-9]+e/
      a(Wyt, 'representYamlFloat')
      a(Uyt, 'isFloat')
      ;(jyt = new yi('tag:yaml.org,2002:float', {
        kind: 'scalar',
        resolve: Gyt,
        construct: Vyt,
        predicate: Uyt,
        represent: Wyt,
        defaultStyle: 'lowercase',
      })),
        (bG = _yt.extend({ implicit: [vyt, Dyt, Fyt, jyt] })),
        (qyt = bG),
        (kG = new RegExp('^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$')),
        (TG = new RegExp(
          '^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$',
        ))
      a(Hyt, 'resolveYamlTimestamp')
      a(Yyt, 'constructYamlTimestamp')
      a(Xyt, 'representYamlTimestamp')
      Kyt = new yi('tag:yaml.org,2002:timestamp', {
        kind: 'scalar',
        resolve: Hyt,
        construct: Yyt,
        instanceOf: Date,
        represent: Xyt,
      })
      a(Qyt, 'resolveYamlMerge')
      ;(Zyt = new yi('tag:yaml.org,2002:merge', { kind: 'scalar', resolve: Qyt })),
        (W4 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`)
      a(Jyt, 'resolveYamlBinary')
      a(txt, 'constructYamlBinary')
      a(ext, 'representYamlBinary')
      a(rxt, 'isBinary')
      ;(nxt = new yi('tag:yaml.org,2002:binary', {
        kind: 'scalar',
        resolve: Jyt,
        construct: txt,
        predicate: rxt,
        represent: ext,
      })),
        (ixt = Object.prototype.hasOwnProperty),
        (sxt = Object.prototype.toString)
      a(axt, 'resolveYamlOmap')
      a(oxt, 'constructYamlOmap')
      ;(lxt = new yi('tag:yaml.org,2002:omap', { kind: 'sequence', resolve: axt, construct: oxt })),
        (cxt = Object.prototype.toString)
      a(uxt, 'resolveYamlPairs')
      a(hxt, 'constructYamlPairs')
      ;(fxt = new yi('tag:yaml.org,2002:pairs', { kind: 'sequence', resolve: uxt, construct: hxt })),
        (dxt = Object.prototype.hasOwnProperty)
      a(pxt, 'resolveYamlSet')
      a(mxt, 'constructYamlSet')
      ;(gxt = new yi('tag:yaml.org,2002:set', { kind: 'mapping', resolve: pxt, construct: mxt })),
        (SG = qyt.extend({ implicit: [Kyt, Zyt], explicit: [nxt, lxt, fxt, gxt] })),
        (Sc = Object.prototype.hasOwnProperty),
        (xb = 1),
        (_G = 2),
        (CG = 3),
        (bb = 4),
        (B4 = 1),
        (yxt = 2),
        (nG = 3),
        (xxt =
          /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/),
        (bxt = /[\x85\u2028\u2029]/),
        (kxt = /[,\[\]\{\}]/),
        (wG = /^(?:!|!!|![a-z\-]+!)$/i),
        (EG = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i)
      a(iG, '_class')
      a(xo, 'is_EOL')
      a(Ku, 'is_WHITE_SPACE')
      a(os, 'is_WS_OR_EOL')
      a(ad, 'is_FLOW_INDICATOR')
      a(Txt, 'fromHexCode')
      a(Sxt, 'escapedHexLen')
      a(_xt, 'fromDecimalCode')
      a(sG, 'simpleEscapeSequence')
      a(Cxt, 'charFromCodepoint')
      ;(vG = new Array(256)), (AG = new Array(256))
      for (Xu = 0; Xu < 256; Xu++) (vG[Xu] = sG(Xu) ? 1 : 0), (AG[Xu] = sG(Xu))
      a(wxt, 'State$1')
      a(LG, 'generateError')
      a(me, 'throwError')
      a(kb, 'throwWarning')
      aG = {
        YAML: a(function (t, r, n) {
          var i, s, o
          t.version !== null && me(t, 'duplication of %YAML directive'),
            n.length !== 1 && me(t, 'YAML directive accepts exactly one argument'),
            (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])),
            i === null && me(t, 'ill-formed argument of the YAML directive'),
            (s = parseInt(i[1], 10)),
            (o = parseInt(i[2], 10)),
            s !== 1 && me(t, 'unacceptable YAML version of the document'),
            (t.version = n[0]),
            (t.checkLineBreaks = o < 2),
            o !== 1 && o !== 2 && kb(t, 'unsupported YAML version of the document')
        }, 'handleYamlDirective'),
        TAG: a(function (t, r, n) {
          var i, s
          n.length !== 2 && me(t, 'TAG directive accepts exactly two arguments'),
            (i = n[0]),
            (s = n[1]),
            wG.test(i) || me(t, 'ill-formed tag handle (first argument) of the TAG directive'),
            Sc.call(t.tagMap, i) && me(t, 'there is a previously declared suffix for "' + i + '" tag handle'),
            EG.test(s) || me(t, 'ill-formed tag prefix (second argument) of the TAG directive')
          try {
            s = decodeURIComponent(s)
          } catch {
            me(t, 'tag prefix is malformed: ' + s)
          }
          t.tagMap[i] = s
        }, 'handleTagDirective'),
      }
      a(Tc, 'captureSegment')
      a(oG, 'mergeMappings')
      a(od, 'storeMappingPair')
      a(U4, 'readLineBreak')
      a(An, 'skipSeparationSpace')
      a(_b, 'testDocumentSeparator')
      a(j4, 'writeFoldedLines')
      a(Ext, 'readPlainScalar')
      a(vxt, 'readSingleQuotedScalar')
      a(Axt, 'readDoubleQuotedScalar')
      a(Lxt, 'readFlowCollection')
      a(Rxt, 'readBlockScalar')
      a(lG, 'readBlockSequence')
      a(Dxt, 'readBlockMapping')
      a(Nxt, 'readTagProperty')
      a(Ixt, 'readAnchorProperty')
      a(Mxt, 'readAlias')
      a(ld, 'composeNode')
      a(Oxt, 'readDocument')
      a(RG, 'loadDocuments')
      a(Pxt, 'loadAll$1')
      a(Bxt, 'load$1')
      ;(Fxt = Pxt),
        ($xt = Bxt),
        (DG = { loadAll: Fxt, load: $xt }),
        (NG = Object.prototype.toString),
        (IG = Object.prototype.hasOwnProperty),
        (q4 = 65279),
        (Gxt = 9),
        (_0 = 10),
        (Vxt = 13),
        (zxt = 32),
        (Wxt = 33),
        (Uxt = 34),
        ($4 = 35),
        (jxt = 37),
        (qxt = 38),
        (Hxt = 39),
        (Yxt = 42),
        (MG = 44),
        (Xxt = 45),
        (Tb = 58),
        (Kxt = 61),
        (Qxt = 62),
        (Zxt = 63),
        (Jxt = 64),
        (OG = 91),
        (PG = 93),
        (t2t = 96),
        (BG = 123),
        (e2t = 124),
        (FG = 125),
        (xi = {})
      xi[0] = '\\0'
      xi[7] = '\\a'
      xi[8] = '\\b'
      xi[9] = '\\t'
      xi[10] = '\\n'
      xi[11] = '\\v'
      xi[12] = '\\f'
      xi[13] = '\\r'
      xi[27] = '\\e'
      xi[34] = '\\"'
      xi[92] = '\\\\'
      xi[133] = '\\N'
      xi[160] = '\\_'
      xi[8232] = '\\L'
      xi[8233] = '\\P'
      ;(r2t = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF']),
        (n2t = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/)
      a(i2t, 'compileStyleMap')
      a(s2t, 'encodeHex')
      ;(a2t = 1), (C0 = 2)
      a(o2t, 'State')
      a(cG, 'indentString')
      a(G4, 'generateNextLine')
      a(l2t, 'testImplicitResolving')
      a(Sb, 'isWhitespace')
      a(w0, 'isPrintable')
      a(uG, 'isNsCharOrWhitespace')
      a(hG, 'isPlainSafe')
      a(c2t, 'isPlainSafeFirst')
      a(u2t, 'isPlainSafeLast')
      a(T0, 'codePointAt')
      a($G, 'needIndentIndicator')
      ;(GG = 1), (V4 = 2), (VG = 3), (zG = 4), (sd = 5)
      a(h2t, 'chooseScalarStyle')
      a(f2t, 'writeScalar')
      a(fG, 'blockHeader')
      a(dG, 'dropEndingNewline')
      a(d2t, 'foldString')
      a(pG, 'foldLine')
      a(p2t, 'escapeString')
      a(m2t, 'writeFlowSequence')
      a(mG, 'writeBlockSequence')
      a(g2t, 'writeFlowMapping')
      a(y2t, 'writeBlockMapping')
      a(gG, 'detectType')
      a(gl, 'writeNode')
      a(x2t, 'getDuplicateReferences')
      a(z4, 'inspectNode')
      a(b2t, 'dump$1')
      ;(k2t = b2t), (T2t = { dump: k2t })
      a(H4, 'renamed')
      ;(_c = bG),
        (Cc = DG.load),
        (Dae = DG.loadAll),
        (Nae = T2t.dump),
        (Iae = H4('safeLoad', 'load')),
        (Mae = H4('safeLoadAll', 'loadAll')),
        (Oae = H4('safeDump', 'dump'))
    })
  function Q4() {
    return {
      async: !1,
      breaks: !1,
      extensions: null,
      gfm: !0,
      hooks: null,
      pedantic: !1,
      renderer: null,
      silent: !1,
      tokenizer: null,
      walkTokens: null,
    }
  }
  function YG(e) {
    Zu = e
  }
  function Tr(e, t = '') {
    let r = typeof e == 'string' ? e : e.source,
      n = {
        replace: a((i, s) => {
          let o = typeof s == 'string' ? s : s.source
          return (o = o.replace($i.caret, '$1')), (r = r.replace(i, o)), n
        }, 'replace'),
        getRegex: a(() => new RegExp(r, t), 'getRegex'),
      }
    return n
  }
  function bo(e, t) {
    if (t) {
      if ($i.escapeTest.test(e)) return e.replace($i.escapeReplace, UG)
    } else if ($i.escapeTestNoEncode.test(e)) return e.replace($i.escapeReplaceNoEncode, UG)
    return e
  }
  function jG(e) {
    try {
      e = encodeURI(e).replace($i.percentDecode, '%')
    } catch {
      return null
    }
    return e
  }
  function qG(e, t) {
    let r = e.replace($i.findPipe, (s, o, l) => {
        let u = !1,
          h = o
        for (; --h >= 0 && l[h] === '\\'; ) u = !u
        return u ? '|' : ' |'
      }),
      n = r.split($i.splitPipe),
      i = 0
    if ((n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), t))
      if (n.length > t) n.splice(t)
      else for (; n.length < t; ) n.push('')
    for (; i < n.length; i++) n[i] = n[i].trim().replace($i.slashPipe, '|')
    return n
  }
  function A0(e, t, r) {
    let n = e.length
    if (n === 0) return ''
    let i = 0
    for (; i < n; ) {
      let s = e.charAt(n - i - 1)
      if (s === t && !r) i++
      else if (s !== t && r) i++
      else break
    }
    return e.slice(0, n - i)
  }
  function ebt(e, t) {
    if (e.indexOf(t[1]) === -1) return -1
    let r = 0
    for (let n = 0; n < e.length; n++)
      if (e[n] === '\\') n++
      else if (e[n] === t[0]) r++
      else if (e[n] === t[1] && (r--, r < 0)) return n
    return r > 0 ? -2 : -1
  }
  function HG(e, t, r, n, i) {
    let s = t.href,
      o = t.title || null,
      l = e[1].replace(i.other.outputLinkReplace, '$1')
    n.state.inLink = !0
    let u = {
      type: e[0].charAt(0) === '!' ? 'image' : 'link',
      raw: r,
      href: s,
      title: o,
      text: l,
      tokens: n.inlineTokens(l),
    }
    return (n.state.inLink = !1), u
  }
  function rbt(e, t, r) {
    let n = e.match(r.other.indentCodeCompensation)
    if (n === null) return t
    let i = n[1]
    return t
      .split(
        `
`,
      )
      .map((s) => {
        let o = s.match(r.other.beginningSpace)
        if (o === null) return s
        let [l] = o
        return l.length >= i.length ? s.slice(i.length) : s
      }).join(`
`)
  }
  function br(e, t) {
    return Qu.parse(e, t)
  }
  var Zu,
    R0,
    $i,
    S2t,
    _2t,
    C2t,
    D0,
    w2t,
    Z4,
    XG,
    KG,
    E2t,
    J4,
    v2t,
    tA,
    A2t,
    L2t,
    Lb,
    eA,
    R2t,
    QG,
    D2t,
    rA,
    WG,
    N2t,
    I2t,
    M2t,
    O2t,
    ZG,
    P2t,
    Rb,
    nA,
    JG,
    B2t,
    tV,
    F2t,
    $2t,
    G2t,
    eV,
    V2t,
    z2t,
    rV,
    W2t,
    U2t,
    j2t,
    q2t,
    H2t,
    Y2t,
    X2t,
    Eb,
    K2t,
    nV,
    iV,
    Q2t,
    iA,
    Z2t,
    Y4,
    J2t,
    wb,
    v0,
    tbt,
    UG,
    vb,
    yl,
    Ab,
    sA,
    xl,
    L0,
    nbt,
    Qu,
    Bae,
    Fae,
    $ae,
    Gae,
    Vae,
    zae,
    Wae,
    sV = x(() => {
      'use strict'
      a(Q4, 'L')
      Zu = Q4()
      a(YG, 'G')
      R0 = { exec: a(() => null, 'exec') }
      a(Tr, 'h')
      ;($i = {
        codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
        outputLinkReplace: /\\([\[\]])/g,
        indentCodeCompensation: /^(\s+)(?:```)/,
        beginningSpace: /^\s+/,
        endingHash: /#$/,
        startingSpaceChar: /^ /,
        endingSpaceChar: / $/,
        nonSpaceChar: /[^ ]/,
        newLineCharGlobal: /\n/g,
        tabCharGlobal: /\t/g,
        multipleSpaceGlobal: /\s+/g,
        blankLine: /^[ \t]*$/,
        doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
        blockquoteStart: /^ {0,3}>/,
        blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
        blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
        listReplaceTabs: /^\t+/,
        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
        listIsTask: /^\[[ xX]\] /,
        listReplaceTask: /^\[[ xX]\] +/,
        anyLine: /\n.*\n/,
        hrefBrackets: /^<(.*)>$/,
        tableDelimiter: /[:|]/,
        tableAlignChars: /^\||\| *$/g,
        tableRowBlankLine: /\n[ \t]*$/,
        tableAlignRight: /^ *-+: *$/,
        tableAlignCenter: /^ *:-+: *$/,
        tableAlignLeft: /^ *:-+ *$/,
        startATag: /^<a /i,
        endATag: /^<\/a>/i,
        startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
        endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
        startAngleBracket: /^</,
        endAngleBracket: />$/,
        pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
        unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
        escapeTest: /[&<>"']/,
        escapeReplace: /[&<>"']/g,
        escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
        escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
        unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,
        caret: /(^|[^\[])\^/g,
        percentDecode: /%25/g,
        findPipe: /\|/g,
        splitPipe: / \|/,
        slashPipe: /\\\|/g,
        carriageReturn: /\r\n|\r/g,
        spaceLine: /^ +$/gm,
        notSpaceStart: /^\S*/,
        endingNewline: /\n$/,
        listItemRegex: a((e) => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`), 'listItemRegex'),
        nextBulletRegex: a(
          (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
          'nextBulletRegex',
        ),
        hrRegex: a(
          (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
          'hrRegex',
        ),
        fencesBeginRegex: a((e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`), 'fencesBeginRegex'),
        headingBeginRegex: a((e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`), 'headingBeginRegex'),
        htmlBeginRegex: a((e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, 'i'), 'htmlBeginRegex'),
      }),
        (S2t = /^(?:[ \t]*(?:\n|$))+/),
        (_2t = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/),
        (C2t =
          /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/),
        (D0 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/),
        (w2t = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/),
        (Z4 = /(?:[*+-]|\d{1,9}[.)])/),
        (XG =
          /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/),
        (KG = Tr(XG)
          .replace(/bull/g, Z4)
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
          .replace(/blockquote/g, / {0,3}>/)
          .replace(/heading/g, / {0,3}#{1,6}/)
          .replace(/html/g, / {0,3}<[^\n>]+>\n/)
          .replace(/\|table/g, '')
          .getRegex()),
        (E2t = Tr(XG)
          .replace(/bull/g, Z4)
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
          .replace(/blockquote/g, / {0,3}>/)
          .replace(/heading/g, / {0,3}#{1,6}/)
          .replace(/html/g, / {0,3}<[^\n>]+>\n/)
          .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/)
          .getRegex()),
        (J4 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/),
        (v2t = /^[^\n]+/),
        (tA = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/),
        (A2t = Tr(
          /^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/,
        )
          .replace('label', tA)
          .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
          .getRegex()),
        (L2t = Tr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
          .replace(/bull/g, Z4)
          .getRegex()),
        (Lb =
          'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul'),
        (eA = /<!--(?:-?>|[\s\S]*?(?:-->|$))/),
        (R2t = Tr(
          '^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))',
          'i',
        )
          .replace('comment', eA)
          .replace('tag', Lb)
          .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
          .getRegex()),
        (QG = Tr(J4)
          .replace('hr', D0)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('|lheading', '')
          .replace('|table', '')
          .replace('blockquote', ' {0,3}>')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', Lb)
          .getRegex()),
        (D2t = Tr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
          .replace('paragraph', QG)
          .getRegex()),
        (rA = {
          blockquote: D2t,
          code: _2t,
          def: A2t,
          fences: C2t,
          heading: w2t,
          hr: D0,
          html: R2t,
          lheading: KG,
          list: L2t,
          newline: S2t,
          paragraph: QG,
          table: R0,
          text: v2t,
        }),
        (WG = Tr(
          '^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
        )
          .replace('hr', D0)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('blockquote', ' {0,3}>')
          .replace('code', '(?: {4}| {0,3}	)[^\\n]')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', Lb)
          .getRegex()),
        (N2t = {
          ...rA,
          lheading: E2t,
          table: WG,
          paragraph: Tr(J4)
            .replace('hr', D0)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('|lheading', '')
            .replace('table', WG)
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
            .replace('tag', Lb)
            .getRegex(),
        }),
        (I2t = {
          ...rA,
          html: Tr(
            `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
          )
            .replace('comment', eA)
            .replace(
              /tag/g,
              '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b',
            )
            .getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: R0,
          lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
          paragraph: Tr(J4)
            .replace('hr', D0)
            .replace(
              'heading',
              ` *#{1,6} *[^
]`,
            )
            .replace('lheading', KG)
            .replace('|table', '')
            .replace('blockquote', ' {0,3}>')
            .replace('|fences', '')
            .replace('|list', '')
            .replace('|html', '')
            .replace('|tag', '')
            .getRegex(),
        }),
        (M2t = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/),
        (O2t = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/),
        (ZG = /^( {2,}|\\)\n(?!\s*$)/),
        (P2t = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/),
        (Rb = /[\p{P}\p{S}]/u),
        (nA = /[\s\p{P}\p{S}]/u),
        (JG = /[^\s\p{P}\p{S}]/u),
        (B2t = Tr(/^((?![*_])punctSpace)/, 'u')
          .replace(/punctSpace/g, nA)
          .getRegex()),
        (tV = /(?!~)[\p{P}\p{S}]/u),
        (F2t = /(?!~)[\s\p{P}\p{S}]/u),
        ($2t = /(?:[^\s\p{P}\p{S}]|~)/u),
        (G2t = /\[[^\[\]]*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g),
        (eV = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/),
        (V2t = Tr(eV, 'u').replace(/punct/g, Rb).getRegex()),
        (z2t = Tr(eV, 'u').replace(/punct/g, tV).getRegex()),
        (rV =
          '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)'),
        (W2t = Tr(rV, 'gu')
          .replace(/notPunctSpace/g, JG)
          .replace(/punctSpace/g, nA)
          .replace(/punct/g, Rb)
          .getRegex()),
        (U2t = Tr(rV, 'gu')
          .replace(/notPunctSpace/g, $2t)
          .replace(/punctSpace/g, F2t)
          .replace(/punct/g, tV)
          .getRegex()),
        (j2t = Tr(
          '^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)',
          'gu',
        )
          .replace(/notPunctSpace/g, JG)
          .replace(/punctSpace/g, nA)
          .replace(/punct/g, Rb)
          .getRegex()),
        (q2t = Tr(/\\(punct)/, 'gu')
          .replace(/punct/g, Rb)
          .getRegex()),
        (H2t = Tr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
          .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
          .replace(
            'email',
            /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
          )
          .getRegex()),
        (Y2t = Tr(eA).replace('(?:-->|$)', '-->').getRegex()),
        (X2t = Tr(
          '^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
        )
          .replace('comment', Y2t)
          .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
          .getRegex()),
        (Eb = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`[^`]*`|[^\[\]\\`])*?/),
        (K2t = Tr(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/)
          .replace('label', Eb)
          .replace('href', /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/)
          .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
          .getRegex()),
        (nV = Tr(/^!?\[(label)\]\[(ref)\]/)
          .replace('label', Eb)
          .replace('ref', tA)
          .getRegex()),
        (iV = Tr(/^!?\[(ref)\](?:\[\])?/)
          .replace('ref', tA)
          .getRegex()),
        (Q2t = Tr('reflink|nolink(?!\\()', 'g').replace('reflink', nV).replace('nolink', iV).getRegex()),
        (iA = {
          _backpedal: R0,
          anyPunctuation: q2t,
          autolink: H2t,
          blockSkip: G2t,
          br: ZG,
          code: O2t,
          del: R0,
          emStrongLDelim: V2t,
          emStrongRDelimAst: W2t,
          emStrongRDelimUnd: j2t,
          escape: M2t,
          link: K2t,
          nolink: iV,
          punctuation: B2t,
          reflink: nV,
          reflinkSearch: Q2t,
          tag: X2t,
          text: P2t,
          url: R0,
        }),
        (Z2t = {
          ...iA,
          link: Tr(/^!?\[(label)\]\((.*?)\)/)
            .replace('label', Eb)
            .getRegex(),
          reflink: Tr(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace('label', Eb)
            .getRegex(),
        }),
        (Y4 = {
          ...iA,
          emStrongRDelimAst: U2t,
          emStrongLDelim: z2t,
          url: Tr(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
            .getRegex(),
          _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
          del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,
          text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
        }),
        (J2t = {
          ...Y4,
          br: Tr(ZG).replace('{2,}', '*').getRegex(),
          text: Tr(Y4.text)
            .replace('\\b_', '\\b_| {2,}\\n')
            .replace(/\{2,\}/g, '*')
            .getRegex(),
        }),
        (wb = { normal: rA, gfm: N2t, pedantic: I2t }),
        (v0 = { normal: iA, gfm: Y4, breaks: J2t, pedantic: Z2t }),
        (tbt = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }),
        (UG = a((e) => tbt[e], 'ke'))
      a(bo, 'w')
      a(jG, 'J')
      a(qG, 'V')
      a(A0, 'z')
      a(ebt, 'ge')
      a(HG, 'fe')
      a(rbt, 'Je')
      ;(vb = class {
        static {
          a(this, 'y')
        }
        options
        rules
        lexer
        constructor(e) {
          this.options = e || Zu
        }
        space(e) {
          let t = this.rules.block.newline.exec(e)
          if (t && t[0].length > 0) return { type: 'space', raw: t[0] }
        }
        code(e) {
          let t = this.rules.block.code.exec(e)
          if (t) {
            let r = t[0].replace(this.rules.other.codeRemoveIndent, '')
            return {
              type: 'code',
              raw: t[0],
              codeBlockStyle: 'indented',
              text: this.options.pedantic
                ? r
                : A0(
                    r,
                    `
`,
                  ),
            }
          }
        }
        fences(e) {
          let t = this.rules.block.fences.exec(e)
          if (t) {
            let r = t[0],
              n = rbt(r, t[3] || '', this.rules)
            return {
              type: 'code',
              raw: r,
              lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : t[2],
              text: n,
            }
          }
        }
        heading(e) {
          let t = this.rules.block.heading.exec(e)
          if (t) {
            let r = t[2].trim()
            if (this.rules.other.endingHash.test(r)) {
              let n = A0(r, '#')
              ;(this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim())
            }
            return { type: 'heading', raw: t[0], depth: t[1].length, text: r, tokens: this.lexer.inline(r) }
          }
        }
        hr(e) {
          let t = this.rules.block.hr.exec(e)
          if (t)
            return {
              type: 'hr',
              raw: A0(
                t[0],
                `
`,
              ),
            }
        }
        blockquote(e) {
          let t = this.rules.block.blockquote.exec(e)
          if (t) {
            let r = A0(
                t[0],
                `
`,
              ).split(`
`),
              n = '',
              i = '',
              s = []
            for (; r.length > 0; ) {
              let o = !1,
                l = [],
                u
              for (u = 0; u < r.length; u++)
                if (this.rules.other.blockquoteStart.test(r[u])) l.push(r[u]), (o = !0)
                else if (!o) l.push(r[u])
                else break
              r = r.slice(u)
              let h = l.join(`
`),
                f = h
                  .replace(
                    this.rules.other.blockquoteSetextReplace,
                    `
    $1`,
                  )
                  .replace(this.rules.other.blockquoteSetextReplace2, '')
              ;(n = n
                ? `${n}
${h}`
                : h),
                (i = i
                  ? `${i}
${f}`
                  : f)
              let d = this.lexer.state.top
              if (
                ((this.lexer.state.top = !0),
                this.lexer.blockTokens(f, s, !0),
                (this.lexer.state.top = d),
                r.length === 0)
              )
                break
              let p = s.at(-1)
              if (p?.type === 'code') break
              if (p?.type === 'blockquote') {
                let m = p,
                  g =
                    m.raw +
                    `
` +
                    r.join(`
`),
                  y = this.blockquote(g)
                ;(s[s.length - 1] = y),
                  (n = n.substring(0, n.length - m.raw.length) + y.raw),
                  (i = i.substring(0, i.length - m.text.length) + y.text)
                break
              } else if (p?.type === 'list') {
                let m = p,
                  g =
                    m.raw +
                    `
` +
                    r.join(`
`),
                  y = this.list(g)
                ;(s[s.length - 1] = y),
                  (n = n.substring(0, n.length - p.raw.length) + y.raw),
                  (i = i.substring(0, i.length - m.raw.length) + y.raw),
                  (r = g.substring(s.at(-1).raw.length).split(`
`))
                continue
              }
            }
            return { type: 'blockquote', raw: n, tokens: s, text: i }
          }
        }
        list(e) {
          let t = this.rules.block.list.exec(e)
          if (t) {
            let r = t[1].trim(),
              n = r.length > 1,
              i = { type: 'list', raw: '', ordered: n, start: n ? +r.slice(0, -1) : '', loose: !1, items: [] }
            ;(r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`), this.options.pedantic && (r = n ? r : '[*+-]')
            let s = this.rules.other.listItemRegex(r),
              o = !1
            for (; e; ) {
              let u = !1,
                h = '',
                f = ''
              if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break
              ;(h = t[0]), (e = e.substring(h.length))
              let d = t[2]
                  .split(
                    `
`,
                    1,
                  )[0]
                  .replace(this.rules.other.listReplaceTabs, (k) => ' '.repeat(3 * k.length)),
                p = e.split(
                  `
`,
                  1,
                )[0],
                m = !d.trim(),
                g = 0
              if (
                (this.options.pedantic
                  ? ((g = 2), (f = d.trimStart()))
                  : m
                    ? (g = t[1].length + 1)
                    : ((g = t[2].search(this.rules.other.nonSpaceChar)),
                      (g = g > 4 ? 1 : g),
                      (f = d.slice(g)),
                      (g += t[1].length)),
                m &&
                  this.rules.other.blankLine.test(p) &&
                  ((h +=
                    p +
                    `
`),
                  (e = e.substring(p.length + 1)),
                  (u = !0)),
                !u)
              ) {
                let k = this.rules.other.nextBulletRegex(g),
                  T = this.rules.other.hrRegex(g),
                  C = this.rules.other.fencesBeginRegex(g),
                  A = this.rules.other.headingBeginRegex(g),
                  w = this.rules.other.htmlBeginRegex(g)
                for (; e; ) {
                  let D = e.split(
                      `
`,
                      1,
                    )[0],
                    G
                  if (
                    ((p = D),
                    this.options.pedantic
                      ? ((p = p.replace(this.rules.other.listReplaceNesting, '  ')), (G = p))
                      : (G = p.replace(this.rules.other.tabCharGlobal, '    ')),
                    C.test(p) || A.test(p) || w.test(p) || k.test(p) || T.test(p))
                  )
                    break
                  if (G.search(this.rules.other.nonSpaceChar) >= g || !p.trim())
                    f +=
                      `
` + G.slice(g)
                  else {
                    if (
                      m ||
                      d.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4 ||
                      C.test(d) ||
                      A.test(d) ||
                      T.test(d)
                    )
                      break
                    f +=
                      `
` + p
                  }
                  !m && !p.trim() && (m = !0),
                    (h +=
                      D +
                      `
`),
                    (e = e.substring(D.length + 1)),
                    (d = G.slice(g))
                }
              }
              i.loose || (o ? (i.loose = !0) : this.rules.other.doubleBlankLine.test(h) && (o = !0))
              let y = null,
                b
              this.options.gfm &&
                ((y = this.rules.other.listIsTask.exec(f)),
                y && ((b = y[0] !== '[ ] '), (f = f.replace(this.rules.other.listReplaceTask, '')))),
                i.items.push({ type: 'list_item', raw: h, task: !!y, checked: b, loose: !1, text: f, tokens: [] }),
                (i.raw += h)
            }
            let l = i.items.at(-1)
            if (l) (l.raw = l.raw.trimEnd()), (l.text = l.text.trimEnd())
            else return
            i.raw = i.raw.trimEnd()
            for (let u = 0; u < i.items.length; u++)
              if (
                ((this.lexer.state.top = !1),
                (i.items[u].tokens = this.lexer.blockTokens(i.items[u].text, [])),
                !i.loose)
              ) {
                let h = i.items[u].tokens.filter((d) => d.type === 'space'),
                  f = h.length > 0 && h.some((d) => this.rules.other.anyLine.test(d.raw))
                i.loose = f
              }
            if (i.loose) for (let u = 0; u < i.items.length; u++) i.items[u].loose = !0
            return i
          }
        }
        html(e) {
          let t = this.rules.block.html.exec(e)
          if (t)
            return {
              type: 'html',
              block: !0,
              raw: t[0],
              pre: t[1] === 'pre' || t[1] === 'script' || t[1] === 'style',
              text: t[0],
            }
        }
        def(e) {
          let t = this.rules.block.def.exec(e)
          if (t) {
            let r = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' '),
              n = t[2]
                ? t[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1')
                : '',
              i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : t[3]
            return { type: 'def', tag: r, raw: t[0], href: n, title: i }
          }
        }
        table(e) {
          let t = this.rules.block.table.exec(e)
          if (!t || !this.rules.other.tableDelimiter.test(t[2])) return
          let r = qG(t[1]),
            n = t[2].replace(this.rules.other.tableAlignChars, '').split('|'),
            i = t[3]?.trim()
              ? t[3].replace(this.rules.other.tableRowBlankLine, '').split(`
`)
              : [],
            s = { type: 'table', raw: t[0], header: [], align: [], rows: [] }
          if (r.length === n.length) {
            for (let o of n)
              this.rules.other.tableAlignRight.test(o)
                ? s.align.push('right')
                : this.rules.other.tableAlignCenter.test(o)
                  ? s.align.push('center')
                  : this.rules.other.tableAlignLeft.test(o)
                    ? s.align.push('left')
                    : s.align.push(null)
            for (let o = 0; o < r.length; o++)
              s.header.push({ text: r[o], tokens: this.lexer.inline(r[o]), header: !0, align: s.align[o] })
            for (let o of i)
              s.rows.push(
                qG(o, s.header.length).map((l, u) => ({
                  text: l,
                  tokens: this.lexer.inline(l),
                  header: !1,
                  align: s.align[u],
                })),
              )
            return s
          }
        }
        lheading(e) {
          let t = this.rules.block.lheading.exec(e)
          if (t)
            return {
              type: 'heading',
              raw: t[0],
              depth: t[2].charAt(0) === '=' ? 1 : 2,
              text: t[1],
              tokens: this.lexer.inline(t[1]),
            }
        }
        paragraph(e) {
          let t = this.rules.block.paragraph.exec(e)
          if (t) {
            let r =
              t[1].charAt(t[1].length - 1) ===
              `
`
                ? t[1].slice(0, -1)
                : t[1]
            return { type: 'paragraph', raw: t[0], text: r, tokens: this.lexer.inline(r) }
          }
        }
        text(e) {
          let t = this.rules.block.text.exec(e)
          if (t) return { type: 'text', raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) }
        }
        escape(e) {
          let t = this.rules.inline.escape.exec(e)
          if (t) return { type: 'escape', raw: t[0], text: t[1] }
        }
        tag(e) {
          let t = this.rules.inline.tag.exec(e)
          if (t)
            return (
              !this.lexer.state.inLink && this.rules.other.startATag.test(t[0])
                ? (this.lexer.state.inLink = !0)
                : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1),
              !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0])
                ? (this.lexer.state.inRawBlock = !0)
                : this.lexer.state.inRawBlock &&
                  this.rules.other.endPreScriptTag.test(t[0]) &&
                  (this.lexer.state.inRawBlock = !1),
              {
                type: 'html',
                raw: t[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: !1,
                text: t[0],
              }
            )
        }
        link(e) {
          let t = this.rules.inline.link.exec(e)
          if (t) {
            let r = t[2].trim()
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
              if (!this.rules.other.endAngleBracket.test(r)) return
              let s = A0(r.slice(0, -1), '\\')
              if ((r.length - s.length) % 2 === 0) return
            } else {
              let s = ebt(t[2], '()')
              if (s === -2) return
              if (s > -1) {
                let o = (t[0].indexOf('!') === 0 ? 5 : 4) + t[1].length + s
                ;(t[2] = t[2].substring(0, s)), (t[0] = t[0].substring(0, o).trim()), (t[3] = '')
              }
            }
            let n = t[2],
              i = ''
            if (this.options.pedantic) {
              let s = this.rules.other.pedanticHrefTitle.exec(n)
              s && ((n = s[1]), (i = s[3]))
            } else i = t[3] ? t[3].slice(1, -1) : ''
            return (
              (n = n.trim()),
              this.rules.other.startAngleBracket.test(n) &&
                (this.options.pedantic && !this.rules.other.endAngleBracket.test(r)
                  ? (n = n.slice(1))
                  : (n = n.slice(1, -1))),
              HG(
                t,
                {
                  href: n && n.replace(this.rules.inline.anyPunctuation, '$1'),
                  title: i && i.replace(this.rules.inline.anyPunctuation, '$1'),
                },
                t[0],
                this.lexer,
                this.rules,
              )
            )
          }
        }
        reflink(e, t) {
          let r
          if ((r = this.rules.inline.reflink.exec(e)) || (r = this.rules.inline.nolink.exec(e))) {
            let n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, ' '),
              i = t[n.toLowerCase()]
            if (!i) {
              let s = r[0].charAt(0)
              return { type: 'text', raw: s, text: s }
            }
            return HG(r, i, r[0], this.lexer, this.rules)
          }
        }
        emStrong(e, t, r = '') {
          let n = this.rules.inline.emStrongLDelim.exec(e)
          if (
            !(!n || (n[3] && r.match(this.rules.other.unicodeAlphaNumeric))) &&
            (!(n[1] || n[2]) || !r || this.rules.inline.punctuation.exec(r))
          ) {
            let i = [...n[0]].length - 1,
              s,
              o,
              l = i,
              u = 0,
              h = n[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd
            for (h.lastIndex = 0, t = t.slice(-1 * e.length + i); (n = h.exec(t)) != null; ) {
              if (((s = n[1] || n[2] || n[3] || n[4] || n[5] || n[6]), !s)) continue
              if (((o = [...s].length), n[3] || n[4])) {
                l += o
                continue
              } else if ((n[5] || n[6]) && i % 3 && !((i + o) % 3)) {
                u += o
                continue
              }
              if (((l -= o), l > 0)) continue
              o = Math.min(o, o + l + u)
              let f = [...n[0]][0].length,
                d = e.slice(0, i + n.index + f + o)
              if (Math.min(i, o) % 2) {
                let m = d.slice(1, -1)
                return { type: 'em', raw: d, text: m, tokens: this.lexer.inlineTokens(m) }
              }
              let p = d.slice(2, -2)
              return { type: 'strong', raw: d, text: p, tokens: this.lexer.inlineTokens(p) }
            }
          }
        }
        codespan(e) {
          let t = this.rules.inline.code.exec(e)
          if (t) {
            let r = t[2].replace(this.rules.other.newLineCharGlobal, ' '),
              n = this.rules.other.nonSpaceChar.test(r),
              i = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r)
            return n && i && (r = r.substring(1, r.length - 1)), { type: 'codespan', raw: t[0], text: r }
          }
        }
        br(e) {
          let t = this.rules.inline.br.exec(e)
          if (t) return { type: 'br', raw: t[0] }
        }
        del(e) {
          let t = this.rules.inline.del.exec(e)
          if (t) return { type: 'del', raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) }
        }
        autolink(e) {
          let t = this.rules.inline.autolink.exec(e)
          if (t) {
            let r, n
            return (
              t[2] === '@' ? ((r = t[1]), (n = 'mailto:' + r)) : ((r = t[1]), (n = r)),
              { type: 'link', raw: t[0], text: r, href: n, tokens: [{ type: 'text', raw: r, text: r }] }
            )
          }
        }
        url(e) {
          let t
          if ((t = this.rules.inline.url.exec(e))) {
            let r, n
            if (t[2] === '@') (r = t[0]), (n = 'mailto:' + r)
            else {
              let i
              do (i = t[0]), (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? '')
              while (i !== t[0])
              ;(r = t[0]), t[1] === 'www.' ? (n = 'http://' + t[0]) : (n = t[0])
            }
            return { type: 'link', raw: t[0], text: r, href: n, tokens: [{ type: 'text', raw: r, text: r }] }
          }
        }
        inlineText(e) {
          let t = this.rules.inline.text.exec(e)
          if (t) {
            let r = this.lexer.state.inRawBlock
            return { type: 'text', raw: t[0], text: t[0], escaped: r }
          }
        }
      }),
        (yl = class X4 {
          static {
            a(this, 'l')
          }
          tokens
          options
          state
          tokenizer
          inlineQueue
          constructor(t) {
            ;(this.tokens = []),
              (this.tokens.links = Object.create(null)),
              (this.options = t || Zu),
              (this.options.tokenizer = this.options.tokenizer || new vb()),
              (this.tokenizer = this.options.tokenizer),
              (this.tokenizer.options = this.options),
              (this.tokenizer.lexer = this),
              (this.inlineQueue = []),
              (this.state = { inLink: !1, inRawBlock: !1, top: !0 })
            let r = { other: $i, block: wb.normal, inline: v0.normal }
            this.options.pedantic
              ? ((r.block = wb.pedantic), (r.inline = v0.pedantic))
              : this.options.gfm &&
                ((r.block = wb.gfm), this.options.breaks ? (r.inline = v0.breaks) : (r.inline = v0.gfm)),
              (this.tokenizer.rules = r)
          }
          static get rules() {
            return { block: wb, inline: v0 }
          }
          static lex(t, r) {
            return new X4(r).lex(t)
          }
          static lexInline(t, r) {
            return new X4(r).inlineTokens(t)
          }
          lex(t) {
            ;(t = t.replace(
              $i.carriageReturn,
              `
`,
            )),
              this.blockTokens(t, this.tokens)
            for (let r = 0; r < this.inlineQueue.length; r++) {
              let n = this.inlineQueue[r]
              this.inlineTokens(n.src, n.tokens)
            }
            return (this.inlineQueue = []), this.tokens
          }
          blockTokens(t, r = [], n = !1) {
            for (this.options.pedantic && (t = t.replace($i.tabCharGlobal, '    ').replace($i.spaceLine, '')); t; ) {
              let i
              if (
                this.options.extensions?.block?.some((o) =>
                  (i = o.call({ lexer: this }, t, r)) ? ((t = t.substring(i.raw.length)), r.push(i), !0) : !1,
                )
              )
                continue
              if ((i = this.tokenizer.space(t))) {
                t = t.substring(i.raw.length)
                let o = r.at(-1)
                i.raw.length === 1 && o !== void 0
                  ? (o.raw += `
`)
                  : r.push(i)
                continue
              }
              if ((i = this.tokenizer.code(t))) {
                t = t.substring(i.raw.length)
                let o = r.at(-1)
                o?.type === 'paragraph' || o?.type === 'text'
                  ? ((o.raw +=
                      (o.raw.endsWith(`
`)
                        ? ''
                        : `
`) + i.raw),
                    (o.text +=
                      `
` + i.text),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i)
                continue
              }
              if ((i = this.tokenizer.fences(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.heading(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.hr(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.blockquote(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.list(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.html(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.def(t))) {
                t = t.substring(i.raw.length)
                let o = r.at(-1)
                o?.type === 'paragraph' || o?.type === 'text'
                  ? ((o.raw +=
                      (o.raw.endsWith(`
`)
                        ? ''
                        : `
`) + i.raw),
                    (o.text +=
                      `
` + i.raw),
                    (this.inlineQueue.at(-1).src = o.text))
                  : this.tokens.links[i.tag] ||
                    ((this.tokens.links[i.tag] = { href: i.href, title: i.title }), r.push(i))
                continue
              }
              if ((i = this.tokenizer.table(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              if ((i = this.tokenizer.lheading(t))) {
                ;(t = t.substring(i.raw.length)), r.push(i)
                continue
              }
              let s = t
              if (this.options.extensions?.startBlock) {
                let o = 1 / 0,
                  l = t.slice(1),
                  u
                this.options.extensions.startBlock.forEach((h) => {
                  ;(u = h.call({ lexer: this }, l)), typeof u == 'number' && u >= 0 && (o = Math.min(o, u))
                }),
                  o < 1 / 0 && o >= 0 && (s = t.substring(0, o + 1))
              }
              if (this.state.top && (i = this.tokenizer.paragraph(s))) {
                let o = r.at(-1)
                n && o?.type === 'paragraph'
                  ? ((o.raw +=
                      (o.raw.endsWith(`
`)
                        ? ''
                        : `
`) + i.raw),
                    (o.text +=
                      `
` + i.text),
                    this.inlineQueue.pop(),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i),
                  (n = s.length !== t.length),
                  (t = t.substring(i.raw.length))
                continue
              }
              if ((i = this.tokenizer.text(t))) {
                t = t.substring(i.raw.length)
                let o = r.at(-1)
                o?.type === 'text'
                  ? ((o.raw +=
                      (o.raw.endsWith(`
`)
                        ? ''
                        : `
`) + i.raw),
                    (o.text +=
                      `
` + i.text),
                    this.inlineQueue.pop(),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i)
                continue
              }
              if (t) {
                let o = 'Infinite loop on byte: ' + t.charCodeAt(0)
                if (this.options.silent) {
                  console.error(o)
                  break
                } else throw new Error(o)
              }
            }
            return (this.state.top = !0), r
          }
          inline(t, r = []) {
            return this.inlineQueue.push({ src: t, tokens: r }), r
          }
          inlineTokens(t, r = []) {
            let n = t,
              i = null
            if (this.tokens.links) {
              let l = Object.keys(this.tokens.links)
              if (l.length > 0)
                for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; )
                  l.includes(i[0].slice(i[0].lastIndexOf('[') + 1, -1)) &&
                    (n =
                      n.slice(0, i.index) +
                      '[' +
                      'a'.repeat(i[0].length - 2) +
                      ']' +
                      n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
            }
            for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; )
              n = n.slice(0, i.index) + '++' + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex)
            for (; (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; )
              n =
                n.slice(0, i.index) +
                '[' +
                'a'.repeat(i[0].length - 2) +
                ']' +
                n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
            n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n
            let s = !1,
              o = ''
            for (; t; ) {
              s || (o = ''), (s = !1)
              let l
              if (
                this.options.extensions?.inline?.some((h) =>
                  (l = h.call({ lexer: this }, t, r)) ? ((t = t.substring(l.raw.length)), r.push(l), !0) : !1,
                )
              )
                continue
              if ((l = this.tokenizer.escape(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.tag(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.link(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.reflink(t, this.tokens.links))) {
                t = t.substring(l.raw.length)
                let h = r.at(-1)
                l.type === 'text' && h?.type === 'text' ? ((h.raw += l.raw), (h.text += l.text)) : r.push(l)
                continue
              }
              if ((l = this.tokenizer.emStrong(t, n, o))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.codespan(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.br(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.del(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if ((l = this.tokenizer.autolink(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              if (!this.state.inLink && (l = this.tokenizer.url(t))) {
                ;(t = t.substring(l.raw.length)), r.push(l)
                continue
              }
              let u = t
              if (this.options.extensions?.startInline) {
                let h = 1 / 0,
                  f = t.slice(1),
                  d
                this.options.extensions.startInline.forEach((p) => {
                  ;(d = p.call({ lexer: this }, f)), typeof d == 'number' && d >= 0 && (h = Math.min(h, d))
                }),
                  h < 1 / 0 && h >= 0 && (u = t.substring(0, h + 1))
              }
              if ((l = this.tokenizer.inlineText(u))) {
                ;(t = t.substring(l.raw.length)), l.raw.slice(-1) !== '_' && (o = l.raw.slice(-1)), (s = !0)
                let h = r.at(-1)
                h?.type === 'text' ? ((h.raw += l.raw), (h.text += l.text)) : r.push(l)
                continue
              }
              if (t) {
                let h = 'Infinite loop on byte: ' + t.charCodeAt(0)
                if (this.options.silent) {
                  console.error(h)
                  break
                } else throw new Error(h)
              }
            }
            return r
          }
        }),
        (Ab = class {
          static {
            a(this, 'P')
          }
          options
          parser
          constructor(e) {
            this.options = e || Zu
          }
          space(e) {
            return ''
          }
          code({ text: e, lang: t, escaped: r }) {
            let n = (t || '').match($i.notSpaceStart)?.[0],
              i =
                e.replace($i.endingNewline, '') +
                `
`
            return n
              ? '<pre><code class="language-' +
                  bo(n) +
                  '">' +
                  (r ? i : bo(i, !0)) +
                  `</code></pre>
`
              : '<pre><code>' +
                  (r ? i : bo(i, !0)) +
                  `</code></pre>
`
          }
          blockquote({ tokens: e }) {
            return `<blockquote>
${this.parser.parse(e)}</blockquote>
`
          }
          html({ text: e }) {
            return e
          }
          def(e) {
            return ''
          }
          heading({ tokens: e, depth: t }) {
            return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`
          }
          hr(e) {
            return `<hr>
`
          }
          list(e) {
            let t = e.ordered,
              r = e.start,
              n = ''
            for (let o = 0; o < e.items.length; o++) {
              let l = e.items[o]
              n += this.listitem(l)
            }
            let i = t ? 'ol' : 'ul',
              s = t && r !== 1 ? ' start="' + r + '"' : ''
            return (
              '<' +
              i +
              s +
              `>
` +
              n +
              '</' +
              i +
              `>
`
            )
          }
          listitem(e) {
            let t = ''
            if (e.task) {
              let r = this.checkbox({ checked: !!e.checked })
              e.loose
                ? e.tokens[0]?.type === 'paragraph'
                  ? ((e.tokens[0].text = r + ' ' + e.tokens[0].text),
                    e.tokens[0].tokens &&
                      e.tokens[0].tokens.length > 0 &&
                      e.tokens[0].tokens[0].type === 'text' &&
                      ((e.tokens[0].tokens[0].text = r + ' ' + bo(e.tokens[0].tokens[0].text)),
                      (e.tokens[0].tokens[0].escaped = !0)))
                  : e.tokens.unshift({ type: 'text', raw: r + ' ', text: r + ' ', escaped: !0 })
                : (t += r + ' ')
            }
            return (
              (t += this.parser.parse(e.tokens, !!e.loose)),
              `<li>${t}</li>
`
            )
          }
          checkbox({ checked: e }) {
            return '<input ' + (e ? 'checked="" ' : '') + 'disabled="" type="checkbox">'
          }
          paragraph({ tokens: e }) {
            return `<p>${this.parser.parseInline(e)}</p>
`
          }
          table(e) {
            let t = '',
              r = ''
            for (let i = 0; i < e.header.length; i++) r += this.tablecell(e.header[i])
            t += this.tablerow({ text: r })
            let n = ''
            for (let i = 0; i < e.rows.length; i++) {
              let s = e.rows[i]
              r = ''
              for (let o = 0; o < s.length; o++) r += this.tablecell(s[o])
              n += this.tablerow({ text: r })
            }
            return (
              n && (n = `<tbody>${n}</tbody>`),
              `<table>
<thead>
` +
                t +
                `</thead>
` +
                n +
                `</table>
`
            )
          }
          tablerow({ text: e }) {
            return `<tr>
${e}</tr>
`
          }
          tablecell(e) {
            let t = this.parser.parseInline(e.tokens),
              r = e.header ? 'th' : 'td'
            return (
              (e.align ? `<${r} align="${e.align}">` : `<${r}>`) +
              t +
              `</${r}>
`
            )
          }
          strong({ tokens: e }) {
            return `<strong>${this.parser.parseInline(e)}</strong>`
          }
          em({ tokens: e }) {
            return `<em>${this.parser.parseInline(e)}</em>`
          }
          codespan({ text: e }) {
            return `<code>${bo(e, !0)}</code>`
          }
          br(e) {
            return '<br>'
          }
          del({ tokens: e }) {
            return `<del>${this.parser.parseInline(e)}</del>`
          }
          link({ href: e, title: t, tokens: r }) {
            let n = this.parser.parseInline(r),
              i = jG(e)
            if (i === null) return n
            e = i
            let s = '<a href="' + e + '"'
            return t && (s += ' title="' + bo(t) + '"'), (s += '>' + n + '</a>'), s
          }
          image({ href: e, title: t, text: r, tokens: n }) {
            n && (r = this.parser.parseInline(n, this.parser.textRenderer))
            let i = jG(e)
            if (i === null) return bo(r)
            e = i
            let s = `<img src="${e}" alt="${r}"`
            return t && (s += ` title="${bo(t)}"`), (s += '>'), s
          }
          text(e) {
            return 'tokens' in e && e.tokens
              ? this.parser.parseInline(e.tokens)
              : 'escaped' in e && e.escaped
                ? e.text
                : bo(e.text)
          }
        }),
        (sA = class {
          static {
            a(this, '$')
          }
          strong({ text: e }) {
            return e
          }
          em({ text: e }) {
            return e
          }
          codespan({ text: e }) {
            return e
          }
          del({ text: e }) {
            return e
          }
          html({ text: e }) {
            return e
          }
          text({ text: e }) {
            return e
          }
          link({ text: e }) {
            return '' + e
          }
          image({ text: e }) {
            return '' + e
          }
          br() {
            return ''
          }
        }),
        (xl = class K4 {
          static {
            a(this, 'l')
          }
          options
          renderer
          textRenderer
          constructor(t) {
            ;(this.options = t || Zu),
              (this.options.renderer = this.options.renderer || new Ab()),
              (this.renderer = this.options.renderer),
              (this.renderer.options = this.options),
              (this.renderer.parser = this),
              (this.textRenderer = new sA())
          }
          static parse(t, r) {
            return new K4(r).parse(t)
          }
          static parseInline(t, r) {
            return new K4(r).parseInline(t)
          }
          parse(t, r = !0) {
            let n = ''
            for (let i = 0; i < t.length; i++) {
              let s = t[i]
              if (this.options.extensions?.renderers?.[s.type]) {
                let l = s,
                  u = this.options.extensions.renderers[l.type].call({ parser: this }, l)
                if (
                  u !== !1 ||
                  ![
                    'space',
                    'hr',
                    'heading',
                    'code',
                    'table',
                    'blockquote',
                    'list',
                    'html',
                    'def',
                    'paragraph',
                    'text',
                  ].includes(l.type)
                ) {
                  n += u || ''
                  continue
                }
              }
              let o = s
              switch (o.type) {
                case 'space': {
                  n += this.renderer.space(o)
                  continue
                }
                case 'hr': {
                  n += this.renderer.hr(o)
                  continue
                }
                case 'heading': {
                  n += this.renderer.heading(o)
                  continue
                }
                case 'code': {
                  n += this.renderer.code(o)
                  continue
                }
                case 'table': {
                  n += this.renderer.table(o)
                  continue
                }
                case 'blockquote': {
                  n += this.renderer.blockquote(o)
                  continue
                }
                case 'list': {
                  n += this.renderer.list(o)
                  continue
                }
                case 'html': {
                  n += this.renderer.html(o)
                  continue
                }
                case 'def': {
                  n += this.renderer.def(o)
                  continue
                }
                case 'paragraph': {
                  n += this.renderer.paragraph(o)
                  continue
                }
                case 'text': {
                  let l = o,
                    u = this.renderer.text(l)
                  for (; i + 1 < t.length && t[i + 1].type === 'text'; )
                    (l = t[++i]),
                      (u +=
                        `
` + this.renderer.text(l))
                  r
                    ? (n += this.renderer.paragraph({
                        type: 'paragraph',
                        raw: u,
                        text: u,
                        tokens: [{ type: 'text', raw: u, text: u, escaped: !0 }],
                      }))
                    : (n += u)
                  continue
                }
                default: {
                  let l = 'Token with "' + o.type + '" type was not found.'
                  if (this.options.silent) return console.error(l), ''
                  throw new Error(l)
                }
              }
            }
            return n
          }
          parseInline(t, r = this.renderer) {
            let n = ''
            for (let i = 0; i < t.length; i++) {
              let s = t[i]
              if (this.options.extensions?.renderers?.[s.type]) {
                let l = this.options.extensions.renderers[s.type].call({ parser: this }, s)
                if (
                  l !== !1 ||
                  !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(s.type)
                ) {
                  n += l || ''
                  continue
                }
              }
              let o = s
              switch (o.type) {
                case 'escape': {
                  n += r.text(o)
                  break
                }
                case 'html': {
                  n += r.html(o)
                  break
                }
                case 'link': {
                  n += r.link(o)
                  break
                }
                case 'image': {
                  n += r.image(o)
                  break
                }
                case 'strong': {
                  n += r.strong(o)
                  break
                }
                case 'em': {
                  n += r.em(o)
                  break
                }
                case 'codespan': {
                  n += r.codespan(o)
                  break
                }
                case 'br': {
                  n += r.br(o)
                  break
                }
                case 'del': {
                  n += r.del(o)
                  break
                }
                case 'text': {
                  n += r.text(o)
                  break
                }
                default: {
                  let l = 'Token with "' + o.type + '" type was not found.'
                  if (this.options.silent) return console.error(l), ''
                  throw new Error(l)
                }
              }
            }
            return n
          }
        }),
        (L0 = class {
          static {
            a(this, 'S')
          }
          options
          block
          constructor(e) {
            this.options = e || Zu
          }
          static passThroughHooks = new Set(['preprocess', 'postprocess', 'processAllTokens', 'emStrongMask'])
          static passThroughHooksRespectAsync = new Set(['preprocess', 'postprocess', 'processAllTokens'])
          preprocess(e) {
            return e
          }
          postprocess(e) {
            return e
          }
          processAllTokens(e) {
            return e
          }
          emStrongMask(e) {
            return e
          }
          provideLexer() {
            return this.block ? yl.lex : yl.lexInline
          }
          provideParser() {
            return this.block ? xl.parse : xl.parseInline
          }
        }),
        (nbt = class {
          static {
            a(this, 'B')
          }
          defaults = Q4()
          options = this.setOptions
          parse = this.parseMarkdown(!0)
          parseInline = this.parseMarkdown(!1)
          Parser = xl
          Renderer = Ab
          TextRenderer = sA
          Lexer = yl
          Tokenizer = vb
          Hooks = L0
          constructor(...e) {
            this.use(...e)
          }
          walkTokens(e, t) {
            let r = []
            for (let n of e)
              switch (((r = r.concat(t.call(this, n))), n.type)) {
                case 'table': {
                  let i = n
                  for (let s of i.header) r = r.concat(this.walkTokens(s.tokens, t))
                  for (let s of i.rows) for (let o of s) r = r.concat(this.walkTokens(o.tokens, t))
                  break
                }
                case 'list': {
                  let i = n
                  r = r.concat(this.walkTokens(i.items, t))
                  break
                }
                default: {
                  let i = n
                  this.defaults.extensions?.childTokens?.[i.type]
                    ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
                        let o = i[s].flat(1 / 0)
                        r = r.concat(this.walkTokens(o, t))
                      })
                    : i.tokens && (r = r.concat(this.walkTokens(i.tokens, t)))
                }
              }
            return r
          }
          use(...e) {
            let t = this.defaults.extensions || { renderers: {}, childTokens: {} }
            return (
              e.forEach((r) => {
                let n = { ...r }
                if (
                  ((n.async = this.defaults.async || n.async || !1),
                  r.extensions &&
                    (r.extensions.forEach((i) => {
                      if (!i.name) throw new Error('extension name required')
                      if ('renderer' in i) {
                        let s = t.renderers[i.name]
                        s
                          ? (t.renderers[i.name] = function (...o) {
                              let l = i.renderer.apply(this, o)
                              return l === !1 && (l = s.apply(this, o)), l
                            })
                          : (t.renderers[i.name] = i.renderer)
                      }
                      if ('tokenizer' in i) {
                        if (!i.level || (i.level !== 'block' && i.level !== 'inline'))
                          throw new Error("extension level must be 'block' or 'inline'")
                        let s = t[i.level]
                        s ? s.unshift(i.tokenizer) : (t[i.level] = [i.tokenizer]),
                          i.start &&
                            (i.level === 'block'
                              ? t.startBlock
                                ? t.startBlock.push(i.start)
                                : (t.startBlock = [i.start])
                              : i.level === 'inline' &&
                                (t.startInline ? t.startInline.push(i.start) : (t.startInline = [i.start])))
                      }
                      'childTokens' in i && i.childTokens && (t.childTokens[i.name] = i.childTokens)
                    }),
                    (n.extensions = t)),
                  r.renderer)
                ) {
                  let i = this.defaults.renderer || new Ab(this.defaults)
                  for (let s in r.renderer) {
                    if (!(s in i)) throw new Error(`renderer '${s}' does not exist`)
                    if (['options', 'parser'].includes(s)) continue
                    let o = s,
                      l = r.renderer[o],
                      u = i[o]
                    i[o] = (...h) => {
                      let f = l.apply(i, h)
                      return f === !1 && (f = u.apply(i, h)), f || ''
                    }
                  }
                  n.renderer = i
                }
                if (r.tokenizer) {
                  let i = this.defaults.tokenizer || new vb(this.defaults)
                  for (let s in r.tokenizer) {
                    if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`)
                    if (['options', 'rules', 'lexer'].includes(s)) continue
                    let o = s,
                      l = r.tokenizer[o],
                      u = i[o]
                    i[o] = (...h) => {
                      let f = l.apply(i, h)
                      return f === !1 && (f = u.apply(i, h)), f
                    }
                  }
                  n.tokenizer = i
                }
                if (r.hooks) {
                  let i = this.defaults.hooks || new L0()
                  for (let s in r.hooks) {
                    if (!(s in i)) throw new Error(`hook '${s}' does not exist`)
                    if (['options', 'block'].includes(s)) continue
                    let o = s,
                      l = r.hooks[o],
                      u = i[o]
                    L0.passThroughHooks.has(s)
                      ? (i[o] = (h) => {
                          if (this.defaults.async && L0.passThroughHooksRespectAsync.has(s))
                            return Promise.resolve(l.call(i, h)).then((d) => u.call(i, d))
                          let f = l.call(i, h)
                          return u.call(i, f)
                        })
                      : (i[o] = (...h) => {
                          let f = l.apply(i, h)
                          return f === !1 && (f = u.apply(i, h)), f
                        })
                  }
                  n.hooks = i
                }
                if (r.walkTokens) {
                  let i = this.defaults.walkTokens,
                    s = r.walkTokens
                  n.walkTokens = function (o) {
                    let l = []
                    return l.push(s.call(this, o)), i && (l = l.concat(i.call(this, o))), l
                  }
                }
                this.defaults = { ...this.defaults, ...n }
              }),
              this
            )
          }
          setOptions(e) {
            return (this.defaults = { ...this.defaults, ...e }), this
          }
          lexer(e, t) {
            return yl.lex(e, t ?? this.defaults)
          }
          parser(e, t) {
            return xl.parse(e, t ?? this.defaults)
          }
          parseMarkdown(e) {
            return (t, r) => {
              let n = { ...r },
                i = { ...this.defaults, ...n },
                s = this.onError(!!i.silent, !!i.async)
              if (this.defaults.async === !0 && n.async === !1)
                return s(
                  new Error(
                    'marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.',
                  ),
                )
              if (typeof t > 'u' || t === null) return s(new Error('marked(): input parameter is undefined or null'))
              if (typeof t != 'string')
                return s(
                  new Error(
                    'marked(): input parameter is of type ' + Object.prototype.toString.call(t) + ', string expected',
                  ),
                )
              i.hooks && ((i.hooks.options = i), (i.hooks.block = e))
              let o = i.hooks ? i.hooks.provideLexer() : e ? yl.lex : yl.lexInline,
                l = i.hooks ? i.hooks.provideParser() : e ? xl.parse : xl.parseInline
              if (i.async)
                return Promise.resolve(i.hooks ? i.hooks.preprocess(t) : t)
                  .then((u) => o(u, i))
                  .then((u) => (i.hooks ? i.hooks.processAllTokens(u) : u))
                  .then((u) => (i.walkTokens ? Promise.all(this.walkTokens(u, i.walkTokens)).then(() => u) : u))
                  .then((u) => l(u, i))
                  .then((u) => (i.hooks ? i.hooks.postprocess(u) : u))
                  .catch(s)
              try {
                i.hooks && (t = i.hooks.preprocess(t))
                let u = o(t, i)
                i.hooks && (u = i.hooks.processAllTokens(u)), i.walkTokens && this.walkTokens(u, i.walkTokens)
                let h = l(u, i)
                return i.hooks && (h = i.hooks.postprocess(h)), h
              } catch (u) {
                return s(u)
              }
            }
          }
          onError(e, t) {
            return (r) => {
              if (
                ((r.message += `
Please report this to https://github.com/markedjs/marked.`),
                e)
              ) {
                let n = '<p>An error occurred:</p><pre>' + bo(r.message + '', !0) + '</pre>'
                return t ? Promise.resolve(n) : n
              }
              if (t) return Promise.reject(r)
              throw r
            }
          }
        }),
        (Qu = new nbt())
      a(br, 'd')
      br.options = br.setOptions = function (e) {
        return Qu.setOptions(e), (br.defaults = Qu.defaults), YG(br.defaults), br
      }
      br.getDefaults = Q4
      br.defaults = Zu
      br.use = function (...e) {
        return Qu.use(...e), (br.defaults = Qu.defaults), YG(br.defaults), br
      }
      br.walkTokens = function (e, t) {
        return Qu.walkTokens(e, t)
      }
      br.parseInline = Qu.parseInline
      br.Parser = xl
      br.parser = xl.parse
      br.Renderer = Ab
      br.TextRenderer = sA
      br.Lexer = yl
      br.lexer = yl.lex
      br.Tokenizer = vb
      br.Hooks = L0
      br.parse = br
      ;(Bae = br.options),
        (Fae = br.setOptions),
        ($ae = br.use),
        (Gae = br.walkTokens),
        (Vae = br.parseInline),
        (zae = xl.parse),
        (Wae = yl.lex)
    })
  function ibt(e, { markdownAutoWrap: t }) {
    let n = e
        .replace(
          /<br\/>/g,
          `
`,
        )
        .replace(
          /\n{2,}/g,
          `
`,
        ),
      i = bx(n)
    return t === !1 ? i.replace(/ /g, '&nbsp;') : i
  }
  function aV(e, t = {}) {
    let r = ibt(e, t),
      n = br.lexer(r),
      i = [[]],
      s = 0
    function o(l, u = 'normal') {
      l.type === 'text'
        ? l.text
            .split(
              `
`,
            )
            .forEach((f, d) => {
              d !== 0 && (s++, i.push([])),
                f.split(' ').forEach((p) => {
                  ;(p = p.replace(/&#39;/g, "'")), p && i[s].push({ content: p, type: u })
                })
            })
        : l.type === 'strong' || l.type === 'em'
          ? l.tokens.forEach((h) => {
              o(h, l.type)
            })
          : l.type === 'html' && i[s].push({ content: l.text, type: 'normal' })
    }
    return (
      a(o, 'processNode'),
      n.forEach((l) => {
        l.type === 'paragraph'
          ? l.tokens?.forEach((u) => {
              o(u)
            })
          : l.type === 'html'
            ? i[s].push({ content: l.text, type: 'normal' })
            : i[s].push({ content: l.raw, type: 'normal' })
      }),
      i
    )
  }
  function oV(e, { markdownAutoWrap: t } = {}) {
    let r = br.lexer(e)
    function n(i) {
      return i.type === 'text'
        ? t === !1
          ? i.text.replace(/\n */g, '<br/>').replace(/ /g, '&nbsp;')
          : i.text.replace(/\n */g, '<br/>')
        : i.type === 'strong'
          ? `<strong>${i.tokens?.map(n).join('')}</strong>`
          : i.type === 'em'
            ? `<em>${i.tokens?.map(n).join('')}</em>`
            : i.type === 'paragraph'
              ? `<p>${i.tokens?.map(n).join('')}</p>`
              : i.type === 'space'
                ? ''
                : i.type === 'html'
                  ? `${i.text}`
                  : i.type === 'escape'
                    ? i.text
                    : (B.warn(`Unsupported markdown: ${i.type}`), i.raw)
    }
    return a(n, 'output'), r.map(n).join('')
  }
  var lV = x(() => {
    'use strict'
    sV()
    pw()
    Vt()
    a(ibt, 'preprocessMarkdown')
    a(aV, 'markdownToLines')
    a(oV, 'markdownToHTML')
  })
  function sbt(e) {
    return Intl.Segmenter ? [...new Intl.Segmenter().segment(e)].map((t) => t.segment) : [...e]
  }
  function abt(e, t) {
    let r = sbt(t.content)
    return cV(e, [], r, t.type)
  }
  function cV(e, t, r, n) {
    if (r.length === 0)
      return [
        { content: t.join(''), type: n },
        { content: '', type: n },
      ]
    let [i, ...s] = r,
      o = [...t, i]
    return e([{ content: o.join(''), type: n }])
      ? cV(e, o, s, n)
      : (t.length === 0 && i && (t.push(i), r.shift()),
        [
          { content: t.join(''), type: n },
          { content: r.join(''), type: n },
        ])
  }
  function uV(e, t) {
    if (
      e.some(({ content: r }) =>
        r.includes(`
`),
      )
    )
      throw new Error('splitLineToFitWidth does not support newlines in the line')
    return aA(e, t)
  }
  function aA(e, t, r = [], n = []) {
    if (e.length === 0) return n.length > 0 && r.push(n), r.length > 0 ? r : []
    let i = ''
    e[0].content === ' ' && ((i = ' '), e.shift())
    let s = e.shift() ?? { content: ' ', type: 'normal' },
      o = [...n]
    if ((i !== '' && o.push({ content: i, type: 'normal' }), o.push(s), t(o))) return aA(e, t, r, o)
    if (n.length > 0) r.push(n), e.unshift(s)
    else if (s.content) {
      let [l, u] = abt(t, s)
      r.push([l]), u.content && e.unshift(u)
    }
    return aA(e, t, r)
  }
  var hV = x(() => {
    'use strict'
    a(sbt, 'splitTextToChars')
    a(abt, 'splitWordToFitWidth')
    a(cV, 'splitWordToFitWidthRecursion')
    a(uV, 'splitLineToFitWidth')
    a(aA, 'splitLineToFitWidthRecursion')
  })
  function fV(e, t) {
    t && e.attr('style', t)
  }
  async function obt(e, t, r, n, i = !1, s = Te()) {
    let o = e.append('foreignObject')
    o.attr('width', `${10 * r}px`), o.attr('height', `${10 * r}px`)
    let l = o.append('xhtml:div'),
      u = $r(t.label)
        ? await Xl(
            t.label.replace(
              Rt.lineBreakRegex,
              `
`,
            ),
            s,
          )
        : Ie(t.label, s),
      h = t.isNode ? 'nodeLabel' : 'edgeLabel',
      f = l.append('span')
    f.html(u),
      fV(f, t.labelStyle),
      f.attr('class', `${h} ${n}`),
      fV(l, t.labelStyle),
      l.style('display', 'table-cell'),
      l.style('white-space', 'nowrap'),
      l.style('line-height', '1.5'),
      l.style('max-width', r + 'px'),
      l.style('text-align', 'center'),
      l.attr('xmlns', 'http://www.w3.org/1999/xhtml'),
      i && l.attr('class', 'labelBkg')
    let d = l.node().getBoundingClientRect()
    return (
      d.width === r &&
        (l.style('display', 'table'),
        l.style('white-space', 'break-spaces'),
        l.style('width', r + 'px'),
        (d = l.node().getBoundingClientRect())),
      o.node()
    )
  }
  function oA(e, t, r) {
    return e
      .append('tspan')
      .attr('class', 'text-outer-tspan')
      .attr('x', 0)
      .attr('y', t * r - 0.1 + 'em')
      .attr('dy', r + 'em')
  }
  function lbt(e, t, r) {
    let n = e.append('text'),
      i = oA(n, 1, t)
    lA(i, r)
    let s = i.node().getComputedTextLength()
    return n.remove(), s
  }
  function dV(e, t, r) {
    let n = e.append('text'),
      i = oA(n, 1, t)
    lA(i, [{ content: r, type: 'normal' }])
    let s = i.node()?.getBoundingClientRect()
    return s && n.remove(), s
  }
  function cbt(e, t, r, n = !1) {
    let s = t.append('g'),
      o = s.insert('rect').attr('class', 'background').attr('style', 'stroke: none'),
      l = s.append('text').attr('y', '-10.1'),
      u = 0
    for (let h of r) {
      let f = a((p) => lbt(s, 1.1, p) <= e, 'checkWidth'),
        d = f(h) ? [h] : uV(h, f)
      for (let p of d) {
        let m = oA(l, u, 1.1)
        lA(m, p), u++
      }
    }
    if (n) {
      let h = l.node().getBBox(),
        f = 2
      return (
        o
          .attr('x', h.x - f)
          .attr('y', h.y - f)
          .attr('width', h.width + 2 * f)
          .attr('height', h.height + 2 * f),
        s.node()
      )
    } else return l.node()
  }
  function lA(e, t) {
    e.text(''),
      t.forEach((r, n) => {
        let i = e
          .append('tspan')
          .attr('font-style', r.type === 'em' ? 'italic' : 'normal')
          .attr('class', 'text-inner-tspan')
          .attr('font-weight', r.type === 'strong' ? 'bold' : 'normal')
        n === 0 ? i.text(r.content) : i.text(' ' + r.content)
      })
  }
  async function cA(e, t = {}) {
    let r = []
    e.replace(
      /(fa[bklrs]?):fa-([\w-]+)/g,
      (i, s, o) => (
        r.push(
          (async () => {
            let l = `${s}:${o}`
            return (await SI(l))
              ? await ro(l, void 0, { class: 'label-icon' })
              : `<i class='${Ie(i, t).replace(':', ' ')}'></i>`
          })(),
        ),
        i
      ),
    )
    let n = await Promise.all(r)
    return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? '')
  }
  var Kn,
    $a = x(() => {
      'use strict'
      Ge()
      Be()
      Vt()
      lV()
      Ce()
      bu()
      hV()
      fn()
      a(fV, 'applyStyle')
      a(obt, 'addHtmlSpan')
      a(oA, 'createTspan')
      a(lbt, 'computeWidthOfText')
      a(dV, 'computeDimensionOfText')
      a(cbt, 'createFormattedText')
      a(lA, 'updateTextContentAndStyles')
      a(cA, 'replaceIconSubstring')
      Kn = a(
        async (
          e,
          t = '',
          {
            style: r = '',
            isTitle: n = !1,
            classes: i = '',
            useHtmlLabels: s = !0,
            isNode: o = !0,
            width: l = 200,
            addSvgBackground: u = !1,
          } = {},
          h,
        ) => {
          if ((B.debug('XYZ createText', t, r, n, i, s, o, 'addSvgBackground: ', u), s)) {
            let f = oV(t, h),
              d = await cA(Xn(f), h),
              p = t.replace(/\\\\/g, '\\'),
              m = { isNode: o, label: $r(t) ? p : d, labelStyle: r.replace('fill:', 'color:') }
            return await obt(e, m, l, i, u, h)
          } else {
            let f = t.replace(/<br\s*\/?>/g, '<br/>'),
              d = aV(f.replace('<br>', '<br/>'), h),
              p = cbt(l, e, d, t ? u : !1)
            if (o) {
              ;/stroke:/.exec(r) && (r = r.replace('stroke:', 'lineColor:'))
              let m = r
                .replace(/stroke:[^;]+;?/g, '')
                .replace(/stroke-width:[^;]+;?/g, '')
                .replace(/fill:[^;]+;?/g, '')
                .replace(/color:/g, 'fill:')
              xt(p).attr('style', m)
            } else {
              let m = r
                .replace(/stroke:[^;]+;?/g, '')
                .replace(/stroke-width:[^;]+;?/g, '')
                .replace(/fill:[^;]+;?/g, '')
                .replace(/background:/g, 'fill:')
              xt(p)
                .select('rect')
                .attr('style', m.replace(/background:/g, 'fill:'))
              let g = r
                .replace(/stroke:[^;]+;?/g, '')
                .replace(/stroke-width:[^;]+;?/g, '')
                .replace(/fill:[^;]+;?/g, '')
                .replace(/color:/g, 'fill:')
              xt(p).select('text').attr('style', g)
            }
            return p
          }
        },
        'createText',
      )
    })
  function ie(e) {
    let t = e.map((r, n) => `${n === 0 ? 'M' : 'L'}${r.x},${r.y}`)
    return t.push('Z'), t.join(' ')
  }
  function na(e, t, r, n, i, s) {
    let o = [],
      u = r - e,
      h = n - t,
      f = u / s,
      d = (2 * Math.PI) / f,
      p = t + h / 2
    for (let m = 0; m <= 50; m++) {
      let g = m / 50,
        y = e + g * u,
        b = p + i * Math.sin(d * (y - e))
      o.push({ x: y, y: b })
    }
    return o
  }
  function Ju(e, t, r, n, i, s) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1)
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p)
      o.push({ x: -m, y: -g })
    }
    return o
  }
  var Bt,
    Db,
    Ct,
    Ot,
    Qt = x(() => {
      'use strict'
      $a()
      pe()
      Ge()
      _s()
      Be()
      Ce()
      ;(Bt = a(async (e, t, r) => {
        let n,
          i = t.useHtmlLabels || Pe(K()?.htmlLabels)
        r ? (n = r) : (n = 'node default')
        let s = e
            .insert('g')
            .attr('class', n)
            .attr('id', t.domId || t.id),
          o = s.insert('g').attr('class', 'label').attr('style', Ir(t.labelStyle)),
          l
        t.label === void 0 ? (l = '') : (l = typeof t.label == 'string' ? t.label : t.label[0])
        let u = await Kn(o, Ie(Xn(l), K()), {
            useHtmlLabels: i,
            width: t.width || K().flowchart?.wrappingWidth,
            cssClasses: 'markdown-node-label',
            style: t.labelStyle,
            addSvgBackground: !!t.icon || !!t.img,
          }),
          h = u.getBBox(),
          f = (t?.padding ?? 0) / 2
        if (i) {
          let d = u.children[0],
            p = xt(u),
            m = d.getElementsByTagName('img')
          if (m) {
            let g = l.replace(/<img[^>]*>/g, '').trim() === ''
            await Promise.all(
              [...m].map(
                (y) =>
                  new Promise((b) => {
                    function k() {
                      if (((y.style.display = 'flex'), (y.style.flexDirection = 'column'), g)) {
                        let T = K().fontSize ? K().fontSize : window.getComputedStyle(document.body).fontSize,
                          C = 5,
                          [A = ze.fontSize] = yo(T),
                          w = A * C + 'px'
                        ;(y.style.minWidth = w), (y.style.maxWidth = w)
                      } else y.style.width = '100%'
                      b(y)
                    }
                    a(k, 'setupImage'),
                      setTimeout(() => {
                        y.complete && k()
                      }),
                      y.addEventListener('error', k),
                      y.addEventListener('load', k)
                  }),
              ),
            )
          }
          ;(h = d.getBoundingClientRect()), p.attr('width', h.width), p.attr('height', h.height)
        }
        return (
          i
            ? o.attr('transform', 'translate(' + -h.width / 2 + ', ' + -h.height / 2 + ')')
            : o.attr('transform', 'translate(0, ' + -h.height / 2 + ')'),
          t.centerLabel && o.attr('transform', 'translate(' + -h.width / 2 + ', ' + -h.height / 2 + ')'),
          o.insert('rect', ':first-child'),
          { shapeSvg: s, bbox: h, halfPadding: f, label: o }
        )
      }, 'labelHelper')),
        (Db = a(async (e, t, r) => {
          let n = r.useHtmlLabels || Pe(K()?.flowchart?.htmlLabels),
            i = e
              .insert('g')
              .attr('class', 'label')
              .attr('style', r.labelStyle || ''),
            s = await Kn(i, Ie(Xn(t), K()), {
              useHtmlLabels: n,
              width: r.width || K()?.flowchart?.wrappingWidth,
              style: r.labelStyle,
              addSvgBackground: !!r.icon || !!r.img,
            }),
            o = s.getBBox(),
            l = r.padding / 2
          if (Pe(K()?.flowchart?.htmlLabels)) {
            let u = s.children[0],
              h = xt(s)
            ;(o = u.getBoundingClientRect()), h.attr('width', o.width), h.attr('height', o.height)
          }
          return (
            n
              ? i.attr('transform', 'translate(' + -o.width / 2 + ', ' + -o.height / 2 + ')')
              : i.attr('transform', 'translate(0, ' + -o.height / 2 + ')'),
            r.centerLabel && i.attr('transform', 'translate(' + -o.width / 2 + ', ' + -o.height / 2 + ')'),
            i.insert('rect', ':first-child'),
            { shapeSvg: e, bbox: o, halfPadding: l, label: i }
          )
        }, 'insertLabel')),
        (Ct = a((e, t) => {
          let r = t.node().getBBox()
          ;(e.width = r.width), (e.height = r.height)
        }, 'updateNodeBounds')),
        (Ot = a(
          (e, t) => (e.look === 'handDrawn' ? 'rough-node' : 'node') + ' ' + e.cssClasses + ' ' + (t || ''),
          'getNodeClasses',
        ))
      a(ie, 'createPathFromPoints')
      a(na, 'generateFullSineWavePoints')
      a(Ju, 'generateCirclePoints')
    })
  function ubt(e, t) {
    return e.intersect(t)
  }
  var pV,
    mV = x(() => {
      'use strict'
      a(ubt, 'intersectNode')
      pV = ubt
    })
  function hbt(e, t, r, n) {
    var i = e.x,
      s = e.y,
      o = i - n.x,
      l = s - n.y,
      u = Math.sqrt(t * t * l * l + r * r * o * o),
      h = Math.abs((t * r * o) / u)
    n.x < i && (h = -h)
    var f = Math.abs((t * r * l) / u)
    return n.y < s && (f = -f), { x: i + h, y: s + f }
  }
  var Nb,
    uA = x(() => {
      'use strict'
      a(hbt, 'intersectEllipse')
      Nb = hbt
    })
  function fbt(e, t, r) {
    return Nb(e, t, t, r)
  }
  var gV,
    yV = x(() => {
      'use strict'
      uA()
      a(fbt, 'intersectCircle')
      gV = fbt
    })
  function dbt(e, t, r, n) {
    {
      let i = t.y - e.y,
        s = e.x - t.x,
        o = t.x * e.y - e.x * t.y,
        l = i * r.x + s * r.y + o,
        u = i * n.x + s * n.y + o,
        h = 1e-6
      if (l !== 0 && u !== 0 && xV(l, u)) return
      let f = n.y - r.y,
        d = r.x - n.x,
        p = n.x * r.y - r.x * n.y,
        m = f * e.x + d * e.y + p,
        g = f * t.x + d * t.y + p
      if (Math.abs(m) < h && Math.abs(g) < h && xV(m, g)) return
      let y = i * d - f * s
      if (y === 0) return
      let b = Math.abs(y / 2),
        k = s * p - d * o,
        T = k < 0 ? (k - b) / y : (k + b) / y
      k = f * o - i * p
      let C = k < 0 ? (k - b) / y : (k + b) / y
      return { x: T, y: C }
    }
  }
  function xV(e, t) {
    return e * t > 0
  }
  var bV,
    kV = x(() => {
      'use strict'
      a(dbt, 'intersectLine')
      a(xV, 'sameSign')
      bV = dbt
    })
  function pbt(e, t, r) {
    let n = e.x,
      i = e.y,
      s = [],
      o = Number.POSITIVE_INFINITY,
      l = Number.POSITIVE_INFINITY
    typeof t.forEach == 'function'
      ? t.forEach(function (f) {
          ;(o = Math.min(o, f.x)), (l = Math.min(l, f.y))
        })
      : ((o = Math.min(o, t.x)), (l = Math.min(l, t.y)))
    let u = n - e.width / 2 - o,
      h = i - e.height / 2 - l
    for (let f = 0; f < t.length; f++) {
      let d = t[f],
        p = t[f < t.length - 1 ? f + 1 : 0],
        m = bV(e, r, { x: u + d.x, y: h + d.y }, { x: u + p.x, y: h + p.y })
      m && s.push(m)
    }
    return s.length
      ? (s.length > 1 &&
          s.sort(function (f, d) {
            let p = f.x - r.x,
              m = f.y - r.y,
              g = Math.sqrt(p * p + m * m),
              y = d.x - r.x,
              b = d.y - r.y,
              k = Math.sqrt(y * y + b * b)
            return g < k ? -1 : g === k ? 0 : 1
          }),
        s[0])
      : e
  }
  var TV,
    SV = x(() => {
      'use strict'
      kV()
      a(pbt, 'intersectPolygon')
      TV = pbt
    })
  var mbt,
    wc,
    hA = x(() => {
      'use strict'
      ;(mbt = a((e, t) => {
        var r = e.x,
          n = e.y,
          i = t.x - r,
          s = t.y - n,
          o = e.width / 2,
          l = e.height / 2,
          u,
          h
        return (
          Math.abs(s) * o > Math.abs(i) * l
            ? (s < 0 && (l = -l), (u = s === 0 ? 0 : (l * i) / s), (h = l))
            : (i < 0 && (o = -o), (u = o), (h = i === 0 ? 0 : (o * s) / i)),
          { x: r + u, y: n + h }
        )
      }, 'intersectRect')),
        (wc = mbt)
    })
  var Tt,
    ae = x(() => {
      'use strict'
      mV()
      yV()
      uA()
      SV()
      hA()
      Tt = { node: pV, circle: gV, ellipse: Nb, polygon: TV, rect: wc }
    })
  var _V,
    ko,
    gbt,
    N0,
    St,
    Et,
    ybt,
    re = x(() => {
      'use strict'
      pe()
      ;(_V = a((e) => {
        let { handDrawnSeed: t } = K()
        return { fill: e, hachureAngle: 120, hachureGap: 4, fillWeight: 2, roughness: 0.7, stroke: e, seed: t }
      }, 'solidStateFill')),
        (ko = a((e) => {
          let t = gbt([...(e.cssCompiledStyles || []), ...(e.cssStyles || []), ...(e.labelStyle || [])])
          return { stylesMap: t, stylesArray: [...t] }
        }, 'compileStyles')),
        (gbt = a((e) => {
          let t = new Map()
          return (
            e.forEach((r) => {
              let [n, i] = r.split(':')
              t.set(n.trim(), i?.trim())
            }),
            t
          )
        }, 'styles2Map')),
        (N0 = a(
          (e) =>
            e === 'color' ||
            e === 'font-size' ||
            e === 'font-family' ||
            e === 'font-weight' ||
            e === 'font-style' ||
            e === 'text-decoration' ||
            e === 'text-align' ||
            e === 'text-transform' ||
            e === 'line-height' ||
            e === 'letter-spacing' ||
            e === 'word-spacing' ||
            e === 'text-shadow' ||
            e === 'text-overflow' ||
            e === 'white-space' ||
            e === 'word-wrap' ||
            e === 'word-break' ||
            e === 'overflow-wrap' ||
            e === 'hyphens',
          'isLabelStyle',
        )),
        (St = a((e) => {
          let { stylesArray: t } = ko(e),
            r = [],
            n = [],
            i = [],
            s = []
          return (
            t.forEach((o) => {
              let l = o[0]
              N0(l)
                ? r.push(o.join(':') + ' !important')
                : (n.push(o.join(':') + ' !important'),
                  l.includes('stroke') && i.push(o.join(':') + ' !important'),
                  l === 'fill' && s.push(o.join(':') + ' !important'))
            }),
            { labelStyles: r.join(';'), nodeStyles: n.join(';'), stylesArray: t, borderStyles: i, backgroundStyles: s }
          )
        }, 'styles2String')),
        (Et = a((e, t) => {
          let { themeVariables: r, handDrawnSeed: n } = K(),
            { nodeBorder: i, mainBkg: s } = r,
            { stylesMap: o } = ko(e)
          return Object.assign(
            {
              roughness: 0.7,
              fill: o.get('fill') || s,
              fillStyle: 'hachure',
              fillWeight: 4,
              hachureGap: 5.2,
              stroke: o.get('stroke') || i,
              seed: n,
              strokeWidth: o.get('stroke-width')?.replace('px', '') || 1.3,
              fillLineDash: [0, 0],
              strokeLineDash: ybt(o.get('stroke-dasharray')),
            },
            t,
          )
        }, 'userNodeOverrides')),
        (ybt = a((e) => {
          if (!e) return [0, 0]
          let t = e.trim().split(/\s+/).map(Number)
          if (t.length === 1) {
            let i = isNaN(t[0]) ? 0 : t[0]
            return [i, i]
          }
          let r = isNaN(t[0]) ? 0 : t[0],
            n = isNaN(t[1]) ? 0 : t[1]
          return [r, n]
        }, 'getStrokeDashArray'))
    })
  function fA(e, t, r) {
    if (e && e.length) {
      let [n, i] = t,
        s = (Math.PI / 180) * r,
        o = Math.cos(s),
        l = Math.sin(s)
      for (let u of e) {
        let [h, f] = u
        ;(u[0] = (h - n) * o - (f - i) * l + n), (u[1] = (h - n) * l + (f - i) * o + i)
      }
    }
  }
  function xbt(e, t) {
    return e[0] === t[0] && e[1] === t[1]
  }
  function bbt(e, t, r, n = 1) {
    let i = r,
      s = Math.max(t, 0.1),
      o = e[0] && e[0][0] && typeof e[0][0] == 'number' ? [e] : e,
      l = [0, 0]
    if (i) for (let h of o) fA(h, l, i)
    let u = (function (h, f, d) {
      let p = []
      for (let T of h) {
        let C = [...T]
        xbt(C[0], C[C.length - 1]) || C.push([C[0][0], C[0][1]]), C.length > 2 && p.push(C)
      }
      let m = []
      f = Math.max(f, 0.1)
      let g = []
      for (let T of p)
        for (let C = 0; C < T.length - 1; C++) {
          let A = T[C],
            w = T[C + 1]
          if (A[1] !== w[1]) {
            let D = Math.min(A[1], w[1])
            g.push({
              ymin: D,
              ymax: Math.max(A[1], w[1]),
              x: D === A[1] ? A[0] : w[0],
              islope: (w[0] - A[0]) / (w[1] - A[1]),
            })
          }
        }
      if (
        (g.sort((T, C) =>
          T.ymin < C.ymin
            ? -1
            : T.ymin > C.ymin
              ? 1
              : T.x < C.x
                ? -1
                : T.x > C.x
                  ? 1
                  : T.ymax === C.ymax
                    ? 0
                    : (T.ymax - C.ymax) / Math.abs(T.ymax - C.ymax),
        ),
        !g.length)
      )
        return m
      let y = [],
        b = g[0].ymin,
        k = 0
      for (; y.length || g.length; ) {
        if (g.length) {
          let T = -1
          for (let C = 0; C < g.length && !(g[C].ymin > b); C++) T = C
          g.splice(0, T + 1).forEach((C) => {
            y.push({ s: b, edge: C })
          })
        }
        if (
          ((y = y.filter((T) => !(T.edge.ymax <= b))),
          y.sort((T, C) => (T.edge.x === C.edge.x ? 0 : (T.edge.x - C.edge.x) / Math.abs(T.edge.x - C.edge.x))),
          (d !== 1 || k % f == 0) && y.length > 1)
        )
          for (let T = 0; T < y.length; T += 2) {
            let C = T + 1
            if (C >= y.length) break
            let A = y[T].edge,
              w = y[C].edge
            m.push([
              [Math.round(A.x), b],
              [Math.round(w.x), b],
            ])
          }
        ;(b += d),
          y.forEach((T) => {
            T.edge.x = T.edge.x + d * T.edge.islope
          }),
          k++
      }
      return m
    })(o, s, n)
    if (i) {
      for (let h of o) fA(h, l, -i)
      ;(function (h, f, d) {
        let p = []
        h.forEach((m) => p.push(...m)), fA(p, f, d)
      })(u, l, -i)
    }
    return u
  }
  function P0(e, t) {
    var r
    let n = t.hachureAngle + 90,
      i = t.hachureGap
    i < 0 && (i = 4 * t.strokeWidth), (i = Math.round(Math.max(i, 0.1)))
    let s = 1
    return (
      t.roughness >= 1 &&
        (((r = t.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 &&
        (s = i),
      bbt(e, i, n, s || 1)
    )
  }
  function Vb(e) {
    let t = e[0],
      r = e[1]
    return Math.sqrt(Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2))
  }
  function pA(e, t) {
    return e.type === t
  }
  function AA(e) {
    let t = [],
      r = (function (o) {
        let l = new Array()
        for (; o !== ''; )
          if (o.match(/^([ \t\r\n,]+)/)) o = o.substr(RegExp.$1.length)
          else if (o.match(/^([aAcChHlLmMqQsStTvVzZ])/))
            (l[l.length] = { type: kbt, text: RegExp.$1 }), (o = o.substr(RegExp.$1.length))
          else {
            if (!o.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return []
            ;(l[l.length] = { type: dA, text: `${parseFloat(RegExp.$1)}` }), (o = o.substr(RegExp.$1.length))
          }
        return (l[l.length] = { type: CV, text: '' }), l
      })(e),
      n = 'BOD',
      i = 0,
      s = r[i]
    for (; !pA(s, CV); ) {
      let o = 0,
        l = []
      if (n === 'BOD') {
        if (s.text !== 'M' && s.text !== 'm') return AA('M0,0' + e)
        i++, (o = Ib[s.text]), (n = s.text)
      } else pA(s, dA) ? (o = Ib[n]) : (i++, (o = Ib[s.text]), (n = s.text))
      if (!(i + o < r.length)) throw new Error('Path data ended short')
      for (let u = i; u < i + o; u++) {
        let h = r[u]
        if (!pA(h, dA)) throw new Error('Param not a number: ' + n + ',' + h.text)
        l[l.length] = +h.text
      }
      if (typeof Ib[n] != 'number') throw new Error('Bad segment: ' + n)
      {
        let u = { key: n, data: l }
        t.push(u), (i += o), (s = r[i]), n === 'M' && (n = 'L'), n === 'm' && (n = 'l')
      }
    }
    return t
  }
  function NV(e) {
    let t = 0,
      r = 0,
      n = 0,
      i = 0,
      s = []
    for (let { key: o, data: l } of e)
      switch (o) {
        case 'M':
          s.push({ key: 'M', data: [...l] }), ([t, r] = l), ([n, i] = l)
          break
        case 'm':
          ;(t += l[0]), (r += l[1]), s.push({ key: 'M', data: [t, r] }), (n = t), (i = r)
          break
        case 'L':
          s.push({ key: 'L', data: [...l] }), ([t, r] = l)
          break
        case 'l':
          ;(t += l[0]), (r += l[1]), s.push({ key: 'L', data: [t, r] })
          break
        case 'C':
          s.push({ key: 'C', data: [...l] }), (t = l[4]), (r = l[5])
          break
        case 'c': {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t))
          s.push({ key: 'C', data: u }), (t = u[4]), (r = u[5])
          break
        }
        case 'Q':
          s.push({ key: 'Q', data: [...l] }), (t = l[2]), (r = l[3])
          break
        case 'q': {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t))
          s.push({ key: 'Q', data: u }), (t = u[2]), (r = u[3])
          break
        }
        case 'A':
          s.push({ key: 'A', data: [...l] }), (t = l[5]), (r = l[6])
          break
        case 'a':
          ;(t += l[5]), (r += l[6]), s.push({ key: 'A', data: [l[0], l[1], l[2], l[3], l[4], t, r] })
          break
        case 'H':
          s.push({ key: 'H', data: [...l] }), (t = l[0])
          break
        case 'h':
          ;(t += l[0]), s.push({ key: 'H', data: [t] })
          break
        case 'V':
          s.push({ key: 'V', data: [...l] }), (r = l[0])
          break
        case 'v':
          ;(r += l[0]), s.push({ key: 'V', data: [r] })
          break
        case 'S':
          s.push({ key: 'S', data: [...l] }), (t = l[2]), (r = l[3])
          break
        case 's': {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t))
          s.push({ key: 'S', data: u }), (t = u[2]), (r = u[3])
          break
        }
        case 'T':
          s.push({ key: 'T', data: [...l] }), (t = l[0]), (r = l[1])
          break
        case 't':
          ;(t += l[0]), (r += l[1]), s.push({ key: 'T', data: [t, r] })
          break
        case 'Z':
        case 'z':
          s.push({ key: 'Z', data: [] }), (t = n), (r = i)
      }
    return s
  }
  function IV(e) {
    let t = [],
      r = '',
      n = 0,
      i = 0,
      s = 0,
      o = 0,
      l = 0,
      u = 0
    for (let { key: h, data: f } of e) {
      switch (h) {
        case 'M':
          t.push({ key: 'M', data: [...f] }), ([n, i] = f), ([s, o] = f)
          break
        case 'C':
          t.push({ key: 'C', data: [...f] }), (n = f[4]), (i = f[5]), (l = f[2]), (u = f[3])
          break
        case 'L':
          t.push({ key: 'L', data: [...f] }), ([n, i] = f)
          break
        case 'H':
          ;(n = f[0]), t.push({ key: 'L', data: [n, i] })
          break
        case 'V':
          ;(i = f[0]), t.push({ key: 'L', data: [n, i] })
          break
        case 'S': {
          let d = 0,
            p = 0
          r === 'C' || r === 'S' ? ((d = n + (n - l)), (p = i + (i - u))) : ((d = n), (p = i)),
            t.push({ key: 'C', data: [d, p, ...f] }),
            (l = f[0]),
            (u = f[1]),
            (n = f[2]),
            (i = f[3])
          break
        }
        case 'T': {
          let [d, p] = f,
            m = 0,
            g = 0
          r === 'Q' || r === 'T' ? ((m = n + (n - l)), (g = i + (i - u))) : ((m = n), (g = i))
          let y = n + (2 * (m - n)) / 3,
            b = i + (2 * (g - i)) / 3,
            k = d + (2 * (m - d)) / 3,
            T = p + (2 * (g - p)) / 3
          t.push({ key: 'C', data: [y, b, k, T, d, p] }), (l = m), (u = g), (n = d), (i = p)
          break
        }
        case 'Q': {
          let [d, p, m, g] = f,
            y = n + (2 * (d - n)) / 3,
            b = i + (2 * (p - i)) / 3,
            k = m + (2 * (d - m)) / 3,
            T = g + (2 * (p - g)) / 3
          t.push({ key: 'C', data: [y, b, k, T, m, g] }), (l = d), (u = p), (n = m), (i = g)
          break
        }
        case 'A': {
          let d = Math.abs(f[0]),
            p = Math.abs(f[1]),
            m = f[2],
            g = f[3],
            y = f[4],
            b = f[5],
            k = f[6]
          d === 0 || p === 0
            ? (t.push({ key: 'C', data: [n, i, b, k, b, k] }), (n = b), (i = k))
            : (n !== b || i !== k) &&
              (MV(n, i, b, k, d, p, m, g, y).forEach(function (T) {
                t.push({ key: 'C', data: T })
              }),
              (n = b),
              (i = k))
          break
        }
        case 'Z':
          t.push({ key: 'Z', data: [] }), (n = s), (i = o)
      }
      r = h
    }
    return t
  }
  function I0(e, t, r) {
    return [e * Math.cos(r) - t * Math.sin(r), e * Math.sin(r) + t * Math.cos(r)]
  }
  function MV(e, t, r, n, i, s, o, l, u, h) {
    let f = ((d = o), (Math.PI * d) / 180)
    var d
    let p = [],
      m = 0,
      g = 0,
      y = 0,
      b = 0
    if (h) [m, g, y, b] = h
    else {
      ;([e, t] = I0(e, t, -f)), ([r, n] = I0(r, n, -f))
      let E = (e - r) / 2,
        _ = (t - n) / 2,
        L = (E * E) / (i * i) + (_ * _) / (s * s)
      L > 1 && ((L = Math.sqrt(L)), (i *= L), (s *= L))
      let N = i * i,
        P = s * s,
        I = N * P - N * _ * _ - P * E * E,
        M = N * _ * _ + P * E * E,
        V = (l === u ? -1 : 1) * Math.sqrt(Math.abs(I / M))
      ;(y = (V * i * _) / s + (e + r) / 2),
        (b = (V * -s * E) / i + (t + n) / 2),
        (m = Math.asin(parseFloat(((t - b) / s).toFixed(9)))),
        (g = Math.asin(parseFloat(((n - b) / s).toFixed(9)))),
        e < y && (m = Math.PI - m),
        r < y && (g = Math.PI - g),
        m < 0 && (m = 2 * Math.PI + m),
        g < 0 && (g = 2 * Math.PI + g),
        u && m > g && (m -= 2 * Math.PI),
        !u && g > m && (g -= 2 * Math.PI)
    }
    let k = g - m
    if (Math.abs(k) > (120 * Math.PI) / 180) {
      let E = g,
        _ = r,
        L = n
      ;(g = u && g > m ? m + ((120 * Math.PI) / 180) * 1 : m + ((120 * Math.PI) / 180) * -1),
        (p = MV((r = y + i * Math.cos(g)), (n = b + s * Math.sin(g)), _, L, i, s, o, 0, u, [g, E, y, b]))
    }
    k = g - m
    let T = Math.cos(m),
      C = Math.sin(m),
      A = Math.cos(g),
      w = Math.sin(g),
      D = Math.tan(k / 4),
      G = (4 / 3) * i * D,
      v = (4 / 3) * s * D,
      R = [e, t],
      F = [e + G * C, t - v * T],
      S = [r + G * w, n - v * A],
      O = [r, n]
    if (((F[0] = 2 * R[0] - F[0]), (F[1] = 2 * R[1] - F[1]), h)) return [F, S, O].concat(p)
    {
      p = [F, S, O].concat(p)
      let E = []
      for (let _ = 0; _ < p.length; _ += 3) {
        let L = I0(p[_][0], p[_][1], f),
          N = I0(p[_ + 1][0], p[_ + 1][1], f),
          P = I0(p[_ + 2][0], p[_ + 2][1], f)
        E.push([L[0], L[1], N[0], N[1], P[0], P[1]])
      }
      return E
    }
  }
  function OV(e, t, r, n, i) {
    return { type: 'path', ops: Ec(e, t, r, n, i) }
  }
  function Pb(e, t, r) {
    let n = (e || []).length
    if (n > 2) {
      let i = []
      for (let s = 0; s < n - 1; s++) i.push(...Ec(e[s][0], e[s][1], e[s + 1][0], e[s + 1][1], r))
      return t && i.push(...Ec(e[n - 1][0], e[n - 1][1], e[0][0], e[0][1], r)), { type: 'path', ops: i }
    }
    return n === 2 ? OV(e[0][0], e[0][1], e[1][0], e[1][1], r) : { type: 'path', ops: [] }
  }
  function Sbt(e, t, r, n, i) {
    return (function (s, o) {
      return Pb(s, !0, o)
    })(
      [
        [e, t],
        [e + r, t],
        [e + r, t + n],
        [e, t + n],
      ],
      i,
    )
  }
  function wV(e, t) {
    if (e.length) {
      let r = typeof e[0][0] == 'number' ? [e] : e,
        n = Mb(r[0], 1 * (1 + 0.2 * t.roughness), t),
        i = t.disableMultiStroke ? [] : Mb(r[0], 1.5 * (1 + 0.22 * t.roughness), AV(t))
      for (let s = 1; s < r.length; s++) {
        let o = r[s]
        if (o.length) {
          let l = Mb(o, 1 * (1 + 0.2 * t.roughness), t),
            u = t.disableMultiStroke ? [] : Mb(o, 1.5 * (1 + 0.22 * t.roughness), AV(t))
          for (let h of l) h.op !== 'move' && n.push(h)
          for (let h of u) h.op !== 'move' && i.push(h)
        }
      }
      return { type: 'path', ops: n.concat(i) }
    }
    return { type: 'path', ops: [] }
  }
  function PV(e, t, r) {
    let n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2)),
      i = Math.ceil(Math.max(r.curveStepCount, (r.curveStepCount / Math.sqrt(200)) * n)),
      s = (2 * Math.PI) / i,
      o = Math.abs(e / 2),
      l = Math.abs(t / 2),
      u = 1 - r.curveFitting
    return (o += we(o * u, r)), (l += we(l * u, r)), { increment: s, rx: o, ry: l }
  }
  function _A(e, t, r, n) {
    let [i, s] = LV(n.increment, e, t, n.rx, n.ry, 1, n.increment * Fb(0.1, Fb(0.4, 1, r), r), r),
      o = $b(i, null, r)
    if (!r.disableMultiStroke && r.roughness !== 0) {
      let [l] = LV(n.increment, e, t, n.rx, n.ry, 1.5, 0, r),
        u = $b(l, null, r)
      o = o.concat(u)
    }
    return { estimatedPoints: s, opset: { type: 'path', ops: o } }
  }
  function EV(e, t, r, n, i, s, o, l, u) {
    let h = e,
      f = t,
      d = Math.abs(r / 2),
      p = Math.abs(n / 2)
    ;(d += we(0.01 * d, u)), (p += we(0.01 * p, u))
    let m = i,
      g = s
    for (; m < 0; ) (m += 2 * Math.PI), (g += 2 * Math.PI)
    g - m > 2 * Math.PI && ((m = 0), (g = 2 * Math.PI))
    let y = (2 * Math.PI) / u.curveStepCount,
      b = Math.min(y / 2, (g - m) / 2),
      k = RV(b, h, f, d, p, m, g, 1, u)
    if (!u.disableMultiStroke) {
      let T = RV(b, h, f, d, p, m, g, 1.5, u)
      k.push(...T)
    }
    return (
      o &&
        (l
          ? k.push(
              ...Ec(h, f, h + d * Math.cos(m), f + p * Math.sin(m), u),
              ...Ec(h, f, h + d * Math.cos(g), f + p * Math.sin(g), u),
            )
          : k.push({ op: 'lineTo', data: [h, f] }, { op: 'lineTo', data: [h + d * Math.cos(m), f + p * Math.sin(m)] })),
      { type: 'path', ops: k }
    )
  }
  function vV(e, t) {
    let r = IV(NV(AA(e))),
      n = [],
      i = [0, 0],
      s = [0, 0]
    for (let { key: o, data: l } of r)
      switch (o) {
        case 'M':
          ;(s = [l[0], l[1]]), (i = [l[0], l[1]])
          break
        case 'L':
          n.push(...Ec(s[0], s[1], l[0], l[1], t)), (s = [l[0], l[1]])
          break
        case 'C': {
          let [u, h, f, d, p, m] = l
          n.push(..._bt(u, h, f, d, p, m, s, t)), (s = [p, m])
          break
        }
        case 'Z':
          n.push(...Ec(s[0], s[1], i[0], i[1], t)), (s = [i[0], i[1]])
      }
    return { type: 'path', ops: n }
  }
  function mA(e, t) {
    let r = []
    for (let n of e)
      if (n.length) {
        let i = t.maxRandomnessOffset || 0,
          s = n.length
        if (s > 2) {
          r.push({ op: 'move', data: [n[0][0] + we(i, t), n[0][1] + we(i, t)] })
          for (let o = 1; o < s; o++) r.push({ op: 'lineTo', data: [n[o][0] + we(i, t), n[o][1] + we(i, t)] })
        }
      }
    return { type: 'fillPath', ops: r }
  }
  function cd(e, t) {
    return (function (r, n) {
      let i = r.fillStyle || 'hachure'
      if (!ls[i])
        switch (i) {
          case 'zigzag':
            ls[i] || (ls[i] = new yA(n))
            break
          case 'cross-hatch':
            ls[i] || (ls[i] = new xA(n))
            break
          case 'dots':
            ls[i] || (ls[i] = new bA(n))
            break
          case 'dashed':
            ls[i] || (ls[i] = new kA(n))
            break
          case 'zigzag-line':
            ls[i] || (ls[i] = new TA(n))
            break
          default:
            ;(i = 'hachure'), ls[i] || (ls[i] = new O0(n))
        }
      return ls[i]
    })(t, Tbt).fillPolygons(e, t)
  }
  function AV(e) {
    let t = Object.assign({}, e)
    return (t.randomizer = void 0), e.seed && (t.seed = e.seed + 1), t
  }
  function BV(e) {
    return e.randomizer || (e.randomizer = new SA(e.seed || 0)), e.randomizer.next()
  }
  function Fb(e, t, r, n = 1) {
    return r.roughness * n * (BV(r) * (t - e) + e)
  }
  function we(e, t, r = 1) {
    return Fb(-e, e, t, r)
  }
  function Ec(e, t, r, n, i, s = !1) {
    let o = s ? i.disableMultiStrokeFill : i.disableMultiStroke,
      l = CA(e, t, r, n, i, !0, !1)
    if (o) return l
    let u = CA(e, t, r, n, i, !0, !0)
    return l.concat(u)
  }
  function CA(e, t, r, n, i, s, o) {
    let l = Math.pow(e - r, 2) + Math.pow(t - n, 2),
      u = Math.sqrt(l),
      h = 1
    h = u < 200 ? 1 : u > 500 ? 0.4 : -0.0016668 * u + 1.233334
    let f = i.maxRandomnessOffset || 0
    f * f * 100 > l && (f = u / 10)
    let d = f / 2,
      p = 0.2 + 0.2 * BV(i),
      m = (i.bowing * i.maxRandomnessOffset * (n - t)) / 200,
      g = (i.bowing * i.maxRandomnessOffset * (e - r)) / 200
    ;(m = we(m, i, h)), (g = we(g, i, h))
    let y = [],
      b = a(() => we(d, i, h), 'M'),
      k = a(() => we(f, i, h), 'k'),
      T = i.preserveVertices
    return (
      s &&
        (o
          ? y.push({ op: 'move', data: [e + (T ? 0 : b()), t + (T ? 0 : b())] })
          : y.push({ op: 'move', data: [e + (T ? 0 : we(f, i, h)), t + (T ? 0 : we(f, i, h))] })),
      o
        ? y.push({
            op: 'bcurveTo',
            data: [
              m + e + (r - e) * p + b(),
              g + t + (n - t) * p + b(),
              m + e + 2 * (r - e) * p + b(),
              g + t + 2 * (n - t) * p + b(),
              r + (T ? 0 : b()),
              n + (T ? 0 : b()),
            ],
          })
        : y.push({
            op: 'bcurveTo',
            data: [
              m + e + (r - e) * p + k(),
              g + t + (n - t) * p + k(),
              m + e + 2 * (r - e) * p + k(),
              g + t + 2 * (n - t) * p + k(),
              r + (T ? 0 : k()),
              n + (T ? 0 : k()),
            ],
          }),
      y
    )
  }
  function Mb(e, t, r) {
    if (!e.length) return []
    let n = []
    n.push([e[0][0] + we(t, r), e[0][1] + we(t, r)]), n.push([e[0][0] + we(t, r), e[0][1] + we(t, r)])
    for (let i = 1; i < e.length; i++)
      n.push([e[i][0] + we(t, r), e[i][1] + we(t, r)]),
        i === e.length - 1 && n.push([e[i][0] + we(t, r), e[i][1] + we(t, r)])
    return $b(n, null, r)
  }
  function $b(e, t, r) {
    let n = e.length,
      i = []
    if (n > 3) {
      let s = [],
        o = 1 - r.curveTightness
      i.push({ op: 'move', data: [e[1][0], e[1][1]] })
      for (let l = 1; l + 2 < n; l++) {
        let u = e[l]
        ;(s[0] = [u[0], u[1]]),
          (s[1] = [u[0] + (o * e[l + 1][0] - o * e[l - 1][0]) / 6, u[1] + (o * e[l + 1][1] - o * e[l - 1][1]) / 6]),
          (s[2] = [
            e[l + 1][0] + (o * e[l][0] - o * e[l + 2][0]) / 6,
            e[l + 1][1] + (o * e[l][1] - o * e[l + 2][1]) / 6,
          ]),
          (s[3] = [e[l + 1][0], e[l + 1][1]]),
          i.push({ op: 'bcurveTo', data: [s[1][0], s[1][1], s[2][0], s[2][1], s[3][0], s[3][1]] })
      }
      if (t && t.length === 2) {
        let l = r.maxRandomnessOffset
        i.push({ op: 'lineTo', data: [t[0] + we(l, r), t[1] + we(l, r)] })
      }
    } else
      n === 3
        ? (i.push({ op: 'move', data: [e[1][0], e[1][1]] }),
          i.push({ op: 'bcurveTo', data: [e[1][0], e[1][1], e[2][0], e[2][1], e[2][0], e[2][1]] }))
        : n === 2 && i.push(...CA(e[0][0], e[0][1], e[1][0], e[1][1], r, !0, !0))
    return i
  }
  function LV(e, t, r, n, i, s, o, l) {
    let u = [],
      h = []
    if (l.roughness === 0) {
      ;(e /= 4), h.push([t + n * Math.cos(-e), r + i * Math.sin(-e)])
      for (let f = 0; f <= 2 * Math.PI; f += e) {
        let d = [t + n * Math.cos(f), r + i * Math.sin(f)]
        u.push(d), h.push(d)
      }
      h.push([t + n * Math.cos(0), r + i * Math.sin(0)]), h.push([t + n * Math.cos(e), r + i * Math.sin(e)])
    } else {
      let f = we(0.5, l) - Math.PI / 2
      h.push([we(s, l) + t + 0.9 * n * Math.cos(f - e), we(s, l) + r + 0.9 * i * Math.sin(f - e)])
      let d = 2 * Math.PI + f - 0.01
      for (let p = f; p < d; p += e) {
        let m = [we(s, l) + t + n * Math.cos(p), we(s, l) + r + i * Math.sin(p)]
        u.push(m), h.push(m)
      }
      h.push([
        we(s, l) + t + n * Math.cos(f + 2 * Math.PI + 0.5 * o),
        we(s, l) + r + i * Math.sin(f + 2 * Math.PI + 0.5 * o),
      ]),
        h.push([we(s, l) + t + 0.98 * n * Math.cos(f + o), we(s, l) + r + 0.98 * i * Math.sin(f + o)]),
        h.push([we(s, l) + t + 0.9 * n * Math.cos(f + 0.5 * o), we(s, l) + r + 0.9 * i * Math.sin(f + 0.5 * o)])
    }
    return [h, u]
  }
  function RV(e, t, r, n, i, s, o, l, u) {
    let h = s + we(0.1, u),
      f = []
    f.push([we(l, u) + t + 0.9 * n * Math.cos(h - e), we(l, u) + r + 0.9 * i * Math.sin(h - e)])
    for (let d = h; d <= o; d += e) f.push([we(l, u) + t + n * Math.cos(d), we(l, u) + r + i * Math.sin(d)])
    return (
      f.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
      f.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
      $b(f, null, u)
    )
  }
  function _bt(e, t, r, n, i, s, o, l) {
    let u = [],
      h = [l.maxRandomnessOffset || 1, (l.maxRandomnessOffset || 1) + 0.3],
      f = [0, 0],
      d = l.disableMultiStroke ? 1 : 2,
      p = l.preserveVertices
    for (let m = 0; m < d; m++)
      m === 0
        ? u.push({ op: 'move', data: [o[0], o[1]] })
        : u.push({ op: 'move', data: [o[0] + (p ? 0 : we(h[0], l)), o[1] + (p ? 0 : we(h[0], l))] }),
        (f = p ? [i, s] : [i + we(h[m], l), s + we(h[m], l)]),
        u.push({
          op: 'bcurveTo',
          data: [e + we(h[m], l), t + we(h[m], l), r + we(h[m], l), n + we(h[m], l), f[0], f[1]],
        })
    return u
  }
  function M0(e) {
    return [...e]
  }
  function DV(e, t = 0) {
    let r = e.length
    if (r < 3) throw new Error('A curve must have at least three points.')
    let n = []
    if (r === 3) n.push(M0(e[0]), M0(e[1]), M0(e[2]), M0(e[2]))
    else {
      let i = []
      i.push(e[0], e[0])
      for (let l = 1; l < e.length; l++) i.push(e[l]), l === e.length - 1 && i.push(e[l])
      let s = [],
        o = 1 - t
      n.push(M0(i[0]))
      for (let l = 1; l + 2 < i.length; l++) {
        let u = i[l]
        ;(s[0] = [u[0], u[1]]),
          (s[1] = [u[0] + (o * i[l + 1][0] - o * i[l - 1][0]) / 6, u[1] + (o * i[l + 1][1] - o * i[l - 1][1]) / 6]),
          (s[2] = [
            i[l + 1][0] + (o * i[l][0] - o * i[l + 2][0]) / 6,
            i[l + 1][1] + (o * i[l][1] - o * i[l + 2][1]) / 6,
          ]),
          (s[3] = [i[l + 1][0], i[l + 1][1]]),
          n.push(s[1], s[2], s[3])
      }
    }
    return n
  }
  function Bb(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2)
  }
  function Cbt(e, t, r) {
    let n = Bb(t, r)
    if (n === 0) return Bb(e, t)
    let i = ((e[0] - t[0]) * (r[0] - t[0]) + (e[1] - t[1]) * (r[1] - t[1])) / n
    return (i = Math.max(0, Math.min(1, i))), Bb(e, th(t, r, i))
  }
  function th(e, t, r) {
    return [e[0] + (t[0] - e[0]) * r, e[1] + (t[1] - e[1]) * r]
  }
  function wA(e, t, r, n) {
    let i = n || []
    if (
      (function (l, u) {
        let h = l[u + 0],
          f = l[u + 1],
          d = l[u + 2],
          p = l[u + 3],
          m = 3 * f[0] - 2 * h[0] - p[0]
        m *= m
        let g = 3 * f[1] - 2 * h[1] - p[1]
        g *= g
        let y = 3 * d[0] - 2 * p[0] - h[0]
        y *= y
        let b = 3 * d[1] - 2 * p[1] - h[1]
        return (b *= b), m < y && (m = y), g < b && (g = b), m + g
      })(e, t) < r
    ) {
      let l = e[t + 0]
      i.length ? ((s = i[i.length - 1]), (o = l), Math.sqrt(Bb(s, o)) > 1 && i.push(l)) : i.push(l), i.push(e[t + 3])
    } else {
      let u = e[t + 0],
        h = e[t + 1],
        f = e[t + 2],
        d = e[t + 3],
        p = th(u, h, 0.5),
        m = th(h, f, 0.5),
        g = th(f, d, 0.5),
        y = th(p, m, 0.5),
        b = th(m, g, 0.5),
        k = th(y, b, 0.5)
      wA([u, p, y, k], 0, r, i), wA([k, b, g, d], 0, r, i)
    }
    var s, o
    return i
  }
  function wbt(e, t) {
    return Gb(e, 0, e.length, t)
  }
  function Gb(e, t, r, n, i) {
    let s = i || [],
      o = e[t],
      l = e[r - 1],
      u = 0,
      h = 1
    for (let f = t + 1; f < r - 1; ++f) {
      let d = Cbt(e[f], o, l)
      d > u && ((u = d), (h = f))
    }
    return Math.sqrt(u) > n ? (Gb(e, t, h + 1, n, s), Gb(e, h, r, n, s)) : (s.length || s.push(o), s.push(l)), s
  }
  function gA(e, t = 0.15, r) {
    let n = [],
      i = (e.length - 1) / 3
    for (let s = 0; s < i; s++) wA(e, 3 * s, t, n)
    return r && r > 0 ? Gb(n, 0, n.length, r) : n
  }
  var O0,
    yA,
    xA,
    bA,
    kA,
    TA,
    ls,
    SA,
    kbt,
    dA,
    CV,
    Ib,
    Tbt,
    Rs,
    ud,
    EA,
    Ob,
    vA,
    wt,
    oe = x(() => {
      'use strict'
      a(fA, 't')
      a(xbt, 'e')
      a(bbt, 's')
      a(P0, 'n')
      O0 = class {
        static {
          a(this, 'o')
        }
        constructor(t) {
          this.helper = t
        }
        fillPolygons(t, r) {
          return this._fillPolygons(t, r)
        }
        _fillPolygons(t, r) {
          let n = P0(t, r)
          return { type: 'fillSketch', ops: this.renderLines(n, r) }
        }
        renderLines(t, r) {
          let n = []
          for (let i of t) n.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], r))
          return n
        }
      }
      a(Vb, 'a')
      ;(yA = class extends O0 {
        static {
          a(this, 'h')
        }
        fillPolygons(t, r) {
          let n = r.hachureGap
          n < 0 && (n = 4 * r.strokeWidth), (n = Math.max(n, 0.1))
          let i = P0(t, Object.assign({}, r, { hachureGap: n })),
            s = (Math.PI / 180) * r.hachureAngle,
            o = [],
            l = 0.5 * n * Math.cos(s),
            u = 0.5 * n * Math.sin(s)
          for (let [h, f] of i) Vb([h, f]) && o.push([[h[0] - l, h[1] + u], [...f]], [[h[0] + l, h[1] - u], [...f]])
          return { type: 'fillSketch', ops: this.renderLines(o, r) }
        }
      }),
        (xA = class extends O0 {
          static {
            a(this, 'r')
          }
          fillPolygons(t, r) {
            let n = this._fillPolygons(t, r),
              i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }),
              s = this._fillPolygons(t, i)
            return (n.ops = n.ops.concat(s.ops)), n
          }
        }),
        (bA = class {
          static {
            a(this, 'i')
          }
          constructor(t) {
            this.helper = t
          }
          fillPolygons(t, r) {
            let n = P0(t, (r = Object.assign({}, r, { hachureAngle: 0 })))
            return this.dotsOnLines(n, r)
          }
          dotsOnLines(t, r) {
            let n = [],
              i = r.hachureGap
            i < 0 && (i = 4 * r.strokeWidth), (i = Math.max(i, 0.1))
            let s = r.fillWeight
            s < 0 && (s = r.strokeWidth / 2)
            let o = i / 4
            for (let l of t) {
              let u = Vb(l),
                h = u / i,
                f = Math.ceil(h) - 1,
                d = u - f * i,
                p = (l[0][0] + l[1][0]) / 2 - i / 4,
                m = Math.min(l[0][1], l[1][1])
              for (let g = 0; g < f; g++) {
                let y = m + d + g * i,
                  b = p - o + 2 * Math.random() * o,
                  k = y - o + 2 * Math.random() * o,
                  T = this.helper.ellipse(b, k, s, s, r)
                n.push(...T.ops)
              }
            }
            return { type: 'fillSketch', ops: n }
          }
        }),
        (kA = class {
          static {
            a(this, 'c')
          }
          constructor(t) {
            this.helper = t
          }
          fillPolygons(t, r) {
            let n = P0(t, r)
            return { type: 'fillSketch', ops: this.dashedLine(n, r) }
          }
          dashedLine(t, r) {
            let n = r.dashOffset < 0 ? (r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap) : r.dashOffset,
              i = r.dashGap < 0 ? (r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap) : r.dashGap,
              s = []
            return (
              t.forEach((o) => {
                let l = Vb(o),
                  u = Math.floor(l / (n + i)),
                  h = (l + i - u * (n + i)) / 2,
                  f = o[0],
                  d = o[1]
                f[0] > d[0] && ((f = o[1]), (d = o[0]))
                let p = Math.atan((d[1] - f[1]) / (d[0] - f[0]))
                for (let m = 0; m < u; m++) {
                  let g = m * (n + i),
                    y = g + n,
                    b = [f[0] + g * Math.cos(p) + h * Math.cos(p), f[1] + g * Math.sin(p) + h * Math.sin(p)],
                    k = [f[0] + y * Math.cos(p) + h * Math.cos(p), f[1] + y * Math.sin(p) + h * Math.sin(p)]
                  s.push(...this.helper.doubleLineOps(b[0], b[1], k[0], k[1], r))
                }
              }),
              s
            )
          }
        }),
        (TA = class {
          static {
            a(this, 'l')
          }
          constructor(t) {
            this.helper = t
          }
          fillPolygons(t, r) {
            let n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap,
              i = r.zigzagOffset < 0 ? n : r.zigzagOffset,
              s = P0(t, (r = Object.assign({}, r, { hachureGap: n + i })))
            return { type: 'fillSketch', ops: this.zigzagLines(s, i, r) }
          }
          zigzagLines(t, r, n) {
            let i = []
            return (
              t.forEach((s) => {
                let o = Vb(s),
                  l = Math.round(o / (2 * r)),
                  u = s[0],
                  h = s[1]
                u[0] > h[0] && ((u = s[1]), (h = s[0]))
                let f = Math.atan((h[1] - u[1]) / (h[0] - u[0]))
                for (let d = 0; d < l; d++) {
                  let p = 2 * d * r,
                    m = 2 * (d + 1) * r,
                    g = Math.sqrt(2 * Math.pow(r, 2)),
                    y = [u[0] + p * Math.cos(f), u[1] + p * Math.sin(f)],
                    b = [u[0] + m * Math.cos(f), u[1] + m * Math.sin(f)],
                    k = [y[0] + g * Math.cos(f + Math.PI / 4), y[1] + g * Math.sin(f + Math.PI / 4)]
                  i.push(
                    ...this.helper.doubleLineOps(y[0], y[1], k[0], k[1], n),
                    ...this.helper.doubleLineOps(k[0], k[1], b[0], b[1], n),
                  )
                }
              }),
              i
            )
          }
        }),
        (ls = {}),
        (SA = class {
          static {
            a(this, 'p')
          }
          constructor(t) {
            this.seed = t
          }
          next() {
            return this.seed ? ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random()
          }
        }),
        (kbt = 0),
        (dA = 1),
        (CV = 2),
        (Ib = {
          A: 7,
          a: 7,
          C: 6,
          c: 6,
          H: 1,
          h: 1,
          L: 2,
          l: 2,
          M: 2,
          m: 2,
          Q: 4,
          q: 4,
          S: 4,
          s: 4,
          T: 2,
          t: 2,
          V: 1,
          v: 1,
          Z: 0,
          z: 0,
        })
      a(pA, 'k')
      a(AA, 'b')
      a(NV, 'y')
      a(IV, 'm')
      a(I0, 'w')
      a(MV, 'x')
      Tbt = {
        randOffset: a(function (e, t) {
          return we(e, t)
        }, 'randOffset'),
        randOffsetWithRange: a(function (e, t, r) {
          return Fb(e, t, r)
        }, 'randOffsetWithRange'),
        ellipse: a(function (e, t, r, n, i) {
          let s = PV(r, n, i)
          return _A(e, t, i, s).opset
        }, 'ellipse'),
        doubleLineOps: a(function (e, t, r, n, i) {
          return Ec(e, t, r, n, i, !0)
        }, 'doubleLineOps'),
      }
      a(OV, 'v')
      a(Pb, 'S')
      a(Sbt, 'O')
      a(wV, 'L')
      a(PV, 'T')
      a(_A, 'D')
      a(EV, 'A')
      a(vV, '_')
      a(mA, 'I')
      a(cd, 'C')
      a(AV, 'z')
      a(BV, 'W')
      a(Fb, 'E')
      a(we, 'G')
      a(Ec, '$')
      a(CA, 'R')
      a(Mb, 'j')
      a($b, 'q')
      a(LV, 'F')
      a(RV, 'V')
      a(_bt, 'Z')
      a(M0, 'Q')
      a(DV, 'H')
      a(Bb, 'N')
      a(Cbt, 'B')
      a(th, 'J')
      a(wA, 'K')
      a(wbt, 'U')
      a(Gb, 'X')
      a(gA, 'Y')
      ;(Rs = 'none'),
        (ud = class {
          static {
            a(this, 'et')
          }
          constructor(t) {
            ;(this.defaultOptions = {
              maxRandomnessOffset: 2,
              roughness: 1,
              bowing: 1,
              stroke: '#000',
              strokeWidth: 1,
              curveTightness: 0,
              curveFitting: 0.95,
              curveStepCount: 9,
              fillStyle: 'hachure',
              fillWeight: -1,
              hachureAngle: -41,
              hachureGap: -1,
              dashOffset: -1,
              dashGap: -1,
              zigzagOffset: -1,
              seed: 0,
              disableMultiStroke: !1,
              disableMultiStrokeFill: !1,
              preserveVertices: !1,
              fillShapeRoughnessGain: 0.8,
            }),
              (this.config = t || {}),
              this.config.options && (this.defaultOptions = this._o(this.config.options))
          }
          static newSeed() {
            return Math.floor(Math.random() * 2 ** 31)
          }
          _o(t) {
            return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions
          }
          _d(t, r, n) {
            return { shape: t, sets: r || [], options: n || this.defaultOptions }
          }
          line(t, r, n, i, s) {
            let o = this._o(s)
            return this._d('line', [OV(t, r, n, i, o)], o)
          }
          rectangle(t, r, n, i, s) {
            let o = this._o(s),
              l = [],
              u = Sbt(t, r, n, i, o)
            if (o.fill) {
              let h = [
                [t, r],
                [t + n, r],
                [t + n, r + i],
                [t, r + i],
              ]
              o.fillStyle === 'solid' ? l.push(mA([h], o)) : l.push(cd([h], o))
            }
            return o.stroke !== Rs && l.push(u), this._d('rectangle', l, o)
          }
          ellipse(t, r, n, i, s) {
            let o = this._o(s),
              l = [],
              u = PV(n, i, o),
              h = _A(t, r, o, u)
            if (o.fill)
              if (o.fillStyle === 'solid') {
                let f = _A(t, r, o, u).opset
                ;(f.type = 'fillPath'), l.push(f)
              } else l.push(cd([h.estimatedPoints], o))
            return o.stroke !== Rs && l.push(h.opset), this._d('ellipse', l, o)
          }
          circle(t, r, n, i) {
            let s = this.ellipse(t, r, n, n, i)
            return (s.shape = 'circle'), s
          }
          linearPath(t, r) {
            let n = this._o(r)
            return this._d('linearPath', [Pb(t, !1, n)], n)
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this._o(u),
              f = [],
              d = EV(t, r, n, i, s, o, l, !0, h)
            if (l && h.fill)
              if (h.fillStyle === 'solid') {
                let p = Object.assign({}, h)
                p.disableMultiStroke = !0
                let m = EV(t, r, n, i, s, o, !0, !1, p)
                ;(m.type = 'fillPath'), f.push(m)
              } else
                f.push(
                  (function (p, m, g, y, b, k, T) {
                    let C = p,
                      A = m,
                      w = Math.abs(g / 2),
                      D = Math.abs(y / 2)
                    ;(w += we(0.01 * w, T)), (D += we(0.01 * D, T))
                    let G = b,
                      v = k
                    for (; G < 0; ) (G += 2 * Math.PI), (v += 2 * Math.PI)
                    v - G > 2 * Math.PI && ((G = 0), (v = 2 * Math.PI))
                    let R = (v - G) / T.curveStepCount,
                      F = []
                    for (let S = G; S <= v; S += R) F.push([C + w * Math.cos(S), A + D * Math.sin(S)])
                    return F.push([C + w * Math.cos(v), A + D * Math.sin(v)]), F.push([C, A]), cd([F], T)
                  })(t, r, n, i, s, o, h),
                )
            return h.stroke !== Rs && f.push(d), this._d('arc', f, h)
          }
          curve(t, r) {
            let n = this._o(r),
              i = [],
              s = wV(t, n)
            if (n.fill && n.fill !== Rs)
              if (n.fillStyle === 'solid') {
                let o = wV(
                  t,
                  Object.assign(Object.assign({}, n), {
                    disableMultiStroke: !0,
                    roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0,
                  }),
                )
                i.push({ type: 'fillPath', ops: this._mergedShape(o.ops) })
              } else {
                let o = [],
                  l = t
                if (l.length) {
                  let u = typeof l[0][0] == 'number' ? [l] : l
                  for (let h of u)
                    h.length < 3
                      ? o.push(...h)
                      : h.length === 3
                        ? o.push(...gA(DV([h[0], h[0], h[1], h[2]]), 10, (1 + n.roughness) / 2))
                        : o.push(...gA(DV(h), 10, (1 + n.roughness) / 2))
                }
                o.length && i.push(cd([o], n))
              }
            return n.stroke !== Rs && i.push(s), this._d('curve', i, n)
          }
          polygon(t, r) {
            let n = this._o(r),
              i = [],
              s = Pb(t, !0, n)
            return (
              n.fill && (n.fillStyle === 'solid' ? i.push(mA([t], n)) : i.push(cd([t], n))),
              n.stroke !== Rs && i.push(s),
              this._d('polygon', i, n)
            )
          }
          path(t, r) {
            let n = this._o(r),
              i = []
            if (!t) return this._d('path', i, n)
            t = (t || '').replace(/\n/g, ' ').replace(/(-\s)/g, '-').replace('/(ss)/g', ' ')
            let s = n.fill && n.fill !== 'transparent' && n.fill !== Rs,
              o = n.stroke !== Rs,
              l = !!(n.simplification && n.simplification < 1),
              u = (function (f, d, p) {
                let m = IV(NV(AA(f))),
                  g = [],
                  y = [],
                  b = [0, 0],
                  k = [],
                  T = a(() => {
                    k.length >= 4 && y.push(...gA(k, d)), (k = [])
                  }, 'i'),
                  C = a(() => {
                    T(), y.length && (g.push(y), (y = []))
                  }, 'c')
                for (let { key: w, data: D } of m)
                  switch (w) {
                    case 'M':
                      C(), (b = [D[0], D[1]]), y.push(b)
                      break
                    case 'L':
                      T(), y.push([D[0], D[1]])
                      break
                    case 'C':
                      if (!k.length) {
                        let G = y.length ? y[y.length - 1] : b
                        k.push([G[0], G[1]])
                      }
                      k.push([D[0], D[1]]), k.push([D[2], D[3]]), k.push([D[4], D[5]])
                      break
                    case 'Z':
                      T(), y.push([b[0], b[1]])
                  }
                if ((C(), !p)) return g
                let A = []
                for (let w of g) {
                  let D = wbt(w, p)
                  D.length && A.push(D)
                }
                return A
              })(t, 1, l ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2),
              h = vV(t, n)
            if (s)
              if (n.fillStyle === 'solid')
                if (u.length === 1) {
                  let f = vV(
                    t,
                    Object.assign(Object.assign({}, n), {
                      disableMultiStroke: !0,
                      roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0,
                    }),
                  )
                  i.push({ type: 'fillPath', ops: this._mergedShape(f.ops) })
                } else i.push(mA(u, n))
              else i.push(cd(u, n))
            return (
              o &&
                (l
                  ? u.forEach((f) => {
                      i.push(Pb(f, !1, n))
                    })
                  : i.push(h)),
              this._d('path', i, n)
            )
          }
          opsToPath(t, r) {
            let n = ''
            for (let i of t.ops) {
              let s = typeof r == 'number' && r >= 0 ? i.data.map((o) => +o.toFixed(r)) : i.data
              switch (i.op) {
                case 'move':
                  n += `M${s[0]} ${s[1]} `
                  break
                case 'bcurveTo':
                  n += `C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `
                  break
                case 'lineTo':
                  n += `L${s[0]} ${s[1]} `
              }
            }
            return n.trim()
          }
          toPaths(t) {
            let r = t.sets || [],
              n = t.options || this.defaultOptions,
              i = []
            for (let s of r) {
              let o = null
              switch (s.type) {
                case 'path':
                  o = { d: this.opsToPath(s), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: Rs }
                  break
                case 'fillPath':
                  o = { d: this.opsToPath(s), stroke: Rs, strokeWidth: 0, fill: n.fill || Rs }
                  break
                case 'fillSketch':
                  o = this.fillSketch(s, n)
              }
              o && i.push(o)
            }
            return i
          }
          fillSketch(t, r) {
            let n = r.fillWeight
            return (
              n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(t), stroke: r.fill || Rs, strokeWidth: n, fill: Rs }
            )
          }
          _mergedShape(t) {
            return t.filter((r, n) => n === 0 || r.op !== 'move')
          }
        }),
        (EA = class {
          static {
            a(this, 'st')
          }
          constructor(t, r) {
            ;(this.canvas = t), (this.ctx = this.canvas.getContext('2d')), (this.gen = new ud(r))
          }
          draw(t) {
            let r = t.sets || [],
              n = t.options || this.getDefaultOptions(),
              i = this.ctx,
              s = t.options.fixedDecimalPlaceDigits
            for (let o of r)
              switch (o.type) {
                case 'path':
                  i.save(),
                    (i.strokeStyle = n.stroke === 'none' ? 'transparent' : n.stroke),
                    (i.lineWidth = n.strokeWidth),
                    n.strokeLineDash && i.setLineDash(n.strokeLineDash),
                    n.strokeLineDashOffset && (i.lineDashOffset = n.strokeLineDashOffset),
                    this._drawToContext(i, o, s),
                    i.restore()
                  break
                case 'fillPath': {
                  i.save(), (i.fillStyle = n.fill || '')
                  let l = t.shape === 'curve' || t.shape === 'polygon' || t.shape === 'path' ? 'evenodd' : 'nonzero'
                  this._drawToContext(i, o, s, l), i.restore()
                  break
                }
                case 'fillSketch':
                  this.fillSketch(i, o, n)
              }
          }
          fillSketch(t, r, n) {
            let i = n.fillWeight
            i < 0 && (i = n.strokeWidth / 2),
              t.save(),
              n.fillLineDash && t.setLineDash(n.fillLineDash),
              n.fillLineDashOffset && (t.lineDashOffset = n.fillLineDashOffset),
              (t.strokeStyle = n.fill || ''),
              (t.lineWidth = i),
              this._drawToContext(t, r, n.fixedDecimalPlaceDigits),
              t.restore()
          }
          _drawToContext(t, r, n, i = 'nonzero') {
            t.beginPath()
            for (let s of r.ops) {
              let o = typeof n == 'number' && n >= 0 ? s.data.map((l) => +l.toFixed(n)) : s.data
              switch (s.op) {
                case 'move':
                  t.moveTo(o[0], o[1])
                  break
                case 'bcurveTo':
                  t.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5])
                  break
                case 'lineTo':
                  t.lineTo(o[0], o[1])
              }
            }
            r.type === 'fillPath' ? t.fill(i) : t.stroke()
          }
          get generator() {
            return this.gen
          }
          getDefaultOptions() {
            return this.gen.defaultOptions
          }
          line(t, r, n, i, s) {
            let o = this.gen.line(t, r, n, i, s)
            return this.draw(o), o
          }
          rectangle(t, r, n, i, s) {
            let o = this.gen.rectangle(t, r, n, i, s)
            return this.draw(o), o
          }
          ellipse(t, r, n, i, s) {
            let o = this.gen.ellipse(t, r, n, i, s)
            return this.draw(o), o
          }
          circle(t, r, n, i) {
            let s = this.gen.circle(t, r, n, i)
            return this.draw(s), s
          }
          linearPath(t, r) {
            let n = this.gen.linearPath(t, r)
            return this.draw(n), n
          }
          polygon(t, r) {
            let n = this.gen.polygon(t, r)
            return this.draw(n), n
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this.gen.arc(t, r, n, i, s, o, l, u)
            return this.draw(h), h
          }
          curve(t, r) {
            let n = this.gen.curve(t, r)
            return this.draw(n), n
          }
          path(t, r) {
            let n = this.gen.path(t, r)
            return this.draw(n), n
          }
        }),
        (Ob = 'http://www.w3.org/2000/svg'),
        (vA = class {
          static {
            a(this, 'ot')
          }
          constructor(t, r) {
            ;(this.svg = t), (this.gen = new ud(r))
          }
          draw(t) {
            let r = t.sets || [],
              n = t.options || this.getDefaultOptions(),
              i = this.svg.ownerDocument || window.document,
              s = i.createElementNS(Ob, 'g'),
              o = t.options.fixedDecimalPlaceDigits
            for (let l of r) {
              let u = null
              switch (l.type) {
                case 'path':
                  ;(u = i.createElementNS(Ob, 'path')),
                    u.setAttribute('d', this.opsToPath(l, o)),
                    u.setAttribute('stroke', n.stroke),
                    u.setAttribute('stroke-width', n.strokeWidth + ''),
                    u.setAttribute('fill', 'none'),
                    n.strokeLineDash && u.setAttribute('stroke-dasharray', n.strokeLineDash.join(' ').trim()),
                    n.strokeLineDashOffset && u.setAttribute('stroke-dashoffset', `${n.strokeLineDashOffset}`)
                  break
                case 'fillPath':
                  ;(u = i.createElementNS(Ob, 'path')),
                    u.setAttribute('d', this.opsToPath(l, o)),
                    u.setAttribute('stroke', 'none'),
                    u.setAttribute('stroke-width', '0'),
                    u.setAttribute('fill', n.fill || ''),
                    (t.shape !== 'curve' && t.shape !== 'polygon') || u.setAttribute('fill-rule', 'evenodd')
                  break
                case 'fillSketch':
                  u = this.fillSketch(i, l, n)
              }
              u && s.appendChild(u)
            }
            return s
          }
          fillSketch(t, r, n) {
            let i = n.fillWeight
            i < 0 && (i = n.strokeWidth / 2)
            let s = t.createElementNS(Ob, 'path')
            return (
              s.setAttribute('d', this.opsToPath(r, n.fixedDecimalPlaceDigits)),
              s.setAttribute('stroke', n.fill || ''),
              s.setAttribute('stroke-width', i + ''),
              s.setAttribute('fill', 'none'),
              n.fillLineDash && s.setAttribute('stroke-dasharray', n.fillLineDash.join(' ').trim()),
              n.fillLineDashOffset && s.setAttribute('stroke-dashoffset', `${n.fillLineDashOffset}`),
              s
            )
          }
          get generator() {
            return this.gen
          }
          getDefaultOptions() {
            return this.gen.defaultOptions
          }
          opsToPath(t, r) {
            return this.gen.opsToPath(t, r)
          }
          line(t, r, n, i, s) {
            let o = this.gen.line(t, r, n, i, s)
            return this.draw(o)
          }
          rectangle(t, r, n, i, s) {
            let o = this.gen.rectangle(t, r, n, i, s)
            return this.draw(o)
          }
          ellipse(t, r, n, i, s) {
            let o = this.gen.ellipse(t, r, n, i, s)
            return this.draw(o)
          }
          circle(t, r, n, i) {
            let s = this.gen.circle(t, r, n, i)
            return this.draw(s)
          }
          linearPath(t, r) {
            let n = this.gen.linearPath(t, r)
            return this.draw(n)
          }
          polygon(t, r) {
            let n = this.gen.polygon(t, r)
            return this.draw(n)
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this.gen.arc(t, r, n, i, s, o, l, u)
            return this.draw(h)
          }
          curve(t, r) {
            let n = this.gen.curve(t, r)
            return this.draw(n)
          }
          path(t, r) {
            let n = this.gen.path(t, r)
            return this.draw(n)
          }
        }),
        (wt = {
          canvas: a((e, t) => new EA(e, t), 'canvas'),
          svg: a((e, t) => new vA(e, t), 'svg'),
          generator: a((e) => new ud(e), 'generator'),
          newSeed: a(() => ud.newSeed(), 'newSeed'),
        })
    })
  function FV(e, t) {
    let { labelStyles: r } = St(t)
    t.labelStyle = r
    let n = Ot(t),
      i = n
    n || (i = 'anchor')
    let s = e
        .insert('g')
        .attr('class', i)
        .attr('id', t.domId || t.id),
      o = 1,
      { cssStyles: l } = t,
      u = wt.svg(s),
      h = Et(t, { fill: 'black', stroke: 'none', fillStyle: 'solid' })
    t.look !== 'handDrawn' && (h.roughness = 0)
    let f = u.circle(0, 0, o * 2, h),
      d = s.insert(() => f, ':first-child')
    return (
      d.attr('class', 'anchor').attr('style', Ir(l)),
      Ct(t, d),
      (t.intersect = function (p) {
        return B.info('Circle intersect', t, o, p), Tt.circle(t, o, p)
      }),
      s
    )
  }
  var $V = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    Ce()
    a(FV, 'anchor')
  })
  function GV(e, t, r, n, i, s, o) {
    let u = (e + r) / 2,
      h = (t + n) / 2,
      f = Math.atan2(n - t, r - e),
      d = (r - e) / 2,
      p = (n - t) / 2,
      m = d / i,
      g = p / s,
      y = Math.sqrt(m ** 2 + g ** 2)
    if (y > 1) throw new Error('The given radii are too small to create an arc between the points.')
    let b = Math.sqrt(1 - y ** 2),
      k = u + b * s * Math.sin(f) * (o ? -1 : 1),
      T = h - b * i * Math.cos(f) * (o ? -1 : 1),
      C = Math.atan2((t - T) / s, (e - k) / i),
      w = Math.atan2((n - T) / s, (r - k) / i) - C
    o && w < 0 && (w += 2 * Math.PI), !o && w > 0 && (w -= 2 * Math.PI)
    let D = []
    for (let G = 0; G < 20; G++) {
      let v = G / 19,
        R = C + v * w,
        F = k + i * Math.cos(R),
        S = T + s * Math.sin(R)
      D.push({ x: F, y: S })
    }
    return D
  }
  async function VV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding + 20,
      l = s.height + t.padding,
      u = l / 2,
      h = u / (2.5 + l / 50),
      { cssStyles: f } = t,
      d = [
        { x: o / 2, y: -l / 2 },
        { x: -o / 2, y: -l / 2 },
        ...GV(-o / 2, -l / 2, -o / 2, l / 2, h, u, !1),
        { x: o / 2, y: l / 2 },
        ...GV(o / 2, l / 2, o / 2, -l / 2, h, u, !0),
      ],
      p = wt.svg(i),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = ie(d),
      y = p.path(g, m),
      b = i.insert(() => y, ':first-child')
    return (
      b.attr('class', 'basic label-container'),
      f && t.look !== 'handDrawn' && b.selectAll('path').attr('style', f),
      n && t.look !== 'handDrawn' && b.selectAll('path').attr('style', n),
      b.attr('transform', `translate(${h / 2}, 0)`),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, d, k)
      }),
      i
    )
  }
  var zV = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(GV, 'generateArcPoints')
    a(VV, 'bowTieRect')
  })
  function cs(e, t, r, n) {
    return e
      .insert('polygon', ':first-child')
      .attr(
        'points',
        n
          .map(function (i) {
            return i.x + ',' + i.y
          })
          .join(' '),
      )
      .attr('class', 'label-container')
      .attr('transform', 'translate(' + -t / 2 + ',' + r / 2 + ')')
  }
  var vc = x(() => {
    'use strict'
    a(cs, 'insertPolygonShape')
  })
  async function WV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + t.padding,
      l = 12,
      u = s.width + t.padding + l,
      h = 0,
      f = u,
      d = -o,
      p = 0,
      m = [
        { x: h + l, y: d },
        { x: f, y: d },
        { x: f, y: p },
        { x: h, y: p },
        { x: h, y: d + l },
        { x: h + l, y: d },
      ],
      g,
      { cssStyles: y } = t
    if (t.look === 'handDrawn') {
      let b = wt.svg(i),
        k = Et(t, {}),
        T = ie(m),
        C = b.path(T, k)
      ;(g = i.insert(() => C, ':first-child').attr('transform', `translate(${-u / 2}, ${o / 2})`)),
        y && g.attr('style', y)
    } else g = cs(i, u, o, m)
    return (
      n && g.attr('style', n),
      Ct(t, g),
      (t.intersect = function (b) {
        return Tt.polygon(t, m, b)
      }),
      i
    )
  }
  var UV = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    Qt()
    a(WV, 'card')
  })
  function jV(e, t) {
    let { nodeStyles: r } = St(t)
    t.label = ''
    let n = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId ?? t.id),
      { cssStyles: i } = t,
      s = Math.max(28, t.width ?? 0),
      o = [
        { x: 0, y: s / 2 },
        { x: s / 2, y: 0 },
        { x: 0, y: -s / 2 },
        { x: -s / 2, y: 0 },
      ],
      l = wt.svg(n),
      u = Et(t, {})
    t.look !== 'handDrawn' && ((u.roughness = 0), (u.fillStyle = 'solid'))
    let h = ie(o),
      f = l.path(h, u),
      d = n.insert(() => f, ':first-child')
    return (
      i && t.look !== 'handDrawn' && d.selectAll('path').attr('style', i),
      r && t.look !== 'handDrawn' && d.selectAll('path').attr('style', r),
      (t.width = 28),
      (t.height = 28),
      (t.intersect = function (p) {
        return Tt.polygon(t, o, p)
      }),
      n
    )
  }
  var qV = x(() => {
    'use strict'
    ae()
    oe()
    re()
    Qt()
    a(jV, 'choice')
  })
  async function zb(e, t, r) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    t.labelStyle = n
    let { shapeSvg: s, bbox: o, halfPadding: l } = await Bt(e, t, Ot(t)),
      u = r?.padding ?? l,
      h = o.width / 2 + u,
      f,
      { cssStyles: d } = t
    if (t.look === 'handDrawn') {
      let p = wt.svg(s),
        m = Et(t, {}),
        g = p.circle(0, 0, h * 2, m)
      ;(f = s.insert(() => g, ':first-child')), f.attr('class', 'basic label-container').attr('style', Ir(d))
    } else
      f = s
        .insert('circle', ':first-child')
        .attr('class', 'basic label-container')
        .attr('style', i)
        .attr('r', h)
        .attr('cx', 0)
        .attr('cy', 0)
    return (
      Ct(t, f),
      (t.calcIntersect = function (p, m) {
        let g = p.width / 2
        return Tt.circle(p, g, m)
      }),
      (t.intersect = function (p) {
        return B.info('Circle intersect', t, h, p), Tt.circle(t, h, p)
      }),
      s
    )
  }
  var LA = x(() => {
    'use strict'
    oe()
    Vt()
    Ce()
    ae()
    re()
    Qt()
    a(zb, 'circle')
  })
  function Ebt(e) {
    let t = Math.cos(Math.PI / 4),
      r = Math.sin(Math.PI / 4),
      n = e * 2,
      i = { x: (n / 2) * t, y: (n / 2) * r },
      s = { x: -(n / 2) * t, y: (n / 2) * r },
      o = { x: -(n / 2) * t, y: -(n / 2) * r },
      l = { x: (n / 2) * t, y: -(n / 2) * r }
    return `M ${s.x},${s.y} L ${l.x},${l.y}
                   M ${i.x},${i.y} L ${o.x},${o.y}`
  }
  function HV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    ;(t.labelStyle = r), (t.label = '')
    let i = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId ?? t.id),
      s = Math.max(30, t?.width ?? 0),
      { cssStyles: o } = t,
      l = wt.svg(i),
      u = Et(t, {})
    t.look !== 'handDrawn' && ((u.roughness = 0), (u.fillStyle = 'solid'))
    let h = l.circle(0, 0, s * 2, u),
      f = Ebt(s),
      d = l.path(f, u),
      p = i.insert(() => h, ':first-child')
    return (
      p.insert(() => d),
      o && t.look !== 'handDrawn' && p.selectAll('path').attr('style', o),
      n && t.look !== 'handDrawn' && p.selectAll('path').attr('style', n),
      Ct(t, p),
      (t.intersect = function (m) {
        return B.info('crossedCircle intersect', t, { radius: s, point: m }), Tt.circle(t, s, m)
      }),
      i
    )
  }
  var YV = x(() => {
    'use strict'
    Vt()
    Qt()
    re()
    oe()
    ae()
    a(Ebt, 'createLine')
    a(HV, 'crossedCircle')
  })
  function Ac(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1)
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p)
      o.push({ x: -m, y: -g })
    }
    return o
  }
  async function XV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...Ac(l / 2, -u / 2, h, 30, -90, 0),
        { x: -l / 2 - h, y: h },
        ...Ac(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Ac(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: -u / 2 },
        ...Ac(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        { x: l / 2, y: -u / 2 - h },
        { x: -l / 2, y: -u / 2 - h },
        ...Ac(l / 2, -u / 2, h, 20, -90, 0),
        { x: -l / 2 - h, y: -h },
        ...Ac(l / 2 + l * 0.1, -h, h, 20, -180, -270),
        ...Ac(l / 2 + l * 0.1, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: u / 2 },
        ...Ac(l / 2, u / 2, h, 20, 0, 90),
        { x: -l / 2, y: u / 2 + h },
        { x: l / 2, y: u / 2 + h },
      ],
      m = wt.svg(i),
      g = Et(t, { fill: 'none' })
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let b = ie(d).replace('Z', ''),
      k = m.path(b, g),
      T = ie(p),
      C = m.path(T, { ...g }),
      A = i.insert('g', ':first-child')
    return (
      A.insert(() => C, ':first-child').attr('stroke-opacity', 0),
      A.insert(() => k, ':first-child'),
      A.attr('class', 'text'),
      f && t.look !== 'handDrawn' && A.selectAll('path').attr('style', f),
      n && t.look !== 'handDrawn' && A.selectAll('path').attr('style', n),
      A.attr('transform', `translate(${h}, 0)`),
      o.attr(
        'transform',
        `translate(${-l / 2 + h - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, A),
      (t.intersect = function (w) {
        return Tt.polygon(t, p, w)
      }),
      i
    )
  }
  var KV = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(Ac, 'generateCirclePoints')
    a(XV, 'curlyBraceLeft')
  })
  function Lc(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1)
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p)
      o.push({ x: m, y: g })
    }
    return o
  }
  async function QV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...Lc(l / 2, -u / 2, h, 20, -90, 0),
        { x: l / 2 + h, y: -h },
        ...Lc(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Lc(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: l / 2 + h, y: u / 2 },
        ...Lc(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        { x: -l / 2, y: -u / 2 - h },
        { x: l / 2, y: -u / 2 - h },
        ...Lc(l / 2, -u / 2, h, 20, -90, 0),
        { x: l / 2 + h, y: -h },
        ...Lc(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Lc(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: l / 2 + h, y: u / 2 },
        ...Lc(l / 2, u / 2, h, 20, 0, 90),
        { x: l / 2, y: u / 2 + h },
        { x: -l / 2, y: u / 2 + h },
      ],
      m = wt.svg(i),
      g = Et(t, { fill: 'none' })
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let b = ie(d).replace('Z', ''),
      k = m.path(b, g),
      T = ie(p),
      C = m.path(T, { ...g }),
      A = i.insert('g', ':first-child')
    return (
      A.insert(() => C, ':first-child').attr('stroke-opacity', 0),
      A.insert(() => k, ':first-child'),
      A.attr('class', 'text'),
      f && t.look !== 'handDrawn' && A.selectAll('path').attr('style', f),
      n && t.look !== 'handDrawn' && A.selectAll('path').attr('style', n),
      A.attr('transform', `translate(${-h}, 0)`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, A),
      (t.intersect = function (w) {
        return Tt.polygon(t, p, w)
      }),
      i
    )
  }
  var ZV = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(Lc, 'generateCirclePoints')
    a(QV, 'curlyBraceRight')
  })
  function bi(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1)
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p)
      o.push({ x: -m, y: -g })
    }
    return o
  }
  async function JV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...bi(l / 2, -u / 2, h, 30, -90, 0),
        { x: -l / 2 - h, y: h },
        ...bi(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...bi(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: -u / 2 },
        ...bi(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        ...bi(-l / 2 + h + h / 2, -u / 2, h, 20, -90, -180),
        { x: l / 2 - h / 2, y: h },
        ...bi(-l / 2 - h / 2, -h, h, 20, 0, 90),
        ...bi(-l / 2 - h / 2, h, h, 20, -90, 0),
        { x: l / 2 - h / 2, y: -h },
        ...bi(-l / 2 + h + h / 2, u / 2, h, 30, -180, -270),
      ],
      m = [
        { x: l / 2, y: -u / 2 - h },
        { x: -l / 2, y: -u / 2 - h },
        ...bi(l / 2, -u / 2, h, 20, -90, 0),
        { x: -l / 2 - h, y: -h },
        ...bi(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...bi(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: u / 2 },
        ...bi(l / 2, u / 2, h, 20, 0, 90),
        { x: -l / 2, y: u / 2 + h },
        { x: l / 2 - h - h / 2, y: u / 2 + h },
        ...bi(-l / 2 + h + h / 2, -u / 2, h, 20, -90, -180),
        { x: l / 2 - h / 2, y: h },
        ...bi(-l / 2 - h / 2, -h, h, 20, 0, 90),
        ...bi(-l / 2 - h / 2, h, h, 20, -90, 0),
        { x: l / 2 - h / 2, y: -h },
        ...bi(-l / 2 + h + h / 2, u / 2, h, 30, -180, -270),
      ],
      g = wt.svg(i),
      y = Et(t, { fill: 'none' })
    t.look !== 'handDrawn' && ((y.roughness = 0), (y.fillStyle = 'solid'))
    let k = ie(d).replace('Z', ''),
      T = g.path(k, y),
      A = ie(p).replace('Z', ''),
      w = g.path(A, y),
      D = ie(m),
      G = g.path(D, { ...y }),
      v = i.insert('g', ':first-child')
    return (
      v.insert(() => G, ':first-child').attr('stroke-opacity', 0),
      v.insert(() => T, ':first-child'),
      v.insert(() => w, ':first-child'),
      v.attr('class', 'text'),
      f && t.look !== 'handDrawn' && v.selectAll('path').attr('style', f),
      n && t.look !== 'handDrawn' && v.selectAll('path').attr('style', n),
      v.attr('transform', `translate(${h - h / 4}, 0)`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, v),
      (t.intersect = function (R) {
        return Tt.polygon(t, m, R)
      }),
      i
    )
  }
  var tz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(bi, 'generateCirclePoints')
    a(JV, 'curlyBraces')
  })
  async function ez(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 80,
      l = 20,
      u = Math.max(o, (s.width + (t.padding ?? 0) * 2) * 1.25, t?.width ?? 0),
      h = Math.max(l, s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = h / 2,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = u,
      y = h,
      b = g - f,
      k = y / 4,
      T = [
        { x: b, y: 0 },
        { x: k, y: 0 },
        { x: 0, y: y / 2 },
        { x: k, y },
        { x: b, y },
        ...Ju(-b, -y / 2, f, 50, 270, 90),
      ],
      C = ie(T),
      A = p.path(C, m),
      w = i.insert(() => A, ':first-child')
    return (
      w.attr('class', 'basic label-container'),
      d && t.look !== 'handDrawn' && w.selectChildren('path').attr('style', d),
      n && t.look !== 'handDrawn' && w.selectChildren('path').attr('style', n),
      w.attr('transform', `translate(${-u / 2}, ${-h / 2})`),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, T, D)
      }),
      i
    )
  }
  var rz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(ez, 'curvedTrapezoid')
  })
  async function nz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + t.padding, t.width ?? 0),
      u = l / 2,
      h = u / (2.5 + l / 50),
      f = Math.max(s.height + h + t.padding, t.height ?? 0),
      d,
      { cssStyles: p } = t
    if (t.look === 'handDrawn') {
      let m = wt.svg(i),
        g = Abt(0, 0, l, f, u, h),
        y = Lbt(0, h, l, f, u, h),
        b = m.path(g, Et(t, {})),
        k = m.path(y, Et(t, { fill: 'none' }))
      ;(d = i.insert(() => k, ':first-child')),
        (d = i.insert(() => b, ':first-child')),
        d.attr('class', 'basic label-container'),
        p && d.attr('style', p)
    } else {
      let m = vbt(0, 0, l, f, u, h)
      d = i
        .insert('path', ':first-child')
        .attr('d', m)
        .attr('class', 'basic label-container')
        .attr('style', Ir(p))
        .attr('style', n)
    }
    return (
      d.attr('label-offset-y', h),
      d.attr('transform', `translate(${-l / 2}, ${-(f / 2 + h)})`),
      Ct(t, d),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + (t.padding ?? 0) / 1.5 - (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (m) {
        let g = Tt.rect(t, m),
          y = g.x - (t.x ?? 0)
        if (
          u != 0 &&
          (Math.abs(y) < (t.width ?? 0) / 2 ||
            (Math.abs(y) == (t.width ?? 0) / 2 && Math.abs(g.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h))
        ) {
          let b = h * h * (1 - (y * y) / (u * u))
          b > 0 && (b = Math.sqrt(b)), (b = h - b), m.y - (t.y ?? 0) > 0 && (b = -b), (g.y += b)
        }
        return g
      }),
      i
    )
  }
  var vbt,
    Abt,
    Lbt,
    iz = x(() => {
      'use strict'
      Qt()
      ae()
      re()
      oe()
      Ce()
      ;(vbt = a(
        (e, t, r, n, i, s) =>
          [
            `M${e},${t + s}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `a${i},${s} 0,0,0 ${-r},0`,
            `l0,${n}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `l0,${-n}`,
          ].join(' '),
        'createCylinderPathD',
      )),
        (Abt = a(
          (e, t, r, n, i, s) =>
            [
              `M${e},${t + s}`,
              `M${e + r},${t + s}`,
              `a${i},${s} 0,0,0 ${-r},0`,
              `l0,${n}`,
              `a${i},${s} 0,0,0 ${r},0`,
              `l0,${-n}`,
            ].join(' '),
          'createOuterCylinderPathD',
        )),
        (Lbt = a(
          (e, t, r, n, i, s) => [`M${e - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(' '),
          'createInnerCylinderPathD',
        ))
      a(nz, 'cylinder')
    })
  async function sz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + t.padding,
      u = s.height + t.padding,
      h = u * 0.2,
      f = -l / 2,
      d = -u / 2 - h / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {})
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let y = [
        { x: f, y: d + h },
        { x: -f, y: d + h },
        { x: -f, y: -d },
        { x: f, y: -d },
        { x: f, y: d },
        { x: -f, y: d },
        { x: -f, y: d + h },
      ],
      b = m.polygon(
        y.map((T) => [T.x, T.y]),
        g,
      ),
      k = i.insert(() => b, ':first-child')
    return (
      k.attr('class', 'basic label-container'),
      p && t.look !== 'handDrawn' && k.selectAll('path').attr('style', p),
      n && t.look !== 'handDrawn' && k.selectAll('path').attr('style', n),
      o.attr(
        'transform',
        `translate(${f + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))}, ${d + h + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T)
      }),
      i
    )
  }
  var az = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(sz, 'dividedRectangle')
  })
  async function oz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, halfPadding: o } = await Bt(e, t, Ot(t)),
      u = s.width / 2 + o + 5,
      h = s.width / 2 + o,
      f,
      { cssStyles: d } = t
    if (t.look === 'handDrawn') {
      let p = wt.svg(i),
        m = Et(t, { roughness: 0.2, strokeWidth: 2.5 }),
        g = Et(t, { roughness: 0.2, strokeWidth: 1.5 }),
        y = p.circle(0, 0, u * 2, m),
        b = p.circle(0, 0, h * 2, g)
      ;(f = i.insert('g', ':first-child')),
        f.attr('class', Ir(t.cssClasses)).attr('style', Ir(d)),
        f.node()?.appendChild(y),
        f.node()?.appendChild(b)
    } else {
      f = i.insert('g', ':first-child')
      let p = f.insert('circle', ':first-child'),
        m = f.insert('circle')
      f.attr('class', 'basic label-container').attr('style', n),
        p.attr('class', 'outer-circle').attr('style', n).attr('r', u).attr('cx', 0).attr('cy', 0),
        m.attr('class', 'inner-circle').attr('style', n).attr('r', h).attr('cx', 0).attr('cy', 0)
    }
    return (
      Ct(t, f),
      (t.intersect = function (p) {
        return B.info('DoubleCircle intersect', t, u, p), Tt.circle(t, u, p)
      }),
      i
    )
  }
  var lz = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    Ce()
    a(oz, 'doublecircle')
  })
  function cz(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    ;(t.label = ''), (t.labelStyle = n)
    let s = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId ?? t.id),
      o = 7,
      { cssStyles: l } = t,
      u = wt.svg(s),
      { nodeBorder: h } = r,
      f = Et(t, { fillStyle: 'solid' })
    t.look !== 'handDrawn' && (f.roughness = 0)
    let d = u.circle(0, 0, o * 2, f),
      p = s.insert(() => d, ':first-child')
    return (
      p.selectAll('path').attr('style', `fill: ${h} !important;`),
      l && l.length > 0 && t.look !== 'handDrawn' && p.selectAll('path').attr('style', l),
      i && t.look !== 'handDrawn' && p.selectAll('path').attr('style', i),
      Ct(t, p),
      (t.intersect = function (m) {
        return B.info('filledCircle intersect', t, { radius: o, point: m }), Tt.circle(t, o, m)
      }),
      s
    )
  }
  var uz = x(() => {
    'use strict'
    oe()
    Vt()
    ae()
    re()
    Qt()
    a(cz, 'filledCircle')
  })
  async function hz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = l + s.height,
      h = l + s.height,
      f = [
        { x: 0, y: -u },
        { x: h, y: -u },
        { x: h / 2, y: 0 },
      ],
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = ie(f),
      y = p.path(g, m),
      b = i.insert(() => y, ':first-child').attr('transform', `translate(${-u / 2}, ${u / 2})`)
    return (
      d && t.look !== 'handDrawn' && b.selectChildren('path').attr('style', d),
      n && t.look !== 'handDrawn' && b.selectChildren('path').attr('style', n),
      (t.width = l),
      (t.height = u),
      Ct(t, b),
      o.attr(
        'transform',
        `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-u / 2 + (t.padding ?? 0) / 2 + (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (k) {
        return B.info('Triangle intersect', t, f, k), Tt.polygon(t, f, k)
      }),
      i
    )
  }
  var fz = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    Qt()
    a(hz, 'flippedTriangle')
  })
  function dz(e, t, { dir: r, config: { state: n, themeVariables: i } }) {
    let { nodeStyles: s } = St(t)
    t.label = ''
    let o = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId ?? t.id),
      { cssStyles: l } = t,
      u = Math.max(70, t?.width ?? 0),
      h = Math.max(10, t?.height ?? 0)
    r === 'LR' && ((u = Math.max(10, t?.width ?? 0)), (h = Math.max(70, t?.height ?? 0)))
    let f = (-1 * u) / 2,
      d = (-1 * h) / 2,
      p = wt.svg(o),
      m = Et(t, { stroke: i.lineColor, fill: i.lineColor })
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = p.rectangle(f, d, u, h, m),
      y = o.insert(() => g, ':first-child')
    l && t.look !== 'handDrawn' && y.selectAll('path').attr('style', l),
      s && t.look !== 'handDrawn' && y.selectAll('path').attr('style', s),
      Ct(t, y)
    let b = n?.padding ?? 0
    return (
      t.width && t.height && ((t.width += b / 2 || 0), (t.height += b / 2 || 0)),
      (t.intersect = function (k) {
        return Tt.rect(t, k)
      }),
      o
    )
  }
  var pz = x(() => {
    'use strict'
    oe()
    ae()
    re()
    Qt()
    a(dz, 'forkJoin')
  })
  async function mz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let i = 80,
      s = 50,
      { shapeSvg: o, bbox: l } = await Bt(e, t, Ot(t)),
      u = Math.max(i, l.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s, l.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = h / 2,
      { cssStyles: d } = t,
      p = wt.svg(o),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = [
        { x: -u / 2, y: -h / 2 },
        { x: u / 2 - f, y: -h / 2 },
        ...Ju(-u / 2 + f, 0, f, 50, 90, 270),
        { x: u / 2 - f, y: h / 2 },
        { x: -u / 2, y: h / 2 },
      ],
      y = ie(g),
      b = p.path(y, m),
      k = o.insert(() => b, ':first-child')
    return (
      k.attr('class', 'basic label-container'),
      d && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', d),
      n && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', n),
      Ct(t, k),
      (t.intersect = function (T) {
        return B.info('Pill intersect', t, { radius: f, point: T }), Tt.polygon(t, g, T)
      }),
      o
    )
  }
  var gz = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    a(mz, 'halfRoundedRectangle')
  })
  async function yz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + (t.padding ?? 0),
      l = s.width + (t.padding ?? 0) * 2.5,
      { cssStyles: u } = t,
      h = wt.svg(i),
      f = Et(t, {})
    t.look !== 'handDrawn' && ((f.roughness = 0), (f.fillStyle = 'solid'))
    let d = l / 2,
      p = d / 6
    d = d + p
    let m = o / 2,
      g = m / 2,
      y = d - g,
      b = [
        { x: -y, y: -m },
        { x: 0, y: -m },
        { x: y, y: -m },
        { x: d, y: 0 },
        { x: y, y: m },
        { x: 0, y: m },
        { x: -y, y: m },
        { x: -d, y: 0 },
      ],
      k = ie(b),
      T = h.path(k, f),
      C = i.insert(() => T, ':first-child')
    return (
      C.attr('class', 'basic label-container'),
      u && t.look !== 'handDrawn' && C.selectChildren('path').attr('style', u),
      n && t.look !== 'handDrawn' && C.selectChildren('path').attr('style', n),
      (t.width = l),
      (t.height = o),
      Ct(t, C),
      (t.intersect = function (A) {
        return Tt.polygon(t, b, A)
      }),
      i
    )
  }
  var xz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(yz, 'hexagon')
  })
  async function bz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    ;(t.label = ''), (t.labelStyle = r)
    let { shapeSvg: i } = await Bt(e, t, Ot(t)),
      s = Math.max(30, t?.width ?? 0),
      o = Math.max(30, t?.height ?? 0),
      { cssStyles: l } = t,
      u = wt.svg(i),
      h = Et(t, {})
    t.look !== 'handDrawn' && ((h.roughness = 0), (h.fillStyle = 'solid'))
    let f = [
        { x: 0, y: 0 },
        { x: s, y: 0 },
        { x: 0, y: o },
        { x: s, y: o },
      ],
      d = ie(f),
      p = u.path(d, h),
      m = i.insert(() => p, ':first-child')
    return (
      m.attr('class', 'basic label-container'),
      l && t.look !== 'handDrawn' && m.selectChildren('path').attr('style', l),
      n && t.look !== 'handDrawn' && m.selectChildren('path').attr('style', n),
      m.attr('transform', `translate(${-s / 2}, ${-o / 2})`),
      Ct(t, m),
      (t.intersect = function (g) {
        return B.info('Pill intersect', t, { points: f }), Tt.polygon(t, f, g)
      }),
      i
    )
  }
  var kz = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    a(bz, 'hourglass')
  })
  async function Tz(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t)
    t.labelStyle = i
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth
    t.width = Math.max(l, u ?? 0)
    let { shapeSvg: h, bbox: f, label: d } = await Bt(e, t, 'icon-shape default'),
      p = t.pos === 't',
      m = l,
      g = l,
      { nodeBorder: y } = r,
      { stylesMap: b } = ko(t),
      k = -g / 2,
      T = -m / 2,
      C = t.label ? 8 : 0,
      A = wt.svg(h),
      w = Et(t, { stroke: 'none', fill: 'none' })
    t.look !== 'handDrawn' && ((w.roughness = 0), (w.fillStyle = 'solid'))
    let D = A.rectangle(k, T, g, m, w),
      G = Math.max(g, f.width),
      v = m + f.height + C,
      R = A.rectangle(-G / 2, -v / 2, G, v, { ...w, fill: 'transparent', stroke: 'none' }),
      F = h.insert(() => D, ':first-child'),
      S = h.insert(() => R)
    if (t.icon) {
      let O = h.append('g')
      O.html(`<g>${await ro(t.icon, { height: l, width: l, fallbackPrefix: '' })}</g>`)
      let E = O.node().getBBox(),
        _ = E.width,
        L = E.height,
        N = E.x,
        P = E.y
      O.attr(
        'transform',
        `translate(${-_ / 2 - N},${p ? f.height / 2 + C / 2 - L / 2 - P : -f.height / 2 - C / 2 - L / 2 - P})`,
      ),
        O.attr('style', `color: ${b.get('stroke') ?? y};`)
    }
    return (
      d.attr('transform', `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${p ? -v / 2 : v / 2 - f.height})`),
      F.attr('transform', `translate(0,${p ? f.height / 2 + C / 2 : -f.height / 2 - C / 2})`),
      Ct(t, S),
      (t.intersect = function (O) {
        if ((B.info('iconSquare intersect', t, O), !t.label)) return Tt.rect(t, O)
        let E = t.x ?? 0,
          _ = t.y ?? 0,
          L = t.height ?? 0,
          N = []
        return (
          p
            ? (N = [
                { x: E - f.width / 2, y: _ - L / 2 },
                { x: E + f.width / 2, y: _ - L / 2 },
                { x: E + f.width / 2, y: _ - L / 2 + f.height + C },
                { x: E + g / 2, y: _ - L / 2 + f.height + C },
                { x: E + g / 2, y: _ + L / 2 },
                { x: E - g / 2, y: _ + L / 2 },
                { x: E - g / 2, y: _ - L / 2 + f.height + C },
                { x: E - f.width / 2, y: _ - L / 2 + f.height + C },
              ])
            : (N = [
                { x: E - g / 2, y: _ - L / 2 },
                { x: E + g / 2, y: _ - L / 2 },
                { x: E + g / 2, y: _ - L / 2 + m },
                { x: E + f.width / 2, y: _ - L / 2 + m },
                { x: E + f.width / 2 / 2, y: _ + L / 2 },
                { x: E - f.width / 2, y: _ + L / 2 },
                { x: E - f.width / 2, y: _ - L / 2 + m },
                { x: E - g / 2, y: _ - L / 2 + m },
              ]),
          Tt.polygon(t, N, O)
        )
      }),
      h
    )
  }
  var Sz = x(() => {
    'use strict'
    oe()
    Vt()
    bu()
    ae()
    re()
    Qt()
    a(Tz, 'icon')
  })
  async function _z(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t)
    t.labelStyle = i
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth
    t.width = Math.max(l, u ?? 0)
    let { shapeSvg: h, bbox: f, label: d } = await Bt(e, t, 'icon-shape default'),
      p = 20,
      m = t.label ? 8 : 0,
      g = t.pos === 't',
      { nodeBorder: y, mainBkg: b } = r,
      { stylesMap: k } = ko(t),
      T = wt.svg(h),
      C = Et(t, {})
    t.look !== 'handDrawn' && ((C.roughness = 0), (C.fillStyle = 'solid'))
    let A = k.get('fill')
    C.stroke = A ?? b
    let w = h.append('g')
    t.icon && w.html(`<g>${await ro(t.icon, { height: l, width: l, fallbackPrefix: '' })}</g>`)
    let D = w.node().getBBox(),
      G = D.width,
      v = D.height,
      R = D.x,
      F = D.y,
      S = Math.max(G, v) * Math.SQRT2 + p * 2,
      O = T.circle(0, 0, S, C),
      E = Math.max(S, f.width),
      _ = S + f.height + m,
      L = T.rectangle(-E / 2, -_ / 2, E, _, { ...C, fill: 'transparent', stroke: 'none' }),
      N = h.insert(() => O, ':first-child'),
      P = h.insert(() => L)
    return (
      w.attr(
        'transform',
        `translate(${-G / 2 - R},${g ? f.height / 2 + m / 2 - v / 2 - F : -f.height / 2 - m / 2 - v / 2 - F})`,
      ),
      w.attr('style', `color: ${k.get('stroke') ?? y};`),
      d.attr('transform', `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${g ? -_ / 2 : _ / 2 - f.height})`),
      N.attr('transform', `translate(0,${g ? f.height / 2 + m / 2 : -f.height / 2 - m / 2})`),
      Ct(t, P),
      (t.intersect = function (I) {
        return B.info('iconSquare intersect', t, I), Tt.rect(t, I)
      }),
      h
    )
  }
  var Cz = x(() => {
    'use strict'
    oe()
    Vt()
    bu()
    ae()
    re()
    Qt()
    a(_z, 'iconCircle')
  })
  var us,
    eh = x(() => {
      'use strict'
      us = a(
        (e, t, r, n, i) =>
          [
            'M',
            e + i,
            t,
            'H',
            e + r - i,
            'A',
            i,
            i,
            0,
            0,
            1,
            e + r,
            t + i,
            'V',
            t + n - i,
            'A',
            i,
            i,
            0,
            0,
            1,
            e + r - i,
            t + n,
            'H',
            e + i,
            'A',
            i,
            i,
            0,
            0,
            1,
            e,
            t + n - i,
            'V',
            t + i,
            'A',
            i,
            i,
            0,
            0,
            1,
            e + i,
            t,
            'Z',
          ].join(' '),
        'createRoundedRectPathD',
      )
    })
  async function wz(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t)
    t.labelStyle = i
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth
    t.width = Math.max(l, u ?? 0)
    let { shapeSvg: h, bbox: f, halfPadding: d, label: p } = await Bt(e, t, 'icon-shape default'),
      m = t.pos === 't',
      g = l + d * 2,
      y = l + d * 2,
      { nodeBorder: b, mainBkg: k } = r,
      { stylesMap: T } = ko(t),
      C = -y / 2,
      A = -g / 2,
      w = t.label ? 8 : 0,
      D = wt.svg(h),
      G = Et(t, {})
    t.look !== 'handDrawn' && ((G.roughness = 0), (G.fillStyle = 'solid'))
    let v = T.get('fill')
    G.stroke = v ?? k
    let R = D.path(us(C, A, y, g, 5), G),
      F = Math.max(y, f.width),
      S = g + f.height + w,
      O = D.rectangle(-F / 2, -S / 2, F, S, { ...G, fill: 'transparent', stroke: 'none' }),
      E = h.insert(() => R, ':first-child').attr('class', 'icon-shape2'),
      _ = h.insert(() => O)
    if (t.icon) {
      let L = h.append('g')
      L.html(`<g>${await ro(t.icon, { height: l, width: l, fallbackPrefix: '' })}</g>`)
      let N = L.node().getBBox(),
        P = N.width,
        I = N.height,
        M = N.x,
        V = N.y
      L.attr(
        'transform',
        `translate(${-P / 2 - M},${m ? f.height / 2 + w / 2 - I / 2 - V : -f.height / 2 - w / 2 - I / 2 - V})`,
      ),
        L.attr('style', `color: ${T.get('stroke') ?? b};`)
    }
    return (
      p.attr('transform', `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${m ? -S / 2 : S / 2 - f.height})`),
      E.attr('transform', `translate(0,${m ? f.height / 2 + w / 2 : -f.height / 2 - w / 2})`),
      Ct(t, _),
      (t.intersect = function (L) {
        if ((B.info('iconSquare intersect', t, L), !t.label)) return Tt.rect(t, L)
        let N = t.x ?? 0,
          P = t.y ?? 0,
          I = t.height ?? 0,
          M = []
        return (
          m
            ? (M = [
                { x: N - f.width / 2, y: P - I / 2 },
                { x: N + f.width / 2, y: P - I / 2 },
                { x: N + f.width / 2, y: P - I / 2 + f.height + w },
                { x: N + y / 2, y: P - I / 2 + f.height + w },
                { x: N + y / 2, y: P + I / 2 },
                { x: N - y / 2, y: P + I / 2 },
                { x: N - y / 2, y: P - I / 2 + f.height + w },
                { x: N - f.width / 2, y: P - I / 2 + f.height + w },
              ])
            : (M = [
                { x: N - y / 2, y: P - I / 2 },
                { x: N + y / 2, y: P - I / 2 },
                { x: N + y / 2, y: P - I / 2 + g },
                { x: N + f.width / 2, y: P - I / 2 + g },
                { x: N + f.width / 2 / 2, y: P + I / 2 },
                { x: N - f.width / 2, y: P + I / 2 },
                { x: N - f.width / 2, y: P - I / 2 + g },
                { x: N - y / 2, y: P - I / 2 + g },
              ]),
          Tt.polygon(t, M, L)
        )
      }),
      h
    )
  }
  var Ez = x(() => {
    'use strict'
    oe()
    Vt()
    bu()
    ae()
    re()
    eh()
    Qt()
    a(wz, 'iconRounded')
  })
  async function vz(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t)
    t.labelStyle = i
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth
    t.width = Math.max(l, u ?? 0)
    let { shapeSvg: h, bbox: f, halfPadding: d, label: p } = await Bt(e, t, 'icon-shape default'),
      m = t.pos === 't',
      g = l + d * 2,
      y = l + d * 2,
      { nodeBorder: b, mainBkg: k } = r,
      { stylesMap: T } = ko(t),
      C = -y / 2,
      A = -g / 2,
      w = t.label ? 8 : 0,
      D = wt.svg(h),
      G = Et(t, {})
    t.look !== 'handDrawn' && ((G.roughness = 0), (G.fillStyle = 'solid'))
    let v = T.get('fill')
    G.stroke = v ?? k
    let R = D.path(us(C, A, y, g, 0.1), G),
      F = Math.max(y, f.width),
      S = g + f.height + w,
      O = D.rectangle(-F / 2, -S / 2, F, S, { ...G, fill: 'transparent', stroke: 'none' }),
      E = h.insert(() => R, ':first-child'),
      _ = h.insert(() => O)
    if (t.icon) {
      let L = h.append('g')
      L.html(`<g>${await ro(t.icon, { height: l, width: l, fallbackPrefix: '' })}</g>`)
      let N = L.node().getBBox(),
        P = N.width,
        I = N.height,
        M = N.x,
        V = N.y
      L.attr(
        'transform',
        `translate(${-P / 2 - M},${m ? f.height / 2 + w / 2 - I / 2 - V : -f.height / 2 - w / 2 - I / 2 - V})`,
      ),
        L.attr('style', `color: ${T.get('stroke') ?? b};`)
    }
    return (
      p.attr('transform', `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${m ? -S / 2 : S / 2 - f.height})`),
      E.attr('transform', `translate(0,${m ? f.height / 2 + w / 2 : -f.height / 2 - w / 2})`),
      Ct(t, _),
      (t.intersect = function (L) {
        if ((B.info('iconSquare intersect', t, L), !t.label)) return Tt.rect(t, L)
        let N = t.x ?? 0,
          P = t.y ?? 0,
          I = t.height ?? 0,
          M = []
        return (
          m
            ? (M = [
                { x: N - f.width / 2, y: P - I / 2 },
                { x: N + f.width / 2, y: P - I / 2 },
                { x: N + f.width / 2, y: P - I / 2 + f.height + w },
                { x: N + y / 2, y: P - I / 2 + f.height + w },
                { x: N + y / 2, y: P + I / 2 },
                { x: N - y / 2, y: P + I / 2 },
                { x: N - y / 2, y: P - I / 2 + f.height + w },
                { x: N - f.width / 2, y: P - I / 2 + f.height + w },
              ])
            : (M = [
                { x: N - y / 2, y: P - I / 2 },
                { x: N + y / 2, y: P - I / 2 },
                { x: N + y / 2, y: P - I / 2 + g },
                { x: N + f.width / 2, y: P - I / 2 + g },
                { x: N + f.width / 2 / 2, y: P + I / 2 },
                { x: N - f.width / 2, y: P + I / 2 },
                { x: N - f.width / 2, y: P - I / 2 + g },
                { x: N - y / 2, y: P - I / 2 + g },
              ]),
          Tt.polygon(t, M, L)
        )
      }),
      h
    )
  }
  var Az = x(() => {
    'use strict'
    oe()
    Vt()
    bu()
    ae()
    eh()
    re()
    Qt()
    a(vz, 'iconSquare')
  })
  async function Lz(e, t, { config: { flowchart: r } }) {
    let n = new Image()
    ;(n.src = t?.img ?? ''), await n.decode()
    let i = Number(n.naturalWidth.toString().replace('px', '')),
      s = Number(n.naturalHeight.toString().replace('px', ''))
    t.imageAspectRatio = i / s
    let { labelStyles: o } = St(t)
    t.labelStyle = o
    let l = r?.wrappingWidth
    t.defaultWidth = r?.wrappingWidth
    let u = Math.max(t.label ? (l ?? 0) : 0, t?.assetWidth ?? i),
      h = t.constraint === 'on' && t?.assetHeight ? t.assetHeight * t.imageAspectRatio : u,
      f = t.constraint === 'on' ? h / t.imageAspectRatio : (t?.assetHeight ?? s)
    t.width = Math.max(h, l ?? 0)
    let { shapeSvg: d, bbox: p, label: m } = await Bt(e, t, 'image-shape default'),
      g = t.pos === 't',
      y = -h / 2,
      b = -f / 2,
      k = t.label ? 8 : 0,
      T = wt.svg(d),
      C = Et(t, {})
    t.look !== 'handDrawn' && ((C.roughness = 0), (C.fillStyle = 'solid'))
    let A = T.rectangle(y, b, h, f, C),
      w = Math.max(h, p.width),
      D = f + p.height + k,
      G = T.rectangle(-w / 2, -D / 2, w, D, { ...C, fill: 'none', stroke: 'none' }),
      v = d.insert(() => A, ':first-child'),
      R = d.insert(() => G)
    if (t.img) {
      let F = d.append('image')
      F.attr('href', t.img),
        F.attr('width', h),
        F.attr('height', f),
        F.attr('preserveAspectRatio', 'none'),
        F.attr('transform', `translate(${-h / 2},${g ? D / 2 - f : -D / 2})`)
    }
    return (
      m.attr(
        'transform',
        `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${g ? -f / 2 - p.height / 2 - k / 2 : f / 2 - p.height / 2 + k / 2})`,
      ),
      v.attr('transform', `translate(0,${g ? p.height / 2 + k / 2 : -p.height / 2 - k / 2})`),
      Ct(t, R),
      (t.intersect = function (F) {
        if ((B.info('iconSquare intersect', t, F), !t.label)) return Tt.rect(t, F)
        let S = t.x ?? 0,
          O = t.y ?? 0,
          E = t.height ?? 0,
          _ = []
        return (
          g
            ? (_ = [
                { x: S - p.width / 2, y: O - E / 2 },
                { x: S + p.width / 2, y: O - E / 2 },
                { x: S + p.width / 2, y: O - E / 2 + p.height + k },
                { x: S + h / 2, y: O - E / 2 + p.height + k },
                { x: S + h / 2, y: O + E / 2 },
                { x: S - h / 2, y: O + E / 2 },
                { x: S - h / 2, y: O - E / 2 + p.height + k },
                { x: S - p.width / 2, y: O - E / 2 + p.height + k },
              ])
            : (_ = [
                { x: S - h / 2, y: O - E / 2 },
                { x: S + h / 2, y: O - E / 2 },
                { x: S + h / 2, y: O - E / 2 + f },
                { x: S + p.width / 2, y: O - E / 2 + f },
                { x: S + p.width / 2 / 2, y: O + E / 2 },
                { x: S - p.width / 2, y: O + E / 2 },
                { x: S - p.width / 2, y: O - E / 2 + f },
                { x: S - h / 2, y: O - E / 2 + f },
              ]),
          Tt.polygon(t, _, F)
        )
      }),
      d
    )
  }
  var Rz = x(() => {
    'use strict'
    oe()
    Vt()
    ae()
    re()
    Qt()
    a(Lz, 'imageSquare')
  })
  async function Dz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      u = [
        { x: 0, y: 0 },
        { x: o, y: 0 },
        { x: o + (3 * l) / 6, y: -l },
        { x: (-3 * l) / 6, y: -l },
      ],
      h,
      { cssStyles: f } = t
    if (t.look === 'handDrawn') {
      let d = wt.svg(i),
        p = Et(t, {}),
        m = ie(u),
        g = d.path(m, p)
      ;(h = i.insert(() => g, ':first-child').attr('transform', `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr('style', f)
    } else h = cs(i, o, l, u)
    return (
      n && h.attr('style', n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d)
      }),
      i
    )
  }
  var Nz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    a(Dz, 'inv_trapezoid')
  })
  async function rh(e, t, r) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    t.labelStyle = n
    let { shapeSvg: s, bbox: o } = await Bt(e, t, Ot(t)),
      l = Math.max(o.width + r.labelPaddingX * 2, t?.width || 0),
      u = Math.max(o.height + r.labelPaddingY * 2, t?.height || 0),
      h = -l / 2,
      f = -u / 2,
      d,
      { rx: p, ry: m } = t,
      { cssStyles: g } = t
    if ((r?.rx && r.ry && ((p = r.rx), (m = r.ry)), t.look === 'handDrawn')) {
      let y = wt.svg(s),
        b = Et(t, {}),
        k = p || m ? y.path(us(h, f, l, u, p || 0), b) : y.rectangle(h, f, l, u, b)
      ;(d = s.insert(() => k, ':first-child')), d.attr('class', 'basic label-container').attr('style', Ir(g))
    } else
      (d = s.insert('rect', ':first-child')),
        d
          .attr('class', 'basic label-container')
          .attr('style', i)
          .attr('rx', Ir(p))
          .attr('ry', Ir(m))
          .attr('x', h)
          .attr('y', f)
          .attr('width', l)
          .attr('height', u)
    return (
      Ct(t, d),
      (t.calcIntersect = function (y, b) {
        return Tt.rect(y, b)
      }),
      (t.intersect = function (y) {
        return Tt.rect(t, y)
      }),
      s
    )
  }
  var B0 = x(() => {
    'use strict'
    Qt()
    ae()
    eh()
    re()
    oe()
    Ce()
    a(rh, 'drawRect')
  })
  async function Iz(e, t) {
    let { shapeSvg: r, bbox: n, label: i } = await Bt(e, t, 'label'),
      s = r.insert('rect', ':first-child')
    return (
      s.attr('width', 0.1).attr('height', 0.1),
      r.attr('class', 'label edgeLabel'),
      i.attr(
        'transform',
        `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`,
      ),
      Ct(t, s),
      (t.intersect = function (u) {
        return Tt.rect(t, u)
      }),
      r
    )
  }
  var Mz = x(() => {
    'use strict'
    B0()
    Qt()
    ae()
    a(Iz, 'labelRect')
  })
  async function Oz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      u = [
        { x: 0, y: 0 },
        { x: o + (3 * l) / 6, y: 0 },
        { x: o, y: -l },
        { x: -(3 * l) / 6, y: -l },
      ],
      h,
      { cssStyles: f } = t
    if (t.look === 'handDrawn') {
      let d = wt.svg(i),
        p = Et(t, {}),
        m = ie(u),
        g = d.path(m, p)
      ;(h = i.insert(() => g, ':first-child').attr('transform', `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr('style', f)
    } else h = cs(i, o, l, u)
    return (
      n && h.attr('style', n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d)
      }),
      i
    )
  }
  var Pz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    a(Oz, 'lean_left')
  })
  async function Bz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      u = [
        { x: (-3 * l) / 6, y: 0 },
        { x: o, y: 0 },
        { x: o + (3 * l) / 6, y: -l },
        { x: 0, y: -l },
      ],
      h,
      { cssStyles: f } = t
    if (t.look === 'handDrawn') {
      let d = wt.svg(i),
        p = Et(t, {}),
        m = ie(u),
        g = d.path(m, p)
      ;(h = i.insert(() => g, ':first-child').attr('transform', `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr('style', f)
    } else h = cs(i, o, l, u)
    return (
      n && h.attr('style', n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d)
      }),
      i
    )
  }
  var Fz = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    a(Bz, 'lean_right')
  })
  function $z(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    ;(t.label = ''), (t.labelStyle = r)
    let i = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId ?? t.id),
      { cssStyles: s } = t,
      o = Math.max(35, t?.width ?? 0),
      l = Math.max(35, t?.height ?? 0),
      u = 7,
      h = [
        { x: o, y: 0 },
        { x: 0, y: l + u / 2 },
        { x: o - 2 * u, y: l + u / 2 },
        { x: 0, y: 2 * l },
        { x: o, y: l - u / 2 },
        { x: 2 * u, y: l - u / 2 },
      ],
      f = wt.svg(i),
      d = Et(t, {})
    t.look !== 'handDrawn' && ((d.roughness = 0), (d.fillStyle = 'solid'))
    let p = ie(h),
      m = f.path(p, d),
      g = i.insert(() => m, ':first-child')
    return (
      s && t.look !== 'handDrawn' && g.selectAll('path').attr('style', s),
      n && t.look !== 'handDrawn' && g.selectAll('path').attr('style', n),
      g.attr('transform', `translate(-${o / 2},${-l})`),
      Ct(t, g),
      (t.intersect = function (y) {
        return B.info('lightningBolt intersect', t, y), Tt.polygon(t, h, y)
      }),
      i
    )
  }
  var Gz = x(() => {
    'use strict'
    Vt()
    Qt()
    re()
    oe()
    ae()
    Qt()
    a($z, 'lightningBolt')
  })
  async function Vz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0), t.width ?? 0),
      u = l / 2,
      h = u / (2.5 + l / 50),
      f = Math.max(s.height + h + (t.padding ?? 0), t.height ?? 0),
      d = f * 0.1,
      p,
      { cssStyles: m } = t
    if (t.look === 'handDrawn') {
      let g = wt.svg(i),
        y = Dbt(0, 0, l, f, u, h, d),
        b = Nbt(0, h, l, f, u, h),
        k = Et(t, {}),
        T = g.path(y, k),
        C = g.path(b, k)
      i.insert(() => C, ':first-child').attr('class', 'line'),
        (p = i.insert(() => T, ':first-child')),
        p.attr('class', 'basic label-container'),
        m && p.attr('style', m)
    } else {
      let g = Rbt(0, 0, l, f, u, h, d)
      p = i
        .insert('path', ':first-child')
        .attr('d', g)
        .attr('class', 'basic label-container')
        .attr('style', Ir(m))
        .attr('style', n)
    }
    return (
      p.attr('label-offset-y', h),
      p.attr('transform', `translate(${-l / 2}, ${-(f / 2 + h)})`),
      Ct(t, p),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h - (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (g) {
        let y = Tt.rect(t, g),
          b = y.x - (t.x ?? 0)
        if (
          u != 0 &&
          (Math.abs(b) < (t.width ?? 0) / 2 ||
            (Math.abs(b) == (t.width ?? 0) / 2 && Math.abs(y.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h))
        ) {
          let k = h * h * (1 - (b * b) / (u * u))
          k > 0 && (k = Math.sqrt(k)), (k = h - k), g.y - (t.y ?? 0) > 0 && (k = -k), (y.y += k)
        }
        return y
      }),
      i
    )
  }
  var Rbt,
    Dbt,
    Nbt,
    zz = x(() => {
      'use strict'
      Qt()
      ae()
      re()
      oe()
      Ce()
      ;(Rbt = a(
        (e, t, r, n, i, s, o) =>
          [
            `M${e},${t + s}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `a${i},${s} 0,0,0 ${-r},0`,
            `l0,${n}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `l0,${-n}`,
            `M${e},${t + s + o}`,
            `a${i},${s} 0,0,0 ${r},0`,
          ].join(' '),
        'createCylinderPathD',
      )),
        (Dbt = a(
          (e, t, r, n, i, s, o) =>
            [
              `M${e},${t + s}`,
              `M${e + r},${t + s}`,
              `a${i},${s} 0,0,0 ${-r},0`,
              `l0,${n}`,
              `a${i},${s} 0,0,0 ${r},0`,
              `l0,${-n}`,
              `M${e},${t + s + o}`,
              `a${i},${s} 0,0,0 ${r},0`,
            ].join(' '),
          'createOuterCylinderPathD',
        )),
        (Nbt = a(
          (e, t, r, n, i, s) => [`M${e - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(' '),
          'createInnerCylinderPathD',
        ))
      a(Vz, 'linedCylinder')
    })
  async function Wz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = u + h,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = [
        { x: -l / 2 - (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: f / 2 },
        ...na(-l / 2 - (l / 2) * 0.1, f / 2, l / 2 + (l / 2) * 0.1, f / 2, h, 0.8),
        { x: l / 2 + (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2, y: -f / 2 },
        { x: -l / 2, y: (f / 2) * 1.1 },
        { x: -l / 2, y: -f / 2 },
      ],
      y = p.polygon(
        g.map((k) => [k.x, k.y]),
        m,
      ),
      b = i.insert(() => y, ':first-child')
    return (
      b.attr('class', 'basic label-container'),
      d && t.look !== 'handDrawn' && b.selectAll('path').attr('style', d),
      n && t.look !== 'handDrawn' && b.selectAll('path').attr('style', n),
      b.attr('transform', `translate(0,${-h / 2})`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) + ((l / 2) * 0.1) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, g, k)
      }),
      i
    )
  }
  var Uz = x(() => {
    'use strict'
    Qt()
    ae()
    oe()
    re()
    a(Wz, 'linedWaveEdgedRect')
  })
  async function jz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = 5,
      f = -l / 2,
      d = -u / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {}),
      y = [
        { x: f - h, y: d + h },
        { x: f - h, y: d + u + h },
        { x: f + l - h, y: d + u + h },
        { x: f + l - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d + u - h },
        { x: f + l + h, y: d + u - h },
        { x: f + l + h, y: d - h },
        { x: f + h, y: d - h },
        { x: f + h, y: d },
        { x: f, y: d },
        { x: f, y: d + h },
      ],
      b = [
        { x: f, y: d + h },
        { x: f + l - h, y: d + h },
        { x: f + l - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d },
        { x: f, y: d },
      ]
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let k = ie(y),
      T = m.path(k, g),
      C = ie(b),
      A = m.path(C, { ...g, fill: 'none' }),
      w = i.insert(() => A, ':first-child')
    return (
      w.insert(() => T, ':first-child'),
      w.attr('class', 'basic label-container'),
      p && t.look !== 'handDrawn' && w.selectAll('path').attr('style', p),
      n && t.look !== 'handDrawn' && w.selectAll('path').attr('style', n),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) - h - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, y, D)
      }),
      i
    )
  }
  var qz = x(() => {
    'use strict'
    Qt()
    re()
    oe()
    ae()
    a(jz, 'multiRect')
  })
  async function Hz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = u + h,
      d = -l / 2,
      p = -f / 2,
      m = 5,
      { cssStyles: g } = t,
      y = na(d - m, p + f + m, d + l - m, p + f + m, h, 0.8),
      b = y?.[y.length - 1],
      k = [
        { x: d - m, y: p + m },
        { x: d - m, y: p + f + m },
        ...y,
        { x: d + l - m, y: b.y - m },
        { x: d + l, y: b.y - m },
        { x: d + l, y: b.y - 2 * m },
        { x: d + l + m, y: b.y - 2 * m },
        { x: d + l + m, y: p - m },
        { x: d + m, y: p - m },
        { x: d + m, y: p },
        { x: d, y: p },
        { x: d, y: p + m },
      ],
      T = [
        { x: d, y: p + m },
        { x: d + l - m, y: p + m },
        { x: d + l - m, y: b.y - m },
        { x: d + l, y: b.y - m },
        { x: d + l, y: p },
        { x: d, y: p },
      ],
      C = wt.svg(i),
      A = Et(t, {})
    t.look !== 'handDrawn' && ((A.roughness = 0), (A.fillStyle = 'solid'))
    let w = ie(k),
      D = C.path(w, A),
      G = ie(T),
      v = C.path(G, A),
      R = i.insert(() => D, ':first-child')
    return (
      R.insert(() => v),
      R.attr('class', 'basic label-container'),
      g && t.look !== 'handDrawn' && R.selectAll('path').attr('style', g),
      n && t.look !== 'handDrawn' && R.selectAll('path').attr('style', n),
      R.attr('transform', `translate(0,${-h / 2})`),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) - m - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + m - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, R),
      (t.intersect = function (F) {
        return Tt.polygon(t, k, F)
      }),
      i
    )
  }
  var Yz = x(() => {
    'use strict'
    Qt()
    ae()
    oe()
    re()
    a(Hz, 'multiWaveEdgedRectangle')
  })
  async function Xz(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    ;(t.labelStyle = n), t.useHtmlLabels || Te().flowchart?.htmlLabels !== !1 || (t.centerLabel = !0)
    let { shapeSvg: o, bbox: l, label: u } = await Bt(e, t, Ot(t)),
      h = Math.max(l.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      f = Math.max(l.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      d = -h / 2,
      p = -f / 2,
      { cssStyles: m } = t,
      g = wt.svg(o),
      y = Et(t, { fill: r.noteBkgColor, stroke: r.noteBorderColor })
    t.look !== 'handDrawn' && ((y.roughness = 0), (y.fillStyle = 'solid'))
    let b = g.rectangle(d, p, h, f, y),
      k = o.insert(() => b, ':first-child')
    return (
      k.attr('class', 'basic label-container'),
      m && t.look !== 'handDrawn' && k.selectAll('path').attr('style', m),
      i && t.look !== 'handDrawn' && k.selectAll('path').attr('style', i),
      u.attr(
        'transform',
        `translate(${-l.width / 2 - (l.x - (l.left ?? 0))}, ${-(l.height / 2) - (l.y - (l.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T)
      }),
      o
    )
  }
  var Kz = x(() => {
    'use strict'
    oe()
    ae()
    re()
    Qt()
    fn()
    a(Xz, 'note')
  })
  async function Qz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding,
      l = s.height + t.padding,
      u = o + l,
      h = 0.5,
      f = [
        { x: u / 2, y: 0 },
        { x: u, y: -u / 2 },
        { x: u / 2, y: -u },
        { x: 0, y: -u / 2 },
      ],
      d,
      { cssStyles: p } = t
    if (t.look === 'handDrawn') {
      let m = wt.svg(i),
        g = Et(t, {}),
        y = Ibt(0, 0, u),
        b = m.path(y, g)
      ;(d = i.insert(() => b, ':first-child').attr('transform', `translate(${-u / 2 + h}, ${u / 2})`)),
        p && d.attr('style', p)
    } else (d = cs(i, u, u, f)), d.attr('transform', `translate(${-u / 2 + h}, ${u / 2})`)
    return (
      n && d.attr('style', n),
      Ct(t, d),
      (t.calcIntersect = function (m, g) {
        let y = m.width,
          b = [
            { x: y / 2, y: 0 },
            { x: y, y: -y / 2 },
            { x: y / 2, y: -y },
            { x: 0, y: -y / 2 },
          ],
          k = Tt.polygon(m, b, g)
        return { x: k.x - 0.5, y: k.y - 0.5 }
      }),
      (t.intersect = function (m) {
        return this.calcIntersect(t, m)
      }),
      i
    )
  }
  var Ibt,
    Zz = x(() => {
      'use strict'
      Qt()
      ae()
      re()
      oe()
      vc()
      Ibt = a(
        (e, t, r) =>
          [`M${e + r / 2},${t}`, `L${e + r},${t - r / 2}`, `L${e + r / 2},${t - r}`, `L${e},${t - r / 2}`, 'Z'].join(
            ' ',
          ),
        'createDecisionBoxPathD',
      )
      a(Qz, 'question')
    })
  async function Jz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      h = -l / 2,
      f = -u / 2,
      d = f / 2,
      p = [
        { x: h + d, y: f },
        { x: h, y: 0 },
        { x: h + d, y: -f },
        { x: -h, y: -f },
        { x: -h, y: f },
      ],
      { cssStyles: m } = t,
      g = wt.svg(i),
      y = Et(t, {})
    t.look !== 'handDrawn' && ((y.roughness = 0), (y.fillStyle = 'solid'))
    let b = ie(p),
      k = g.path(b, y),
      T = i.insert(() => k, ':first-child')
    return (
      T.attr('class', 'basic label-container'),
      m && t.look !== 'handDrawn' && T.selectAll('path').attr('style', m),
      n && t.look !== 'handDrawn' && T.selectAll('path').attr('style', n),
      T.attr('transform', `translate(${-d / 2},0)`),
      o.attr(
        'transform',
        `translate(${-d / 2 - s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, p, C)
      }),
      i
    )
  }
  var tW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(Jz, 'rect_left_inv_arrow')
  })
  function Mbt(e, t) {
    t && e.attr('style', t)
  }
  async function Obt(e) {
    let t = xt(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')),
      r = t.append('xhtml:div'),
      n = K(),
      i = e.label
    e.label &&
      $r(e.label) &&
      (i = await Xl(
        e.label.replace(
          Rt.lineBreakRegex,
          `
`,
        ),
        n,
      ))
    let o =
      '<span class="' +
      (e.isNode ? 'nodeLabel' : 'edgeLabel') +
      '" ' +
      (e.labelStyle ? 'style="' + e.labelStyle + '"' : '') +
      '>' +
      i +
      '</span>'
    return (
      r.html(Ie(o, n)),
      Mbt(r, e.labelStyle),
      r.style('display', 'inline-block'),
      r.style('padding-right', '1px'),
      r.style('white-space', 'nowrap'),
      r.attr('xmlns', 'http://www.w3.org/1999/xhtml'),
      t.node()
    )
  }
  var Pbt,
    To,
    Wb = x(() => {
      'use strict'
      Ge()
      pe()
      Be()
      Vt()
      Ce()
      a(Mbt, 'applyStyle')
      a(Obt, 'addHtmlLabel')
      ;(Pbt = a(async (e, t, r, n) => {
        let i = e || ''
        if ((typeof i == 'object' && (i = i[0]), Pe(K().flowchart.htmlLabels))) {
          ;(i = i.replace(/\\n|\n/g, '<br />')), B.info('vertexText' + i)
          let s = {
            isNode: n,
            label: Xn(i).replace(/fa[blrs]?:fa-[\w-]+/g, (l) => `<i class='${l.replace(':', ' ')}'></i>`),
            labelStyle: t && t.replace('fill:', 'color:'),
          }
          return await Obt(s)
        } else {
          let s = document.createElementNS('http://www.w3.org/2000/svg', 'text')
          s.setAttribute('style', t.replace('color:', 'fill:'))
          let o = []
          typeof i == 'string' ? (o = i.split(/\\n|\n|<br\s*\/?>/gi)) : Array.isArray(i) ? (o = i) : (o = [])
          for (let l of o) {
            let u = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
            u.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'),
              u.setAttribute('dy', '1em'),
              u.setAttribute('x', '0'),
              r ? u.setAttribute('class', 'title-row') : u.setAttribute('class', 'row'),
              (u.textContent = l.trim()),
              s.appendChild(u)
          }
          return s
        }
      }, 'createLabel')),
        (To = Pbt)
    })
  async function eW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let i
    t.cssClasses ? (i = 'node ' + t.cssClasses) : (i = 'node default')
    let s = e
        .insert('g')
        .attr('class', i)
        .attr('id', t.domId || t.id),
      o = s.insert('g'),
      l = s.insert('g').attr('class', 'label').attr('style', n),
      u = t.description,
      h = t.label,
      f = l.node().appendChild(await To(h, t.labelStyle, !0, !0)),
      d = { width: 0, height: 0 }
    if (Pe(K()?.flowchart?.htmlLabels)) {
      let v = f.children[0],
        R = xt(f)
      ;(d = v.getBoundingClientRect()), R.attr('width', d.width), R.attr('height', d.height)
    }
    B.info('Text 2', u)
    let p = u || [],
      m = f.getBBox(),
      g = l.node().appendChild(await To(p.join ? p.join('<br/>') : p, t.labelStyle, !0, !0)),
      y = g.children[0],
      b = xt(g)
    ;(d = y.getBoundingClientRect()), b.attr('width', d.width), b.attr('height', d.height)
    let k = (t.padding || 0) / 2
    xt(g).attr(
      'transform',
      'translate( ' + (d.width > m.width ? 0 : (m.width - d.width) / 2) + ', ' + (m.height + k + 5) + ')',
    ),
      xt(f).attr('transform', 'translate( ' + (d.width < m.width ? 0 : -(m.width - d.width) / 2) + ', 0)'),
      (d = l.node().getBBox()),
      l.attr('transform', 'translate(' + -d.width / 2 + ', ' + (-d.height / 2 - k + 3) + ')')
    let T = d.width + (t.padding || 0),
      C = d.height + (t.padding || 0),
      A = -d.width / 2 - k,
      w = -d.height / 2 - k,
      D,
      G
    if (t.look === 'handDrawn') {
      let v = wt.svg(s),
        R = Et(t, {}),
        F = v.path(us(A, w, T, C, t.rx || 0), R),
        S = v.line(
          -d.width / 2 - k,
          -d.height / 2 - k + m.height + k,
          d.width / 2 + k,
          -d.height / 2 - k + m.height + k,
          R,
        )
      ;(G = s.insert(() => (B.debug('Rough node insert CXC', F), S), ':first-child')),
        (D = s.insert(() => (B.debug('Rough node insert CXC', F), F), ':first-child'))
    } else
      (D = o.insert('rect', ':first-child')),
        (G = o.insert('line')),
        D.attr('class', 'outer title-state')
          .attr('style', n)
          .attr('x', -d.width / 2 - k)
          .attr('y', -d.height / 2 - k)
          .attr('width', d.width + (t.padding || 0))
          .attr('height', d.height + (t.padding || 0)),
        G.attr('class', 'divider')
          .attr('x1', -d.width / 2 - k)
          .attr('x2', d.width / 2 + k)
          .attr('y1', -d.height / 2 - k + m.height + k)
          .attr('y2', -d.height / 2 - k + m.height + k)
    return (
      Ct(t, D),
      (t.intersect = function (v) {
        return Tt.rect(t, v)
      }),
      s
    )
  }
  var rW = x(() => {
    'use strict'
    Ge()
    Be()
    Qt()
    Wb()
    ae()
    re()
    oe()
    pe()
    eh()
    Vt()
    a(eW, 'rectWithTitle')
  })
  function Ub(e, t, r, n, i, s, o) {
    let u = (e + r) / 2,
      h = (t + n) / 2,
      f = Math.atan2(n - t, r - e),
      d = (r - e) / 2,
      p = (n - t) / 2,
      m = d / i,
      g = p / s,
      y = Math.sqrt(m ** 2 + g ** 2)
    if (y > 1) throw new Error('The given radii are too small to create an arc between the points.')
    let b = Math.sqrt(1 - y ** 2),
      k = u + b * s * Math.sin(f) * (o ? -1 : 1),
      T = h - b * i * Math.cos(f) * (o ? -1 : 1),
      C = Math.atan2((t - T) / s, (e - k) / i),
      w = Math.atan2((n - T) / s, (r - k) / i) - C
    o && w < 0 && (w += 2 * Math.PI), !o && w > 0 && (w -= 2 * Math.PI)
    let D = []
    for (let G = 0; G < 20; G++) {
      let v = G / 19,
        R = C + v * w,
        F = k + i * Math.cos(R),
        S = T + s * Math.sin(R)
      D.push({ x: F, y: S })
    }
    return D
  }
  async function nW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = t?.padding ?? 0,
      l = t?.padding ?? 0,
      u = (t?.width ? t?.width : s.width) + o * 2,
      h = (t?.height ? t?.height : s.height) + l * 2,
      f = t.radius || 5,
      d = t.taper || 5,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {})
    t.stroke && (g.stroke = t.stroke), t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let y = [
        { x: -u / 2 + d, y: -h / 2 },
        { x: u / 2 - d, y: -h / 2 },
        ...Ub(u / 2 - d, -h / 2, u / 2, -h / 2 + d, f, f, !0),
        { x: u / 2, y: -h / 2 + d },
        { x: u / 2, y: h / 2 - d },
        ...Ub(u / 2, h / 2 - d, u / 2 - d, h / 2, f, f, !0),
        { x: u / 2 - d, y: h / 2 },
        { x: -u / 2 + d, y: h / 2 },
        ...Ub(-u / 2 + d, h / 2, -u / 2, h / 2 - d, f, f, !0),
        { x: -u / 2, y: h / 2 - d },
        { x: -u / 2, y: -h / 2 + d },
        ...Ub(-u / 2, -h / 2 + d, -u / 2 + d, -h / 2, f, f, !0),
      ],
      b = ie(y),
      k = m.path(b, g),
      T = i.insert(() => k, ':first-child')
    return (
      T.attr('class', 'basic label-container outer-path'),
      p && t.look !== 'handDrawn' && T.selectChildren('path').attr('style', p),
      n && t.look !== 'handDrawn' && T.selectChildren('path').attr('style', n),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, y, C)
      }),
      i
    )
  }
  var iW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(Ub, 'generateArcPoints')
    a(nW, 'roundedRect')
  })
  async function sW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = t?.padding ?? 0,
      u = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = -s.width / 2 - l,
      d = -s.height / 2 - l,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {})
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let y = [
        { x: f, y: d },
        { x: f + u + 8, y: d },
        { x: f + u + 8, y: d + h },
        { x: f - 8, y: d + h },
        { x: f - 8, y: d },
        { x: f, y: d },
        { x: f, y: d + h },
      ],
      b = m.polygon(
        y.map((T) => [T.x, T.y]),
        g,
      ),
      k = i.insert(() => b, ':first-child')
    return (
      k.attr('class', 'basic label-container').attr('style', Ir(p)),
      n && t.look !== 'handDrawn' && k.selectAll('path').attr('style', n),
      p && t.look !== 'handDrawn' && k.selectAll('path').attr('style', n),
      o.attr(
        'transform',
        `translate(${-u / 2 + 4 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-h / 2 + (t.padding ?? 0) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T)
      }),
      i
    )
  }
  var aW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    Ce()
    a(sW, 'shadedProcess')
  })
  async function oW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = -l / 2,
      f = -u / 2,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = Et(t, {})
    t.look !== 'handDrawn' && ((m.roughness = 0), (m.fillStyle = 'solid'))
    let g = [
        { x: h, y: f },
        { x: h, y: f + u },
        { x: h + l, y: f + u },
        { x: h + l, y: f - u / 2 },
      ],
      y = ie(g),
      b = p.path(y, m),
      k = i.insert(() => b, ':first-child')
    return (
      k.attr('class', 'basic label-container'),
      d && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', d),
      n && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', n),
      k.attr('transform', `translate(0, ${u / 4})`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))}, ${-u / 4 + (t.padding ?? 0) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.polygon(t, g, T)
      }),
      i
    )
  }
  var lW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(oW, 'slopedRect')
  })
  async function cW(e, t) {
    let r = {
      rx: 0,
      ry: 0,
      classes: '',
      labelPaddingX: t.labelPaddingX ?? (t?.padding || 0) * 2,
      labelPaddingY: (t?.padding || 0) * 1,
    }
    return rh(e, t, r)
  }
  var uW = x(() => {
    'use strict'
    B0()
    a(cW, 'squareRect')
  })
  async function hW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + t.padding,
      l = s.width + o / 4 + t.padding,
      u = o / 2,
      { cssStyles: h } = t,
      f = wt.svg(i),
      d = Et(t, {})
    t.look !== 'handDrawn' && ((d.roughness = 0), (d.fillStyle = 'solid'))
    let p = [
        { x: -l / 2 + u, y: -o / 2 },
        { x: l / 2 - u, y: -o / 2 },
        ...Ju(-l / 2 + u, 0, u, 50, 90, 270),
        { x: l / 2 - u, y: o / 2 },
        ...Ju(l / 2 - u, 0, u, 50, 270, 450),
      ],
      m = ie(p),
      g = f.path(m, d),
      y = i.insert(() => g, ':first-child')
    return (
      y.attr('class', 'basic label-container outer-path'),
      h && t.look !== 'handDrawn' && y.selectChildren('path').attr('style', h),
      n && t.look !== 'handDrawn' && y.selectChildren('path').attr('style', n),
      Ct(t, y),
      (t.intersect = function (b) {
        return Tt.polygon(t, p, b)
      }),
      i
    )
  }
  var fW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(hW, 'stadium')
  })
  async function dW(e, t) {
    return rh(e, t, { rx: 5, ry: 5, classes: 'flowchart-node' })
  }
  var pW = x(() => {
    'use strict'
    B0()
    a(dW, 'state')
  })
  function mW(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    t.labelStyle = n
    let { cssStyles: s } = t,
      { lineColor: o, stateBorder: l, nodeBorder: u } = r,
      h = e
        .insert('g')
        .attr('class', 'node default')
        .attr('id', t.domId || t.id),
      f = wt.svg(h),
      d = Et(t, {})
    t.look !== 'handDrawn' && ((d.roughness = 0), (d.fillStyle = 'solid'))
    let p = f.circle(0, 0, 14, { ...d, stroke: o, strokeWidth: 2 }),
      m = l ?? u,
      g = f.circle(0, 0, 5, { ...d, fill: m, stroke: m, strokeWidth: 2, fillStyle: 'solid' }),
      y = h.insert(() => p, ':first-child')
    return (
      y.insert(() => g),
      s && y.selectAll('path').attr('style', s),
      i && y.selectAll('path').attr('style', i),
      Ct(t, y),
      (t.intersect = function (b) {
        return Tt.circle(t, 7, b)
      }),
      h
    )
  }
  var gW = x(() => {
    'use strict'
    oe()
    ae()
    re()
    Qt()
    a(mW, 'stateEnd')
  })
  function yW(e, t, { config: { themeVariables: r } }) {
    let { lineColor: n } = r,
      i = e
        .insert('g')
        .attr('class', 'node default')
        .attr('id', t.domId || t.id),
      s
    if (t.look === 'handDrawn') {
      let l = wt.svg(i).circle(0, 0, 14, _V(n))
      ;(s = i.insert(() => l)), s.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14)
    } else
      (s = i.insert('circle', ':first-child')),
        s.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14)
    return (
      Ct(t, s),
      (t.intersect = function (o) {
        return Tt.circle(t, 7, o)
      }),
      i
    )
  }
  var xW = x(() => {
    'use strict'
    oe()
    ae()
    re()
    Qt()
    a(yW, 'stateStart')
  })
  async function bW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = (t?.padding || 0) / 2,
      l = s.width + t.padding,
      u = s.height + t.padding,
      h = -s.width / 2 - o,
      f = -s.height / 2 - o,
      d = [
        { x: 0, y: 0 },
        { x: l, y: 0 },
        { x: l, y: -u },
        { x: 0, y: -u },
        { x: 0, y: 0 },
        { x: -8, y: 0 },
        { x: l + 8, y: 0 },
        { x: l + 8, y: -u },
        { x: -8, y: -u },
        { x: -8, y: 0 },
      ]
    if (t.look === 'handDrawn') {
      let p = wt.svg(i),
        m = Et(t, {}),
        g = p.rectangle(h - 8, f, l + 16, u, m),
        y = p.line(h, f, h, f + u, m),
        b = p.line(h + l, f, h + l, f + u, m)
      i.insert(() => y, ':first-child'), i.insert(() => b, ':first-child')
      let k = i.insert(() => g, ':first-child'),
        { cssStyles: T } = t
      k.attr('class', 'basic label-container').attr('style', Ir(T)), Ct(t, k)
    } else {
      let p = cs(i, l, u, d)
      n && p.attr('style', n), Ct(t, p)
    }
    return (
      (t.intersect = function (p) {
        return Tt.polygon(t, d, p)
      }),
      i
    )
  }
  var kW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    Ce()
    a(bW, 'subroutine')
  })
  async function TW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      u = -o / 2,
      h = -l / 2,
      f = 0.2 * l,
      d = 0.2 * l,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {}),
      y = [
        { x: u - f / 2, y: h },
        { x: u + o + f / 2, y: h },
        { x: u + o + f / 2, y: h + l },
        { x: u - f / 2, y: h + l },
      ],
      b = [
        { x: u + o - f / 2, y: h + l },
        { x: u + o + f / 2, y: h + l },
        { x: u + o + f / 2, y: h + l - d },
      ]
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let k = ie(y),
      T = m.path(k, g),
      C = ie(b),
      A = m.path(C, { ...g, fillStyle: 'solid' }),
      w = i.insert(() => A, ':first-child')
    return (
      w.insert(() => T, ':first-child'),
      w.attr('class', 'basic label-container'),
      p && t.look !== 'handDrawn' && w.selectAll('path').attr('style', p),
      n && t.look !== 'handDrawn' && w.selectAll('path').attr('style', n),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, y, D)
      }),
      i
    )
  }
  var SW = x(() => {
    'use strict'
    Qt()
    re()
    oe()
    ae()
    a(TW, 'taggedRect')
  })
  async function _W(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = 0.2 * l,
      d = 0.2 * u,
      p = u + h,
      { cssStyles: m } = t,
      g = wt.svg(i),
      y = Et(t, {})
    t.look !== 'handDrawn' && ((y.roughness = 0), (y.fillStyle = 'solid'))
    let b = [
        { x: -l / 2 - (l / 2) * 0.1, y: p / 2 },
        ...na(-l / 2 - (l / 2) * 0.1, p / 2, l / 2 + (l / 2) * 0.1, p / 2, h, 0.8),
        { x: l / 2 + (l / 2) * 0.1, y: -p / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: -p / 2 },
      ],
      k = -l / 2 + (l / 2) * 0.1,
      T = -p / 2 - d * 0.4,
      C = [
        { x: k + l - f, y: (T + u) * 1.4 },
        { x: k + l, y: T + u - d },
        { x: k + l, y: (T + u) * 0.9 },
        ...na(k + l, (T + u) * 1.3, k + l - f, (T + u) * 1.5, -u * 0.03, 0.5),
      ],
      A = ie(b),
      w = g.path(A, y),
      D = ie(C),
      G = g.path(D, { ...y, fillStyle: 'solid' }),
      v = i.insert(() => G, ':first-child')
    return (
      v.insert(() => w, ':first-child'),
      v.attr('class', 'basic label-container'),
      m && t.look !== 'handDrawn' && v.selectAll('path').attr('style', m),
      n && t.look !== 'handDrawn' && v.selectAll('path').attr('style', n),
      v.attr('transform', `translate(0,${-h / 2})`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, v),
      (t.intersect = function (R) {
        return Tt.polygon(t, b, R)
      }),
      i
    )
  }
  var CW = x(() => {
    'use strict'
    Qt()
    ae()
    oe()
    re()
    a(_W, 'taggedWaveEdgedRectangle')
  })
  async function wW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + t.padding, t?.width || 0),
      l = Math.max(s.height + t.padding, t?.height || 0),
      u = -o / 2,
      h = -l / 2,
      f = i.insert('rect', ':first-child')
    return (
      f
        .attr('class', 'text')
        .attr('style', n)
        .attr('rx', 0)
        .attr('ry', 0)
        .attr('x', u)
        .attr('y', h)
        .attr('width', o)
        .attr('height', l),
      Ct(t, f),
      (t.intersect = function (d) {
        return Tt.rect(t, d)
      }),
      i
    )
  }
  var EW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    a(wW, 'text')
  })
  async function vW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o, halfPadding: l } = await Bt(e, t, Ot(t)),
      u = t.look === 'neo' ? l * 2 : l,
      h = s.height + u,
      f = h / 2,
      d = f / (2.5 + h / 50),
      p = s.width + d + u,
      { cssStyles: m } = t,
      g
    if (t.look === 'handDrawn') {
      let y = wt.svg(i),
        b = Fbt(0, 0, p, h, d, f),
        k = $bt(0, 0, p, h, d, f),
        T = y.path(b, Et(t, {})),
        C = y.path(k, Et(t, { fill: 'none' }))
      ;(g = i.insert(() => C, ':first-child')),
        (g = i.insert(() => T, ':first-child')),
        g.attr('class', 'basic label-container'),
        m && g.attr('style', m)
    } else {
      let y = Bbt(0, 0, p, h, d, f)
      ;(g = i
        .insert('path', ':first-child')
        .attr('d', y)
        .attr('class', 'basic label-container')
        .attr('style', Ir(m))
        .attr('style', n)),
        g.attr('class', 'basic label-container'),
        m && g.selectAll('path').attr('style', m),
        n && g.selectAll('path').attr('style', n)
    }
    return (
      g.attr('label-offset-x', d),
      g.attr('transform', `translate(${-p / 2}, ${h / 2} )`),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) - d - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, g),
      (t.intersect = function (y) {
        let b = Tt.rect(t, y),
          k = b.y - (t.y ?? 0)
        if (
          f != 0 &&
          (Math.abs(k) < (t.height ?? 0) / 2 ||
            (Math.abs(k) == (t.height ?? 0) / 2 && Math.abs(b.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - d))
        ) {
          let T = d * d * (1 - (k * k) / (f * f))
          T != 0 && (T = Math.sqrt(Math.abs(T))), (T = d - T), y.x - (t.x ?? 0) > 0 && (T = -T), (b.x += T)
        }
        return b
      }),
      i
    )
  }
  var Bbt,
    Fbt,
    $bt,
    AW = x(() => {
      'use strict'
      Qt()
      re()
      oe()
      ae()
      Ce()
      ;(Bbt = a(
        (e, t, r, n, i, s) => `M${e},${t}
    a${i},${s} 0,0,1 0,${-n}
    l${r},0
    a${i},${s} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${s} 0,0,0 0,${n}
    l${-r},0`,
        'createCylinderPathD',
      )),
        (Fbt = a(
          (e, t, r, n, i, s) =>
            [
              `M${e},${t}`,
              `M${e + r},${t}`,
              `a${i},${s} 0,0,0 0,${-n}`,
              `l${-r},0`,
              `a${i},${s} 0,0,0 0,${n}`,
              `l${r},0`,
            ].join(' '),
          'createOuterCylinderPathD',
        )),
        ($bt = a(
          (e, t, r, n, i, s) => [`M${e + r / 2},${-n / 2}`, `a${i},${s} 0,0,0 0,${n}`].join(' '),
          'createInnerCylinderPathD',
        ))
      a(vW, 'tiltedCylinder')
    })
  async function LW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding,
      l = s.height + t.padding,
      u = [
        { x: (-3 * l) / 6, y: 0 },
        { x: o + (3 * l) / 6, y: 0 },
        { x: o, y: -l },
        { x: 0, y: -l },
      ],
      h,
      { cssStyles: f } = t
    if (t.look === 'handDrawn') {
      let d = wt.svg(i),
        p = Et(t, {}),
        m = ie(u),
        g = d.path(m, p)
      ;(h = i.insert(() => g, ':first-child').attr('transform', `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr('style', f)
    } else h = cs(i, o, l, u)
    return (
      n && h.attr('style', n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d)
      }),
      i
    )
  }
  var RW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    vc()
    a(LW, 'trapezoid')
  })
  async function DW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 60,
      l = 20,
      u = Math.max(o, s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(l, s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      { cssStyles: f } = t,
      d = wt.svg(i),
      p = Et(t, {})
    t.look !== 'handDrawn' && ((p.roughness = 0), (p.fillStyle = 'solid'))
    let m = [
        { x: (-u / 2) * 0.8, y: -h / 2 },
        { x: (u / 2) * 0.8, y: -h / 2 },
        { x: u / 2, y: (-h / 2) * 0.6 },
        { x: u / 2, y: h / 2 },
        { x: -u / 2, y: h / 2 },
        { x: -u / 2, y: (-h / 2) * 0.6 },
      ],
      g = ie(m),
      y = d.path(g, p),
      b = i.insert(() => y, ':first-child')
    return (
      b.attr('class', 'basic label-container'),
      f && t.look !== 'handDrawn' && b.selectChildren('path').attr('style', f),
      n && t.look !== 'handDrawn' && b.selectChildren('path').attr('style', n),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, m, k)
      }),
      i
    )
  }
  var NW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(DW, 'trapezoidalPentagon')
  })
  async function IW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Pe(K().flowchart?.htmlLabels),
      u = s.width + (t.padding ?? 0),
      h = u + s.height,
      f = u + s.height,
      d = [
        { x: 0, y: 0 },
        { x: f, y: 0 },
        { x: f / 2, y: -h },
      ],
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {})
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let y = ie(d),
      b = m.path(y, g),
      k = i.insert(() => b, ':first-child').attr('transform', `translate(${-h / 2}, ${h / 2})`)
    return (
      p && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', p),
      n && t.look !== 'handDrawn' && k.selectChildren('path').attr('style', n),
      (t.width = u),
      (t.height = h),
      Ct(t, k),
      o.attr(
        'transform',
        `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${h / 2 - (s.height + (t.padding ?? 0) / (l ? 2 : 1) - (s.y - (s.top ?? 0)))})`,
      ),
      (t.intersect = function (T) {
        return B.info('Triangle intersect', t, d, T), Tt.polygon(t, d, T)
      }),
      i
    )
  }
  var MW = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    Qt()
    Be()
    pe()
    a(IW, 'triangle')
  })
  async function OW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 8,
      f = u + h,
      { cssStyles: d } = t,
      m = 70 - l,
      g = m > 0 ? m / 2 : 0,
      y = wt.svg(i),
      b = Et(t, {})
    t.look !== 'handDrawn' && ((b.roughness = 0), (b.fillStyle = 'solid'))
    let k = [
        { x: -l / 2 - g, y: f / 2 },
        ...na(-l / 2 - g, f / 2, l / 2 + g, f / 2, h, 0.8),
        { x: l / 2 + g, y: -f / 2 },
        { x: -l / 2 - g, y: -f / 2 },
      ],
      T = ie(k),
      C = y.path(T, b),
      A = i.insert(() => C, ':first-child')
    return (
      A.attr('class', 'basic label-container'),
      d && t.look !== 'handDrawn' && A.selectAll('path').attr('style', d),
      n && t.look !== 'handDrawn' && A.selectAll('path').attr('style', n),
      A.attr('transform', `translate(0,${-h / 2})`),
      o.attr(
        'transform',
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, A),
      (t.intersect = function (w) {
        return Tt.polygon(t, k, w)
      }),
      i
    )
  }
  var PW = x(() => {
    'use strict'
    Qt()
    ae()
    oe()
    re()
    a(OW, 'waveEdgedRectangle')
  })
  async function BW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 100,
      l = 50,
      u = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = u / h,
      d = u,
      p = h
    d > p * f ? (p = d / f) : (d = p * f), (d = Math.max(d, o)), (p = Math.max(p, l))
    let m = Math.min(p * 0.2, p / 4),
      g = p + m * 2,
      { cssStyles: y } = t,
      b = wt.svg(i),
      k = Et(t, {})
    t.look !== 'handDrawn' && ((k.roughness = 0), (k.fillStyle = 'solid'))
    let T = [
        { x: -d / 2, y: g / 2 },
        ...na(-d / 2, g / 2, d / 2, g / 2, m, 1),
        { x: d / 2, y: -g / 2 },
        ...na(d / 2, -g / 2, -d / 2, -g / 2, m, -1),
      ],
      C = ie(T),
      A = b.path(C, k),
      w = i.insert(() => A, ':first-child')
    return (
      w.attr('class', 'basic label-container'),
      y && t.look !== 'handDrawn' && w.selectAll('path').attr('style', y),
      n && t.look !== 'handDrawn' && w.selectAll('path').attr('style', n),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, T, D)
      }),
      i
    )
  }
  var FW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    a(BW, 'waveRectangle')
  })
  async function $W(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = 5,
      f = -l / 2,
      d = -u / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = Et(t, {}),
      y = [
        { x: f - h, y: d - h },
        { x: f - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d - h },
      ],
      b = `M${f - h},${d - h} L${f + l},${d - h} L${f + l},${d + u} L${f - h},${d + u} L${f - h},${d - h}
                M${f - h},${d} L${f + l},${d}
                M${f},${d - h} L${f},${d + u}`
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let k = m.path(b, g),
      T = i.insert(() => k, ':first-child')
    return (
      T.attr('transform', `translate(${h / 2}, ${h / 2})`),
      T.attr('class', 'basic label-container'),
      p && t.look !== 'handDrawn' && T.selectAll('path').attr('style', p),
      n && t.look !== 'handDrawn' && T.selectAll('path').attr('style', n),
      o.attr(
        'transform',
        `translate(${-(s.width / 2) + h / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, y, C)
      }),
      i
    )
  }
  var GW = x(() => {
    'use strict'
    Qt()
    re()
    oe()
    ae()
    a($W, 'windowPane')
  })
  async function RA(e, t) {
    let r = t
    if ((r.alias && (t.label = r.alias), t.look === 'handDrawn')) {
      let { themeVariables: q } = Te(),
        { background: tt } = q,
        ft = { ...t, id: t.id + '-background', look: 'default', cssStyles: ['stroke: none', `fill: ${tt}`] }
      await RA(e, ft)
    }
    let n = Te()
    t.useHtmlLabels = n.htmlLabels
    let i = n.er?.diagramPadding ?? 10,
      s = n.er?.entityPadding ?? 6,
      { cssStyles: o } = t,
      { labelStyles: l, nodeStyles: u } = St(t)
    if (r.attributes.length === 0 && t.label) {
      let q = { rx: 0, ry: 0, labelPaddingX: i, labelPaddingY: i * 1.5, classes: '' }
      Yn(t.label, n) + q.labelPaddingX * 2 < n.er.minEntityWidth && (t.width = n.er.minEntityWidth)
      let tt = await rh(e, t, q)
      if (!Pe(n.htmlLabels)) {
        let ft = tt.select('text'),
          H = ft.node()?.getBBox()
        ft.attr('transform', `translate(${-H.width / 2}, 0)`)
      }
      return tt
    }
    n.htmlLabels || ((i *= 1.25), (s *= 1.25))
    let h = Ot(t)
    h || (h = 'node default')
    let f = e
        .insert('g')
        .attr('class', h)
        .attr('id', t.domId || t.id),
      d = await F0(f, t.label ?? '', n, 0, 0, ['name'], l)
    d.height += s
    let p = 0,
      m = [],
      g = [],
      y = 0,
      b = 0,
      k = 0,
      T = 0,
      C = !0,
      A = !0
    for (let q of r.attributes) {
      let tt = await F0(f, q.type, n, 0, p, ['attribute-type'], l)
      y = Math.max(y, tt.width + i)
      let ft = await F0(f, q.name, n, 0, p, ['attribute-name'], l)
      b = Math.max(b, ft.width + i)
      let H = await F0(f, q.keys.join(), n, 0, p, ['attribute-keys'], l)
      k = Math.max(k, H.width + i)
      let kt = await F0(f, q.comment, n, 0, p, ['attribute-comment'], l)
      T = Math.max(T, kt.width + i)
      let ht = Math.max(tt.height, ft.height, H.height, kt.height) + s
      g.push({ yOffset: p, rowHeight: ht }), (p += ht)
    }
    let w = 4
    k <= i && ((C = !1), (k = 0), w--), T <= i && ((A = !1), (T = 0), w--)
    let D = f.node().getBBox()
    if (d.width + i * 2 - (y + b + k + T) > 0) {
      let q = d.width + i * 2 - (y + b + k + T)
      ;(y += q / w), (b += q / w), k > 0 && (k += q / w), T > 0 && (T += q / w)
    }
    let G = y + b + k + T,
      v = wt.svg(f),
      R = Et(t, {})
    t.look !== 'handDrawn' && ((R.roughness = 0), (R.fillStyle = 'solid'))
    let F = 0
    g.length > 0 && (F = g.reduce((q, tt) => q + (tt?.rowHeight ?? 0), 0))
    let S = Math.max(D.width + i * 2, t?.width || 0, G),
      O = Math.max((F ?? 0) + d.height, t?.height || 0),
      E = -S / 2,
      _ = -O / 2
    f.selectAll('g:not(:first-child)').each((q, tt, ft) => {
      let H = xt(ft[tt]),
        kt = H.attr('transform'),
        ht = 0,
        yt = 0
      if (kt) {
        let dt = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(kt)
        dt &&
          ((ht = parseFloat(dt[1])),
          (yt = parseFloat(dt[2])),
          H.attr('class').includes('attribute-name')
            ? (ht += y)
            : H.attr('class').includes('attribute-keys')
              ? (ht += y + b)
              : H.attr('class').includes('attribute-comment') && (ht += y + b + k))
      }
      H.attr('transform', `translate(${E + i / 2 + ht}, ${yt + _ + d.height + s / 2})`)
    }),
      f.select('.name').attr('transform', 'translate(' + -d.width / 2 + ', ' + (_ + s / 2) + ')')
    let L = v.rectangle(E, _, S, O, R),
      N = f.insert(() => L, ':first-child').attr('style', o.join('')),
      { themeVariables: P } = Te(),
      { rowEven: I, rowOdd: M, nodeBorder: V } = P
    m.push(0)
    for (let [q, tt] of g.entries()) {
      let H = (q + 1) % 2 === 0 && tt.yOffset !== 0,
        kt = v.rectangle(E, d.height + _ + tt?.yOffset, S, tt?.rowHeight, { ...R, fill: H ? I : M, stroke: V })
      f.insert(() => kt, 'g.label')
        .attr('style', o.join(''))
        .attr('class', `row-rect-${H ? 'even' : 'odd'}`)
    }
    let $ = v.line(E, d.height + _, S + E, d.height + _, R)
    f.insert(() => $).attr('class', 'divider'),
      ($ = v.line(y + E, d.height + _, y + E, O + _, R)),
      f.insert(() => $).attr('class', 'divider'),
      C && (($ = v.line(y + b + E, d.height + _, y + b + E, O + _, R)), f.insert(() => $).attr('class', 'divider')),
      A &&
        (($ = v.line(y + b + k + E, d.height + _, y + b + k + E, O + _, R)), f.insert(() => $).attr('class', 'divider'))
    for (let q of m)
      ($ = v.line(E, d.height + _ + q, S + E, d.height + _ + q, R)), f.insert(() => $).attr('class', 'divider')
    if ((Ct(t, N), u && t.look !== 'handDrawn')) {
      let tt = u
        .split(';')
        ?.filter((ft) => ft.includes('stroke'))
        ?.map((ft) => `${ft}`)
        .join('; ')
      f.selectAll('path').attr('style', tt ?? ''), f.selectAll('.row-rect-even path').attr('style', u)
    }
    return (
      (t.intersect = function (q) {
        return Tt.rect(t, q)
      }),
      f
    )
  }
  async function F0(e, t, r, n = 0, i = 0, s = [], o = '') {
    let l = e
      .insert('g')
      .attr('class', `label ${s.join(' ')}`)
      .attr('transform', `translate(${n}, ${i})`)
      .attr('style', o)
    t !== eo(t) && ((t = eo(t)), (t = t.replaceAll('<', '&lt;').replaceAll('>', '&gt;')))
    let u = l.node().appendChild(await Kn(l, t, { width: Yn(t, r) + 100, style: o, useHtmlLabels: r.htmlLabels }, r))
    if (t.includes('&lt;') || t.includes('&gt;')) {
      let f = u.children[0]
      for (f.textContent = f.textContent.replaceAll('&lt;', '<').replaceAll('&gt;', '>'); f.childNodes[0]; )
        (f = f.childNodes[0]), (f.textContent = f.textContent.replaceAll('&lt;', '<').replaceAll('&gt;', '>'))
    }
    let h = u.getBBox()
    if (Pe(r.htmlLabels)) {
      let f = u.children[0]
      f.style.textAlign = 'start'
      let d = xt(u)
      ;(h = f.getBoundingClientRect()), d.attr('width', h.width), d.attr('height', h.height)
    }
    return h
  }
  var VW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    B0()
    fn()
    $a()
    Be()
    Ge()
    Ce()
    a(RA, 'erBox')
    a(F0, 'addText')
  })
  async function zW(e, t, r, n, i = r.class.padding ?? 12) {
    let s = n ? 0 : 3,
      o = e
        .insert('g')
        .attr('class', Ot(t))
        .attr('id', t.domId || t.id),
      l = null,
      u = null,
      h = null,
      f = null,
      d = 0,
      p = 0,
      m = 0
    if (((l = o.insert('g').attr('class', 'annotation-group text')), t.annotations.length > 0)) {
      let T = t.annotations[0]
      await jb(l, { text: `\xAB${T}\xBB` }, 0), (d = l.node().getBBox().height)
    }
    ;(u = o.insert('g').attr('class', 'label-group text')), await jb(u, t, 0, ['font-weight: bolder'])
    let g = u.node().getBBox()
    ;(p = g.height), (h = o.insert('g').attr('class', 'members-group text'))
    let y = 0
    for (let T of t.members) {
      let C = await jb(h, T, y, [T.parseClassifier()])
      y += C + s
    }
    ;(m = h.node().getBBox().height), m <= 0 && (m = i / 2), (f = o.insert('g').attr('class', 'methods-group text'))
    let b = 0
    for (let T of t.methods) {
      let C = await jb(f, T, b, [T.parseClassifier()])
      b += C + s
    }
    let k = o.node().getBBox()
    if (l !== null) {
      let T = l.node().getBBox()
      l.attr('transform', `translate(${-T.width / 2})`)
    }
    return (
      u.attr('transform', `translate(${-g.width / 2}, ${d})`),
      (k = o.node().getBBox()),
      h.attr('transform', `translate(0, ${d + p + i * 2})`),
      (k = o.node().getBBox()),
      f.attr('transform', `translate(0, ${d + p + (m ? m + i * 4 : i * 2)})`),
      (k = o.node().getBBox()),
      { shapeSvg: o, bbox: k }
    )
  }
  async function jb(e, t, r, n = []) {
    let i = e.insert('g').attr('class', 'label').attr('style', n.join('; ')),
      s = Te(),
      o = 'useHtmlLabels' in t ? t.useHtmlLabels : (Pe(s.htmlLabels) ?? !0),
      l = ''
    'text' in t ? (l = t.text) : (l = t.label), !o && l.startsWith('\\') && (l = l.substring(1)), $r(l) && (o = !0)
    let u = await Kn(i, lg(Xn(l)), { width: Yn(l, s) + 50, classes: 'markdown-node-label', useHtmlLabels: o }, s),
      h,
      f = 1
    if (o) {
      let d = u.children[0],
        p = xt(u)
      ;(f = d.innerHTML.split('<br>').length),
        d.innerHTML.includes('</math>') && (f += d.innerHTML.split('<mrow>').length - 1)
      let m = d.getElementsByTagName('img')
      if (m) {
        let g = l.replace(/<img[^>]*>/g, '').trim() === ''
        await Promise.all(
          [...m].map(
            (y) =>
              new Promise((b) => {
                function k() {
                  if (((y.style.display = 'flex'), (y.style.flexDirection = 'column'), g)) {
                    let T = s.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize,
                      A = parseInt(T, 10) * 5 + 'px'
                    ;(y.style.minWidth = A), (y.style.maxWidth = A)
                  } else y.style.width = '100%'
                  b(y)
                }
                a(k, 'setupImage'),
                  setTimeout(() => {
                    y.complete && k()
                  }),
                  y.addEventListener('error', k),
                  y.addEventListener('load', k)
              }),
          ),
        )
      }
      ;(h = d.getBoundingClientRect()), p.attr('width', h.width), p.attr('height', h.height)
    } else {
      n.includes('font-weight: bolder') && xt(u).selectAll('tspan').attr('font-weight', ''), (f = u.children.length)
      let d = u.children[0]
      ;(u.textContent === '' || u.textContent.includes('&gt')) &&
        ((d.textContent = l[0] + l.substring(1).replaceAll('&gt;', '>').replaceAll('&lt;', '<').trim()),
        l[1] === ' ' && (d.textContent = d.textContent[0] + ' ' + d.textContent.substring(1))),
        d.textContent === 'undefined' && (d.textContent = ''),
        (h = u.getBBox())
    }
    return i.attr('transform', 'translate(0,' + (-h.height / (2 * f) + r) + ')'), h.height
  }
  var WW = x(() => {
    'use strict'
    Ge()
    fn()
    Qt()
    Ce()
    pe()
    $a()
    Be()
    a(zW, 'textHelper')
    a(jb, 'addText')
  })
  async function UW(e, t) {
    let r = K(),
      n = r.class.padding ?? 12,
      i = n,
      s = t.useHtmlLabels ?? Pe(r.htmlLabels) ?? !0,
      o = t
    ;(o.annotations = o.annotations ?? []), (o.members = o.members ?? []), (o.methods = o.methods ?? [])
    let { shapeSvg: l, bbox: u } = await zW(e, t, r, s, i),
      { labelStyles: h, nodeStyles: f } = St(t)
    ;(t.labelStyle = h), (t.cssStyles = o.styles || '')
    let d = o.styles?.join(';') || f || ''
    t.cssStyles || (t.cssStyles = d.replaceAll('!important', '').split(';'))
    let p = o.members.length === 0 && o.methods.length === 0 && !r.class?.hideEmptyMembersBox,
      m = wt.svg(l),
      g = Et(t, {})
    t.look !== 'handDrawn' && ((g.roughness = 0), (g.fillStyle = 'solid'))
    let y = u.width,
      b = u.height
    o.members.length === 0 && o.methods.length === 0
      ? (b += i)
      : o.members.length > 0 && o.methods.length === 0 && (b += i * 2)
    let k = -y / 2,
      T = -b / 2,
      C = m.rectangle(
        k - n,
        T - n - (p ? n : o.members.length === 0 && o.methods.length === 0 ? -n / 2 : 0),
        y + 2 * n,
        b + 2 * n + (p ? n * 2 : o.members.length === 0 && o.methods.length === 0 ? -n : 0),
        g,
      ),
      A = l.insert(() => C, ':first-child')
    A.attr('class', 'basic label-container')
    let w = A.node().getBBox()
    l.selectAll('.text').each((R, F, S) => {
      let O = xt(S[F]),
        E = O.attr('transform'),
        _ = 0
      if (E) {
        let I = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(E)
        I && (_ = parseFloat(I[2]))
      }
      let L = _ + T + n - (p ? n : o.members.length === 0 && o.methods.length === 0 ? -n / 2 : 0)
      s || (L -= 4)
      let N = k
      ;(O.attr('class').includes('label-group') || O.attr('class').includes('annotation-group')) &&
        ((N = -O.node()?.getBBox().width / 2 || 0),
        l.selectAll('text').each(function (P, I, M) {
          window.getComputedStyle(M[I]).textAnchor === 'middle' && (N = 0)
        })),
        O.attr('transform', `translate(${N}, ${L})`)
    })
    let D = l.select('.annotation-group').node().getBBox().height - (p ? n / 2 : 0) || 0,
      G = l.select('.label-group').node().getBBox().height - (p ? n / 2 : 0) || 0,
      v = l.select('.members-group').node().getBBox().height - (p ? n / 2 : 0) || 0
    if (o.members.length > 0 || o.methods.length > 0 || p) {
      let R = m.line(w.x, D + G + T + n, w.x + w.width, D + G + T + n, g)
      l.insert(() => R)
        .attr('class', 'divider')
        .attr('style', d)
    }
    if (p || o.members.length > 0 || o.methods.length > 0) {
      let R = m.line(w.x, D + G + v + T + i * 2 + n, w.x + w.width, D + G + v + T + n + i * 2, g)
      l.insert(() => R)
        .attr('class', 'divider')
        .attr('style', d)
    }
    if (
      (o.look !== 'handDrawn' && l.selectAll('path').attr('style', d),
      A.select(':nth-child(2)').attr('style', d),
      l.selectAll('.divider').select('path').attr('style', d),
      t.labelStyle ? l.selectAll('span').attr('style', t.labelStyle) : l.selectAll('span').attr('style', d),
      !s)
    ) {
      let R = RegExp(/color\s*:\s*([^;]*)/),
        F = R.exec(d)
      if (F) {
        let S = F[0].replace('color', 'fill')
        l.selectAll('tspan').attr('style', S)
      } else if (h) {
        let S = R.exec(h)
        if (S) {
          let O = S[0].replace('color', 'fill')
          l.selectAll('tspan').attr('style', O)
        }
      }
    }
    return (
      Ct(t, A),
      (t.intersect = function (R) {
        return Tt.rect(t, R)
      }),
      l
    )
  }
  var jW = x(() => {
    'use strict'
    Qt()
    pe()
    Ge()
    oe()
    re()
    ae()
    WW()
    Be()
    a(UW, 'classBox')
  })
  async function qW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let i = t,
      s = t,
      o = 20,
      l = 20,
      u = 'verifyMethod' in t,
      h = Ot(t),
      f = e
        .insert('g')
        .attr('class', h)
        .attr('id', t.domId ?? t.id),
      d
    u
      ? (d = await bl(f, `&lt;&lt;${i.type}&gt;&gt;`, 0, t.labelStyle))
      : (d = await bl(f, '&lt;&lt;Element&gt;&gt;', 0, t.labelStyle))
    let p = d,
      m = await bl(f, i.name, p, t.labelStyle + '; font-weight: bold;')
    if (((p += m + l), u)) {
      let D = await bl(f, `${i.requirementId ? `ID: ${i.requirementId}` : ''}`, p, t.labelStyle)
      p += D
      let G = await bl(f, `${i.text ? `Text: ${i.text}` : ''}`, p, t.labelStyle)
      p += G
      let v = await bl(f, `${i.risk ? `Risk: ${i.risk}` : ''}`, p, t.labelStyle)
      ;(p += v), await bl(f, `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ''}`, p, t.labelStyle)
    } else {
      let D = await bl(f, `${s.type ? `Type: ${s.type}` : ''}`, p, t.labelStyle)
      ;(p += D), await bl(f, `${s.docRef ? `Doc Ref: ${s.docRef}` : ''}`, p, t.labelStyle)
    }
    let g = (f.node()?.getBBox().width ?? 200) + o,
      y = (f.node()?.getBBox().height ?? 200) + o,
      b = -g / 2,
      k = -y / 2,
      T = wt.svg(f),
      C = Et(t, {})
    t.look !== 'handDrawn' && ((C.roughness = 0), (C.fillStyle = 'solid'))
    let A = T.rectangle(b, k, g, y, C),
      w = f.insert(() => A, ':first-child')
    if (
      (w.attr('class', 'basic label-container').attr('style', n),
      f.selectAll('.label').each((D, G, v) => {
        let R = xt(v[G]),
          F = R.attr('transform'),
          S = 0,
          O = 0
        if (F) {
          let N = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(F)
          N && ((S = parseFloat(N[1])), (O = parseFloat(N[2])))
        }
        let E = O - y / 2,
          _ = b + o / 2
        ;(G === 0 || G === 1) && (_ = S), R.attr('transform', `translate(${_}, ${E + o})`)
      }),
      p > d + m + l)
    ) {
      let D = T.line(b, k + d + m + l, b + g, k + d + m + l, C)
      f.insert(() => D).attr('style', n)
    }
    return (
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.rect(t, D)
      }),
      f
    )
  }
  async function bl(e, t, r, n = '') {
    if (t === '') return 0
    let i = e.insert('g').attr('class', 'label').attr('style', n),
      s = K(),
      o = s.htmlLabels ?? !0,
      l = await Kn(
        i,
        lg(Xn(t)),
        { width: Yn(t, s) + 50, classes: 'markdown-node-label', useHtmlLabels: o, style: n },
        s,
      ),
      u
    if (o) {
      let h = l.children[0],
        f = xt(l)
      ;(u = h.getBoundingClientRect()), f.attr('width', u.width), f.attr('height', u.height)
    } else {
      let h = l.children[0]
      for (let f of h.children)
        (f.textContent = f.textContent.replaceAll('&gt;', '>').replaceAll('&lt;', '<')), n && f.setAttribute('style', n)
      ;(u = l.getBBox()), (u.height += 6)
    }
    return i.attr('transform', `translate(${-u.width / 2},${-u.height / 2 + r})`), u.height
  }
  var HW = x(() => {
    'use strict'
    Qt()
    ae()
    re()
    oe()
    Ce()
    pe()
    $a()
    Ge()
    a(qW, 'requirementBox')
    a(bl, 'addText')
  })
  async function YW(e, t, { config: r }) {
    let { labelStyles: n, nodeStyles: i } = St(t)
    t.labelStyle = n || ''
    let s = 10,
      o = t.width
    t.width = (t.width ?? 200) - 10
    let { shapeSvg: l, bbox: u, label: h } = await Bt(e, t, Ot(t)),
      f = t.padding || 10,
      d = '',
      p
    'ticket' in t &&
      t.ticket &&
      r?.kanban?.ticketBaseUrl &&
      ((d = r?.kanban?.ticketBaseUrl.replace('#TICKET#', t.ticket)),
      (p = l
        .insert('svg:a', ':first-child')
        .attr('class', 'kanban-ticket-link')
        .attr('xlink:href', d)
        .attr('target', '_blank')))
    let m = {
        useHtmlLabels: t.useHtmlLabels,
        labelStyle: t.labelStyle || '',
        width: t.width,
        img: t.img,
        padding: t.padding || 8,
        centerLabel: !1,
      },
      g,
      y
    p
      ? ({ label: g, bbox: y } = await Db(p, ('ticket' in t && t.ticket) || '', m))
      : ({ label: g, bbox: y } = await Db(l, ('ticket' in t && t.ticket) || '', m))
    let { label: b, bbox: k } = await Db(l, ('assigned' in t && t.assigned) || '', m)
    t.width = o
    let T = 10,
      C = t?.width || 0,
      A = Math.max(y.height, k.height) / 2,
      w = Math.max(u.height + T * 2, t?.height || 0) + A,
      D = -C / 2,
      G = -w / 2
    h.attr('transform', 'translate(' + (f - C / 2) + ', ' + (-A - u.height / 2) + ')'),
      g.attr('transform', 'translate(' + (f - C / 2) + ', ' + (-A + u.height / 2) + ')'),
      b.attr('transform', 'translate(' + (f + C / 2 - k.width - 2 * s) + ', ' + (-A + u.height / 2) + ')')
    let v,
      { rx: R, ry: F } = t,
      { cssStyles: S } = t
    if (t.look === 'handDrawn') {
      let O = wt.svg(l),
        E = Et(t, {}),
        _ = R || F ? O.path(us(D, G, C, w, R || 0), E) : O.rectangle(D, G, C, w, E)
      ;(v = l.insert(() => _, ':first-child')), v.attr('class', 'basic label-container').attr('style', S || null)
    } else {
      ;(v = l.insert('rect', ':first-child')),
        v
          .attr('class', 'basic label-container __APA__')
          .attr('style', i)
          .attr('rx', R ?? 5)
          .attr('ry', F ?? 5)
          .attr('x', D)
          .attr('y', G)
          .attr('width', C)
          .attr('height', w)
      let O = 'priority' in t && t.priority
      if (O) {
        let E = l.append('line'),
          _ = D + 2,
          L = G + Math.floor((R ?? 0) / 2),
          N = G + w - Math.floor((R ?? 0) / 2)
        E.attr('x1', _).attr('y1', L).attr('x2', _).attr('y2', N).attr('stroke-width', '4').attr('stroke', Gbt(O))
      }
    }
    return (
      Ct(t, v),
      (t.height = w),
      (t.intersect = function (O) {
        return Tt.rect(t, O)
      }),
      l
    )
  }
  var Gbt,
    XW = x(() => {
      'use strict'
      Qt()
      ae()
      eh()
      re()
      oe()
      Gbt = a((e) => {
        switch (e) {
          case 'Very High':
            return 'red'
          case 'High':
            return 'orange'
          case 'Medium':
            return null
          case 'Low':
            return 'blue'
          case 'Very Low':
            return 'lightblue'
        }
      }, 'colorFromPriority')
      a(YW, 'kanbanItem')
    })
  async function KW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, halfPadding: o, label: l } = await Bt(e, t, Ot(t)),
      u = s.width + 10 * o,
      h = s.height + 8 * o,
      f = 0.15 * u,
      { cssStyles: d } = t,
      p = s.width + 20,
      m = s.height + 20,
      g = Math.max(u, p),
      y = Math.max(h, m)
    l.attr('transform', `translate(${-s.width / 2}, ${-s.height / 2})`)
    let b,
      k = `M0 0
    a${f},${f} 1 0,0 ${g * 0.25},${-1 * y * 0.1}
    a${f},${f} 1 0,0 ${g * 0.25},0
    a${f},${f} 1 0,0 ${g * 0.25},0
    a${f},${f} 1 0,0 ${g * 0.25},${y * 0.1}

    a${f},${f} 1 0,0 ${g * 0.15},${y * 0.33}
    a${f * 0.8},${f * 0.8} 1 0,0 0,${y * 0.34}
    a${f},${f} 1 0,0 ${-1 * g * 0.15},${y * 0.33}

    a${f},${f} 1 0,0 ${-1 * g * 0.25},${y * 0.15}
    a${f},${f} 1 0,0 ${-1 * g * 0.25},0
    a${f},${f} 1 0,0 ${-1 * g * 0.25},0
    a${f},${f} 1 0,0 ${-1 * g * 0.25},${-1 * y * 0.15}

    a${f},${f} 1 0,0 ${-1 * g * 0.1},${-1 * y * 0.33}
    a${f * 0.8},${f * 0.8} 1 0,0 0,${-1 * y * 0.34}
    a${f},${f} 1 0,0 ${g * 0.1},${-1 * y * 0.33}
  H0 V0 Z`
    if (t.look === 'handDrawn') {
      let T = wt.svg(i),
        C = Et(t, {}),
        A = T.path(k, C)
      ;(b = i.insert(() => A, ':first-child')), b.attr('class', 'basic label-container').attr('style', Ir(d))
    } else b = i.insert('path', ':first-child').attr('class', 'basic label-container').attr('style', n).attr('d', k)
    return (
      b.attr('transform', `translate(${-g / 2}, ${-y / 2})`),
      Ct(t, b),
      (t.calcIntersect = function (T, C) {
        return Tt.rect(T, C)
      }),
      (t.intersect = function (T) {
        return B.info('Bang intersect', t, T), Tt.rect(t, T)
      }),
      i
    )
  }
  var QW = x(() => {
    'use strict'
    Vt()
    Qt()
    ae()
    re()
    oe()
    Ce()
    a(KW, 'bang')
  })
  async function ZW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, halfPadding: o, label: l } = await Bt(e, t, Ot(t)),
      u = s.width + 2 * o,
      h = s.height + 2 * o,
      f = 0.15 * u,
      d = 0.25 * u,
      p = 0.35 * u,
      m = 0.2 * u,
      { cssStyles: g } = t,
      y,
      b = `M0 0
    a${f},${f} 0 0,1 ${u * 0.25},${-1 * u * 0.1}
    a${p},${p} 1 0,1 ${u * 0.4},${-1 * u * 0.1}
    a${d},${d} 1 0,1 ${u * 0.35},${u * 0.2}

    a${f},${f} 1 0,1 ${u * 0.15},${h * 0.35}
    a${m},${m} 1 0,1 ${-1 * u * 0.15},${h * 0.65}

    a${d},${f} 1 0,1 ${-1 * u * 0.25},${u * 0.15}
    a${p},${p} 1 0,1 ${-1 * u * 0.5},0
    a${f},${f} 1 0,1 ${-1 * u * 0.25},${-1 * u * 0.15}

    a${f},${f} 1 0,1 ${-1 * u * 0.1},${-1 * h * 0.35}
    a${m},${m} 1 0,1 ${u * 0.1},${-1 * h * 0.65}
  H0 V0 Z`
    if (t.look === 'handDrawn') {
      let k = wt.svg(i),
        T = Et(t, {}),
        C = k.path(b, T)
      ;(y = i.insert(() => C, ':first-child')), y.attr('class', 'basic label-container').attr('style', Ir(g))
    } else y = i.insert('path', ':first-child').attr('class', 'basic label-container').attr('style', n).attr('d', b)
    return (
      l.attr('transform', `translate(${-s.width / 2}, ${-s.height / 2})`),
      y.attr('transform', `translate(${-u / 2}, ${-h / 2})`),
      Ct(t, y),
      (t.calcIntersect = function (k, T) {
        return Tt.rect(k, T)
      }),
      (t.intersect = function (k) {
        return B.info('Cloud intersect', t, k), Tt.rect(t, k)
      }),
      i
    )
  }
  var JW = x(() => {
    'use strict'
    oe()
    Vt()
    Ce()
    ae()
    re()
    Qt()
    a(ZW, 'cloud')
  })
  async function tU(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t)
    t.labelStyle = r
    let { shapeSvg: i, bbox: s, halfPadding: o, label: l } = await Bt(e, t, Ot(t)),
      u = s.width + 8 * o,
      h = s.height + 2 * o,
      f = 5,
      d = `
    M${-u / 2} ${h / 2 - f}
    v${-h + 2 * f}
    q0,-${f} ${f},-${f}
    h${u - 2 * f}
    q${f},0 ${f},${f}
    v${h - 2 * f}
    q0,${f} -${f},${f}
    h${-u + 2 * f}
    q-${f},0 -${f},-${f}
    Z
  `,
      p = i
        .append('path')
        .attr('id', 'node-' + t.id)
        .attr('class', 'node-bkg node-' + t.type)
        .attr('style', n)
        .attr('d', d)
    return (
      i
        .append('line')
        .attr('class', 'node-line-')
        .attr('x1', -u / 2)
        .attr('y1', h / 2)
        .attr('x2', u / 2)
        .attr('y2', h / 2),
      l.attr('transform', `translate(${-s.width / 2}, ${-s.height / 2})`),
      i.append(() => l.node()),
      Ct(t, p),
      (t.calcIntersect = function (m, g) {
        return Tt.rect(m, g)
      }),
      (t.intersect = function (m) {
        return Tt.rect(t, m)
      }),
      i
    )
  }
  var eU = x(() => {
    'use strict'
    ae()
    re()
    Qt()
    a(tU, 'defaultMindmapNode')
  })
  async function rU(e, t) {
    let r = { padding: t.padding ?? 0 }
    return zb(e, t, r)
  }
  var nU = x(() => {
    'use strict'
    LA()
    a(rU, 'mindmapCircle')
  })
  function iU(e) {
    return e in DA
  }
  var Vbt,
    zbt,
    DA,
    NA = x(() => {
      'use strict'
      $V()
      zV()
      UV()
      qV()
      LA()
      YV()
      KV()
      ZV()
      tz()
      rz()
      iz()
      az()
      lz()
      uz()
      fz()
      pz()
      gz()
      xz()
      kz()
      Sz()
      Cz()
      Ez()
      Az()
      Rz()
      Nz()
      Mz()
      Pz()
      Fz()
      Gz()
      zz()
      Uz()
      qz()
      Yz()
      Kz()
      Zz()
      tW()
      rW()
      iW()
      aW()
      lW()
      uW()
      fW()
      pW()
      gW()
      xW()
      kW()
      SW()
      CW()
      EW()
      AW()
      RW()
      NW()
      MW()
      PW()
      FW()
      GW()
      VW()
      jW()
      HW()
      XW()
      QW()
      JW()
      eU()
      nU()
      ;(Vbt = [
        {
          semanticName: 'Process',
          name: 'Rectangle',
          shortName: 'rect',
          description: 'Standard process shape',
          aliases: ['proc', 'process', 'rectangle'],
          internalAliases: ['squareRect'],
          handler: cW,
        },
        {
          semanticName: 'Event',
          name: 'Rounded Rectangle',
          shortName: 'rounded',
          description: 'Represents an event',
          aliases: ['event'],
          internalAliases: ['roundedRect'],
          handler: nW,
        },
        {
          semanticName: 'Terminal Point',
          name: 'Stadium',
          shortName: 'stadium',
          description: 'Terminal point',
          aliases: ['terminal', 'pill'],
          handler: hW,
        },
        {
          semanticName: 'Subprocess',
          name: 'Framed Rectangle',
          shortName: 'fr-rect',
          description: 'Subprocess',
          aliases: ['subprocess', 'subproc', 'framed-rectangle', 'subroutine'],
          handler: bW,
        },
        {
          semanticName: 'Database',
          name: 'Cylinder',
          shortName: 'cyl',
          description: 'Database storage',
          aliases: ['db', 'database', 'cylinder'],
          handler: nz,
        },
        {
          semanticName: 'Start',
          name: 'Circle',
          shortName: 'circle',
          description: 'Starting point',
          aliases: ['circ'],
          handler: zb,
        },
        { semanticName: 'Bang', name: 'Bang', shortName: 'bang', description: 'Bang', aliases: ['bang'], handler: KW },
        {
          semanticName: 'Cloud',
          name: 'Cloud',
          shortName: 'cloud',
          description: 'cloud',
          aliases: ['cloud'],
          handler: ZW,
        },
        {
          semanticName: 'Decision',
          name: 'Diamond',
          shortName: 'diam',
          description: 'Decision-making step',
          aliases: ['decision', 'diamond', 'question'],
          handler: Qz,
        },
        {
          semanticName: 'Prepare Conditional',
          name: 'Hexagon',
          shortName: 'hex',
          description: 'Preparation or condition step',
          aliases: ['hexagon', 'prepare'],
          handler: yz,
        },
        {
          semanticName: 'Data Input/Output',
          name: 'Lean Right',
          shortName: 'lean-r',
          description: 'Represents input or output',
          aliases: ['lean-right', 'in-out'],
          internalAliases: ['lean_right'],
          handler: Bz,
        },
        {
          semanticName: 'Data Input/Output',
          name: 'Lean Left',
          shortName: 'lean-l',
          description: 'Represents output or input',
          aliases: ['lean-left', 'out-in'],
          internalAliases: ['lean_left'],
          handler: Oz,
        },
        {
          semanticName: 'Priority Action',
          name: 'Trapezoid Base Bottom',
          shortName: 'trap-b',
          description: 'Priority action',
          aliases: ['priority', 'trapezoid-bottom', 'trapezoid'],
          handler: LW,
        },
        {
          semanticName: 'Manual Operation',
          name: 'Trapezoid Base Top',
          shortName: 'trap-t',
          description: 'Represents a manual task',
          aliases: ['manual', 'trapezoid-top', 'inv-trapezoid'],
          internalAliases: ['inv_trapezoid'],
          handler: Dz,
        },
        {
          semanticName: 'Stop',
          name: 'Double Circle',
          shortName: 'dbl-circ',
          description: 'Represents a stop point',
          aliases: ['double-circle'],
          internalAliases: ['doublecircle'],
          handler: oz,
        },
        { semanticName: 'Text Block', name: 'Text Block', shortName: 'text', description: 'Text block', handler: wW },
        {
          semanticName: 'Card',
          name: 'Notched Rectangle',
          shortName: 'notch-rect',
          description: 'Represents a card',
          aliases: ['card', 'notched-rectangle'],
          handler: WV,
        },
        {
          semanticName: 'Lined/Shaded Process',
          name: 'Lined Rectangle',
          shortName: 'lin-rect',
          description: 'Lined process shape',
          aliases: ['lined-rectangle', 'lined-process', 'lin-proc', 'shaded-process'],
          handler: sW,
        },
        {
          semanticName: 'Start',
          name: 'Small Circle',
          shortName: 'sm-circ',
          description: 'Small starting point',
          aliases: ['start', 'small-circle'],
          internalAliases: ['stateStart'],
          handler: yW,
        },
        {
          semanticName: 'Stop',
          name: 'Framed Circle',
          shortName: 'fr-circ',
          description: 'Stop point',
          aliases: ['stop', 'framed-circle'],
          internalAliases: ['stateEnd'],
          handler: mW,
        },
        {
          semanticName: 'Fork/Join',
          name: 'Filled Rectangle',
          shortName: 'fork',
          description: 'Fork or join in process flow',
          aliases: ['join'],
          internalAliases: ['forkJoin'],
          handler: dz,
        },
        {
          semanticName: 'Collate',
          name: 'Hourglass',
          shortName: 'hourglass',
          description: 'Represents a collate operation',
          aliases: ['hourglass', 'collate'],
          handler: bz,
        },
        {
          semanticName: 'Comment',
          name: 'Curly Brace',
          shortName: 'brace',
          description: 'Adds a comment',
          aliases: ['comment', 'brace-l'],
          handler: XV,
        },
        {
          semanticName: 'Comment Right',
          name: 'Curly Brace',
          shortName: 'brace-r',
          description: 'Adds a comment',
          handler: QV,
        },
        {
          semanticName: 'Comment with braces on both sides',
          name: 'Curly Braces',
          shortName: 'braces',
          description: 'Adds a comment',
          handler: JV,
        },
        {
          semanticName: 'Com Link',
          name: 'Lightning Bolt',
          shortName: 'bolt',
          description: 'Communication link',
          aliases: ['com-link', 'lightning-bolt'],
          handler: $z,
        },
        {
          semanticName: 'Document',
          name: 'Document',
          shortName: 'doc',
          description: 'Represents a document',
          aliases: ['doc', 'document'],
          handler: OW,
        },
        {
          semanticName: 'Delay',
          name: 'Half-Rounded Rectangle',
          shortName: 'delay',
          description: 'Represents a delay',
          aliases: ['half-rounded-rectangle'],
          handler: mz,
        },
        {
          semanticName: 'Direct Access Storage',
          name: 'Horizontal Cylinder',
          shortName: 'h-cyl',
          description: 'Direct access storage',
          aliases: ['das', 'horizontal-cylinder'],
          handler: vW,
        },
        {
          semanticName: 'Disk Storage',
          name: 'Lined Cylinder',
          shortName: 'lin-cyl',
          description: 'Disk storage',
          aliases: ['disk', 'lined-cylinder'],
          handler: Vz,
        },
        {
          semanticName: 'Display',
          name: 'Curved Trapezoid',
          shortName: 'curv-trap',
          description: 'Represents a display',
          aliases: ['curved-trapezoid', 'display'],
          handler: ez,
        },
        {
          semanticName: 'Divided Process',
          name: 'Divided Rectangle',
          shortName: 'div-rect',
          description: 'Divided process shape',
          aliases: ['div-proc', 'divided-rectangle', 'divided-process'],
          handler: sz,
        },
        {
          semanticName: 'Extract',
          name: 'Triangle',
          shortName: 'tri',
          description: 'Extraction process',
          aliases: ['extract', 'triangle'],
          handler: IW,
        },
        {
          semanticName: 'Internal Storage',
          name: 'Window Pane',
          shortName: 'win-pane',
          description: 'Internal storage',
          aliases: ['internal-storage', 'window-pane'],
          handler: $W,
        },
        {
          semanticName: 'Junction',
          name: 'Filled Circle',
          shortName: 'f-circ',
          description: 'Junction point',
          aliases: ['junction', 'filled-circle'],
          handler: cz,
        },
        {
          semanticName: 'Loop Limit',
          name: 'Trapezoidal Pentagon',
          shortName: 'notch-pent',
          description: 'Loop limit step',
          aliases: ['loop-limit', 'notched-pentagon'],
          handler: DW,
        },
        {
          semanticName: 'Manual File',
          name: 'Flipped Triangle',
          shortName: 'flip-tri',
          description: 'Manual file operation',
          aliases: ['manual-file', 'flipped-triangle'],
          handler: hz,
        },
        {
          semanticName: 'Manual Input',
          name: 'Sloped Rectangle',
          shortName: 'sl-rect',
          description: 'Manual input step',
          aliases: ['manual-input', 'sloped-rectangle'],
          handler: oW,
        },
        {
          semanticName: 'Multi-Document',
          name: 'Stacked Document',
          shortName: 'docs',
          description: 'Multiple documents',
          aliases: ['documents', 'st-doc', 'stacked-document'],
          handler: Hz,
        },
        {
          semanticName: 'Multi-Process',
          name: 'Stacked Rectangle',
          shortName: 'st-rect',
          description: 'Multiple processes',
          aliases: ['procs', 'processes', 'stacked-rectangle'],
          handler: jz,
        },
        {
          semanticName: 'Stored Data',
          name: 'Bow Tie Rectangle',
          shortName: 'bow-rect',
          description: 'Stored data',
          aliases: ['stored-data', 'bow-tie-rectangle'],
          handler: VV,
        },
        {
          semanticName: 'Summary',
          name: 'Crossed Circle',
          shortName: 'cross-circ',
          description: 'Summary',
          aliases: ['summary', 'crossed-circle'],
          handler: HV,
        },
        {
          semanticName: 'Tagged Document',
          name: 'Tagged Document',
          shortName: 'tag-doc',
          description: 'Tagged document',
          aliases: ['tag-doc', 'tagged-document'],
          handler: _W,
        },
        {
          semanticName: 'Tagged Process',
          name: 'Tagged Rectangle',
          shortName: 'tag-rect',
          description: 'Tagged process',
          aliases: ['tagged-rectangle', 'tag-proc', 'tagged-process'],
          handler: TW,
        },
        {
          semanticName: 'Paper Tape',
          name: 'Flag',
          shortName: 'flag',
          description: 'Paper tape',
          aliases: ['paper-tape'],
          handler: BW,
        },
        {
          semanticName: 'Odd',
          name: 'Odd',
          shortName: 'odd',
          description: 'Odd shape',
          internalAliases: ['rect_left_inv_arrow'],
          handler: Jz,
        },
        {
          semanticName: 'Lined Document',
          name: 'Lined Document',
          shortName: 'lin-doc',
          description: 'Lined document',
          aliases: ['lined-document'],
          handler: Wz,
        },
      ]),
        (zbt = a(() => {
          let t = [
            ...Object.entries({
              state: dW,
              choice: jV,
              note: Xz,
              rectWithTitle: eW,
              labelRect: Iz,
              iconSquare: vz,
              iconCircle: _z,
              icon: Tz,
              iconRounded: wz,
              imageSquare: Lz,
              anchor: FV,
              kanbanItem: YW,
              mindmapCircle: rU,
              defaultMindmapNode: tU,
              classBox: UW,
              erBox: RA,
              requirementBox: qW,
            }),
            ...Vbt.flatMap((r) =>
              [
                r.shortName,
                ...('aliases' in r ? r.aliases : []),
                ...('internalAliases' in r ? r.internalAliases : []),
              ].map((i) => [i, r.handler]),
            ),
          ]
          return Object.fromEntries(t)
        }, 'generateShapeMap')),
        (DA = zbt())
      a(iU, 'isValidShape')
    })
  var Wbt,
    qb,
    sU = x(() => {
      'use strict'
      Ge()
      E0()
      pe()
      Vt()
      NA()
      Ce()
      Be()
      bn()
      ;(Wbt = 'flowchart-'),
        (qb = class {
          constructor() {
            this.vertexCounter = 0
            this.config = K()
            this.vertices = new Map()
            this.edges = []
            this.classes = new Map()
            this.subGraphs = []
            this.subGraphLookup = new Map()
            this.tooltips = new Map()
            this.subCount = 0
            this.firstGraphFlag = !0
            this.secCount = -1
            this.posCrossRef = []
            this.funs = []
            this.setAccTitle = Xe
            this.setAccDescription = er
            this.setDiagramTitle = lr
            this.getAccTitle = tr
            this.getAccDescription = rr
            this.getDiagramTitle = nr
            this.funs.push(this.setupToolTips.bind(this)),
              (this.addVertex = this.addVertex.bind(this)),
              (this.firstGraph = this.firstGraph.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.addSubGraph = this.addSubGraph.bind(this)),
              (this.addLink = this.addLink.bind(this)),
              (this.setLink = this.setLink.bind(this)),
              (this.updateLink = this.updateLink.bind(this)),
              (this.addClass = this.addClass.bind(this)),
              (this.setClass = this.setClass.bind(this)),
              (this.destructLink = this.destructLink.bind(this)),
              (this.setClickEvent = this.setClickEvent.bind(this)),
              (this.setTooltip = this.setTooltip.bind(this)),
              (this.updateLinkInterpolate = this.updateLinkInterpolate.bind(this)),
              (this.setClickFun = this.setClickFun.bind(this)),
              (this.bindFunctions = this.bindFunctions.bind(this)),
              (this.lex = { firstGraph: this.firstGraph.bind(this) }),
              this.clear(),
              this.setGen('gen-2')
          }
          static {
            a(this, 'FlowDB')
          }
          sanitizeText(t) {
            return Rt.sanitizeText(t, this.config)
          }
          lookUpDomId(t) {
            for (let r of this.vertices.values()) if (r.id === t) return r.domId
            return t
          }
          addVertex(t, r, n, i, s, o, l = {}, u) {
            if (!t || t.trim().length === 0) return
            let h
            if (u !== void 0) {
              let m
              u.includes(`
`)
                ? (m =
                    u +
                    `
`)
                : (m =
                    `{
` +
                    u +
                    `
}`),
                (h = Cc(m, { schema: _c }))
            }
            let f = this.edges.find((m) => m.id === t)
            if (f) {
              let m = h
              m?.animate !== void 0 && (f.animate = m.animate),
                m?.animation !== void 0 && (f.animation = m.animation),
                m?.curve !== void 0 && (f.interpolate = m.curve)
              return
            }
            let d,
              p = this.vertices.get(t)
            if (
              (p === void 0 &&
                ((p = { id: t, labelType: 'text', domId: Wbt + t + '-' + this.vertexCounter, styles: [], classes: [] }),
                this.vertices.set(t, p)),
              this.vertexCounter++,
              r !== void 0
                ? ((this.config = K()),
                  (d = this.sanitizeText(r.text.trim())),
                  (p.labelType = r.type),
                  d.startsWith('"') && d.endsWith('"') && (d = d.substring(1, d.length - 1)),
                  (p.text = d))
                : p.text === void 0 && (p.text = t),
              n !== void 0 && (p.type = n),
              i?.forEach((m) => {
                p.styles.push(m)
              }),
              s?.forEach((m) => {
                p.classes.push(m)
              }),
              o !== void 0 && (p.dir = o),
              p.props === void 0 ? (p.props = l) : l !== void 0 && Object.assign(p.props, l),
              h !== void 0)
            ) {
              if (h.shape) {
                if (h.shape !== h.shape.toLowerCase() || h.shape.includes('_'))
                  throw new Error(`No such shape: ${h.shape}. Shape names should be lowercase.`)
                if (!iU(h.shape)) throw new Error(`No such shape: ${h.shape}.`)
                p.type = h?.shape
              }
              h?.label && (p.text = h?.label),
                h?.icon && ((p.icon = h?.icon), !h.label?.trim() && p.text === t && (p.text = '')),
                h?.form && (p.form = h?.form),
                h?.pos && (p.pos = h?.pos),
                h?.img && ((p.img = h?.img), !h.label?.trim() && p.text === t && (p.text = '')),
                h?.constraint && (p.constraint = h.constraint),
                h.w && (p.assetWidth = Number(h.w)),
                h.h && (p.assetHeight = Number(h.h))
            }
          }
          addSingleLink(t, r, n, i) {
            let l = {
              start: t,
              end: r,
              type: void 0,
              text: '',
              labelType: 'text',
              classes: [],
              isUserDefinedId: !1,
              interpolate: this.edges.defaultInterpolate,
            }
            B.info('abc78 Got edge...', l)
            let u = n.text
            if (
              (u !== void 0 &&
                ((l.text = this.sanitizeText(u.text.trim())),
                l.text.startsWith('"') && l.text.endsWith('"') && (l.text = l.text.substring(1, l.text.length - 1)),
                (l.labelType = u.type)),
              n !== void 0 && ((l.type = n.type), (l.stroke = n.stroke), (l.length = n.length > 10 ? 10 : n.length)),
              i && !this.edges.some((h) => h.id === i))
            )
              (l.id = i), (l.isUserDefinedId = !0)
            else {
              let h = this.edges.filter((f) => f.start === l.start && f.end === l.end)
              h.length === 0
                ? (l.id = kc(l.start, l.end, { counter: 0, prefix: 'L' }))
                : (l.id = kc(l.start, l.end, { counter: h.length + 1, prefix: 'L' }))
            }
            if (this.edges.length < (this.config.maxEdges ?? 500)) B.info('Pushing edge...'), this.edges.push(l)
            else
              throw new Error(`Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`)
          }
          isLinkData(t) {
            return t !== null && typeof t == 'object' && 'id' in t && typeof t.id == 'string'
          }
          addLink(t, r, n) {
            let i = this.isLinkData(n) ? n.id.replace('@', '') : void 0
            B.info('addLink', t, r, i)
            for (let s of t)
              for (let o of r) {
                let l = s === t[t.length - 1],
                  u = o === r[0]
                l && u ? this.addSingleLink(s, o, n, i) : this.addSingleLink(s, o, n, void 0)
              }
          }
          updateLinkInterpolate(t, r) {
            t.forEach((n) => {
              n === 'default' ? (this.edges.defaultInterpolate = r) : (this.edges[n].interpolate = r)
            })
          }
          updateLink(t, r) {
            t.forEach((n) => {
              if (typeof n == 'number' && n >= this.edges.length)
                throw new Error(
                  `The index ${n} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`,
                )
              n === 'default'
                ? (this.edges.defaultStyle = r)
                : ((this.edges[n].style = r),
                  (this.edges[n]?.style?.length ?? 0) > 0 &&
                    !this.edges[n]?.style?.some((i) => i?.startsWith('fill')) &&
                    this.edges[n]?.style?.push('fill:none'))
            })
          }
          addClass(t, r) {
            let n = r.join().replace(/\\,/g, '\xA7\xA7\xA7').replace(/,/g, ';').replace(//g, ',').split(';')
            t.split(',').forEach((i) => {
              let s = this.classes.get(i)
              s === void 0 && ((s = { id: i, styles: [], textStyles: [] }), this.classes.set(i, s)),
                n?.forEach((o) => {
                  if (/color/.exec(o)) {
                    let l = o.replace('fill', 'bgFill')
                    s.textStyles.push(l)
                  }
                  s.styles.push(o)
                })
            })
          }
          setDirection(t) {
            ;(this.direction = t.trim()),
              /.*</.exec(this.direction) && (this.direction = 'RL'),
              /.*\^/.exec(this.direction) && (this.direction = 'BT'),
              /.*>/.exec(this.direction) && (this.direction = 'LR'),
              /.*v/.exec(this.direction) && (this.direction = 'TB'),
              this.direction === 'TD' && (this.direction = 'TB')
          }
          setClass(t, r) {
            for (let n of t.split(',')) {
              let i = this.vertices.get(n)
              i && i.classes.push(r)
              let s = this.edges.find((l) => l.id === n)
              s && s.classes.push(r)
              let o = this.subGraphLookup.get(n)
              o && o.classes.push(r)
            }
          }
          setTooltip(t, r) {
            if (r !== void 0) {
              r = this.sanitizeText(r)
              for (let n of t.split(',')) this.tooltips.set(this.version === 'gen-1' ? this.lookUpDomId(n) : n, r)
            }
          }
          setClickFun(t, r, n) {
            let i = this.lookUpDomId(t)
            if (K().securityLevel !== 'loose' || r === void 0) return
            let s = []
            if (typeof n == 'string') {
              s = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
              for (let l = 0; l < s.length; l++) {
                let u = s[l].trim()
                u.startsWith('"') && u.endsWith('"') && (u = u.substr(1, u.length - 2)), (s[l] = u)
              }
            }
            s.length === 0 && s.push(t)
            let o = this.vertices.get(t)
            o &&
              ((o.haveCallback = !0),
              this.funs.push(() => {
                let l = document.querySelector(`[id="${i}"]`)
                l !== null &&
                  l.addEventListener(
                    'click',
                    () => {
                      le.runFunc(r, ...s)
                    },
                    !1,
                  )
              }))
          }
          setLink(t, r, n) {
            t.split(',').forEach((i) => {
              let s = this.vertices.get(i)
              s !== void 0 && ((s.link = le.formatUrl(r, this.config)), (s.linkTarget = n))
            }),
              this.setClass(t, 'clickable')
          }
          getTooltip(t) {
            return this.tooltips.get(t)
          }
          setClickEvent(t, r, n) {
            t.split(',').forEach((i) => {
              this.setClickFun(i, r, n)
            }),
              this.setClass(t, 'clickable')
          }
          bindFunctions(t) {
            this.funs.forEach((r) => {
              r(t)
            })
          }
          getDirection() {
            return this.direction?.trim()
          }
          getVertices() {
            return this.vertices
          }
          getEdges() {
            return this.edges
          }
          getClasses() {
            return this.classes
          }
          setupToolTips(t) {
            let r = xt('.mermaidTooltip')
            ;(r._groups || r)[0][0] === null &&
              (r = xt('body').append('div').attr('class', 'mermaidTooltip').style('opacity', 0)),
              xt(t)
                .select('svg')
                .selectAll('g.node')
                .on('mouseover', (s) => {
                  let o = xt(s.currentTarget)
                  if (o.attr('title') === null) return
                  let u = s.currentTarget?.getBoundingClientRect()
                  r.transition().duration(200).style('opacity', '.9'),
                    r
                      .text(o.attr('title'))
                      .style('left', window.scrollX + u.left + (u.right - u.left) / 2 + 'px')
                      .style('top', window.scrollY + u.bottom + 'px'),
                    r.html(r.html().replace(/&lt;br\/&gt;/g, '<br/>')),
                    o.classed('hover', !0)
                })
                .on('mouseout', (s) => {
                  r.transition().duration(500).style('opacity', 0), xt(s.currentTarget).classed('hover', !1)
                })
          }
          clear(t = 'gen-2') {
            ;(this.vertices = new Map()),
              (this.classes = new Map()),
              (this.edges = []),
              (this.funs = [this.setupToolTips.bind(this)]),
              (this.subGraphs = []),
              (this.subGraphLookup = new Map()),
              (this.subCount = 0),
              (this.tooltips = new Map()),
              (this.firstGraphFlag = !0),
              (this.version = t),
              (this.config = K()),
              Ye()
          }
          setGen(t) {
            this.version = t || 'gen-2'
          }
          defaultStyle() {
            return 'fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;'
          }
          addSubGraph(t, r, n) {
            let i = t.text.trim(),
              s = n.text
            t === n && /\s/.exec(n.text) && (i = void 0)
            let l = a((p) => {
                let m = { boolean: {}, number: {}, string: {} },
                  g = [],
                  y
                return {
                  nodeList: p.filter(function (k) {
                    let T = typeof k
                    return k.stmt && k.stmt === 'dir'
                      ? ((y = k.value), !1)
                      : k.trim() === ''
                        ? !1
                        : T in m
                          ? m[T].hasOwnProperty(k)
                            ? !1
                            : (m[T][k] = !0)
                          : g.includes(k)
                            ? !1
                            : g.push(k)
                  }),
                  dir: y,
                }
              }, 'uniq')(r.flat()),
              u = l.nodeList,
              h = l.dir,
              f = K().flowchart ?? {}
            if (
              ((h = h ?? (f.inheritDir ? (this.getDirection() ?? K().direction ?? void 0) : void 0)),
              this.version === 'gen-1')
            )
              for (let p = 0; p < u.length; p++) u[p] = this.lookUpDomId(u[p])
            ;(i = i ?? 'subGraph' + this.subCount),
              (s = s || ''),
              (s = this.sanitizeText(s)),
              (this.subCount = this.subCount + 1)
            let d = { id: i, nodes: u, title: s.trim(), classes: [], dir: h, labelType: n.type }
            return (
              B.info('Adding', d.id, d.nodes, d.dir),
              (d.nodes = this.makeUniq(d, this.subGraphs).nodes),
              this.subGraphs.push(d),
              this.subGraphLookup.set(i, d),
              i
            )
          }
          getPosForId(t) {
            for (let [r, n] of this.subGraphs.entries()) if (n.id === t) return r
            return -1
          }
          indexNodes2(t, r) {
            let n = this.subGraphs[r].nodes
            if (((this.secCount = this.secCount + 1), this.secCount > 2e3)) return { result: !1, count: 0 }
            if (((this.posCrossRef[this.secCount] = r), this.subGraphs[r].id === t)) return { result: !0, count: 0 }
            let i = 0,
              s = 1
            for (; i < n.length; ) {
              let o = this.getPosForId(n[i])
              if (o >= 0) {
                let l = this.indexNodes2(t, o)
                if (l.result) return { result: !0, count: s + l.count }
                s = s + l.count
              }
              i = i + 1
            }
            return { result: !1, count: s }
          }
          getDepthFirstPos(t) {
            return this.posCrossRef[t]
          }
          indexNodes() {
            ;(this.secCount = -1), this.subGraphs.length > 0 && this.indexNodes2('none', this.subGraphs.length - 1)
          }
          getSubGraphs() {
            return this.subGraphs
          }
          firstGraph() {
            return this.firstGraphFlag ? ((this.firstGraphFlag = !1), !0) : !1
          }
          destructStartLink(t) {
            let r = t.trim(),
              n = 'arrow_open'
            switch (r[0]) {
              case '<':
                ;(n = 'arrow_point'), (r = r.slice(1))
                break
              case 'x':
                ;(n = 'arrow_cross'), (r = r.slice(1))
                break
              case 'o':
                ;(n = 'arrow_circle'), (r = r.slice(1))
                break
            }
            let i = 'normal'
            return r.includes('=') && (i = 'thick'), r.includes('.') && (i = 'dotted'), { type: n, stroke: i }
          }
          countChar(t, r) {
            let n = r.length,
              i = 0
            for (let s = 0; s < n; ++s) r[s] === t && ++i
            return i
          }
          destructEndLink(t) {
            let r = t.trim(),
              n = r.slice(0, -1),
              i = 'arrow_open'
            switch (r.slice(-1)) {
              case 'x':
                ;(i = 'arrow_cross'), r.startsWith('x') && ((i = 'double_' + i), (n = n.slice(1)))
                break
              case '>':
                ;(i = 'arrow_point'), r.startsWith('<') && ((i = 'double_' + i), (n = n.slice(1)))
                break
              case 'o':
                ;(i = 'arrow_circle'), r.startsWith('o') && ((i = 'double_' + i), (n = n.slice(1)))
                break
            }
            let s = 'normal',
              o = n.length - 1
            n.startsWith('=') && (s = 'thick'), n.startsWith('~') && (s = 'invisible')
            let l = this.countChar('.', n)
            return l && ((s = 'dotted'), (o = l)), { type: i, stroke: s, length: o }
          }
          destructLink(t, r) {
            let n = this.destructEndLink(t),
              i
            if (r) {
              if (((i = this.destructStartLink(r)), i.stroke !== n.stroke))
                return { type: 'INVALID', stroke: 'INVALID' }
              if (i.type === 'arrow_open') i.type = n.type
              else {
                if (i.type !== n.type) return { type: 'INVALID', stroke: 'INVALID' }
                i.type = 'double_' + i.type
              }
              return i.type === 'double_arrow' && (i.type = 'double_arrow_point'), (i.length = n.length), i
            }
            return n
          }
          exists(t, r) {
            for (let n of t) if (n.nodes.includes(r)) return !0
            return !1
          }
          makeUniq(t, r) {
            let n = []
            return (
              t.nodes.forEach((i, s) => {
                this.exists(r, i) || n.push(t.nodes[s])
              }),
              { nodes: n }
            )
          }
          getTypeFromVertex(t) {
            if (t.img) return 'imageSquare'
            if (t.icon)
              return t.form === 'circle'
                ? 'iconCircle'
                : t.form === 'square'
                  ? 'iconSquare'
                  : t.form === 'rounded'
                    ? 'iconRounded'
                    : 'icon'
            switch (t.type) {
              case 'square':
              case void 0:
                return 'squareRect'
              case 'round':
                return 'roundedRect'
              case 'ellipse':
                return 'ellipse'
              default:
                return t.type
            }
          }
          findNode(t, r) {
            return t.find((n) => n.id === r)
          }
          destructEdgeType(t) {
            let r = 'none',
              n = 'arrow_point'
            switch (t) {
              case 'arrow_point':
              case 'arrow_circle':
              case 'arrow_cross':
                n = t
                break
              case 'double_arrow_point':
              case 'double_arrow_circle':
              case 'double_arrow_cross':
                ;(r = t.replace('double_', '')), (n = r)
                break
            }
            return { arrowTypeStart: r, arrowTypeEnd: n }
          }
          addNodeFromVertex(t, r, n, i, s, o) {
            let l = n.get(t.id),
              u = i.get(t.id) ?? !1,
              h = this.findNode(r, t.id)
            if (h)
              (h.cssStyles = t.styles),
                (h.cssCompiledStyles = this.getCompiledStyles(t.classes)),
                (h.cssClasses = t.classes.join(' '))
            else {
              let f = {
                id: t.id,
                label: t.text,
                labelStyle: '',
                parentId: l,
                padding: s.flowchart?.padding || 8,
                cssStyles: t.styles,
                cssCompiledStyles: this.getCompiledStyles(['default', 'node', ...t.classes]),
                cssClasses: 'default ' + t.classes.join(' '),
                dir: t.dir,
                domId: t.domId,
                look: o,
                link: t.link,
                linkTarget: t.linkTarget,
                tooltip: this.getTooltip(t.id),
                icon: t.icon,
                pos: t.pos,
                img: t.img,
                assetWidth: t.assetWidth,
                assetHeight: t.assetHeight,
                constraint: t.constraint,
              }
              u
                ? r.push({ ...f, isGroup: !0, shape: 'rect' })
                : r.push({ ...f, isGroup: !1, shape: this.getTypeFromVertex(t) })
            }
          }
          getCompiledStyles(t) {
            let r = []
            for (let n of t) {
              let i = this.classes.get(n)
              i?.styles && (r = [...r, ...(i.styles ?? [])].map((s) => s.trim())),
                i?.textStyles && (r = [...r, ...(i.textStyles ?? [])].map((s) => s.trim()))
            }
            return r
          }
          getData() {
            let t = K(),
              r = [],
              n = [],
              i = this.getSubGraphs(),
              s = new Map(),
              o = new Map()
            for (let h = i.length - 1; h >= 0; h--) {
              let f = i[h]
              f.nodes.length > 0 && o.set(f.id, !0)
              for (let d of f.nodes) s.set(d, f.id)
            }
            for (let h = i.length - 1; h >= 0; h--) {
              let f = i[h]
              r.push({
                id: f.id,
                label: f.title,
                labelStyle: '',
                parentId: s.get(f.id),
                padding: 8,
                cssCompiledStyles: this.getCompiledStyles(f.classes),
                cssClasses: f.classes.join(' '),
                shape: 'rect',
                dir: f.dir,
                isGroup: !0,
                look: t.look,
              })
            }
            this.getVertices().forEach((h) => {
              this.addNodeFromVertex(h, r, s, o, t, t.look || 'classic')
            })
            let u = this.getEdges()
            return (
              u.forEach((h, f) => {
                let { arrowTypeStart: d, arrowTypeEnd: p } = this.destructEdgeType(h.type),
                  m = [...(u.defaultStyle ?? [])]
                h.style && m.push(...h.style)
                let g = {
                  id: kc(h.start, h.end, { counter: f, prefix: 'L' }, h.id),
                  isUserDefinedId: h.isUserDefinedId,
                  start: h.start,
                  end: h.end,
                  type: h.type ?? 'normal',
                  label: h.text,
                  labelpos: 'c',
                  thickness: h.stroke,
                  minlen: h.length,
                  classes: h?.stroke === 'invisible' ? '' : 'edge-thickness-normal edge-pattern-solid flowchart-link',
                  arrowTypeStart: h?.stroke === 'invisible' || h?.type === 'arrow_open' ? 'none' : d,
                  arrowTypeEnd: h?.stroke === 'invisible' || h?.type === 'arrow_open' ? 'none' : p,
                  arrowheadStyle: 'fill: #333',
                  cssCompiledStyles: this.getCompiledStyles(h.classes),
                  labelStyle: m,
                  style: m,
                  pattern: h.stroke,
                  look: t.look,
                  animate: h.animate,
                  animation: h.animation,
                  curve: h.interpolate || this.edges.defaultInterpolate || t.flowchart?.curve,
                }
                n.push(g)
              }),
              { nodes: r, edges: n, other: {}, config: t }
            )
          }
          defaultConfig() {
            return wx.flowchart
          }
        })
    })
  var So,
    hd = x(() => {
      'use strict'
      Ge()
      So = a((e, t) => {
        let r
        return (
          t === 'sandbox' && (r = xt('#i' + e)),
          (t === 'sandbox' ? xt(r.nodes()[0].contentDocument.body) : xt('body')).select(`[id="${e}"]`)
        )
      }, 'getDiagramElement')
    })
  var kl,
    $0 = x(() => {
      'use strict'
      kl = a(({ flowchart: e }) => {
        let t = e?.subGraphTitleMargin?.top ?? 0,
          r = e?.subGraphTitleMargin?.bottom ?? 0,
          n = t + r
        return { subGraphTitleTopMargin: t, subGraphTitleBottomMargin: r, subGraphTitleTotalMargin: n }
      }, 'getSubGraphTitleMargins')
    })
  var aU,
    Ubt,
    jbt,
    qbt,
    Hbt,
    Ybt,
    Xbt,
    oU,
    fd,
    lU,
    Hb = x(() => {
      'use strict'
      pe()
      Be()
      Vt()
      $0()
      Ge()
      oe()
      $a()
      hA()
      Wb()
      eh()
      re()
      ;(aU = a(async (e, t) => {
        B.info('Creating subgraph rect for ', t.id, t)
        let r = K(),
          { themeVariables: n, handDrawnSeed: i } = r,
          { clusterBkg: s, clusterBorder: o } = n,
          { labelStyles: l, nodeStyles: u, borderStyles: h, backgroundStyles: f } = St(t),
          d = e
            .insert('g')
            .attr('class', 'cluster ' + t.cssClasses)
            .attr('id', t.id)
            .attr('data-look', t.look),
          p = Pe(r.flowchart.htmlLabels),
          m = d.insert('g').attr('class', 'cluster-label '),
          g = await Kn(m, t.label, { style: t.labelStyle, useHtmlLabels: p, isNode: !0 }),
          y = g.getBBox()
        if (Pe(r.flowchart.htmlLabels)) {
          let G = g.children[0],
            v = xt(g)
          ;(y = G.getBoundingClientRect()), v.attr('width', y.width), v.attr('height', y.height)
        }
        let b = t.width <= y.width + t.padding ? y.width + t.padding : t.width
        t.width <= y.width + t.padding ? (t.diff = (b - t.width) / 2 - t.padding) : (t.diff = -t.padding)
        let k = t.height,
          T = t.x - b / 2,
          C = t.y - k / 2
        B.trace('Data ', t, JSON.stringify(t))
        let A
        if (t.look === 'handDrawn') {
          let G = wt.svg(d),
            v = Et(t, { roughness: 0.7, fill: s, stroke: o, fillWeight: 3, seed: i }),
            R = G.path(us(T, C, b, k, 0), v)
          ;(A = d.insert(() => (B.debug('Rough node insert CXC', R), R), ':first-child')),
            A.select('path:nth-child(2)').attr('style', h.join(';')),
            A.select('path').attr('style', f.join(';').replace('fill', 'stroke'))
        } else
          (A = d.insert('rect', ':first-child')),
            A.attr('style', u)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('x', T)
              .attr('y', C)
              .attr('width', b)
              .attr('height', k)
        let { subGraphTitleTopMargin: w } = kl(r)
        if ((m.attr('transform', `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + w})`), l)) {
          let G = m.select('span')
          G && G.attr('style', l)
        }
        let D = A.node().getBBox()
        return (
          (t.offsetX = 0),
          (t.width = D.width),
          (t.height = D.height),
          (t.offsetY = y.height - t.padding / 2),
          (t.intersect = function (G) {
            return wc(t, G)
          }),
          { cluster: d, labelBBox: y }
        )
      }, 'rect')),
        (Ubt = a((e, t) => {
          let r = e.insert('g').attr('class', 'note-cluster').attr('id', t.id),
            n = r.insert('rect', ':first-child'),
            i = 0 * t.padding,
            s = i / 2
          n.attr('rx', t.rx)
            .attr('ry', t.ry)
            .attr('x', t.x - t.width / 2 - s)
            .attr('y', t.y - t.height / 2 - s)
            .attr('width', t.width + i)
            .attr('height', t.height + i)
            .attr('fill', 'none')
          let o = n.node().getBBox()
          return (
            (t.width = o.width),
            (t.height = o.height),
            (t.intersect = function (l) {
              return wc(t, l)
            }),
            { cluster: r, labelBBox: { width: 0, height: 0 } }
          )
        }, 'noteGroup')),
        (jbt = a(async (e, t) => {
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            { altBackground: s, compositeBackground: o, compositeTitleBackground: l, nodeBorder: u } = n,
            h = e
              .insert('g')
              .attr('class', t.cssClasses)
              .attr('id', t.id)
              .attr('data-id', t.id)
              .attr('data-look', t.look),
            f = h.insert('g', ':first-child'),
            d = h.insert('g').attr('class', 'cluster-label'),
            p = h.append('rect'),
            m = d.node().appendChild(await To(t.label, t.labelStyle, void 0, !0)),
            g = m.getBBox()
          if (Pe(r.flowchart.htmlLabels)) {
            let R = m.children[0],
              F = xt(m)
            ;(g = R.getBoundingClientRect()), F.attr('width', g.width), F.attr('height', g.height)
          }
          let y = 0 * t.padding,
            b = y / 2,
            k = (t.width <= g.width + t.padding ? g.width + t.padding : t.width) + y
          t.width <= g.width + t.padding ? (t.diff = (k - t.width) / 2 - t.padding) : (t.diff = -t.padding)
          let T = t.height + y,
            C = t.height + y - g.height - 6,
            A = t.x - k / 2,
            w = t.y - T / 2
          t.width = k
          let D = t.y - t.height / 2 - b + g.height + 2,
            G
          if (t.look === 'handDrawn') {
            let R = t.cssClasses.includes('statediagram-cluster-alt'),
              F = wt.svg(h),
              S =
                t.rx || t.ry
                  ? F.path(us(A, w, k, T, 10), { roughness: 0.7, fill: l, fillStyle: 'solid', stroke: u, seed: i })
                  : F.rectangle(A, w, k, T, { seed: i })
            G = h.insert(() => S, ':first-child')
            let O = F.rectangle(A, D, k, C, { fill: R ? s : o, fillStyle: R ? 'hachure' : 'solid', stroke: u, seed: i })
            ;(G = h.insert(() => S, ':first-child')), (p = h.insert(() => O))
          } else
            (G = f.insert('rect', ':first-child')),
              G.attr('class', 'outer')
                .attr('x', A)
                .attr('y', w)
                .attr('width', k)
                .attr('height', T)
                .attr('data-look', t.look),
              p.attr('class', 'inner').attr('x', A).attr('y', D).attr('width', k).attr('height', C)
          d.attr('transform', `translate(${t.x - g.width / 2}, ${w + 1 - (Pe(r.flowchart.htmlLabels) ? 0 : 3)})`)
          let v = G.node().getBBox()
          return (
            (t.height = v.height),
            (t.offsetX = 0),
            (t.offsetY = g.height - t.padding / 2),
            (t.labelBBox = g),
            (t.intersect = function (R) {
              return wc(t, R)
            }),
            { cluster: h, labelBBox: g }
          )
        }, 'roundedWithTitle')),
        (qbt = a(async (e, t) => {
          B.info('Creating subgraph rect for ', t.id, t)
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            { clusterBkg: s, clusterBorder: o } = n,
            { labelStyles: l, nodeStyles: u, borderStyles: h, backgroundStyles: f } = St(t),
            d = e
              .insert('g')
              .attr('class', 'cluster ' + t.cssClasses)
              .attr('id', t.id)
              .attr('data-look', t.look),
            p = Pe(r.flowchart.htmlLabels),
            m = d.insert('g').attr('class', 'cluster-label '),
            g = await Kn(m, t.label, { style: t.labelStyle, useHtmlLabels: p, isNode: !0, width: t.width }),
            y = g.getBBox()
          if (Pe(r.flowchart.htmlLabels)) {
            let G = g.children[0],
              v = xt(g)
            ;(y = G.getBoundingClientRect()), v.attr('width', y.width), v.attr('height', y.height)
          }
          let b = t.width <= y.width + t.padding ? y.width + t.padding : t.width
          t.width <= y.width + t.padding ? (t.diff = (b - t.width) / 2 - t.padding) : (t.diff = -t.padding)
          let k = t.height,
            T = t.x - b / 2,
            C = t.y - k / 2
          B.trace('Data ', t, JSON.stringify(t))
          let A
          if (t.look === 'handDrawn') {
            let G = wt.svg(d),
              v = Et(t, { roughness: 0.7, fill: s, stroke: o, fillWeight: 4, seed: i }),
              R = G.path(us(T, C, b, k, t.rx), v)
            ;(A = d.insert(() => (B.debug('Rough node insert CXC', R), R), ':first-child')),
              A.select('path:nth-child(2)').attr('style', h.join(';')),
              A.select('path').attr('style', f.join(';').replace('fill', 'stroke'))
          } else
            (A = d.insert('rect', ':first-child')),
              A.attr('style', u)
                .attr('rx', t.rx)
                .attr('ry', t.ry)
                .attr('x', T)
                .attr('y', C)
                .attr('width', b)
                .attr('height', k)
          let { subGraphTitleTopMargin: w } = kl(r)
          if ((m.attr('transform', `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + w})`), l)) {
            let G = m.select('span')
            G && G.attr('style', l)
          }
          let D = A.node().getBBox()
          return (
            (t.offsetX = 0),
            (t.width = D.width),
            (t.height = D.height),
            (t.offsetY = y.height - t.padding / 2),
            (t.intersect = function (G) {
              return wc(t, G)
            }),
            { cluster: d, labelBBox: y }
          )
        }, 'kanbanSection')),
        (Hbt = a((e, t) => {
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            { nodeBorder: s } = n,
            o = e.insert('g').attr('class', t.cssClasses).attr('id', t.id).attr('data-look', t.look),
            l = o.insert('g', ':first-child'),
            u = 0 * t.padding,
            h = t.width + u
          t.diff = -t.padding
          let f = t.height + u,
            d = t.x - h / 2,
            p = t.y - f / 2
          t.width = h
          let m
          if (t.look === 'handDrawn') {
            let b = wt
              .svg(o)
              .rectangle(d, p, h, f, { fill: 'lightgrey', roughness: 0.5, strokeLineDash: [5], stroke: s, seed: i })
            m = o.insert(() => b, ':first-child')
          } else
            (m = l.insert('rect', ':first-child')),
              m
                .attr('class', 'divider')
                .attr('x', d)
                .attr('y', p)
                .attr('width', h)
                .attr('height', f)
                .attr('data-look', t.look)
          let g = m.node().getBBox()
          return (
            (t.height = g.height),
            (t.offsetX = 0),
            (t.offsetY = 0),
            (t.intersect = function (y) {
              return wc(t, y)
            }),
            { cluster: o, labelBBox: {} }
          )
        }, 'divider')),
        (Ybt = aU),
        (Xbt = { rect: aU, squareRect: Ybt, roundedWithTitle: jbt, noteGroup: Ubt, divider: Hbt, kanbanSection: qbt }),
        (oU = new Map()),
        (fd = a(async (e, t) => {
          let r = t.shape || 'rect',
            n = await Xbt[r](e, t)
          return oU.set(t.id, n), n
        }, 'insertCluster')),
        (lU = a(() => {
          oU = new Map()
        }, 'clear'))
    })
  function Yb(e, t) {
    if (e === void 0 || t === void 0) return { angle: 0, deltaX: 0, deltaY: 0 }
    ;(e = Zr(e)), (t = Zr(t))
    let [r, n] = [e.x, e.y],
      [i, s] = [t.x, t.y],
      o = i - r,
      l = s - n
    return { angle: Math.atan(l / o), deltaX: o, deltaY: l }
  }
  var ii,
    IA,
    Zr,
    Xb,
    MA = x(() => {
      'use strict'
      ;(ii = {
        aggregation: 17.25,
        extension: 17.25,
        composition: 17.25,
        dependency: 6,
        lollipop: 13.5,
        arrow_point: 4,
      }),
        (IA = { arrow_point: 9, arrow_cross: 12.5, arrow_circle: 12.5 })
      a(Yb, 'calculateDeltaAndAngle')
      ;(Zr = a((e) => (Array.isArray(e) ? { x: e[0], y: e[1] } : e), 'pointTransformer')),
        (Xb = a(
          (e) => ({
            x: a(function (t, r, n) {
              let i = 0,
                s = Zr(n[0]).x < Zr(n[n.length - 1]).x ? 'left' : 'right'
              if (r === 0 && Object.hasOwn(ii, e.arrowTypeStart)) {
                let { angle: m, deltaX: g } = Yb(n[0], n[1])
                i = ii[e.arrowTypeStart] * Math.cos(m) * (g >= 0 ? 1 : -1)
              } else if (r === n.length - 1 && Object.hasOwn(ii, e.arrowTypeEnd)) {
                let { angle: m, deltaX: g } = Yb(n[n.length - 1], n[n.length - 2])
                i = ii[e.arrowTypeEnd] * Math.cos(m) * (g >= 0 ? 1 : -1)
              }
              let o = Math.abs(Zr(t).x - Zr(n[n.length - 1]).x),
                l = Math.abs(Zr(t).y - Zr(n[n.length - 1]).y),
                u = Math.abs(Zr(t).x - Zr(n[0]).x),
                h = Math.abs(Zr(t).y - Zr(n[0]).y),
                f = ii[e.arrowTypeStart],
                d = ii[e.arrowTypeEnd],
                p = 1
              if (o < d && o > 0 && l < d) {
                let m = d + p - o
                ;(m *= s === 'right' ? -1 : 1), (i -= m)
              }
              if (u < f && u > 0 && h < f) {
                let m = f + p - u
                ;(m *= s === 'right' ? -1 : 1), (i += m)
              }
              return Zr(t).x + i
            }, 'x'),
            y: a(function (t, r, n) {
              let i = 0,
                s = Zr(n[0]).y < Zr(n[n.length - 1]).y ? 'down' : 'up'
              if (r === 0 && Object.hasOwn(ii, e.arrowTypeStart)) {
                let { angle: m, deltaY: g } = Yb(n[0], n[1])
                i = ii[e.arrowTypeStart] * Math.abs(Math.sin(m)) * (g >= 0 ? 1 : -1)
              } else if (r === n.length - 1 && Object.hasOwn(ii, e.arrowTypeEnd)) {
                let { angle: m, deltaY: g } = Yb(n[n.length - 1], n[n.length - 2])
                i = ii[e.arrowTypeEnd] * Math.abs(Math.sin(m)) * (g >= 0 ? 1 : -1)
              }
              let o = Math.abs(Zr(t).y - Zr(n[n.length - 1]).y),
                l = Math.abs(Zr(t).x - Zr(n[n.length - 1]).x),
                u = Math.abs(Zr(t).y - Zr(n[0]).y),
                h = Math.abs(Zr(t).x - Zr(n[0]).x),
                f = ii[e.arrowTypeStart],
                d = ii[e.arrowTypeEnd],
                p = 1
              if (o < d && o > 0 && l < d) {
                let m = d + p - o
                ;(m *= s === 'up' ? -1 : 1), (i -= m)
              }
              if (u < f && u > 0 && h < f) {
                let m = f + p - u
                ;(m *= s === 'up' ? -1 : 1), (i += m)
              }
              return Zr(t).y + i
            }, 'y'),
          }),
          'getLineFunctionsWithOffset',
        ))
    })
  var uU,
    Kbt,
    cU,
    hU = x(() => {
      'use strict'
      Vt()
      ;(uU = a((e, t, r, n, i, s) => {
        t.arrowTypeStart && cU(e, 'start', t.arrowTypeStart, r, n, i, s),
          t.arrowTypeEnd && cU(e, 'end', t.arrowTypeEnd, r, n, i, s)
      }, 'addEdgeMarkers')),
        (Kbt = {
          arrow_cross: { type: 'cross', fill: !1 },
          arrow_point: { type: 'point', fill: !0 },
          arrow_barb: { type: 'barb', fill: !0 },
          arrow_circle: { type: 'circle', fill: !1 },
          aggregation: { type: 'aggregation', fill: !1 },
          extension: { type: 'extension', fill: !1 },
          composition: { type: 'composition', fill: !0 },
          dependency: { type: 'dependency', fill: !0 },
          lollipop: { type: 'lollipop', fill: !1 },
          only_one: { type: 'onlyOne', fill: !1 },
          zero_or_one: { type: 'zeroOrOne', fill: !1 },
          one_or_more: { type: 'oneOrMore', fill: !1 },
          zero_or_more: { type: 'zeroOrMore', fill: !1 },
          requirement_arrow: { type: 'requirement_arrow', fill: !1 },
          requirement_contains: { type: 'requirement_contains', fill: !1 },
        }),
        (cU = a((e, t, r, n, i, s, o) => {
          let l = Kbt[r]
          if (!l) {
            B.warn(`Unknown arrow type: ${r}`)
            return
          }
          let u = l.type,
            f = `${i}_${s}-${u}${t === 'start' ? 'Start' : 'End'}`
          if (o && o.trim() !== '') {
            let d = o.replace(/[^\dA-Za-z]/g, '_'),
              p = `${f}_${d}`
            if (!document.getElementById(p)) {
              let m = document.getElementById(f)
              if (m) {
                let g = m.cloneNode(!0)
                ;(g.id = p),
                  g.querySelectorAll('path, circle, line').forEach((b) => {
                    b.setAttribute('stroke', o), l.fill && b.setAttribute('fill', o)
                  }),
                  m.parentNode?.appendChild(g)
              }
            }
            e.attr(`marker-${t}`, `url(${n}#${p})`)
          } else e.attr(`marker-${t}`, `url(${n}#${f})`)
        }, 'addEdgeMarker'))
    })
  function Qb(e, t) {
    K().flowchart.htmlLabels && e && ((e.style.width = t.length * 9 + 'px'), (e.style.height = '12px'))
  }
  function Jbt(e) {
    let t = [],
      r = []
    for (let n = 1; n < e.length - 1; n++) {
      let i = e[n - 1],
        s = e[n],
        o = e[n + 1]
      ;((i.x === s.x && s.y === o.y && Math.abs(s.x - o.x) > 5 && Math.abs(s.y - i.y) > 5) ||
        (i.y === s.y && s.x === o.x && Math.abs(s.x - i.x) > 5 && Math.abs(s.y - o.y) > 5)) &&
        (t.push(s), r.push(n))
    }
    return { cornerPoints: t, cornerPointPositions: r }
  }
  function rkt(e, t) {
    if (e.length < 2) return ''
    let r = '',
      n = e.length,
      i = 1e-5
    for (let s = 0; s < n; s++) {
      let o = e[s],
        l = e[s - 1],
        u = e[s + 1]
      if (s === 0) r += `M${o.x},${o.y}`
      else if (s === n - 1) r += `L${o.x},${o.y}`
      else {
        let h = o.x - l.x,
          f = o.y - l.y,
          d = u.x - o.x,
          p = u.y - o.y,
          m = Math.hypot(h, f),
          g = Math.hypot(d, p)
        if (m < i || g < i) {
          r += `L${o.x},${o.y}`
          continue
        }
        let y = h / m,
          b = f / m,
          k = d / g,
          T = p / g,
          C = y * k + b * T,
          A = Math.max(-1, Math.min(1, C)),
          w = Math.acos(A)
        if (w < i || Math.abs(Math.PI - w) < i) {
          r += `L${o.x},${o.y}`
          continue
        }
        let D = Math.min(t / Math.sin(w / 2), m / 2, g / 2),
          G = o.x - y * D,
          v = o.y - b * D,
          R = o.x + k * D,
          F = o.y + T * D
        ;(r += `L${G},${v}`), (r += `Q${o.x},${o.y} ${R},${F}`)
      }
    }
    return r
  }
  function pU(e, t) {
    if (!e || !t) return { angle: 0, deltaX: 0, deltaY: 0 }
    let r = t.x - e.x,
      n = t.y - e.y
    return { angle: Math.atan2(n, r), deltaX: r, deltaY: n }
  }
  function nkt(e, t) {
    let r = e.map((i) => ({ ...i }))
    if (e.length >= 2 && ii[t.arrowTypeStart]) {
      let i = ii[t.arrowTypeStart],
        s = e[0],
        o = e[1],
        { angle: l } = pU(s, o),
        u = i * Math.cos(l),
        h = i * Math.sin(l)
      ;(r[0].x = s.x + u), (r[0].y = s.y + h)
    }
    let n = e.length
    if (n >= 2 && ii[t.arrowTypeEnd]) {
      let i = ii[t.arrowTypeEnd],
        s = e[n - 1],
        o = e[n - 2],
        { angle: l } = pU(o, s),
        u = i * Math.cos(l),
        h = i * Math.sin(l)
      ;(r[n - 1].x = s.x - u), (r[n - 1].y = s.y - h)
    }
    return r
  }
  var Zb,
    si,
    mU,
    Kb,
    Jb,
    tk,
    Qbt,
    Zbt,
    fU,
    dU,
    tkt,
    ekt,
    ek,
    OA = x(() => {
      'use strict'
      pe()
      Be()
      Vt()
      $a()
      Ce()
      MA()
      $0()
      Ge()
      oe()
      Wb()
      hU()
      re()
      ;(Zb = new Map()),
        (si = new Map()),
        (mU = a(() => {
          Zb.clear(), si.clear()
        }, 'clear')),
        (Kb = a((e) => (e ? e.reduce((r, n) => r + ';' + n, '') : ''), 'getLabelStyles')),
        (Jb = a(async (e, t) => {
          let r = Pe(K().flowchart.htmlLabels),
            { labelStyles: n } = St(t)
          t.labelStyle = n
          let i = await Kn(e, t.label, { style: t.labelStyle, useHtmlLabels: r, addSvgBackground: !0, isNode: !1 })
          B.info('abc82', t, t.labelType)
          let s = e.insert('g').attr('class', 'edgeLabel'),
            o = s.insert('g').attr('class', 'label').attr('data-id', t.id)
          o.node().appendChild(i)
          let l = i.getBBox()
          if (r) {
            let h = i.children[0],
              f = xt(i)
            ;(l = h.getBoundingClientRect()), f.attr('width', l.width), f.attr('height', l.height)
          }
          o.attr('transform', 'translate(' + -l.width / 2 + ', ' + -l.height / 2 + ')'),
            Zb.set(t.id, s),
            (t.width = l.width),
            (t.height = l.height)
          let u
          if (t.startLabelLeft) {
            let h = await To(t.startLabelLeft, Kb(t.labelStyle)),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              si.get(t.id) || si.set(t.id, {}),
              (si.get(t.id).startLeft = f),
              Qb(u, t.startLabelLeft)
          }
          if (t.startLabelRight) {
            let h = await To(t.startLabelRight, Kb(t.labelStyle)),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            ;(u = f.node().appendChild(h)), d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              si.get(t.id) || si.set(t.id, {}),
              (si.get(t.id).startRight = f),
              Qb(u, t.startLabelRight)
          }
          if (t.endLabelLeft) {
            let h = await To(t.endLabelLeft, Kb(t.labelStyle)),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              f.node().appendChild(h),
              si.get(t.id) || si.set(t.id, {}),
              (si.get(t.id).endLeft = f),
              Qb(u, t.endLabelLeft)
          }
          if (t.endLabelRight) {
            let h = await To(t.endLabelRight, Kb(t.labelStyle)),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              f.node().appendChild(h),
              si.get(t.id) || si.set(t.id, {}),
              (si.get(t.id).endRight = f),
              Qb(u, t.endLabelRight)
          }
          return i
        }, 'insertEdgeLabel'))
      a(Qb, 'setTerminalWidth')
      ;(tk = a((e, t) => {
        B.debug('Moving label abc88 ', e.id, e.label, Zb.get(e.id), t)
        let r = t.updatedPath ? t.updatedPath : t.originalPath,
          n = K(),
          { subGraphTitleTotalMargin: i } = kl(n)
        if (e.label) {
          let s = Zb.get(e.id),
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcLabelPosition(r)
            B.debug('Moving label ' + e.label + ' from (', o, ',', l, ') to (', u.x, ',', u.y, ') abc88'),
              t.updatedPath && ((o = u.x), (l = u.y))
          }
          s.attr('transform', `translate(${o}, ${l + i / 2})`)
        }
        if (e.startLabelLeft) {
          let s = si.get(e.id).startLeft,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_left', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.startLabelRight) {
          let s = si.get(e.id).startRight,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_right', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.endLabelLeft) {
          let s = si.get(e.id).endLeft,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_left', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.endLabelRight) {
          let s = si.get(e.id).endRight,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_right', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
      }, 'positionEdgeLabel')),
        (Qbt = a((e, t) => {
          let r = e.x,
            n = e.y,
            i = Math.abs(t.x - r),
            s = Math.abs(t.y - n),
            o = e.width / 2,
            l = e.height / 2
          return i >= o || s >= l
        }, 'outsideNode')),
        (Zbt = a((e, t, r) => {
          B.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`)
          let n = e.x,
            i = e.y,
            s = Math.abs(n - r.x),
            o = e.width / 2,
            l = r.x < t.x ? o - s : o + s,
            u = e.height / 2,
            h = Math.abs(t.y - r.y),
            f = Math.abs(t.x - r.x)
          if (Math.abs(i - t.y) * o > Math.abs(n - t.x) * u) {
            let d = r.y < t.y ? t.y - u - i : i - u - t.y
            l = (f * d) / h
            let p = { x: r.x < t.x ? r.x + l : r.x - f + l, y: r.y < t.y ? r.y + h - d : r.y - h + d }
            return (
              l === 0 && ((p.x = t.x), (p.y = t.y)),
              f === 0 && (p.x = t.x),
              h === 0 && (p.y = t.y),
              B.debug(`abc89 top/bottom calc, Q ${h}, q ${d}, R ${f}, r ${l}`, p),
              p
            )
          } else {
            r.x < t.x ? (l = t.x - o - n) : (l = n - o - t.x)
            let d = (h * l) / f,
              p = r.x < t.x ? r.x + f - l : r.x - f + l,
              m = r.y < t.y ? r.y + d : r.y - d
            return (
              B.debug(`sides calc abc89, Q ${h}, q ${d}, R ${f}, r ${l}`, { _x: p, _y: m }),
              l === 0 && ((p = t.x), (m = t.y)),
              f === 0 && (p = t.x),
              h === 0 && (m = t.y),
              { x: p, y: m }
            )
          }
        }, 'intersection')),
        (fU = a((e, t) => {
          B.warn('abc88 cutPathAtIntersect', e, t)
          let r = [],
            n = e[0],
            i = !1
          return (
            e.forEach((s) => {
              if ((B.info('abc88 checking point', s, t), !Qbt(t, s) && !i)) {
                let o = Zbt(t, n, s)
                B.debug('abc88 inside', s, n, o), B.debug('abc88 intersection', o, t)
                let l = !1
                r.forEach((u) => {
                  l = l || (u.x === o.x && u.y === o.y)
                }),
                  r.some((u) => u.x === o.x && u.y === o.y) ? B.warn('abc88 no intersect', o, r) : r.push(o),
                  (i = !0)
              } else B.warn('abc88 outside', s, n), (n = s), i || r.push(s)
            }),
            B.debug('returning points', r),
            r
          )
        }, 'cutPathAtIntersect'))
      a(Jbt, 'extractCornerPoints')
      ;(dU = a(function (e, t, r) {
        let n = t.x - e.x,
          i = t.y - e.y,
          s = Math.sqrt(n * n + i * i),
          o = r / s
        return { x: t.x - o * n, y: t.y - o * i }
      }, 'findAdjacentPoint')),
        (tkt = a(function (e) {
          let { cornerPointPositions: t } = Jbt(e),
            r = []
          for (let n = 0; n < e.length; n++)
            if (t.includes(n)) {
              let i = e[n - 1],
                s = e[n + 1],
                o = e[n],
                l = dU(i, o, 5),
                u = dU(s, o, 5),
                h = u.x - l.x,
                f = u.y - l.y
              r.push(l)
              let d = Math.sqrt(2) * 2,
                p = { x: o.x, y: o.y }
              if (Math.abs(s.x - i.x) > 10 && Math.abs(s.y - i.y) >= 10) {
                B.debug('Corner point fixing', Math.abs(s.x - i.x), Math.abs(s.y - i.y))
                let m = 5
                o.x === l.x
                  ? (p = { x: h < 0 ? l.x - m + d : l.x + m - d, y: f < 0 ? l.y - d : l.y + d })
                  : (p = { x: h < 0 ? l.x - d : l.x + d, y: f < 0 ? l.y - m + d : l.y + m - d })
              } else B.debug('Corner point skipping fixing', Math.abs(s.x - i.x), Math.abs(s.y - i.y))
              r.push(p, u)
            } else r.push(e[n])
          return r
        }, 'fixCorners')),
        (ekt = a((e, t, r) => {
          let n = e - t - r,
            i = 2,
            s = 2,
            o = i + s,
            l = Math.floor(n / o),
            u = Array(l).fill(`${i} ${s}`).join(' ')
          return `0 ${t} ${u} ${r}`
        }, 'generateDashArray')),
        (ek = a(function (e, t, r, n, i, s, o, l = !1) {
          let { handDrawnSeed: u } = K(),
            h = t.points,
            f = !1,
            d = i
          var p = s
          let m = []
          for (let _ in t.cssCompiledStyles) N0(_) || m.push(t.cssCompiledStyles[_])
          B.debug('UIO intersect check', t.points, p.x, d.x),
            p.intersect &&
              d.intersect &&
              !l &&
              ((h = h.slice(1, t.points.length - 1)),
              h.unshift(d.intersect(h[0])),
              B.debug('Last point UIO', t.start, '-->', t.end, h[h.length - 1], p, p.intersect(h[h.length - 1])),
              h.push(p.intersect(h[h.length - 1])))
          let g = btoa(JSON.stringify(h))
          t.toCluster &&
            (B.info('to cluster abc88', r.get(t.toCluster)), (h = fU(t.points, r.get(t.toCluster).node)), (f = !0)),
            t.fromCluster &&
              (B.debug('from cluster abc88', r.get(t.fromCluster), JSON.stringify(h, null, 2)),
              (h = fU(h.reverse(), r.get(t.fromCluster).node).reverse()),
              (f = !0))
          let y = h.filter((_) => !Number.isNaN(_.y))
          y = tkt(y)
          let b = Xs
          switch (((b = ul), t.curve)) {
            case 'linear':
              b = ul
              break
            case 'basis':
              b = Xs
              break
            case 'cardinal':
              b = Qg
              break
            case 'bumpX':
              b = qg
              break
            case 'bumpY':
              b = Hg
              break
            case 'catmullRom':
              b = t0
              break
            case 'monotoneX':
              b = e0
              break
            case 'monotoneY':
              b = r0
              break
            case 'natural':
              b = $f
              break
            case 'step':
              b = Gf
              break
            case 'stepAfter':
              b = i0
              break
            case 'stepBefore':
              b = n0
              break
            default:
              b = Xs
          }
          let { x: k, y: T } = Xb(t),
            C = Ma().x(k).y(T).curve(b),
            A
          switch (t.thickness) {
            case 'normal':
              A = 'edge-thickness-normal'
              break
            case 'thick':
              A = 'edge-thickness-thick'
              break
            case 'invisible':
              A = 'edge-thickness-invisible'
              break
            default:
              A = 'edge-thickness-normal'
          }
          switch (t.pattern) {
            case 'solid':
              A += ' edge-pattern-solid'
              break
            case 'dotted':
              A += ' edge-pattern-dotted'
              break
            case 'dashed':
              A += ' edge-pattern-dashed'
              break
            default:
              A += ' edge-pattern-solid'
          }
          let w,
            D = t.curve === 'rounded' ? rkt(nkt(y, t), 5) : C(y),
            G = Array.isArray(t.style) ? t.style : [t.style],
            v = G.find((_) => _?.startsWith('stroke:')),
            R = !1
          if (t.look === 'handDrawn') {
            let _ = wt.svg(e)
            Object.assign([], y)
            let L = _.path(D, { roughness: 0.3, seed: u })
            ;(A += ' transition'),
              (w = xt(L)
                .select('path')
                .attr('id', t.id)
                .attr('class', ' ' + A + (t.classes ? ' ' + t.classes : ''))
                .attr('style', G ? G.reduce((P, I) => P + ';' + I, '') : ''))
            let N = w.attr('d')
            w.attr('d', N), e.node().appendChild(w.node())
          } else {
            let _ = m.join(';'),
              L = G ? G.reduce((q, tt) => q + tt + ';', '') : '',
              N = ''
            t.animate && (N = ' edge-animation-fast'), t.animation && (N = ' edge-animation-' + t.animation)
            let P = (_ ? _ + ';' + L + ';' : L) + ';' + (G ? G.reduce((q, tt) => q + ';' + tt, '') : '')
            ;(w = e
              .append('path')
              .attr('d', D)
              .attr('id', t.id)
              .attr('class', ' ' + A + (t.classes ? ' ' + t.classes : '') + (N ?? ''))
              .attr('style', P)),
              (v = P.match(/stroke:([^;]+)/)?.[1]),
              (R = t.animate === !0 || !!t.animation || _.includes('animation'))
            let I = w.node(),
              M = typeof I.getTotalLength == 'function' ? I.getTotalLength() : 0,
              V = IA[t.arrowTypeStart] || 0,
              $ = IA[t.arrowTypeEnd] || 0
            if (t.look === 'neo' && !R) {
              let tt = `stroke-dasharray: ${t.pattern === 'dotted' || t.pattern === 'dashed' ? ekt(M, V, $) : `0 ${V} ${M - V - $} ${$}`}; stroke-dashoffset: 0;`
              w.attr('style', tt + w.attr('style'))
            }
          }
          w.attr('data-edge', !0),
            w.attr('data-et', 'edge'),
            w.attr('data-id', t.id),
            w.attr('data-points', g),
            t.showPoints &&
              y.forEach((_) => {
                e.append('circle')
                  .style('stroke', 'red')
                  .style('fill', 'red')
                  .attr('r', 1)
                  .attr('cx', _.x)
                  .attr('cy', _.y)
              })
          let F = ''
          ;(K().flowchart.arrowMarkerAbsolute || K().state.arrowMarkerAbsolute) &&
            ((F =
              window.location.protocol +
              '//' +
              window.location.host +
              window.location.pathname +
              window.location.search),
            (F = F.replace(/\(/g, '\\(').replace(/\)/g, '\\)'))),
            B.info('arrowTypeStart', t.arrowTypeStart),
            B.info('arrowTypeEnd', t.arrowTypeEnd),
            uU(w, t, F, o, n, v)
          let S = Math.floor(h.length / 2),
            O = h[S]
          le.isLabelCoordinateInPath(O, w.attr('d')) || (f = !0)
          let E = {}
          return f && (E.updatedPath = h), (E.originalPath = t.points), E
        }, 'insertEdge'))
      a(rkt, 'generateRoundedPath')
      a(pU, 'calculateDeltaAndAngle')
      a(nkt, 'applyMarkerOffsetsToPoints')
    })
  var ikt,
    skt,
    akt,
    okt,
    lkt,
    ckt,
    ukt,
    hkt,
    fkt,
    dkt,
    pkt,
    mkt,
    gkt,
    ykt,
    xkt,
    bkt,
    kkt,
    rk,
    PA = x(() => {
      'use strict'
      Vt()
      ;(ikt = a((e, t, r, n) => {
        t.forEach((i) => {
          kkt[i](e, r, n)
        })
      }, 'insertMarkers')),
        (skt = a((e, t, r) => {
          B.trace('Making markers for ', r),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-extensionStart')
              .attr('class', 'marker extension ' + t)
              .attr('refX', 18)
              .attr('refY', 7)
              .attr('markerWidth', 190)
              .attr('markerHeight', 240)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,7 L18,13 V 1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-extensionEnd')
              .attr('class', 'marker extension ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,1 V 13 L18,7 Z')
        }, 'extension')),
        (akt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-compositionStart')
            .attr('class', 'marker composition ' + t)
            .attr('refX', 18)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-compositionEnd')
              .attr('class', 'marker composition ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z')
        }, 'composition')),
        (okt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-aggregationStart')
            .attr('class', 'marker aggregation ' + t)
            .attr('refX', 18)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-aggregationEnd')
              .attr('class', 'marker aggregation ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z')
        }, 'aggregation')),
        (lkt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-dependencyStart')
            .attr('class', 'marker dependency ' + t)
            .attr('refX', 6)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 5,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-dependencyEnd')
              .attr('class', 'marker dependency ' + t)
              .attr('refX', 13)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z')
        }, 'dependency')),
        (ckt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-lollipopStart')
            .attr('class', 'marker lollipop ' + t)
            .attr('refX', 13)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('circle')
            .attr('stroke', 'black')
            .attr('fill', 'transparent')
            .attr('cx', 7)
            .attr('cy', 7)
            .attr('r', 6),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-lollipopEnd')
              .attr('class', 'marker lollipop ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 190)
              .attr('markerHeight', 240)
              .attr('orient', 'auto')
              .append('circle')
              .attr('stroke', 'black')
              .attr('fill', 'transparent')
              .attr('cx', 7)
              .attr('cy', 7)
              .attr('r', 6)
        }, 'lollipop')),
        (ukt = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-pointEnd')
            .attr('class', 'marker ' + t)
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 5)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-pointStart')
              .attr('class', 'marker ' + t)
              .attr('viewBox', '0 0 10 10')
              .attr('refX', 4.5)
              .attr('refY', 5)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 8)
              .attr('markerHeight', 8)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 0 5 L 10 10 L 10 0 z')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 1)
              .style('stroke-dasharray', '1,0')
        }, 'point')),
        (hkt = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-circleEnd')
            .attr('class', 'marker ' + t)
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 11)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 11)
            .attr('markerHeight', 11)
            .attr('orient', 'auto')
            .append('circle')
            .attr('cx', '5')
            .attr('cy', '5')
            .attr('r', '5')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-circleStart')
              .attr('class', 'marker ' + t)
              .attr('viewBox', '0 0 10 10')
              .attr('refX', -1)
              .attr('refY', 5)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 11)
              .attr('markerHeight', 11)
              .attr('orient', 'auto')
              .append('circle')
              .attr('cx', '5')
              .attr('cy', '5')
              .attr('r', '5')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 1)
              .style('stroke-dasharray', '1,0')
        }, 'circle')),
        (fkt = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-crossEnd')
            .attr('class', 'marker cross ' + t)
            .attr('viewBox', '0 0 11 11')
            .attr('refX', 12)
            .attr('refY', 5.2)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 11)
            .attr('markerHeight', 11)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 2)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-crossStart')
              .attr('class', 'marker cross ' + t)
              .attr('viewBox', '0 0 11 11')
              .attr('refX', -1)
              .attr('refY', 5.2)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 11)
              .attr('markerHeight', 11)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 2)
              .style('stroke-dasharray', '1,0')
        }, 'cross')),
        (dkt = a((e, t, r) => {
          e.append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-barbEnd')
            .attr('refX', 19)
            .attr('refY', 7)
            .attr('markerWidth', 20)
            .attr('markerHeight', 14)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z')
        }, 'barb')),
        (pkt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-onlyOneStart')
            .attr('class', 'marker onlyOne ' + t)
            .attr('refX', 0)
            .attr('refY', 9)
            .attr('markerWidth', 18)
            .attr('markerHeight', 18)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M9,0 L9,18 M15,0 L15,18'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-onlyOneEnd')
              .attr('class', 'marker onlyOne ' + t)
              .attr('refX', 18)
              .attr('refY', 9)
              .attr('markerWidth', 18)
              .attr('markerHeight', 18)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M3,0 L3,18 M9,0 L9,18')
        }, 'only_one')),
        (mkt = a((e, t, r) => {
          let n = e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-zeroOrOneStart')
            .attr('class', 'marker zeroOrOne ' + t)
            .attr('refX', 0)
            .attr('refY', 9)
            .attr('markerWidth', 30)
            .attr('markerHeight', 18)
            .attr('orient', 'auto')
          n.append('circle').attr('fill', 'white').attr('cx', 21).attr('cy', 9).attr('r', 6),
            n.append('path').attr('d', 'M9,0 L9,18')
          let i = e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-zeroOrOneEnd')
            .attr('class', 'marker zeroOrOne ' + t)
            .attr('refX', 30)
            .attr('refY', 9)
            .attr('markerWidth', 30)
            .attr('markerHeight', 18)
            .attr('orient', 'auto')
          i.append('circle').attr('fill', 'white').attr('cx', 9).attr('cy', 9).attr('r', 6),
            i.append('path').attr('d', 'M21,0 L21,18')
        }, 'zero_or_one')),
        (gkt = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-oneOrMoreStart')
            .attr('class', 'marker oneOrMore ' + t)
            .attr('refX', 18)
            .attr('refY', 18)
            .attr('markerWidth', 45)
            .attr('markerHeight', 36)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-oneOrMoreEnd')
              .attr('class', 'marker oneOrMore ' + t)
              .attr('refX', 27)
              .attr('refY', 18)
              .attr('markerWidth', 45)
              .attr('markerHeight', 36)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18')
        }, 'one_or_more')),
        (ykt = a((e, t, r) => {
          let n = e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-zeroOrMoreStart')
            .attr('class', 'marker zeroOrMore ' + t)
            .attr('refX', 18)
            .attr('refY', 18)
            .attr('markerWidth', 57)
            .attr('markerHeight', 36)
            .attr('orient', 'auto')
          n.append('circle').attr('fill', 'white').attr('cx', 48).attr('cy', 18).attr('r', 6),
            n.append('path').attr('d', 'M0,18 Q18,0 36,18 Q18,36 0,18')
          let i = e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-zeroOrMoreEnd')
            .attr('class', 'marker zeroOrMore ' + t)
            .attr('refX', 39)
            .attr('refY', 18)
            .attr('markerWidth', 57)
            .attr('markerHeight', 36)
            .attr('orient', 'auto')
          i.append('circle').attr('fill', 'white').attr('cx', 9).attr('cy', 18).attr('r', 6),
            i.append('path').attr('d', 'M21,18 Q39,0 57,18 Q39,36 21,18')
        }, 'zero_or_more')),
        (xkt = a((e, t, r) => {
          e.append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-requirement_arrowEnd')
            .attr('refX', 20)
            .attr('refY', 10)
            .attr('markerWidth', 20)
            .attr('markerHeight', 20)
            .attr('orient', 'auto')
            .append('path')
            .attr(
              'd',
              `M0,0
      L20,10
      M20,10
      L0,20`,
            )
        }, 'requirement_arrow')),
        (bkt = a((e, t, r) => {
          let n = e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-requirement_containsStart')
            .attr('refX', 0)
            .attr('refY', 10)
            .attr('markerWidth', 20)
            .attr('markerHeight', 20)
            .attr('orient', 'auto')
            .append('g')
          n.append('circle').attr('cx', 10).attr('cy', 10).attr('r', 9).attr('fill', 'none'),
            n.append('line').attr('x1', 1).attr('x2', 19).attr('y1', 10).attr('y2', 10),
            n.append('line').attr('y1', 1).attr('y2', 19).attr('x1', 10).attr('x2', 10)
        }, 'requirement_contains')),
        (kkt = {
          extension: skt,
          composition: akt,
          aggregation: okt,
          dependency: lkt,
          lollipop: ckt,
          point: ukt,
          circle: hkt,
          cross: fkt,
          barb: dkt,
          only_one: pkt,
          zero_or_one: mkt,
          one_or_more: gkt,
          zero_or_more: ykt,
          requirement_arrow: xkt,
          requirement_contains: bkt,
        }),
        (rk = ikt)
    })
  async function dd(e, t, r) {
    let n, i
    t.shape === 'rect' && (t.rx && t.ry ? (t.shape = 'roundedRect') : (t.shape = 'squareRect'))
    let s = t.shape ? DA[t.shape] : void 0
    if (!s) throw new Error(`No such shape: ${t.shape}. Please check your syntax.`)
    if (t.link) {
      let o
      r.config.securityLevel === 'sandbox' ? (o = '_top') : t.linkTarget && (o = t.linkTarget || '_blank'),
        (n = e
          .insert('svg:a')
          .attr('xlink:href', t.link)
          .attr('target', o ?? null)),
        (i = await s(n, t, r))
    } else (i = await s(e, t, r)), (n = i)
    return (
      t.tooltip && i.attr('title', t.tooltip),
      nk.set(t.id, n),
      t.haveCallback && n.attr('class', n.attr('class') + ' clickable'),
      n
    )
  }
  var nk,
    gU,
    yU,
    G0,
    ik = x(() => {
      'use strict'
      Vt()
      NA()
      nk = new Map()
      a(dd, 'insertNode')
      ;(gU = a((e, t) => {
        nk.set(t.id, e)
      }, 'setNodeElem')),
        (yU = a(() => {
          nk.clear()
        }, 'clear')),
        (G0 = a((e) => {
          let t = nk.get(e.id)
          B.trace('Transforming node', e.diff, e, 'translate(' + (e.x - e.width / 2 - 5) + ', ' + e.width / 2 + ')')
          let r = 8,
            n = e.diff || 0
          return (
            e.clusterNode
              ? t.attr('transform', 'translate(' + (e.x + n - e.width / 2) + ', ' + (e.y - e.height / 2 - r) + ')')
              : t.attr('transform', 'translate(' + e.x + ', ' + e.y + ')'),
            n
          )
        }, 'positionNode'))
    })
  var xU,
    bU = x(() => {
      'use strict'
      fn()
      Be()
      Vt()
      Hb()
      OA()
      PA()
      ik()
      Qt()
      Ce()
      xU = {
        common: Rt,
        getConfig: Te,
        insertCluster: fd,
        insertEdge: ek,
        insertEdgeLabel: Jb,
        insertMarkers: rk,
        insertNode: dd,
        interpolateToCurve: C4,
        labelHelper: Bt,
        log: B,
        positionEdgeLabel: tk,
      }
    })
  function Skt(e) {
    return typeof e == 'symbol' || (on(e) && ni(e) == Tkt)
  }
  var Tkt,
    Ds,
    nh = x(() => {
      'use strict'
      fl()
      Zs()
      Tkt = '[object Symbol]'
      a(Skt, 'isSymbol')
      Ds = Skt
    })
  function _kt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; ) i[r] = t(e[r], r, e)
    return i
  }
  var hs,
    ih = x(() => {
      'use strict'
      a(_kt, 'arrayMap')
      hs = _kt
    })
  function SU(e) {
    if (typeof e == 'string') return e
    if (Jt(e)) return hs(e, SU) + ''
    if (Ds(e)) return TU ? TU.call(e) : ''
    var t = e + ''
    return t == '0' && 1 / e == -Ckt ? '-0' : t
  }
  var Ckt,
    kU,
    TU,
    _U,
    CU = x(() => {
      'use strict'
      zu()
      ih()
      Qr()
      nh()
      ;(Ckt = 1 / 0), (kU = qn ? qn.prototype : void 0), (TU = kU ? kU.toString : void 0)
      a(SU, 'baseToString')
      _U = SU
    })
  function Ekt(e) {
    for (var t = e.length; t-- && wkt.test(e.charAt(t)); );
    return t
  }
  var wkt,
    wU,
    EU = x(() => {
      'use strict'
      wkt = /\s/
      a(Ekt, 'trimmedEndIndex')
      wU = Ekt
    })
  function Akt(e) {
    return e && e.slice(0, wU(e) + 1).replace(vkt, '')
  }
  var vkt,
    vU,
    AU = x(() => {
      'use strict'
      EU()
      vkt = /^\s+/
      a(Akt, 'baseTrim')
      vU = Akt
    })
  function Ikt(e) {
    if (typeof e == 'number') return e
    if (Ds(e)) return LU
    if (Nr(e)) {
      var t = typeof e.valueOf == 'function' ? e.valueOf() : e
      e = Nr(t) ? t + '' : t
    }
    if (typeof e != 'string') return e === 0 ? e : +e
    e = vU(e)
    var r = Rkt.test(e)
    return r || Dkt.test(e) ? Nkt(e.slice(2), r ? 2 : 8) : Lkt.test(e) ? LU : +e
  }
  var LU,
    Lkt,
    Rkt,
    Dkt,
    Nkt,
    RU,
    DU = x(() => {
      'use strict'
      AU()
      As()
      nh()
      ;(LU = NaN), (Lkt = /^[-+]0x[0-9a-f]+$/i), (Rkt = /^0b[01]+$/i), (Dkt = /^0o[0-7]+$/i), (Nkt = parseInt)
      a(Ikt, 'toNumber')
      RU = Ikt
    })
  function Okt(e) {
    if (!e) return e === 0 ? e : 0
    if (((e = RU(e)), e === NU || e === -NU)) {
      var t = e < 0 ? -1 : 1
      return t * Mkt
    }
    return e === e ? e : 0
  }
  var NU,
    Mkt,
    pd,
    BA = x(() => {
      'use strict'
      DU()
      ;(NU = 1 / 0), (Mkt = 17976931348623157e292)
      a(Okt, 'toFinite')
      pd = Okt
    })
  function Pkt(e) {
    var t = pd(e),
      r = t % 1
    return t === t ? (r ? t - r : t) : 0
  }
  var _o,
    md = x(() => {
      'use strict'
      BA()
      a(Pkt, 'toInteger')
      _o = Pkt
    })
  var Bkt,
    sk,
    IU = x(() => {
      'use strict'
      hc()
      Ks()
      ;(Bkt = rs(pn, 'WeakMap')), (sk = Bkt)
    })
  function Fkt() {}
  var cn,
    FA = x(() => {
      'use strict'
      a(Fkt, 'noop')
      cn = Fkt
    })
  function $kt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n && t(e[r], r, e) !== !1; );
    return e
  }
  var ak,
    $A = x(() => {
      'use strict'
      a($kt, 'arrayEach')
      ak = $kt
    })
  function Gkt(e, t, r, n) {
    for (var i = e.length, s = r + (n ? 1 : -1); n ? s-- : ++s < i; ) if (t(e[s], s, e)) return s
    return -1
  }
  var ok,
    GA = x(() => {
      'use strict'
      a(Gkt, 'baseFindIndex')
      ok = Gkt
    })
  function Vkt(e) {
    return e !== e
  }
  var MU,
    OU = x(() => {
      'use strict'
      a(Vkt, 'baseIsNaN')
      MU = Vkt
    })
  function zkt(e, t, r) {
    for (var n = r - 1, i = e.length; ++n < i; ) if (e[n] === t) return n
    return -1
  }
  var PU,
    BU = x(() => {
      'use strict'
      a(zkt, 'strictIndexOf')
      PU = zkt
    })
  function Wkt(e, t, r) {
    return t === t ? PU(e, t, r) : ok(e, MU, r)
  }
  var gd,
    lk = x(() => {
      'use strict'
      GA()
      OU()
      BU()
      a(Wkt, 'baseIndexOf')
      gd = Wkt
    })
  function Ukt(e, t) {
    var r = e == null ? 0 : e.length
    return !!r && gd(e, t, 0) > -1
  }
  var ck,
    VA = x(() => {
      'use strict'
      lk()
      a(Ukt, 'arrayIncludes')
      ck = Ukt
    })
  var jkt,
    FU,
    $U = x(() => {
      'use strict'
      h4()
      ;(jkt = nb(Object.keys, Object)), (FU = jkt)
    })
  function Ykt(e) {
    if (!po(e)) return FU(e)
    var t = []
    for (var r in Object(e)) Hkt.call(e, r) && r != 'constructor' && t.push(r)
    return t
  }
  var qkt,
    Hkt,
    yd,
    uk = x(() => {
      'use strict'
      Jf()
      $U()
      ;(qkt = Object.prototype), (Hkt = qkt.hasOwnProperty)
      a(Ykt, 'baseKeys')
      yd = Ykt
    })
  function Xkt(e) {
    return mn(e) ? lb(e) : yd(e)
  }
  var cr,
    Co = x(() => {
      'use strict'
      g4()
      uk()
      Js()
      a(Xkt, 'keys')
      cr = Xkt
    })
  var Kkt,
    Qkt,
    Zkt,
    ai,
    GU = x(() => {
      'use strict'
      nd()
      Hu()
      k4()
      Js()
      Jf()
      Co()
      ;(Kkt = Object.prototype),
        (Qkt = Kkt.hasOwnProperty),
        (Zkt = hb(function (e, t) {
          if (po(t) || mn(t)) {
            ra(t, cr(t), e)
            return
          }
          for (var r in t) Qkt.call(t, r) && mo(e, r, t[r])
        })),
        (ai = Zkt)
    })
  function eTt(e, t) {
    if (Jt(e)) return !1
    var r = typeof e
    return r == 'number' || r == 'symbol' || r == 'boolean' || e == null || Ds(e)
      ? !0
      : tTt.test(e) || !Jkt.test(e) || (t != null && e in Object(t))
  }
  var Jkt,
    tTt,
    xd,
    hk = x(() => {
      'use strict'
      Qr()
      nh()
      ;(Jkt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/), (tTt = /^\w*$/)
      a(eTt, 'isKey')
      xd = eTt
    })
  function nTt(e) {
    var t = jf(e, function (n) {
        return r.size === rTt && r.clear(), n
      }),
      r = t.cache
    return t
  }
  var rTt,
    VU,
    zU = x(() => {
      'use strict'
      i4()
      rTt = 500
      a(nTt, 'memoizeCapped')
      VU = nTt
    })
  var iTt,
    sTt,
    aTt,
    WU,
    UU = x(() => {
      'use strict'
      zU()
      ;(iTt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g),
        (sTt = /\\(\\)?/g),
        (aTt = VU(function (e) {
          var t = []
          return (
            e.charCodeAt(0) === 46 && t.push(''),
            e.replace(iTt, function (r, n, i, s) {
              t.push(i ? s.replace(sTt, '$1') : n || r)
            }),
            t
          )
        })),
        (WU = aTt)
    })
  function oTt(e) {
    return e == null ? '' : _U(e)
  }
  var fk,
    zA = x(() => {
      'use strict'
      CU()
      a(oTt, 'toString')
      fk = oTt
    })
  function lTt(e, t) {
    return Jt(e) ? e : xd(e, t) ? [e] : WU(fk(e))
  }
  var Rc,
    V0 = x(() => {
      'use strict'
      Qr()
      hk()
      UU()
      zA()
      a(lTt, 'castPath')
      Rc = lTt
    })
  function uTt(e) {
    if (typeof e == 'string' || Ds(e)) return e
    var t = e + ''
    return t == '0' && 1 / e == -cTt ? '-0' : t
  }
  var cTt,
    wo,
    bd = x(() => {
      'use strict'
      nh()
      cTt = 1 / 0
      a(uTt, 'toKey')
      wo = uTt
    })
  function hTt(e, t) {
    t = Rc(t, e)
    for (var r = 0, n = t.length; e != null && r < n; ) e = e[wo(t[r++])]
    return r && r == n ? e : void 0
  }
  var Dc,
    z0 = x(() => {
      'use strict'
      V0()
      bd()
      a(hTt, 'baseGet')
      Dc = hTt
    })
  function fTt(e, t, r) {
    var n = e == null ? void 0 : Dc(e, t)
    return n === void 0 ? r : n
  }
  var jU,
    qU = x(() => {
      'use strict'
      z0()
      a(fTt, 'get')
      jU = fTt
    })
  function dTt(e, t) {
    for (var r = -1, n = t.length, i = e.length; ++r < n; ) e[i + r] = t[r]
    return e
  }
  var kd,
    dk = x(() => {
      'use strict'
      a(dTt, 'arrayPush')
      kd = dTt
    })
  function pTt(e) {
    return Jt(e) || Pa(e) || !!(HU && e && e[HU])
  }
  var HU,
    YU,
    XU = x(() => {
      'use strict'
      zu()
      td()
      Qr()
      HU = qn ? qn.isConcatSpreadable : void 0
      a(pTt, 'isFlattenable')
      YU = pTt
    })
  function KU(e, t, r, n, i) {
    var s = -1,
      o = e.length
    for (r || (r = YU), i || (i = []); ++s < o; ) {
      var l = e[s]
      t > 0 && r(l) ? (t > 1 ? KU(l, t - 1, r, n, i) : kd(i, l)) : n || (i[i.length] = l)
    }
    return i
  }
  var Eo,
    Td = x(() => {
      'use strict'
      dk()
      XU()
      a(KU, 'baseFlatten')
      Eo = KU
    })
  function mTt(e) {
    var t = e == null ? 0 : e.length
    return t ? Eo(e, 1) : []
  }
  var dr,
    pk = x(() => {
      'use strict'
      Td()
      a(mTt, 'flatten')
      dr = mTt
    })
  function gTt(e) {
    return ub(cb(e, void 0, dr), e + '')
  }
  var QU,
    ZU = x(() => {
      'use strict'
      pk()
      y4()
      b4()
      a(gTt, 'flatRest')
      QU = gTt
    })
  function yTt(e, t, r) {
    var n = -1,
      i = e.length
    t < 0 && (t = -t > i ? 0 : i + t),
      (r = r > i ? i : r),
      r < 0 && (r += i),
      (i = t > r ? 0 : (r - t) >>> 0),
      (t >>>= 0)
    for (var s = Array(i); ++n < i; ) s[n] = e[n + t]
    return s
  }
  var mk,
    WA = x(() => {
      'use strict'
      a(yTt, 'baseSlice')
      mk = yTt
    })
  function ETt(e) {
    return wTt.test(e)
  }
  var xTt,
    bTt,
    kTt,
    TTt,
    STt,
    _Tt,
    CTt,
    wTt,
    JU,
    tj = x(() => {
      'use strict'
      ;(xTt = '\\ud800-\\udfff'),
        (bTt = '\\u0300-\\u036f'),
        (kTt = '\\ufe20-\\ufe2f'),
        (TTt = '\\u20d0-\\u20ff'),
        (STt = bTt + kTt + TTt),
        (_Tt = '\\ufe0e\\ufe0f'),
        (CTt = '\\u200d'),
        (wTt = RegExp('[' + CTt + xTt + STt + _Tt + ']'))
      a(ETt, 'hasUnicode')
      JU = ETt
    })
  function vTt(e, t, r, n) {
    var i = -1,
      s = e == null ? 0 : e.length
    for (n && s && (r = e[++i]); ++i < s; ) r = t(r, e[i], i, e)
    return r
  }
  var ej,
    rj = x(() => {
      'use strict'
      a(vTt, 'arrayReduce')
      ej = vTt
    })
  function ATt(e, t) {
    return e && ra(t, cr(t), e)
  }
  var nj,
    ij = x(() => {
      'use strict'
      Hu()
      Co()
      a(ATt, 'baseAssign')
      nj = ATt
    })
  function LTt(e, t) {
    return e && ra(t, ns(t), e)
  }
  var sj,
    aj = x(() => {
      'use strict'
      Hu()
      xc()
      a(LTt, 'baseAssignIn')
      sj = LTt
    })
  function RTt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
      var o = e[r]
      t(o, r, e) && (s[i++] = o)
    }
    return s
  }
  var Sd,
    gk = x(() => {
      'use strict'
      a(RTt, 'arrayFilter')
      Sd = RTt
    })
  function DTt() {
    return []
  }
  var yk,
    UA = x(() => {
      'use strict'
      a(DTt, 'stubArray')
      yk = DTt
    })
  var NTt,
    ITt,
    oj,
    MTt,
    _d,
    xk = x(() => {
      'use strict'
      gk()
      UA()
      ;(NTt = Object.prototype),
        (ITt = NTt.propertyIsEnumerable),
        (oj = Object.getOwnPropertySymbols),
        (MTt = oj
          ? function (e) {
              return e == null
                ? []
                : ((e = Object(e)),
                  Sd(oj(e), function (t) {
                    return ITt.call(e, t)
                  }))
            }
          : yk),
        (_d = MTt)
    })
  function OTt(e, t) {
    return ra(e, _d(e), t)
  }
  var lj,
    cj = x(() => {
      'use strict'
      Hu()
      xk()
      a(OTt, 'copySymbols')
      lj = OTt
    })
  var PTt,
    BTt,
    bk,
    jA = x(() => {
      'use strict'
      dk()
      ib()
      xk()
      UA()
      ;(PTt = Object.getOwnPropertySymbols),
        (BTt = PTt
          ? function (e) {
              for (var t = []; e; ) kd(t, _d(e)), (e = Zf(e))
              return t
            }
          : yk),
        (bk = BTt)
    })
  function FTt(e, t) {
    return ra(e, bk(e), t)
  }
  var uj,
    hj = x(() => {
      'use strict'
      Hu()
      jA()
      a(FTt, 'copySymbolsIn')
      uj = FTt
    })
  function $Tt(e, t, r) {
    var n = t(e)
    return Jt(e) ? n : kd(n, r(e))
  }
  var kk,
    qA = x(() => {
      'use strict'
      dk()
      Qr()
      a($Tt, 'baseGetAllKeys')
      kk = $Tt
    })
  function GTt(e) {
    return kk(e, cr, _d)
  }
  var W0,
    HA = x(() => {
      'use strict'
      qA()
      xk()
      Co()
      a(GTt, 'getAllKeys')
      W0 = GTt
    })
  function VTt(e) {
    return kk(e, ns, bk)
  }
  var Tk,
    YA = x(() => {
      'use strict'
      qA()
      jA()
      xc()
      a(VTt, 'getAllKeysIn')
      Tk = VTt
    })
  var zTt,
    Sk,
    fj = x(() => {
      'use strict'
      hc()
      Ks()
      ;(zTt = rs(pn, 'DataView')), (Sk = zTt)
    })
  var WTt,
    _k,
    dj = x(() => {
      'use strict'
      hc()
      Ks()
      ;(WTt = rs(pn, 'Promise')), (_k = WTt)
    })
  var UTt,
    Nc,
    XA = x(() => {
      'use strict'
      hc()
      Ks()
      ;(UTt = rs(pn, 'Set')), (Nc = UTt)
    })
  var pj,
    jTt,
    mj,
    gj,
    yj,
    xj,
    qTt,
    HTt,
    YTt,
    XTt,
    KTt,
    sh,
    Ns,
    ah = x(() => {
      'use strict'
      fj()
      K2()
      dj()
      XA()
      IU()
      fl()
      e4()
      ;(pj = '[object Map]'),
        (jTt = '[object Object]'),
        (mj = '[object Promise]'),
        (gj = '[object Set]'),
        (yj = '[object WeakMap]'),
        (xj = '[object DataView]'),
        (qTt = dl(Sk)),
        (HTt = dl(pc)),
        (YTt = dl(_k)),
        (XTt = dl(Nc)),
        (KTt = dl(sk)),
        (sh = ni)
      ;((Sk && sh(new Sk(new ArrayBuffer(1))) != xj) ||
        (pc && sh(new pc()) != pj) ||
        (_k && sh(_k.resolve()) != mj) ||
        (Nc && sh(new Nc()) != gj) ||
        (sk && sh(new sk()) != yj)) &&
        (sh = a(function (e) {
          var t = ni(e),
            r = t == jTt ? e.constructor : void 0,
            n = r ? dl(r) : ''
          if (n)
            switch (n) {
              case qTt:
                return xj
              case HTt:
                return pj
              case YTt:
                return mj
              case XTt:
                return gj
              case KTt:
                return yj
            }
          return t
        }, 'getTag'))
      Ns = sh
    })
  function JTt(e) {
    var t = e.length,
      r = new e.constructor(t)
    return t && typeof e[0] == 'string' && ZTt.call(e, 'index') && ((r.index = e.index), (r.input = e.input)), r
  }
  var QTt,
    ZTt,
    bj,
    kj = x(() => {
      'use strict'
      ;(QTt = Object.prototype), (ZTt = QTt.hasOwnProperty)
      a(JTt, 'initCloneArray')
      bj = JTt
    })
  function tSt(e, t) {
    var r = t ? Qf(e.buffer) : e.buffer
    return new e.constructor(r, e.byteOffset, e.byteLength)
  }
  var Tj,
    Sj = x(() => {
      'use strict'
      tb()
      a(tSt, 'cloneDataView')
      Tj = tSt
    })
  function rSt(e) {
    var t = new e.constructor(e.source, eSt.exec(e))
    return (t.lastIndex = e.lastIndex), t
  }
  var eSt,
    _j,
    Cj = x(() => {
      'use strict'
      eSt = /\w*$/
      a(rSt, 'cloneRegExp')
      _j = rSt
    })
  function nSt(e) {
    return Ej ? Object(Ej.call(e)) : {}
  }
  var wj,
    Ej,
    vj,
    Aj = x(() => {
      'use strict'
      zu()
      ;(wj = qn ? qn.prototype : void 0), (Ej = wj ? wj.valueOf : void 0)
      a(nSt, 'cloneSymbol')
      vj = nSt
    })
  function _St(e, t, r) {
    var n = e.constructor
    switch (t) {
      case fSt:
        return Qf(e)
      case iSt:
      case sSt:
        return new n(+e)
      case dSt:
        return Tj(e, r)
      case pSt:
      case mSt:
      case gSt:
      case ySt:
      case xSt:
      case bSt:
      case kSt:
      case TSt:
      case SSt:
        return eb(e, r)
      case aSt:
        return new n()
      case oSt:
      case uSt:
        return new n(e)
      case lSt:
        return _j(e)
      case cSt:
        return new n()
      case hSt:
        return vj(e)
    }
  }
  var iSt,
    sSt,
    aSt,
    oSt,
    lSt,
    cSt,
    uSt,
    hSt,
    fSt,
    dSt,
    pSt,
    mSt,
    gSt,
    ySt,
    xSt,
    bSt,
    kSt,
    TSt,
    SSt,
    Lj,
    Rj = x(() => {
      'use strict'
      tb()
      Sj()
      Cj()
      Aj()
      c4()
      ;(iSt = '[object Boolean]'),
        (sSt = '[object Date]'),
        (aSt = '[object Map]'),
        (oSt = '[object Number]'),
        (lSt = '[object RegExp]'),
        (cSt = '[object Set]'),
        (uSt = '[object String]'),
        (hSt = '[object Symbol]'),
        (fSt = '[object ArrayBuffer]'),
        (dSt = '[object DataView]'),
        (pSt = '[object Float32Array]'),
        (mSt = '[object Float64Array]'),
        (gSt = '[object Int8Array]'),
        (ySt = '[object Int16Array]'),
        (xSt = '[object Int32Array]'),
        (bSt = '[object Uint8Array]'),
        (kSt = '[object Uint8ClampedArray]'),
        (TSt = '[object Uint16Array]'),
        (SSt = '[object Uint32Array]')
      a(_St, 'initCloneByTag')
      Lj = _St
    })
  function wSt(e) {
    return on(e) && Ns(e) == CSt
  }
  var CSt,
    Dj,
    Nj = x(() => {
      'use strict'
      ah()
      Zs()
      CSt = '[object Map]'
      a(wSt, 'baseIsMap')
      Dj = wSt
    })
  var Ij,
    ESt,
    Mj,
    Oj = x(() => {
      'use strict'
      Nj()
      qu()
      g0()
      ;(Ij = ea && ea.isMap), (ESt = Ij ? ta(Ij) : Dj), (Mj = ESt)
    })
  function ASt(e) {
    return on(e) && Ns(e) == vSt
  }
  var vSt,
    Pj,
    Bj = x(() => {
      'use strict'
      ah()
      Zs()
      vSt = '[object Set]'
      a(ASt, 'baseIsSet')
      Pj = ASt
    })
  var Fj,
    LSt,
    $j,
    Gj = x(() => {
      'use strict'
      Bj()
      qu()
      g0()
      ;(Fj = ea && ea.isSet), (LSt = Fj ? ta(Fj) : Pj), ($j = LSt)
    })
  function Ck(e, t, r, n, i, s) {
    var o,
      l = t & RSt,
      u = t & DSt,
      h = t & NSt
    if ((r && (o = i ? r(e, n, i, s) : r(e)), o !== void 0)) return o
    if (!Nr(e)) return e
    var f = Jt(e)
    if (f) {
      if (((o = bj(e)), !l)) return rb(e, o)
    } else {
      var d = Ns(e),
        p = d == zj || d == BSt
      if (Ba(e)) return J2(e, l)
      if (d == Wj || d == Vj || (p && !i)) {
        if (((o = u || p ? {} : sb(e)), !l)) return u ? uj(e, sj(o, e)) : lj(e, nj(o, e))
      } else {
        if (!Gr[d]) return i ? e : {}
        o = Lj(e, d, l)
      }
    }
    s || (s = new ho())
    var m = s.get(e)
    if (m) return m
    s.set(e, o),
      $j(e)
        ? e.forEach(function (b) {
            o.add(Ck(b, t, r, b, e, s))
          })
        : Mj(e) &&
          e.forEach(function (b, k) {
            o.set(k, Ck(b, t, r, k, e, s))
          })
    var g = h ? (u ? Tk : W0) : u ? ns : cr,
      y = f ? void 0 : g(e)
    return (
      ak(y || e, function (b, k) {
        y && ((k = b), (b = e[k])), mo(o, k, Ck(b, t, r, k, e, s))
      }),
      o
    )
  }
  var RSt,
    DSt,
    NSt,
    Vj,
    ISt,
    MSt,
    OSt,
    PSt,
    zj,
    BSt,
    FSt,
    $St,
    Wj,
    GSt,
    VSt,
    zSt,
    WSt,
    USt,
    jSt,
    qSt,
    HSt,
    YSt,
    XSt,
    KSt,
    QSt,
    ZSt,
    JSt,
    t_t,
    e_t,
    Gr,
    wk,
    KA = x(() => {
      'use strict'
      d0()
      $A()
      nd()
      ij()
      aj()
      o4()
      u4()
      cj()
      hj()
      HA()
      YA()
      ah()
      kj()
      Rj()
      f4()
      Qr()
      rd()
      Oj()
      As()
      Gj()
      Co()
      xc()
      ;(RSt = 1),
        (DSt = 2),
        (NSt = 4),
        (Vj = '[object Arguments]'),
        (ISt = '[object Array]'),
        (MSt = '[object Boolean]'),
        (OSt = '[object Date]'),
        (PSt = '[object Error]'),
        (zj = '[object Function]'),
        (BSt = '[object GeneratorFunction]'),
        (FSt = '[object Map]'),
        ($St = '[object Number]'),
        (Wj = '[object Object]'),
        (GSt = '[object RegExp]'),
        (VSt = '[object Set]'),
        (zSt = '[object String]'),
        (WSt = '[object Symbol]'),
        (USt = '[object WeakMap]'),
        (jSt = '[object ArrayBuffer]'),
        (qSt = '[object DataView]'),
        (HSt = '[object Float32Array]'),
        (YSt = '[object Float64Array]'),
        (XSt = '[object Int8Array]'),
        (KSt = '[object Int16Array]'),
        (QSt = '[object Int32Array]'),
        (ZSt = '[object Uint8Array]'),
        (JSt = '[object Uint8ClampedArray]'),
        (t_t = '[object Uint16Array]'),
        (e_t = '[object Uint32Array]'),
        (Gr = {})
      Gr[Vj] =
        Gr[ISt] =
        Gr[jSt] =
        Gr[qSt] =
        Gr[MSt] =
        Gr[OSt] =
        Gr[HSt] =
        Gr[YSt] =
        Gr[XSt] =
        Gr[KSt] =
        Gr[QSt] =
        Gr[FSt] =
        Gr[$St] =
        Gr[Wj] =
        Gr[GSt] =
        Gr[VSt] =
        Gr[zSt] =
        Gr[WSt] =
        Gr[ZSt] =
        Gr[JSt] =
        Gr[t_t] =
        Gr[e_t] =
          !0
      Gr[PSt] = Gr[zj] = Gr[USt] = !1
      a(Ck, 'baseClone')
      wk = Ck
    })
  function n_t(e) {
    return wk(e, r_t)
  }
  var r_t,
    Sr,
    QA = x(() => {
      'use strict'
      KA()
      r_t = 4
      a(n_t, 'clone')
      Sr = n_t
    })
  function a_t(e) {
    return wk(e, i_t | s_t)
  }
  var i_t,
    s_t,
    ZA,
    Uj = x(() => {
      'use strict'
      KA()
      ;(i_t = 1), (s_t = 4)
      a(a_t, 'cloneDeep')
      ZA = a_t
    })
  function o_t(e) {
    for (var t = -1, r = e == null ? 0 : e.length, n = 0, i = []; ++t < r; ) {
      var s = e[t]
      s && (i[n++] = s)
    }
    return i
  }
  var vo,
    jj = x(() => {
      'use strict'
      a(o_t, 'compact')
      vo = o_t
    })
  function c_t(e) {
    return this.__data__.set(e, l_t), this
  }
  var l_t,
    qj,
    Hj = x(() => {
      'use strict'
      l_t = '__lodash_hash_undefined__'
      a(c_t, 'setCacheAdd')
      qj = c_t
    })
  function u_t(e) {
    return this.__data__.has(e)
  }
  var Yj,
    Xj = x(() => {
      'use strict'
      a(u_t, 'setCacheHas')
      Yj = u_t
    })
  function Ek(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.__data__ = new Uu(); ++t < r; ) this.add(e[t])
  }
  var Cd,
    vk = x(() => {
      'use strict'
      Q2()
      Hj()
      Xj()
      a(Ek, 'SetCache')
      Ek.prototype.add = Ek.prototype.push = qj
      Ek.prototype.has = Yj
      Cd = Ek
    })
  function h_t(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; ) if (t(e[r], r, e)) return !0
    return !1
  }
  var Ak,
    JA = x(() => {
      'use strict'
      a(h_t, 'arraySome')
      Ak = h_t
    })
  function f_t(e, t) {
    return e.has(t)
  }
  var wd,
    Lk = x(() => {
      'use strict'
      a(f_t, 'cacheHas')
      wd = f_t
    })
  function m_t(e, t, r, n, i, s) {
    var o = r & d_t,
      l = e.length,
      u = t.length
    if (l != u && !(o && u > l)) return !1
    var h = s.get(e),
      f = s.get(t)
    if (h && f) return h == t && f == e
    var d = -1,
      p = !0,
      m = r & p_t ? new Cd() : void 0
    for (s.set(e, t), s.set(t, e); ++d < l; ) {
      var g = e[d],
        y = t[d]
      if (n) var b = o ? n(y, g, d, t, e, s) : n(g, y, d, e, t, s)
      if (b !== void 0) {
        if (b) continue
        p = !1
        break
      }
      if (m) {
        if (
          !Ak(t, function (k, T) {
            if (!wd(m, T) && (g === k || i(g, k, r, n, s))) return m.push(T)
          })
        ) {
          p = !1
          break
        }
      } else if (!(g === y || i(g, y, r, n, s))) {
        p = !1
        break
      }
    }
    return s.delete(e), s.delete(t), p
  }
  var d_t,
    p_t,
    Rk,
    t5 = x(() => {
      'use strict'
      vk()
      JA()
      Lk()
      ;(d_t = 1), (p_t = 2)
      a(m_t, 'equalArrays')
      Rk = m_t
    })
  function g_t(e) {
    var t = -1,
      r = Array(e.size)
    return (
      e.forEach(function (n, i) {
        r[++t] = [i, n]
      }),
      r
    )
  }
  var Kj,
    Qj = x(() => {
      'use strict'
      a(g_t, 'mapToArray')
      Kj = g_t
    })
  function y_t(e) {
    var t = -1,
      r = Array(e.size)
    return (
      e.forEach(function (n) {
        r[++t] = n
      }),
      r
    )
  }
  var Ed,
    Dk = x(() => {
      'use strict'
      a(y_t, 'setToArray')
      Ed = y_t
    })
  function D_t(e, t, r, n, i, s, o) {
    switch (r) {
      case R_t:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1
        ;(e = e.buffer), (t = t.buffer)
      case L_t:
        return !(e.byteLength != t.byteLength || !s(new Kf(e), new Kf(t)))
      case k_t:
      case T_t:
      case C_t:
        return Qs(+e, +t)
      case S_t:
        return e.name == t.name && e.message == t.message
      case w_t:
      case v_t:
        return e == t + ''
      case __t:
        var l = Kj
      case E_t:
        var u = n & x_t
        if ((l || (l = Ed), e.size != t.size && !u)) return !1
        var h = o.get(e)
        if (h) return h == t
        ;(n |= b_t), o.set(e, t)
        var f = Rk(l(e), l(t), n, i, s, o)
        return o.delete(e), f
      case A_t:
        if (e5) return e5.call(e) == e5.call(t)
    }
    return !1
  }
  var x_t,
    b_t,
    k_t,
    T_t,
    S_t,
    __t,
    C_t,
    w_t,
    E_t,
    v_t,
    A_t,
    L_t,
    R_t,
    Zj,
    e5,
    Jj,
    tq = x(() => {
      'use strict'
      zu()
      l4()
      Wu()
      t5()
      Qj()
      Dk()
      ;(x_t = 1),
        (b_t = 2),
        (k_t = '[object Boolean]'),
        (T_t = '[object Date]'),
        (S_t = '[object Error]'),
        (__t = '[object Map]'),
        (C_t = '[object Number]'),
        (w_t = '[object RegExp]'),
        (E_t = '[object Set]'),
        (v_t = '[object String]'),
        (A_t = '[object Symbol]'),
        (L_t = '[object ArrayBuffer]'),
        (R_t = '[object DataView]'),
        (Zj = qn ? qn.prototype : void 0),
        (e5 = Zj ? Zj.valueOf : void 0)
      a(D_t, 'equalByTag')
      Jj = D_t
    })
  function O_t(e, t, r, n, i, s) {
    var o = r & N_t,
      l = W0(e),
      u = l.length,
      h = W0(t),
      f = h.length
    if (u != f && !o) return !1
    for (var d = u; d--; ) {
      var p = l[d]
      if (!(o ? p in t : M_t.call(t, p))) return !1
    }
    var m = s.get(e),
      g = s.get(t)
    if (m && g) return m == t && g == e
    var y = !0
    s.set(e, t), s.set(t, e)
    for (var b = o; ++d < u; ) {
      p = l[d]
      var k = e[p],
        T = t[p]
      if (n) var C = o ? n(T, k, p, t, e, s) : n(k, T, p, e, t, s)
      if (!(C === void 0 ? k === T || i(k, T, r, n, s) : C)) {
        y = !1
        break
      }
      b || (b = p == 'constructor')
    }
    if (y && !b) {
      var A = e.constructor,
        w = t.constructor
      A != w &&
        'constructor' in e &&
        'constructor' in t &&
        !(typeof A == 'function' && A instanceof A && typeof w == 'function' && w instanceof w) &&
        (y = !1)
    }
    return s.delete(e), s.delete(t), y
  }
  var N_t,
    I_t,
    M_t,
    eq,
    rq = x(() => {
      'use strict'
      HA()
      ;(N_t = 1), (I_t = Object.prototype), (M_t = I_t.hasOwnProperty)
      a(O_t, 'equalObjects')
      eq = O_t
    })
  function F_t(e, t, r, n, i, s) {
    var o = Jt(e),
      l = Jt(t),
      u = o ? iq : Ns(e),
      h = l ? iq : Ns(t)
    ;(u = u == nq ? Nk : u), (h = h == nq ? Nk : h)
    var f = u == Nk,
      d = h == Nk,
      p = u == h
    if (p && Ba(e)) {
      if (!Ba(t)) return !1
      ;(o = !0), (f = !1)
    }
    if (p && !f) return s || (s = new ho()), o || gc(e) ? Rk(e, t, r, n, i, s) : Jj(e, t, u, r, n, i, s)
    if (!(r & P_t)) {
      var m = f && sq.call(e, '__wrapped__'),
        g = d && sq.call(t, '__wrapped__')
      if (m || g) {
        var y = m ? e.value() : e,
          b = g ? t.value() : t
        return s || (s = new ho()), i(y, b, r, n, s)
      }
    }
    return p ? (s || (s = new ho()), eq(e, t, r, n, i, s)) : !1
  }
  var P_t,
    nq,
    iq,
    Nk,
    B_t,
    sq,
    aq,
    oq = x(() => {
      'use strict'
      d0()
      t5()
      tq()
      rq()
      ah()
      Qr()
      rd()
      y0()
      ;(P_t = 1),
        (nq = '[object Arguments]'),
        (iq = '[object Array]'),
        (Nk = '[object Object]'),
        (B_t = Object.prototype),
        (sq = B_t.hasOwnProperty)
      a(F_t, 'baseIsEqualDeep')
      aq = F_t
    })
  function lq(e, t, r, n, i) {
    return e === t ? !0 : e == null || t == null || (!on(e) && !on(t)) ? e !== e && t !== t : aq(e, t, r, n, lq, i)
  }
  var Ik,
    r5 = x(() => {
      'use strict'
      oq()
      Zs()
      a(lq, 'baseIsEqual')
      Ik = lq
    })
  function V_t(e, t, r, n) {
    var i = r.length,
      s = i,
      o = !n
    if (e == null) return !s
    for (e = Object(e); i--; ) {
      var l = r[i]
      if (o && l[2] ? l[1] !== e[l[0]] : !(l[0] in e)) return !1
    }
    for (; ++i < s; ) {
      l = r[i]
      var u = l[0],
        h = e[u],
        f = l[1]
      if (o && l[2]) {
        if (h === void 0 && !(u in e)) return !1
      } else {
        var d = new ho()
        if (n) var p = n(h, f, u, e, t, d)
        if (!(p === void 0 ? Ik(f, h, $_t | G_t, n, d) : p)) return !1
      }
    }
    return !0
  }
  var $_t,
    G_t,
    cq,
    uq = x(() => {
      'use strict'
      d0()
      r5()
      ;($_t = 1), (G_t = 2)
      a(V_t, 'baseIsMatch')
      cq = V_t
    })
  function z_t(e) {
    return e === e && !Nr(e)
  }
  var Mk,
    n5 = x(() => {
      'use strict'
      As()
      a(z_t, 'isStrictComparable')
      Mk = z_t
    })
  function W_t(e) {
    for (var t = cr(e), r = t.length; r--; ) {
      var n = t[r],
        i = e[n]
      t[r] = [n, i, Mk(i)]
    }
    return t
  }
  var hq,
    fq = x(() => {
      'use strict'
      n5()
      Co()
      a(W_t, 'getMatchData')
      hq = W_t
    })
  function U_t(e, t) {
    return function (r) {
      return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r))
    }
  }
  var Ok,
    i5 = x(() => {
      'use strict'
      a(U_t, 'matchesStrictComparable')
      Ok = U_t
    })
  function j_t(e) {
    var t = hq(e)
    return t.length == 1 && t[0][2]
      ? Ok(t[0][0], t[0][1])
      : function (r) {
          return r === e || cq(r, e, t)
        }
  }
  var dq,
    pq = x(() => {
      'use strict'
      uq()
      fq()
      i5()
      a(j_t, 'baseMatches')
      dq = j_t
    })
  function q_t(e, t) {
    return e != null && t in Object(e)
  }
  var mq,
    gq = x(() => {
      'use strict'
      a(q_t, 'baseHasIn')
      mq = q_t
    })
  function H_t(e, t, r) {
    t = Rc(t, e)
    for (var n = -1, i = t.length, s = !1; ++n < i; ) {
      var o = wo(t[n])
      if (!(s = e != null && r(e, o))) break
      e = e[o]
    }
    return s || ++n != i ? s : ((i = e == null ? 0 : e.length), !!i && ed(i) && yc(o, i) && (Jt(e) || Pa(e)))
  }
  var Pk,
    s5 = x(() => {
      'use strict'
      V0()
      td()
      Qr()
      b0()
      ab()
      bd()
      a(H_t, 'hasPath')
      Pk = H_t
    })
  function Y_t(e, t) {
    return e != null && Pk(e, t, mq)
  }
  var Bk,
    a5 = x(() => {
      'use strict'
      gq()
      s5()
      a(Y_t, 'hasIn')
      Bk = Y_t
    })
  function Q_t(e, t) {
    return xd(e) && Mk(t)
      ? Ok(wo(e), t)
      : function (r) {
          var n = jU(r, e)
          return n === void 0 && n === t ? Bk(r, e) : Ik(t, n, X_t | K_t)
        }
  }
  var X_t,
    K_t,
    yq,
    xq = x(() => {
      'use strict'
      r5()
      qU()
      a5()
      hk()
      n5()
      i5()
      bd()
      ;(X_t = 1), (K_t = 2)
      a(Q_t, 'baseMatchesProperty')
      yq = Q_t
    })
  function Z_t(e) {
    return function (t) {
      return t?.[e]
    }
  }
  var Fk,
    o5 = x(() => {
      'use strict'
      a(Z_t, 'baseProperty')
      Fk = Z_t
    })
  function J_t(e) {
    return function (t) {
      return Dc(t, e)
    }
  }
  var bq,
    kq = x(() => {
      'use strict'
      z0()
      a(J_t, 'basePropertyDeep')
      bq = J_t
    })
  function tCt(e) {
    return xd(e) ? Fk(wo(e)) : bq(e)
  }
  var Tq,
    Sq = x(() => {
      'use strict'
      o5()
      kq()
      hk()
      bd()
      a(tCt, 'property')
      Tq = tCt
    })
  function eCt(e) {
    return typeof e == 'function' ? e : e == null ? Hn : typeof e == 'object' ? (Jt(e) ? yq(e[0], e[1]) : dq(e)) : Tq(e)
  }
  var Rr,
    Gi = x(() => {
      'use strict'
      pq()
      xq()
      ml()
      Qr()
      Sq()
      a(eCt, 'baseIteratee')
      Rr = eCt
    })
  function rCt(e, t, r, n) {
    for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {
      var o = e[i]
      t(n, o, r(o), e)
    }
    return n
  }
  var _q,
    Cq = x(() => {
      'use strict'
      a(rCt, 'arrayAggregator')
      _q = rCt
    })
  function nCt(e, t) {
    return e && Xf(e, t, cr)
  }
  var vd,
    $k = x(() => {
      'use strict'
      Z2()
      Co()
      a(nCt, 'baseForOwn')
      vd = nCt
    })
  function iCt(e, t) {
    return function (r, n) {
      if (r == null) return r
      if (!mn(r)) return e(r, n)
      for (var i = r.length, s = t ? i : -1, o = Object(r); (t ? s-- : ++s < i) && n(o[s], s, o) !== !1; );
      return r
    }
  }
  var wq,
    Eq = x(() => {
      'use strict'
      Js()
      a(iCt, 'createBaseEach')
      wq = iCt
    })
  var sCt,
    fs,
    Ic = x(() => {
      'use strict'
      $k()
      Eq()
      ;(sCt = wq(vd)), (fs = sCt)
    })
  function aCt(e, t, r, n) {
    return (
      fs(e, function (i, s, o) {
        t(n, i, r(i), o)
      }),
      n
    )
  }
  var vq,
    Aq = x(() => {
      'use strict'
      Ic()
      a(aCt, 'baseAggregator')
      vq = aCt
    })
  function oCt(e, t) {
    return function (r, n) {
      var i = Jt(r) ? _q : vq,
        s = t ? t() : {}
      return i(r, e, Rr(n, 2), s)
    }
  }
  var Lq,
    Rq = x(() => {
      'use strict'
      Cq()
      Aq()
      Gi()
      Qr()
      a(oCt, 'createAggregator')
      Lq = oCt
    })
  var lCt,
    Gk,
    Dq = x(() => {
      'use strict'
      Ks()
      ;(lCt = a(function () {
        return pn.Date.now()
      }, 'now')),
        (Gk = lCt)
    })
  var Nq,
    cCt,
    uCt,
    Mc,
    Iq = x(() => {
      'use strict'
      id()
      Wu()
      Yu()
      xc()
      ;(Nq = Object.prototype),
        (cCt = Nq.hasOwnProperty),
        (uCt = go(function (e, t) {
          e = Object(e)
          var r = -1,
            n = t.length,
            i = n > 2 ? t[2] : void 0
          for (i && Ls(t[0], t[1], i) && (n = 1); ++r < n; )
            for (var s = t[r], o = ns(s), l = -1, u = o.length; ++l < u; ) {
              var h = o[l],
                f = e[h]
              ;(f === void 0 || (Qs(f, Nq[h]) && !cCt.call(e, h))) && (e[h] = s[h])
            }
          return e
        })),
        (Mc = uCt)
    })
  function hCt(e, t, r) {
    for (var n = -1, i = e == null ? 0 : e.length; ++n < i; ) if (r(t, e[n])) return !0
    return !1
  }
  var Vk,
    l5 = x(() => {
      'use strict'
      a(hCt, 'arrayIncludesWith')
      Vk = hCt
    })
  function dCt(e, t, r, n) {
    var i = -1,
      s = ck,
      o = !0,
      l = e.length,
      u = [],
      h = t.length
    if (!l) return u
    r && (t = hs(t, ta(r))), n ? ((s = Vk), (o = !1)) : t.length >= fCt && ((s = wd), (o = !1), (t = new Cd(t)))
    t: for (; ++i < l; ) {
      var f = e[i],
        d = r == null ? f : r(f)
      if (((f = n || f !== 0 ? f : 0), o && d === d)) {
        for (var p = h; p--; ) if (t[p] === d) continue t
        u.push(f)
      } else s(t, d, n) || u.push(f)
    }
    return u
  }
  var fCt,
    Mq,
    Oq = x(() => {
      'use strict'
      vk()
      VA()
      l5()
      ih()
      qu()
      Lk()
      fCt = 200
      a(dCt, 'baseDifference')
      Mq = dCt
    })
  var pCt,
    Oc,
    Pq = x(() => {
      'use strict'
      Oq()
      Td()
      id()
      ob()
      ;(pCt = go(function (e, t) {
        return ju(e) ? Mq(e, Eo(t, 1, ju, !0)) : []
      })),
        (Oc = pCt)
    })
  function mCt(e) {
    var t = e == null ? 0 : e.length
    return t ? e[t - 1] : void 0
  }
  var oi,
    Bq = x(() => {
      'use strict'
      a(mCt, 'last')
      oi = mCt
    })
  function gCt(e, t, r) {
    var n = e == null ? 0 : e.length
    return n ? ((t = r || t === void 0 ? 1 : _o(t)), mk(e, t < 0 ? 0 : t, n)) : []
  }
  var kn,
    Fq = x(() => {
      'use strict'
      WA()
      md()
      a(gCt, 'drop')
      kn = gCt
    })
  function yCt(e, t, r) {
    var n = e == null ? 0 : e.length
    return n ? ((t = r || t === void 0 ? 1 : _o(t)), (t = n - t), mk(e, 0, t < 0 ? 0 : t)) : []
  }
  var Tl,
    $q = x(() => {
      'use strict'
      WA()
      md()
      a(yCt, 'dropRight')
      Tl = yCt
    })
  function xCt(e) {
    return typeof e == 'function' ? e : Hn
  }
  var Ad,
    zk = x(() => {
      'use strict'
      ml()
      a(xCt, 'castFunction')
      Ad = xCt
    })
  function bCt(e, t) {
    var r = Jt(e) ? ak : fs
    return r(e, Ad(t))
  }
  var rt,
    Wk = x(() => {
      'use strict'
      $A()
      Ic()
      zk()
      Qr()
      a(bCt, 'forEach')
      rt = bCt
    })
  var Gq = x(() => {
    'use strict'
    Wk()
  })
  function kCt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; ) if (!t(e[r], r, e)) return !1
    return !0
  }
  var Vq,
    zq = x(() => {
      'use strict'
      a(kCt, 'arrayEvery')
      Vq = kCt
    })
  function TCt(e, t) {
    var r = !0
    return (
      fs(e, function (n, i, s) {
        return (r = !!t(n, i, s)), r
      }),
      r
    )
  }
  var Wq,
    Uq = x(() => {
      'use strict'
      Ic()
      a(TCt, 'baseEvery')
      Wq = TCt
    })
  function SCt(e, t, r) {
    var n = Jt(e) ? Vq : Wq
    return r && Ls(e, t, r) && (t = void 0), n(e, Rr(t, 3))
  }
  var ki,
    jq = x(() => {
      'use strict'
      zq()
      Uq()
      Gi()
      Qr()
      Yu()
      a(SCt, 'every')
      ki = SCt
    })
  function _Ct(e, t) {
    var r = []
    return (
      fs(e, function (n, i, s) {
        t(n, i, s) && r.push(n)
      }),
      r
    )
  }
  var Uk,
    c5 = x(() => {
      'use strict'
      Ic()
      a(_Ct, 'baseFilter')
      Uk = _Ct
    })
  function CCt(e, t) {
    var r = Jt(e) ? Sd : Uk
    return r(e, Rr(t, 3))
  }
  var pr,
    u5 = x(() => {
      'use strict'
      gk()
      c5()
      Gi()
      Qr()
      a(CCt, 'filter')
      pr = CCt
    })
  function wCt(e) {
    return function (t, r, n) {
      var i = Object(t)
      if (!mn(t)) {
        var s = Rr(r, 3)
        ;(t = cr(t)),
          (r = a(function (l) {
            return s(i[l], l, i)
          }, 'predicate'))
      }
      var o = e(t, r, n)
      return o > -1 ? i[s ? t[o] : o] : void 0
    }
  }
  var qq,
    Hq = x(() => {
      'use strict'
      Gi()
      Js()
      Co()
      a(wCt, 'createFind')
      qq = wCt
    })
  function vCt(e, t, r) {
    var n = e == null ? 0 : e.length
    if (!n) return -1
    var i = r == null ? 0 : _o(r)
    return i < 0 && (i = ECt(n + i, 0)), ok(e, Rr(t, 3), i)
  }
  var ECt,
    Yq,
    Xq = x(() => {
      'use strict'
      GA()
      Gi()
      md()
      ECt = Math.max
      a(vCt, 'findIndex')
      Yq = vCt
    })
  var ACt,
    Vi,
    Kq = x(() => {
      'use strict'
      Hq()
      Xq()
      ;(ACt = qq(Yq)), (Vi = ACt)
    })
  function LCt(e) {
    return e && e.length ? e[0] : void 0
  }
  var Qn,
    Qq = x(() => {
      'use strict'
      a(LCt, 'head')
      Qn = LCt
    })
  var Zq = x(() => {
    'use strict'
    Qq()
  })
  function RCt(e, t) {
    var r = -1,
      n = mn(e) ? Array(e.length) : []
    return (
      fs(e, function (i, s, o) {
        n[++r] = t(i, s, o)
      }),
      n
    )
  }
  var jk,
    h5 = x(() => {
      'use strict'
      Ic()
      Js()
      a(RCt, 'baseMap')
      jk = RCt
    })
  function DCt(e, t) {
    var r = Jt(e) ? hs : jk
    return r(e, Rr(t, 3))
  }
  var Dt,
    Ld = x(() => {
      'use strict'
      ih()
      Gi()
      h5()
      Qr()
      a(DCt, 'map')
      Dt = DCt
    })
  function NCt(e, t) {
    return Eo(Dt(e, t), 1)
  }
  var li,
    f5 = x(() => {
      'use strict'
      Td()
      Ld()
      a(NCt, 'flatMap')
      li = NCt
    })
  function ICt(e, t) {
    return e == null ? e : Xf(e, Ad(t), ns)
  }
  var d5,
    Jq = x(() => {
      'use strict'
      Z2()
      zk()
      xc()
      a(ICt, 'forIn')
      d5 = ICt
    })
  function MCt(e, t) {
    return e && vd(e, Ad(t))
  }
  var p5,
    tH = x(() => {
      'use strict'
      $k()
      zk()
      a(MCt, 'forOwn')
      p5 = MCt
    })
  var OCt,
    PCt,
    BCt,
    m5,
    eH = x(() => {
      'use strict'
      Yf()
      Rq()
      ;(OCt = Object.prototype),
        (PCt = OCt.hasOwnProperty),
        (BCt = Lq(function (e, t, r) {
          PCt.call(e, r) ? e[r].push(t) : fo(e, r, [t])
        })),
        (m5 = BCt)
    })
  function FCt(e, t) {
    return e > t
  }
  var rH,
    nH = x(() => {
      'use strict'
      a(FCt, 'baseGt')
      rH = FCt
    })
  function VCt(e, t) {
    return e != null && GCt.call(e, t)
  }
  var $Ct,
    GCt,
    iH,
    sH = x(() => {
      'use strict'
      ;($Ct = Object.prototype), (GCt = $Ct.hasOwnProperty)
      a(VCt, 'baseHas')
      iH = VCt
    })
  function zCt(e, t) {
    return e != null && Pk(e, t, iH)
  }
  var te,
    aH = x(() => {
      'use strict'
      sH()
      s5()
      a(zCt, 'has')
      te = zCt
    })
  function UCt(e) {
    return typeof e == 'string' || (!Jt(e) && on(e) && ni(e) == WCt)
  }
  var WCt,
    Tn,
    qk = x(() => {
      'use strict'
      fl()
      Qr()
      Zs()
      WCt = '[object String]'
      a(UCt, 'isString')
      Tn = UCt
    })
  function jCt(e, t) {
    return hs(t, function (r) {
      return e[r]
    })
  }
  var oH,
    lH = x(() => {
      'use strict'
      ih()
      a(jCt, 'baseValues')
      oH = jCt
    })
  function qCt(e) {
    return e == null ? [] : oH(e, cr(e))
  }
  var We,
    g5 = x(() => {
      'use strict'
      lH()
      Co()
      a(qCt, 'values')
      We = qCt
    })
  function YCt(e, t, r, n) {
    ;(e = mn(e) ? e : We(e)), (r = r && !n ? _o(r) : 0)
    var i = e.length
    return r < 0 && (r = HCt(i + r, 0)), Tn(e) ? r <= i && e.indexOf(t, r) > -1 : !!i && gd(e, t, r) > -1
  }
  var HCt,
    Jr,
    cH = x(() => {
      'use strict'
      lk()
      Js()
      qk()
      md()
      g5()
      HCt = Math.max
      a(YCt, 'includes')
      Jr = YCt
    })
  function KCt(e, t, r) {
    var n = e == null ? 0 : e.length
    if (!n) return -1
    var i = r == null ? 0 : _o(r)
    return i < 0 && (i = XCt(n + i, 0)), gd(e, t, i)
  }
  var XCt,
    Hk,
    uH = x(() => {
      'use strict'
      lk()
      md()
      XCt = Math.max
      a(KCt, 'indexOf')
      Hk = KCt
    })
  function ewt(e) {
    if (e == null) return !0
    if (mn(e) && (Jt(e) || typeof e == 'string' || typeof e.splice == 'function' || Ba(e) || gc(e) || Pa(e)))
      return !e.length
    var t = Ns(e)
    if (t == QCt || t == ZCt) return !e.size
    if (po(e)) return !yd(e).length
    for (var r in e) if (twt.call(e, r)) return !1
    return !0
  }
  var QCt,
    ZCt,
    JCt,
    twt,
    De,
    Yk = x(() => {
      'use strict'
      uk()
      ah()
      td()
      Qr()
      Js()
      rd()
      Jf()
      y0()
      ;(QCt = '[object Map]'), (ZCt = '[object Set]'), (JCt = Object.prototype), (twt = JCt.hasOwnProperty)
      a(ewt, 'isEmpty')
      De = ewt
    })
  function nwt(e) {
    return on(e) && ni(e) == rwt
  }
  var rwt,
    hH,
    fH = x(() => {
      'use strict'
      fl()
      Zs()
      rwt = '[object RegExp]'
      a(nwt, 'baseIsRegExp')
      hH = nwt
    })
  var dH,
    iwt,
    ia,
    pH = x(() => {
      'use strict'
      fH()
      qu()
      g0()
      ;(dH = ea && ea.isRegExp), (iwt = dH ? ta(dH) : hH), (ia = iwt)
    })
  function swt(e) {
    return e === void 0
  }
  var Fe,
    mH = x(() => {
      'use strict'
      a(swt, 'isUndefined')
      Fe = swt
    })
  function awt(e, t) {
    return e < t
  }
  var Xk,
    y5 = x(() => {
      'use strict'
      a(awt, 'baseLt')
      Xk = awt
    })
  function owt(e, t) {
    var r = {}
    return (
      (t = Rr(t, 3)),
      vd(e, function (n, i, s) {
        fo(r, i, t(n, i, s))
      }),
      r
    )
  }
  var oh,
    gH = x(() => {
      'use strict'
      Yf()
      $k()
      Gi()
      a(owt, 'mapValues')
      oh = owt
    })
  function lwt(e, t, r) {
    for (var n = -1, i = e.length; ++n < i; ) {
      var s = e[n],
        o = t(s)
      if (o != null && (l === void 0 ? o === o && !Ds(o) : r(o, l)))
        var l = o,
          u = s
    }
    return u
  }
  var Rd,
    Kk = x(() => {
      'use strict'
      nh()
      a(lwt, 'baseExtremum')
      Rd = lwt
    })
  function cwt(e) {
    return e && e.length ? Rd(e, Hn, rH) : void 0
  }
  var ds,
    yH = x(() => {
      'use strict'
      Kk()
      nH()
      ml()
      a(cwt, 'max')
      ds = cwt
    })
  function uwt(e) {
    return e && e.length ? Rd(e, Hn, Xk) : void 0
  }
  var Ga,
    x5 = x(() => {
      'use strict'
      Kk()
      y5()
      ml()
      a(uwt, 'min')
      Ga = uwt
    })
  function hwt(e, t) {
    return e && e.length ? Rd(e, Rr(t, 2), Xk) : void 0
  }
  var lh,
    xH = x(() => {
      'use strict'
      Kk()
      Gi()
      y5()
      a(hwt, 'minBy')
      lh = hwt
    })
  function dwt(e) {
    if (typeof e != 'function') throw new TypeError(fwt)
    return function () {
      var t = arguments
      switch (t.length) {
        case 0:
          return !e.call(this)
        case 1:
          return !e.call(this, t[0])
        case 2:
          return !e.call(this, t[0], t[1])
        case 3:
          return !e.call(this, t[0], t[1], t[2])
      }
      return !e.apply(this, t)
    }
  }
  var fwt,
    bH,
    kH = x(() => {
      'use strict'
      fwt = 'Expected a function'
      a(dwt, 'negate')
      bH = dwt
    })
  function pwt(e, t, r, n) {
    if (!Nr(e)) return e
    t = Rc(t, e)
    for (var i = -1, s = t.length, o = s - 1, l = e; l != null && ++i < s; ) {
      var u = wo(t[i]),
        h = r
      if (u === '__proto__' || u === 'constructor' || u === 'prototype') return e
      if (i != o) {
        var f = l[u]
        ;(h = n ? n(f, u, l) : void 0), h === void 0 && (h = Nr(f) ? f : yc(t[i + 1]) ? [] : {})
      }
      mo(l, u, h), (l = l[u])
    }
    return e
  }
  var TH,
    SH = x(() => {
      'use strict'
      nd()
      V0()
      b0()
      As()
      bd()
      a(pwt, 'baseSet')
      TH = pwt
    })
  function mwt(e, t, r) {
    for (var n = -1, i = t.length, s = {}; ++n < i; ) {
      var o = t[n],
        l = Dc(e, o)
      r(l, o) && TH(s, Rc(o, e), l)
    }
    return s
  }
  var Qk,
    b5 = x(() => {
      'use strict'
      z0()
      SH()
      V0()
      a(mwt, 'basePickBy')
      Qk = mwt
    })
  function gwt(e, t) {
    if (e == null) return {}
    var r = hs(Tk(e), function (n) {
      return [n]
    })
    return (
      (t = Rr(t)),
      Qk(e, r, function (n, i) {
        return t(n, i[0])
      })
    )
  }
  var ps,
    _H = x(() => {
      'use strict'
      ih()
      Gi()
      b5()
      YA()
      a(gwt, 'pickBy')
      ps = gwt
    })
  function ywt(e, t) {
    var r = e.length
    for (e.sort(t); r--; ) e[r] = e[r].value
    return e
  }
  var CH,
    wH = x(() => {
      'use strict'
      a(ywt, 'baseSortBy')
      CH = ywt
    })
  function xwt(e, t) {
    if (e !== t) {
      var r = e !== void 0,
        n = e === null,
        i = e === e,
        s = Ds(e),
        o = t !== void 0,
        l = t === null,
        u = t === t,
        h = Ds(t)
      if ((!l && !h && !s && e > t) || (s && o && u && !l && !h) || (n && o && u) || (!r && u) || !i) return 1
      if ((!n && !s && !h && e < t) || (h && r && i && !n && !s) || (l && r && i) || (!o && i) || !u) return -1
    }
    return 0
  }
  var EH,
    vH = x(() => {
      'use strict'
      nh()
      a(xwt, 'compareAscending')
      EH = xwt
    })
  function bwt(e, t, r) {
    for (var n = -1, i = e.criteria, s = t.criteria, o = i.length, l = r.length; ++n < o; ) {
      var u = EH(i[n], s[n])
      if (u) {
        if (n >= l) return u
        var h = r[n]
        return u * (h == 'desc' ? -1 : 1)
      }
    }
    return e.index - t.index
  }
  var AH,
    LH = x(() => {
      'use strict'
      vH()
      a(bwt, 'compareMultiple')
      AH = bwt
    })
  function kwt(e, t, r) {
    t.length
      ? (t = hs(t, function (s) {
          return Jt(s)
            ? function (o) {
                return Dc(o, s.length === 1 ? s[0] : s)
              }
            : s
        }))
      : (t = [Hn])
    var n = -1
    t = hs(t, ta(Rr))
    var i = jk(e, function (s, o, l) {
      var u = hs(t, function (h) {
        return h(s)
      })
      return { criteria: u, index: ++n, value: s }
    })
    return CH(i, function (s, o) {
      return AH(s, o, r)
    })
  }
  var RH,
    DH = x(() => {
      'use strict'
      ih()
      z0()
      Gi()
      h5()
      wH()
      qu()
      LH()
      ml()
      Qr()
      a(kwt, 'baseOrderBy')
      RH = kwt
    })
  var Twt,
    NH,
    IH = x(() => {
      'use strict'
      o5()
      ;(Twt = Fk('length')), (NH = Twt)
    })
  function Iwt(e) {
    for (var t = (MH.lastIndex = 0); MH.test(e); ) ++t
    return t
  }
  var OH,
    Swt,
    _wt,
    Cwt,
    wwt,
    Ewt,
    vwt,
    k5,
    T5,
    Awt,
    PH,
    BH,
    FH,
    Lwt,
    $H,
    GH,
    Rwt,
    Dwt,
    Nwt,
    MH,
    VH,
    zH = x(() => {
      'use strict'
      ;(OH = '\\ud800-\\udfff'),
        (Swt = '\\u0300-\\u036f'),
        (_wt = '\\ufe20-\\ufe2f'),
        (Cwt = '\\u20d0-\\u20ff'),
        (wwt = Swt + _wt + Cwt),
        (Ewt = '\\ufe0e\\ufe0f'),
        (vwt = '[' + OH + ']'),
        (k5 = '[' + wwt + ']'),
        (T5 = '\\ud83c[\\udffb-\\udfff]'),
        (Awt = '(?:' + k5 + '|' + T5 + ')'),
        (PH = '[^' + OH + ']'),
        (BH = '(?:\\ud83c[\\udde6-\\uddff]){2}'),
        (FH = '[\\ud800-\\udbff][\\udc00-\\udfff]'),
        (Lwt = '\\u200d'),
        ($H = Awt + '?'),
        (GH = '[' + Ewt + ']?'),
        (Rwt = '(?:' + Lwt + '(?:' + [PH, BH, FH].join('|') + ')' + GH + $H + ')*'),
        (Dwt = GH + $H + Rwt),
        (Nwt = '(?:' + [PH + k5 + '?', k5, BH, FH, vwt].join('|') + ')'),
        (MH = RegExp(T5 + '(?=' + T5 + ')|' + Nwt + Dwt, 'g'))
      a(Iwt, 'unicodeSize')
      VH = Iwt
    })
  function Mwt(e) {
    return JU(e) ? VH(e) : NH(e)
  }
  var WH,
    UH = x(() => {
      'use strict'
      IH()
      tj()
      zH()
      a(Mwt, 'stringSize')
      WH = Mwt
    })
  function Owt(e, t) {
    return Qk(e, t, function (r, n) {
      return Bk(e, n)
    })
  }
  var jH,
    qH = x(() => {
      'use strict'
      b5()
      a5()
      a(Owt, 'basePick')
      jH = Owt
    })
  var Pwt,
    ch,
    HH = x(() => {
      'use strict'
      qH()
      ZU()
      ;(Pwt = QU(function (e, t) {
        return e == null ? {} : jH(e, t)
      })),
        (ch = Pwt)
    })
  function $wt(e, t, r, n) {
    for (var i = -1, s = Fwt(Bwt((t - e) / (r || 1)), 0), o = Array(s); s--; ) (o[n ? s : ++i] = e), (e += r)
    return o
  }
  var Bwt,
    Fwt,
    YH,
    XH = x(() => {
      'use strict'
      ;(Bwt = Math.ceil), (Fwt = Math.max)
      a($wt, 'baseRange')
      YH = $wt
    })
  function Gwt(e) {
    return function (t, r, n) {
      return (
        n && typeof n != 'number' && Ls(t, r, n) && (r = n = void 0),
        (t = pd(t)),
        r === void 0 ? ((r = t), (t = 0)) : (r = pd(r)),
        (n = n === void 0 ? (t < r ? 1 : -1) : pd(n)),
        YH(t, r, n, e)
      )
    }
  }
  var KH,
    QH = x(() => {
      'use strict'
      XH()
      Yu()
      BA()
      a(Gwt, 'createRange')
      KH = Gwt
    })
  var Vwt,
    sa,
    ZH = x(() => {
      'use strict'
      QH()
      ;(Vwt = KH()), (sa = Vwt)
    })
  function zwt(e, t, r, n, i) {
    return (
      i(e, function (s, o, l) {
        r = n ? ((n = !1), s) : t(r, s, o, l)
      }),
      r
    )
  }
  var JH,
    tY = x(() => {
      'use strict'
      a(zwt, 'baseReduce')
      JH = zwt
    })
  function Wwt(e, t, r) {
    var n = Jt(e) ? ej : JH,
      i = arguments.length < 3
    return n(e, Rr(t, 4), r, i, fs)
  }
  var mr,
    S5 = x(() => {
      'use strict'
      rj()
      Ic()
      Gi()
      tY()
      Qr()
      a(Wwt, 'reduce')
      mr = Wwt
    })
  function Uwt(e, t) {
    var r = Jt(e) ? Sd : Uk
    return r(e, bH(Rr(t, 3)))
  }
  var Pc,
    eY = x(() => {
      'use strict'
      gk()
      c5()
      Gi()
      Qr()
      kH()
      a(Uwt, 'reject')
      Pc = Uwt
    })
  function Hwt(e) {
    if (e == null) return 0
    if (mn(e)) return Tn(e) ? WH(e) : e.length
    var t = Ns(e)
    return t == jwt || t == qwt ? e.size : yd(e).length
  }
  var jwt,
    qwt,
    _5,
    rY = x(() => {
      'use strict'
      uk()
      ah()
      Js()
      qk()
      UH()
      ;(jwt = '[object Map]'), (qwt = '[object Set]')
      a(Hwt, 'size')
      _5 = Hwt
    })
  function Ywt(e, t) {
    var r
    return (
      fs(e, function (n, i, s) {
        return (r = t(n, i, s)), !r
      }),
      !!r
    )
  }
  var nY,
    iY = x(() => {
      'use strict'
      Ic()
      a(Ywt, 'baseSome')
      nY = Ywt
    })
  function Xwt(e, t, r) {
    var n = Jt(e) ? Ak : nY
    return r && Ls(e, t, r) && (t = void 0), n(e, Rr(t, 3))
  }
  var U0,
    sY = x(() => {
      'use strict'
      JA()
      Gi()
      iY()
      Qr()
      Yu()
      a(Xwt, 'some')
      U0 = Xwt
    })
  var Kwt,
    Ao,
    aY = x(() => {
      'use strict'
      Td()
      DH()
      id()
      Yu()
      ;(Kwt = go(function (e, t) {
        if (e == null) return []
        var r = t.length
        return (
          r > 1 && Ls(e, t[0], t[1]) ? (t = []) : r > 2 && Ls(t[0], t[1], t[2]) && (t = [t[0]]), RH(e, Eo(t, 1), [])
        )
      })),
        (Ao = Kwt)
    })
  var Qwt,
    Zwt,
    oY,
    lY = x(() => {
      'use strict'
      XA()
      FA()
      Dk()
      ;(Qwt = 1 / 0),
        (Zwt =
          Nc && 1 / Ed(new Nc([, -0]))[1] == Qwt
            ? function (e) {
                return new Nc(e)
              }
            : cn),
        (oY = Zwt)
    })
  function tEt(e, t, r) {
    var n = -1,
      i = ck,
      s = e.length,
      o = !0,
      l = [],
      u = l
    if (r) (o = !1), (i = Vk)
    else if (s >= Jwt) {
      var h = t ? null : oY(e)
      if (h) return Ed(h)
      ;(o = !1), (i = wd), (u = new Cd())
    } else u = t ? [] : l
    t: for (; ++n < s; ) {
      var f = e[n],
        d = t ? t(f) : f
      if (((f = r || f !== 0 ? f : 0), o && d === d)) {
        for (var p = u.length; p--; ) if (u[p] === d) continue t
        t && u.push(d), l.push(f)
      } else i(u, d, r) || (u !== l && u.push(d), l.push(f))
    }
    return l
  }
  var Jwt,
    Dd,
    Zk = x(() => {
      'use strict'
      vk()
      VA()
      l5()
      Lk()
      lY()
      Dk()
      Jwt = 200
      a(tEt, 'baseUniq')
      Dd = tEt
    })
  var eEt,
    C5,
    cY = x(() => {
      'use strict'
      Td()
      id()
      Zk()
      ob()
      ;(eEt = go(function (e) {
        return Dd(Eo(e, 1, ju, !0))
      })),
        (C5 = eEt)
    })
  function rEt(e) {
    return e && e.length ? Dd(e) : []
  }
  var Nd,
    uY = x(() => {
      'use strict'
      Zk()
      a(rEt, 'uniq')
      Nd = rEt
    })
  function nEt(e, t) {
    return e && e.length ? Dd(e, Rr(t, 2)) : []
  }
  var hY,
    fY = x(() => {
      'use strict'
      Gi()
      Zk()
      a(nEt, 'uniqBy')
      hY = nEt
    })
  function sEt(e) {
    var t = ++iEt
    return fk(e) + t
  }
  var iEt,
    uh,
    dY = x(() => {
      'use strict'
      zA()
      iEt = 0
      a(sEt, 'uniqueId')
      uh = sEt
    })
  function aEt(e, t, r) {
    for (var n = -1, i = e.length, s = t.length, o = {}; ++n < i; ) {
      var l = n < s ? t[n] : void 0
      r(o, e[n], l)
    }
    return o
  }
  var pY,
    mY = x(() => {
      'use strict'
      a(aEt, 'baseZipObject')
      pY = aEt
    })
  function oEt(e, t) {
    return pY(e || [], t || [], mo)
  }
  var Jk,
    gY = x(() => {
      'use strict'
      nd()
      mY()
      a(oEt, 'zipObject')
      Jk = oEt
    })
  var fe = x(() => {
    'use strict'
    GU()
    QA()
    Uj()
    jj()
    x4()
    Iq()
    Pq()
    Fq()
    $q()
    Gq()
    jq()
    u5()
    Kq()
    Zq()
    f5()
    pk()
    Wk()
    Jq()
    tH()
    eH()
    aH()
    ml()
    cH()
    uH()
    Qr()
    Yk()
    l0()
    As()
    pH()
    qk()
    mH()
    Co()
    Bq()
    Ld()
    gH()
    yH()
    T4()
    x5()
    xH()
    FA()
    Dq()
    HH()
    _H()
    ZH()
    S5()
    eY()
    rY()
    sY()
    aY()
    cY()
    uY()
    dY()
    g5()
    gY()
  })
  function xY(e, t) {
    e[t] ? e[t]++ : (e[t] = 1)
  }
  function bY(e, t) {
    --e[t] || delete e[t]
  }
  function j0(e, t, r, n) {
    var i = '' + t,
      s = '' + r
    if (!e && i > s) {
      var o = i
      ;(i = s), (s = o)
    }
    return i + yY + s + yY + (Fe(n) ? lEt : n)
  }
  function cEt(e, t, r, n) {
    var i = '' + t,
      s = '' + r
    if (!e && i > s) {
      var o = i
      ;(i = s), (s = o)
    }
    var l = { v: i, w: s }
    return n && (l.name = n), l
  }
  function w5(e, t) {
    return j0(e, t.v, t.w, t.name)
  }
  var lEt,
    hh,
    yY,
    _r,
    tT = x(() => {
      'use strict'
      fe()
      ;(lEt = '\0'),
        (hh = '\0'),
        (yY = ''),
        (_r = class {
          static {
            a(this, 'Graph')
          }
          constructor(t = {}) {
            ;(this._isDirected = Object.prototype.hasOwnProperty.call(t, 'directed') ? t.directed : !0),
              (this._isMultigraph = Object.prototype.hasOwnProperty.call(t, 'multigraph') ? t.multigraph : !1),
              (this._isCompound = Object.prototype.hasOwnProperty.call(t, 'compound') ? t.compound : !1),
              (this._label = void 0),
              (this._defaultNodeLabelFn = is(void 0)),
              (this._defaultEdgeLabelFn = is(void 0)),
              (this._nodes = {}),
              this._isCompound && ((this._parent = {}), (this._children = {}), (this._children[hh] = {})),
              (this._in = {}),
              (this._preds = {}),
              (this._out = {}),
              (this._sucs = {}),
              (this._edgeObjs = {}),
              (this._edgeLabels = {})
          }
          isDirected() {
            return this._isDirected
          }
          isMultigraph() {
            return this._isMultigraph
          }
          isCompound() {
            return this._isCompound
          }
          setGraph(t) {
            return (this._label = t), this
          }
          graph() {
            return this._label
          }
          setDefaultNodeLabel(t) {
            return vn(t) || (t = is(t)), (this._defaultNodeLabelFn = t), this
          }
          nodeCount() {
            return this._nodeCount
          }
          nodes() {
            return cr(this._nodes)
          }
          sources() {
            var t = this
            return pr(this.nodes(), function (r) {
              return De(t._in[r])
            })
          }
          sinks() {
            var t = this
            return pr(this.nodes(), function (r) {
              return De(t._out[r])
            })
          }
          setNodes(t, r) {
            var n = arguments,
              i = this
            return (
              rt(t, function (s) {
                n.length > 1 ? i.setNode(s, r) : i.setNode(s)
              }),
              this
            )
          }
          setNode(t, r) {
            return Object.prototype.hasOwnProperty.call(this._nodes, t)
              ? (arguments.length > 1 && (this._nodes[t] = r), this)
              : ((this._nodes[t] = arguments.length > 1 ? r : this._defaultNodeLabelFn(t)),
                this._isCompound && ((this._parent[t] = hh), (this._children[t] = {}), (this._children[hh][t] = !0)),
                (this._in[t] = {}),
                (this._preds[t] = {}),
                (this._out[t] = {}),
                (this._sucs[t] = {}),
                ++this._nodeCount,
                this)
          }
          node(t) {
            return this._nodes[t]
          }
          hasNode(t) {
            return Object.prototype.hasOwnProperty.call(this._nodes, t)
          }
          removeNode(t) {
            if (Object.prototype.hasOwnProperty.call(this._nodes, t)) {
              var r = a((n) => this.removeEdge(this._edgeObjs[n]), 'removeEdge')
              delete this._nodes[t],
                this._isCompound &&
                  (this._removeFromParentsChildList(t),
                  delete this._parent[t],
                  rt(this.children(t), (n) => {
                    this.setParent(n)
                  }),
                  delete this._children[t]),
                rt(cr(this._in[t]), r),
                delete this._in[t],
                delete this._preds[t],
                rt(cr(this._out[t]), r),
                delete this._out[t],
                delete this._sucs[t],
                --this._nodeCount
            }
            return this
          }
          setParent(t, r) {
            if (!this._isCompound) throw new Error('Cannot set parent in a non-compound graph')
            if (Fe(r)) r = hh
            else {
              r += ''
              for (var n = r; !Fe(n); n = this.parent(n))
                if (n === t) throw new Error('Setting ' + r + ' as parent of ' + t + ' would create a cycle')
              this.setNode(r)
            }
            return (
              this.setNode(t),
              this._removeFromParentsChildList(t),
              (this._parent[t] = r),
              (this._children[r][t] = !0),
              this
            )
          }
          _removeFromParentsChildList(t) {
            delete this._children[this._parent[t]][t]
          }
          parent(t) {
            if (this._isCompound) {
              var r = this._parent[t]
              if (r !== hh) return r
            }
          }
          children(t) {
            if ((Fe(t) && (t = hh), this._isCompound)) {
              var r = this._children[t]
              if (r) return cr(r)
            } else {
              if (t === hh) return this.nodes()
              if (this.hasNode(t)) return []
            }
          }
          predecessors(t) {
            var r = this._preds[t]
            if (r) return cr(r)
          }
          successors(t) {
            var r = this._sucs[t]
            if (r) return cr(r)
          }
          neighbors(t) {
            var r = this.predecessors(t)
            if (r) return C5(r, this.successors(t))
          }
          isLeaf(t) {
            var r
            return this.isDirected() ? (r = this.successors(t)) : (r = this.neighbors(t)), r.length === 0
          }
          filterNodes(t) {
            var r = new this.constructor({
              directed: this._isDirected,
              multigraph: this._isMultigraph,
              compound: this._isCompound,
            })
            r.setGraph(this.graph())
            var n = this
            rt(this._nodes, function (o, l) {
              t(l) && r.setNode(l, o)
            }),
              rt(this._edgeObjs, function (o) {
                r.hasNode(o.v) && r.hasNode(o.w) && r.setEdge(o, n.edge(o))
              })
            var i = {}
            function s(o) {
              var l = n.parent(o)
              return l === void 0 || r.hasNode(l) ? ((i[o] = l), l) : l in i ? i[l] : s(l)
            }
            return (
              a(s, 'findParent'),
              this._isCompound &&
                rt(r.nodes(), function (o) {
                  r.setParent(o, s(o))
                }),
              r
            )
          }
          setDefaultEdgeLabel(t) {
            return vn(t) || (t = is(t)), (this._defaultEdgeLabelFn = t), this
          }
          edgeCount() {
            return this._edgeCount
          }
          edges() {
            return We(this._edgeObjs)
          }
          setPath(t, r) {
            var n = this,
              i = arguments
            return (
              mr(t, function (s, o) {
                return i.length > 1 ? n.setEdge(s, o, r) : n.setEdge(s, o), o
              }),
              this
            )
          }
          setEdge() {
            var t,
              r,
              n,
              i,
              s = !1,
              o = arguments[0]
            typeof o == 'object' && o !== null && 'v' in o
              ? ((t = o.v), (r = o.w), (n = o.name), arguments.length === 2 && ((i = arguments[1]), (s = !0)))
              : ((t = o),
                (r = arguments[1]),
                (n = arguments[3]),
                arguments.length > 2 && ((i = arguments[2]), (s = !0))),
              (t = '' + t),
              (r = '' + r),
              Fe(n) || (n = '' + n)
            var l = j0(this._isDirected, t, r, n)
            if (Object.prototype.hasOwnProperty.call(this._edgeLabels, l)) return s && (this._edgeLabels[l] = i), this
            if (!Fe(n) && !this._isMultigraph) throw new Error('Cannot set a named edge when isMultigraph = false')
            this.setNode(t), this.setNode(r), (this._edgeLabels[l] = s ? i : this._defaultEdgeLabelFn(t, r, n))
            var u = cEt(this._isDirected, t, r, n)
            return (
              (t = u.v),
              (r = u.w),
              Object.freeze(u),
              (this._edgeObjs[l] = u),
              xY(this._preds[r], t),
              xY(this._sucs[t], r),
              (this._in[r][l] = u),
              (this._out[t][l] = u),
              this._edgeCount++,
              this
            )
          }
          edge(t, r, n) {
            var i = arguments.length === 1 ? w5(this._isDirected, arguments[0]) : j0(this._isDirected, t, r, n)
            return this._edgeLabels[i]
          }
          hasEdge(t, r, n) {
            var i = arguments.length === 1 ? w5(this._isDirected, arguments[0]) : j0(this._isDirected, t, r, n)
            return Object.prototype.hasOwnProperty.call(this._edgeLabels, i)
          }
          removeEdge(t, r, n) {
            var i = arguments.length === 1 ? w5(this._isDirected, arguments[0]) : j0(this._isDirected, t, r, n),
              s = this._edgeObjs[i]
            return (
              s &&
                ((t = s.v),
                (r = s.w),
                delete this._edgeLabels[i],
                delete this._edgeObjs[i],
                bY(this._preds[r], t),
                bY(this._sucs[t], r),
                delete this._in[r][i],
                delete this._out[t][i],
                this._edgeCount--),
              this
            )
          }
          inEdges(t, r) {
            var n = this._in[t]
            if (n) {
              var i = We(n)
              return r
                ? pr(i, function (s) {
                    return s.v === r
                  })
                : i
            }
          }
          outEdges(t, r) {
            var n = this._out[t]
            if (n) {
              var i = We(n)
              return r
                ? pr(i, function (s) {
                    return s.w === r
                  })
                : i
            }
          }
          nodeEdges(t, r) {
            var n = this.inEdges(t, r)
            if (n) return n.concat(this.outEdges(t, r))
          }
        })
      _r.prototype._nodeCount = 0
      _r.prototype._edgeCount = 0
      a(xY, 'incrementOrInitEntry')
      a(bY, 'decrementOrRemoveEntry')
      a(j0, 'edgeArgsToId')
      a(cEt, 'edgeArgsToObj')
      a(w5, 'edgeObjToId')
    })
  var aa = x(() => {
    'use strict'
    tT()
  })
  function kY(e) {
    ;(e._prev._next = e._next), (e._next._prev = e._prev), delete e._next, delete e._prev
  }
  function uEt(e, t) {
    if (e !== '_next' && e !== '_prev') return t
  }
  var rT,
    TY = x(() => {
      'use strict'
      rT = class {
        static {
          a(this, 'List')
        }
        constructor() {
          var t = {}
          ;(t._next = t._prev = t), (this._sentinel = t)
        }
        dequeue() {
          var t = this._sentinel,
            r = t._prev
          if (r !== t) return kY(r), r
        }
        enqueue(t) {
          var r = this._sentinel
          t._prev && t._next && kY(t), (t._next = r._next), (r._next._prev = t), (r._next = t), (t._prev = r)
        }
        toString() {
          for (var t = [], r = this._sentinel, n = r._prev; n !== r; ) t.push(JSON.stringify(n, uEt)), (n = n._prev)
          return '[' + t.join(', ') + ']'
        }
      }
      a(kY, 'unlink')
      a(uEt, 'filterOutLinks')
    })
  function SY(e, t) {
    if (e.nodeCount() <= 1) return []
    var r = dEt(e, t || hEt),
      n = fEt(r.graph, r.buckets, r.zeroIdx)
    return dr(
      Dt(n, function (i) {
        return e.outEdges(i.v, i.w)
      }),
    )
  }
  function fEt(e, t, r) {
    for (var n = [], i = t[t.length - 1], s = t[0], o; e.nodeCount(); ) {
      for (; (o = s.dequeue()); ) E5(e, t, r, o)
      for (; (o = i.dequeue()); ) E5(e, t, r, o)
      if (e.nodeCount()) {
        for (var l = t.length - 2; l > 0; --l)
          if (((o = t[l].dequeue()), o)) {
            n = n.concat(E5(e, t, r, o, !0))
            break
          }
      }
    }
    return n
  }
  function E5(e, t, r, n, i) {
    var s = i ? [] : void 0
    return (
      rt(e.inEdges(n.v), function (o) {
        var l = e.edge(o),
          u = e.node(o.v)
        i && s.push({ v: o.v, w: o.w }), (u.out -= l), v5(t, r, u)
      }),
      rt(e.outEdges(n.v), function (o) {
        var l = e.edge(o),
          u = o.w,
          h = e.node(u)
        ;(h.in -= l), v5(t, r, h)
      }),
      e.removeNode(n.v),
      s
    )
  }
  function dEt(e, t) {
    var r = new _r(),
      n = 0,
      i = 0
    rt(e.nodes(), function (l) {
      r.setNode(l, { v: l, in: 0, out: 0 })
    }),
      rt(e.edges(), function (l) {
        var u = r.edge(l.v, l.w) || 0,
          h = t(l),
          f = u + h
        r.setEdge(l.v, l.w, f), (i = Math.max(i, (r.node(l.v).out += h))), (n = Math.max(n, (r.node(l.w).in += h)))
      })
    var s = sa(i + n + 3).map(function () {
        return new rT()
      }),
      o = n + 1
    return (
      rt(r.nodes(), function (l) {
        v5(s, o, r.node(l))
      }),
      { graph: r, buckets: s, zeroIdx: o }
    )
  }
  function v5(e, t, r) {
    r.out ? (r.in ? e[r.out - r.in + t].enqueue(r) : e[e.length - 1].enqueue(r)) : e[0].enqueue(r)
  }
  var hEt,
    _Y = x(() => {
      'use strict'
      fe()
      aa()
      TY()
      hEt = is(1)
      a(SY, 'greedyFAS')
      a(fEt, 'doGreedyFAS')
      a(E5, 'removeNode')
      a(dEt, 'buildState')
      a(v5, 'assignBucket')
    })
  function CY(e) {
    var t = e.graph().acyclicer === 'greedy' ? SY(e, r(e)) : pEt(e)
    rt(t, function (n) {
      var i = e.edge(n)
      e.removeEdge(n), (i.forwardName = n.name), (i.reversed = !0), e.setEdge(n.w, n.v, i, uh('rev'))
    })
    function r(n) {
      return function (i) {
        return n.edge(i).weight
      }
    }
    a(r, 'weightFn')
  }
  function pEt(e) {
    var t = [],
      r = {},
      n = {}
    function i(s) {
      Object.prototype.hasOwnProperty.call(n, s) ||
        ((n[s] = !0),
        (r[s] = !0),
        rt(e.outEdges(s), function (o) {
          Object.prototype.hasOwnProperty.call(r, o.w) ? t.push(o) : i(o.w)
        }),
        delete r[s])
    }
    return a(i, 'dfs'), rt(e.nodes(), i), t
  }
  function wY(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t)
      if (r.reversed) {
        e.removeEdge(t)
        var n = r.forwardName
        delete r.reversed, delete r.forwardName, e.setEdge(t.w, t.v, r, n)
      }
    })
  }
  var A5 = x(() => {
    'use strict'
    fe()
    _Y()
    a(CY, 'run')
    a(pEt, 'dfsFAS')
    a(wY, 'undo')
  })
  function Lo(e, t, r, n) {
    var i
    do i = uh(n)
    while (e.hasNode(i))
    return (r.dummy = t), e.setNode(i, r), i
  }
  function vY(e) {
    var t = new _r().setGraph(e.graph())
    return (
      rt(e.nodes(), function (r) {
        t.setNode(r, e.node(r))
      }),
      rt(e.edges(), function (r) {
        var n = t.edge(r.v, r.w) || { weight: 0, minlen: 1 },
          i = e.edge(r)
        t.setEdge(r.v, r.w, { weight: n.weight + i.weight, minlen: Math.max(n.minlen, i.minlen) })
      }),
      t
    )
  }
  function nT(e) {
    var t = new _r({ multigraph: e.isMultigraph() }).setGraph(e.graph())
    return (
      rt(e.nodes(), function (r) {
        e.children(r).length || t.setNode(r, e.node(r))
      }),
      rt(e.edges(), function (r) {
        t.setEdge(r, e.edge(r))
      }),
      t
    )
  }
  function L5(e, t) {
    var r = e.x,
      n = e.y,
      i = t.x - r,
      s = t.y - n,
      o = e.width / 2,
      l = e.height / 2
    if (!i && !s) throw new Error('Not possible to find intersection inside of the rectangle')
    var u, h
    return (
      Math.abs(s) * o > Math.abs(i) * l
        ? (s < 0 && (l = -l), (u = (l * i) / s), (h = l))
        : (i < 0 && (o = -o), (u = o), (h = (o * s) / i)),
      { x: r + u, y: n + h }
    )
  }
  function Bc(e) {
    var t = Dt(sa(D5(e) + 1), function () {
      return []
    })
    return (
      rt(e.nodes(), function (r) {
        var n = e.node(r),
          i = n.rank
        Fe(i) || (t[i][n.order] = r)
      }),
      t
    )
  }
  function AY(e) {
    var t = Ga(
      Dt(e.nodes(), function (r) {
        return e.node(r).rank
      }),
    )
    rt(e.nodes(), function (r) {
      var n = e.node(r)
      te(n, 'rank') && (n.rank -= t)
    })
  }
  function LY(e) {
    var t = Ga(
        Dt(e.nodes(), function (s) {
          return e.node(s).rank
        }),
      ),
      r = []
    rt(e.nodes(), function (s) {
      var o = e.node(s).rank - t
      r[o] || (r[o] = []), r[o].push(s)
    })
    var n = 0,
      i = e.graph().nodeRankFactor
    rt(r, function (s, o) {
      Fe(s) && o % i !== 0
        ? --n
        : n &&
          rt(s, function (l) {
            e.node(l).rank += n
          })
    })
  }
  function R5(e, t, r, n) {
    var i = { width: 0, height: 0 }
    return arguments.length >= 4 && ((i.rank = r), (i.order = n)), Lo(e, 'border', i, t)
  }
  function D5(e) {
    return ds(
      Dt(e.nodes(), function (t) {
        var r = e.node(t).rank
        if (!Fe(r)) return r
      }),
    )
  }
  function RY(e, t) {
    var r = { lhs: [], rhs: [] }
    return (
      rt(e, function (n) {
        t(n) ? r.lhs.push(n) : r.rhs.push(n)
      }),
      r
    )
  }
  function DY(e, t) {
    var r = Gk()
    try {
      return t()
    } finally {
      console.log(e + ' time: ' + (Gk() - r) + 'ms')
    }
  }
  function NY(e, t) {
    return t()
  }
  var Ro = x(() => {
    'use strict'
    fe()
    aa()
    a(Lo, 'addDummyNode')
    a(vY, 'simplify')
    a(nT, 'asNonCompoundGraph')
    a(L5, 'intersectRect')
    a(Bc, 'buildLayerMatrix')
    a(AY, 'normalizeRanks')
    a(LY, 'removeEmptyRanks')
    a(R5, 'addBorderNode')
    a(D5, 'maxRank')
    a(RY, 'partition')
    a(DY, 'time')
    a(NY, 'notime')
  })
  function MY(e) {
    function t(r) {
      var n = e.children(r),
        i = e.node(r)
      if ((n.length && rt(n, t), Object.prototype.hasOwnProperty.call(i, 'minRank'))) {
        ;(i.borderLeft = []), (i.borderRight = [])
        for (var s = i.minRank, o = i.maxRank + 1; s < o; ++s)
          IY(e, 'borderLeft', '_bl', r, i, s), IY(e, 'borderRight', '_br', r, i, s)
      }
    }
    a(t, 'dfs'), rt(e.children(), t)
  }
  function IY(e, t, r, n, i, s) {
    var o = { width: 0, height: 0, rank: s, borderType: t },
      l = i[t][s - 1],
      u = Lo(e, 'border', o, r)
    ;(i[t][s] = u), e.setParent(u, n), l && e.setEdge(l, u, { weight: 1 })
  }
  var OY = x(() => {
    'use strict'
    fe()
    Ro()
    a(MY, 'addBorderSegments')
    a(IY, 'addBorderNode')
  })
  function BY(e) {
    var t = e.graph().rankdir.toLowerCase()
    ;(t === 'lr' || t === 'rl') && $Y(e)
  }
  function FY(e) {
    var t = e.graph().rankdir.toLowerCase()
    ;(t === 'bt' || t === 'rl') && mEt(e), (t === 'lr' || t === 'rl') && (gEt(e), $Y(e))
  }
  function $Y(e) {
    rt(e.nodes(), function (t) {
      PY(e.node(t))
    }),
      rt(e.edges(), function (t) {
        PY(e.edge(t))
      })
  }
  function PY(e) {
    var t = e.width
    ;(e.width = e.height), (e.height = t)
  }
  function mEt(e) {
    rt(e.nodes(), function (t) {
      N5(e.node(t))
    }),
      rt(e.edges(), function (t) {
        var r = e.edge(t)
        rt(r.points, N5), Object.prototype.hasOwnProperty.call(r, 'y') && N5(r)
      })
  }
  function N5(e) {
    e.y = -e.y
  }
  function gEt(e) {
    rt(e.nodes(), function (t) {
      I5(e.node(t))
    }),
      rt(e.edges(), function (t) {
        var r = e.edge(t)
        rt(r.points, I5), Object.prototype.hasOwnProperty.call(r, 'x') && I5(r)
      })
  }
  function I5(e) {
    var t = e.x
    ;(e.x = e.y), (e.y = t)
  }
  var GY = x(() => {
    'use strict'
    fe()
    a(BY, 'adjust')
    a(FY, 'undo')
    a($Y, 'swapWidthHeight')
    a(PY, 'swapWidthHeightOne')
    a(mEt, 'reverseY')
    a(N5, 'reverseYOne')
    a(gEt, 'swapXY')
    a(I5, 'swapXYOne')
  })
  function VY(e) {
    ;(e.graph().dummyChains = []),
      rt(e.edges(), function (t) {
        xEt(e, t)
      })
  }
  function xEt(e, t) {
    var r = t.v,
      n = e.node(r).rank,
      i = t.w,
      s = e.node(i).rank,
      o = t.name,
      l = e.edge(t),
      u = l.labelRank
    if (s !== n + 1) {
      e.removeEdge(t)
      var h = void 0,
        f,
        d
      for (d = 0, ++n; n < s; ++d, ++n)
        (l.points = []),
          (h = { width: 0, height: 0, edgeLabel: l, edgeObj: t, rank: n }),
          (f = Lo(e, 'edge', h, '_d')),
          n === u && ((h.width = l.width), (h.height = l.height), (h.dummy = 'edge-label'), (h.labelpos = l.labelpos)),
          e.setEdge(r, f, { weight: l.weight }, o),
          d === 0 && e.graph().dummyChains.push(f),
          (r = f)
      e.setEdge(r, i, { weight: l.weight }, o)
    }
  }
  function zY(e) {
    rt(e.graph().dummyChains, function (t) {
      var r = e.node(t),
        n = r.edgeLabel,
        i
      for (e.setEdge(r.edgeObj, n); r.dummy; )
        (i = e.successors(t)[0]),
          e.removeNode(t),
          n.points.push({ x: r.x, y: r.y }),
          r.dummy === 'edge-label' && ((n.x = r.x), (n.y = r.y), (n.width = r.width), (n.height = r.height)),
          (t = i),
          (r = e.node(t))
    })
  }
  var M5 = x(() => {
    'use strict'
    fe()
    Ro()
    a(VY, 'run')
    a(xEt, 'normalizeEdge')
    a(zY, 'undo')
  })
  function q0(e) {
    var t = {}
    function r(n) {
      var i = e.node(n)
      if (Object.prototype.hasOwnProperty.call(t, n)) return i.rank
      t[n] = !0
      var s = Ga(
        Dt(e.outEdges(n), function (o) {
          return r(o.w) - e.edge(o).minlen
        }),
      )
      return (s === Number.POSITIVE_INFINITY || s === void 0 || s === null) && (s = 0), (i.rank = s)
    }
    a(r, 'dfs'), rt(e.sources(), r)
  }
  function fh(e, t) {
    return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen
  }
  var iT = x(() => {
    'use strict'
    fe()
    a(q0, 'longestPath')
    a(fh, 'slack')
  })
  function sT(e) {
    var t = new _r({ directed: !1 }),
      r = e.nodes()[0],
      n = e.nodeCount()
    t.setNode(r, {})
    for (var i, s; bEt(t, e) < n; ) (i = kEt(t, e)), (s = t.hasNode(i.v) ? fh(e, i) : -fh(e, i)), TEt(t, e, s)
    return t
  }
  function bEt(e, t) {
    function r(n) {
      rt(t.nodeEdges(n), function (i) {
        var s = i.v,
          o = n === s ? i.w : s
        !e.hasNode(o) && !fh(t, i) && (e.setNode(o, {}), e.setEdge(n, o, {}), r(o))
      })
    }
    return a(r, 'dfs'), rt(e.nodes(), r), e.nodeCount()
  }
  function kEt(e, t) {
    return lh(t.edges(), function (r) {
      if (e.hasNode(r.v) !== e.hasNode(r.w)) return fh(t, r)
    })
  }
  function TEt(e, t, r) {
    rt(e.nodes(), function (n) {
      t.node(n).rank += r
    })
  }
  var O5 = x(() => {
    'use strict'
    fe()
    aa()
    iT()
    a(sT, 'feasibleTree')
    a(bEt, 'tightTree')
    a(kEt, 'findMinSlackEdge')
    a(TEt, 'shiftRanks')
  })
  var UY = x(() => {
    'use strict'
  })
  var P5 = x(() => {
    'use strict'
  })
  var dAe,
    B5 = x(() => {
      'use strict'
      fe()
      P5()
      dAe = is(1)
    })
  var jY = x(() => {
    'use strict'
    B5()
  })
  var F5 = x(() => {
    'use strict'
  })
  var qY = x(() => {
    'use strict'
    F5()
  })
  var CAe,
    HY = x(() => {
      'use strict'
      fe()
      CAe = is(1)
    })
  function $5(e) {
    var t = {},
      r = {},
      n = []
    function i(s) {
      if (Object.prototype.hasOwnProperty.call(r, s)) throw new H0()
      Object.prototype.hasOwnProperty.call(t, s) ||
        ((r[s] = !0), (t[s] = !0), rt(e.predecessors(s), i), delete r[s], n.push(s))
    }
    if ((a(i, 'visit'), rt(e.sinks(), i), _5(t) !== e.nodeCount())) throw new H0()
    return n
  }
  function H0() {}
  var G5 = x(() => {
    'use strict'
    fe()
    $5.CycleException = H0
    a($5, 'topsort')
    a(H0, 'CycleException')
    H0.prototype = new Error()
  })
  var YY = x(() => {
    'use strict'
    G5()
  })
  function aT(e, t, r) {
    Jt(t) || (t = [t])
    var n = (e.isDirected() ? e.successors : e.neighbors).bind(e),
      i = [],
      s = {}
    return (
      rt(t, function (o) {
        if (!e.hasNode(o)) throw new Error('Graph does not have node: ' + o)
        XY(e, o, r === 'post', s, n, i)
      }),
      i
    )
  }
  function XY(e, t, r, n, i, s) {
    Object.prototype.hasOwnProperty.call(n, t) ||
      ((n[t] = !0),
      r || s.push(t),
      rt(i(t), function (o) {
        XY(e, o, r, n, i, s)
      }),
      r && s.push(t))
  }
  var V5 = x(() => {
    'use strict'
    fe()
    a(aT, 'dfs')
    a(XY, 'doDfs')
  })
  function z5(e, t) {
    return aT(e, t, 'post')
  }
  var KY = x(() => {
    'use strict'
    V5()
    a(z5, 'postorder')
  })
  function W5(e, t) {
    return aT(e, t, 'pre')
  }
  var QY = x(() => {
    'use strict'
    V5()
    a(W5, 'preorder')
  })
  var ZY = x(() => {
    'use strict'
    P5()
    tT()
  })
  var JY = x(() => {
    'use strict'
    UY()
    B5()
    jY()
    qY()
    HY()
    YY()
    KY()
    QY()
    ZY()
    F5()
    G5()
  })
  function $c(e) {
    ;(e = vY(e)), q0(e)
    var t = sT(e)
    j5(t), U5(t, e)
    for (var r, n; (r = nX(t)); ) (n = iX(t, e, r)), sX(t, e, r, n)
  }
  function U5(e, t) {
    var r = z5(e, e.nodes())
    ;(r = r.slice(0, r.length - 1)),
      rt(r, function (n) {
        EEt(e, t, n)
      })
  }
  function EEt(e, t, r) {
    var n = e.node(r),
      i = n.parent
    e.edge(r, i).cutvalue = eX(e, t, r)
  }
  function eX(e, t, r) {
    var n = e.node(r),
      i = n.parent,
      s = !0,
      o = t.edge(r, i),
      l = 0
    return (
      o || ((s = !1), (o = t.edge(i, r))),
      (l = o.weight),
      rt(t.nodeEdges(r), function (u) {
        var h = u.v === r,
          f = h ? u.w : u.v
        if (f !== i) {
          var d = h === s,
            p = t.edge(u).weight
          if (((l += d ? p : -p), AEt(e, r, f))) {
            var m = e.edge(r, f).cutvalue
            l += d ? -m : m
          }
        }
      }),
      l
    )
  }
  function j5(e, t) {
    arguments.length < 2 && (t = e.nodes()[0]), rX(e, {}, 1, t)
  }
  function rX(e, t, r, n, i) {
    var s = r,
      o = e.node(n)
    return (
      (t[n] = !0),
      rt(e.neighbors(n), function (l) {
        Object.prototype.hasOwnProperty.call(t, l) || (r = rX(e, t, r, l, n))
      }),
      (o.low = s),
      (o.lim = r++),
      i ? (o.parent = i) : delete o.parent,
      r
    )
  }
  function nX(e) {
    return Vi(e.edges(), function (t) {
      return e.edge(t).cutvalue < 0
    })
  }
  function iX(e, t, r) {
    var n = r.v,
      i = r.w
    t.hasEdge(n, i) || ((n = r.w), (i = r.v))
    var s = e.node(n),
      o = e.node(i),
      l = s,
      u = !1
    s.lim > o.lim && ((l = o), (u = !0))
    var h = pr(t.edges(), function (f) {
      return u === tX(e, e.node(f.v), l) && u !== tX(e, e.node(f.w), l)
    })
    return lh(h, function (f) {
      return fh(t, f)
    })
  }
  function sX(e, t, r, n) {
    var i = r.v,
      s = r.w
    e.removeEdge(i, s), e.setEdge(n.v, n.w, {}), j5(e), U5(e, t), vEt(e, t)
  }
  function vEt(e, t) {
    var r = Vi(e.nodes(), function (i) {
        return !t.node(i).parent
      }),
      n = W5(e, r)
    ;(n = n.slice(1)),
      rt(n, function (i) {
        var s = e.node(i).parent,
          o = t.edge(i, s),
          l = !1
        o || ((o = t.edge(s, i)), (l = !0)), (t.node(i).rank = t.node(s).rank + (l ? o.minlen : -o.minlen))
      })
  }
  function AEt(e, t, r) {
    return e.hasEdge(t, r)
  }
  function tX(e, t, r) {
    return r.low <= t.lim && t.lim <= r.lim
  }
  var aX = x(() => {
    'use strict'
    fe()
    JY()
    Ro()
    O5()
    iT()
    $c.initLowLimValues = j5
    $c.initCutValues = U5
    $c.calcCutValue = eX
    $c.leaveEdge = nX
    $c.enterEdge = iX
    $c.exchangeEdges = sX
    a($c, 'networkSimplex')
    a(U5, 'initCutValues')
    a(EEt, 'assignCutValue')
    a(eX, 'calcCutValue')
    a(j5, 'initLowLimValues')
    a(rX, 'dfsAssignLowLim')
    a(nX, 'leaveEdge')
    a(iX, 'enterEdge')
    a(sX, 'exchangeEdges')
    a(vEt, 'updateRanks')
    a(AEt, 'isTreeEdge')
    a(tX, 'isDescendant')
  })
  function q5(e) {
    switch (e.graph().ranker) {
      case 'network-simplex':
        oX(e)
        break
      case 'tight-tree':
        REt(e)
        break
      case 'longest-path':
        LEt(e)
        break
      default:
        oX(e)
    }
  }
  function REt(e) {
    q0(e), sT(e)
  }
  function oX(e) {
    $c(e)
  }
  var LEt,
    H5 = x(() => {
      'use strict'
      O5()
      aX()
      iT()
      a(q5, 'rank')
      LEt = q0
      a(REt, 'tightTreeRanker')
      a(oX, 'networkSimplexRanker')
    })
  function lX(e) {
    var t = Lo(e, 'root', {}, '_root'),
      r = DEt(e),
      n = ds(We(r)) - 1,
      i = 2 * n + 1
    ;(e.graph().nestingRoot = t),
      rt(e.edges(), function (o) {
        e.edge(o).minlen *= i
      })
    var s = NEt(e) + 1
    rt(e.children(), function (o) {
      cX(e, t, i, s, n, r, o)
    }),
      (e.graph().nodeRankFactor = i)
  }
  function cX(e, t, r, n, i, s, o) {
    var l = e.children(o)
    if (!l.length) {
      o !== t && e.setEdge(t, o, { weight: 0, minlen: r })
      return
    }
    var u = R5(e, '_bt'),
      h = R5(e, '_bb'),
      f = e.node(o)
    e.setParent(u, o),
      (f.borderTop = u),
      e.setParent(h, o),
      (f.borderBottom = h),
      rt(l, function (d) {
        cX(e, t, r, n, i, s, d)
        var p = e.node(d),
          m = p.borderTop ? p.borderTop : d,
          g = p.borderBottom ? p.borderBottom : d,
          y = p.borderTop ? n : 2 * n,
          b = m !== g ? 1 : i - s[o] + 1
        e.setEdge(u, m, { weight: y, minlen: b, nestingEdge: !0 }),
          e.setEdge(g, h, { weight: y, minlen: b, nestingEdge: !0 })
      }),
      e.parent(o) || e.setEdge(t, u, { weight: 0, minlen: i + s[o] })
  }
  function DEt(e) {
    var t = {}
    function r(n, i) {
      var s = e.children(n)
      s &&
        s.length &&
        rt(s, function (o) {
          r(o, i + 1)
        }),
        (t[n] = i)
    }
    return (
      a(r, 'dfs'),
      rt(e.children(), function (n) {
        r(n, 1)
      }),
      t
    )
  }
  function NEt(e) {
    return mr(
      e.edges(),
      function (t, r) {
        return t + e.edge(r).weight
      },
      0,
    )
  }
  function uX(e) {
    var t = e.graph()
    e.removeNode(t.nestingRoot),
      delete t.nestingRoot,
      rt(e.edges(), function (r) {
        var n = e.edge(r)
        n.nestingEdge && e.removeEdge(r)
      })
  }
  var hX = x(() => {
    'use strict'
    fe()
    Ro()
    a(lX, 'run')
    a(cX, 'dfs')
    a(DEt, 'treeDepths')
    a(NEt, 'sumWeights')
    a(uX, 'cleanup')
  })
  function fX(e, t, r) {
    var n = {},
      i
    rt(r, function (s) {
      for (var o = e.parent(s), l, u; o; ) {
        if (((l = e.parent(o)), l ? ((u = n[l]), (n[l] = o)) : ((u = i), (i = o)), u && u !== o)) {
          t.setEdge(u, o)
          return
        }
        o = l
      }
    })
  }
  var dX = x(() => {
    'use strict'
    fe()
    a(fX, 'addSubgraphConstraints')
  })
  function pX(e, t, r) {
    var n = MEt(e),
      i = new _r({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function (s) {
        return e.node(s)
      })
    return (
      rt(e.nodes(), function (s) {
        var o = e.node(s),
          l = e.parent(s)
        ;(o.rank === t || (o.minRank <= t && t <= o.maxRank)) &&
          (i.setNode(s),
          i.setParent(s, l || n),
          rt(e[r](s), function (u) {
            var h = u.v === s ? u.w : u.v,
              f = i.edge(h, s),
              d = Fe(f) ? 0 : f.weight
            i.setEdge(h, s, { weight: e.edge(u).weight + d })
          }),
          Object.prototype.hasOwnProperty.call(o, 'minRank') &&
            i.setNode(s, { borderLeft: o.borderLeft[t], borderRight: o.borderRight[t] }))
      }),
      i
    )
  }
  function MEt(e) {
    for (var t; e.hasNode((t = uh('_root'))); );
    return t
  }
  var mX = x(() => {
    'use strict'
    fe()
    aa()
    a(pX, 'buildLayerGraph')
    a(MEt, 'createRootNode')
  })
  function gX(e, t) {
    for (var r = 0, n = 1; n < t.length; ++n) r += OEt(e, t[n - 1], t[n])
    return r
  }
  function OEt(e, t, r) {
    for (
      var n = Jk(
          r,
          Dt(r, function (h, f) {
            return f
          }),
        ),
        i = dr(
          Dt(t, function (h) {
            return Ao(
              Dt(e.outEdges(h), function (f) {
                return { pos: n[f.w], weight: e.edge(f).weight }
              }),
              'pos',
            )
          }),
        ),
        s = 1;
      s < r.length;

    )
      s <<= 1
    var o = 2 * s - 1
    s -= 1
    var l = Dt(new Array(o), function () {
        return 0
      }),
      u = 0
    return (
      rt(
        i.forEach(function (h) {
          var f = h.pos + s
          l[f] += h.weight
          for (var d = 0; f > 0; ) f % 2 && (d += l[f + 1]), (f = (f - 1) >> 1), (l[f] += h.weight)
          u += h.weight * d
        }),
      ),
      u
    )
  }
  var yX = x(() => {
    'use strict'
    fe()
    a(gX, 'crossCount')
    a(OEt, 'twoLayerCrossCount')
  })
  function xX(e) {
    var t = {},
      r = pr(e.nodes(), function (l) {
        return !e.children(l).length
      }),
      n = ds(
        Dt(r, function (l) {
          return e.node(l).rank
        }),
      ),
      i = Dt(sa(n + 1), function () {
        return []
      })
    function s(l) {
      if (!te(t, l)) {
        t[l] = !0
        var u = e.node(l)
        i[u.rank].push(l), rt(e.successors(l), s)
      }
    }
    a(s, 'dfs')
    var o = Ao(r, function (l) {
      return e.node(l).rank
    })
    return rt(o, s), i
  }
  var bX = x(() => {
    'use strict'
    fe()
    a(xX, 'initOrder')
  })
  function kX(e, t) {
    return Dt(t, function (r) {
      var n = e.inEdges(r)
      if (n.length) {
        var i = mr(
          n,
          function (s, o) {
            var l = e.edge(o),
              u = e.node(o.v)
            return { sum: s.sum + l.weight * u.order, weight: s.weight + l.weight }
          },
          { sum: 0, weight: 0 },
        )
        return { v: r, barycenter: i.sum / i.weight, weight: i.weight }
      } else return { v: r }
    })
  }
  var TX = x(() => {
    'use strict'
    fe()
    a(kX, 'barycenter')
  })
  function SX(e, t) {
    var r = {}
    rt(e, function (i, s) {
      var o = (r[i.v] = { indegree: 0, in: [], out: [], vs: [i.v], i: s })
      Fe(i.barycenter) || ((o.barycenter = i.barycenter), (o.weight = i.weight))
    }),
      rt(t.edges(), function (i) {
        var s = r[i.v],
          o = r[i.w]
        !Fe(s) && !Fe(o) && (o.indegree++, s.out.push(r[i.w]))
      })
    var n = pr(r, function (i) {
      return !i.indegree
    })
    return PEt(n)
  }
  function PEt(e) {
    var t = []
    function r(s) {
      return function (o) {
        o.merged || ((Fe(o.barycenter) || Fe(s.barycenter) || o.barycenter >= s.barycenter) && BEt(s, o))
      }
    }
    a(r, 'handleIn')
    function n(s) {
      return function (o) {
        o.in.push(s), --o.indegree === 0 && e.push(o)
      }
    }
    for (a(n, 'handleOut'); e.length; ) {
      var i = e.pop()
      t.push(i), rt(i.in.reverse(), r(i)), rt(i.out, n(i))
    }
    return Dt(
      pr(t, function (s) {
        return !s.merged
      }),
      function (s) {
        return ch(s, ['vs', 'i', 'barycenter', 'weight'])
      },
    )
  }
  function BEt(e, t) {
    var r = 0,
      n = 0
    e.weight && ((r += e.barycenter * e.weight), (n += e.weight)),
      t.weight && ((r += t.barycenter * t.weight), (n += t.weight)),
      (e.vs = t.vs.concat(e.vs)),
      (e.barycenter = r / n),
      (e.weight = n),
      (e.i = Math.min(t.i, e.i)),
      (t.merged = !0)
  }
  var _X = x(() => {
    'use strict'
    fe()
    a(SX, 'resolveConflicts')
    a(PEt, 'doResolveConflicts')
    a(BEt, 'mergeEntries')
  })
  function wX(e, t) {
    var r = RY(e, function (f) {
        return Object.prototype.hasOwnProperty.call(f, 'barycenter')
      }),
      n = r.lhs,
      i = Ao(r.rhs, function (f) {
        return -f.i
      }),
      s = [],
      o = 0,
      l = 0,
      u = 0
    n.sort(FEt(!!t)),
      (u = CX(s, i, u)),
      rt(n, function (f) {
        ;(u += f.vs.length), s.push(f.vs), (o += f.barycenter * f.weight), (l += f.weight), (u = CX(s, i, u))
      })
    var h = { vs: dr(s) }
    return l && ((h.barycenter = o / l), (h.weight = l)), h
  }
  function CX(e, t, r) {
    for (var n; t.length && (n = oi(t)).i <= r; ) t.pop(), e.push(n.vs), r++
    return r
  }
  function FEt(e) {
    return function (t, r) {
      return t.barycenter < r.barycenter ? -1 : t.barycenter > r.barycenter ? 1 : e ? r.i - t.i : t.i - r.i
    }
  }
  var EX = x(() => {
    'use strict'
    fe()
    Ro()
    a(wX, 'sort')
    a(CX, 'consumeUnsortable')
    a(FEt, 'compareWithBias')
  })
  function Y5(e, t, r, n) {
    var i = e.children(t),
      s = e.node(t),
      o = s ? s.borderLeft : void 0,
      l = s ? s.borderRight : void 0,
      u = {}
    o &&
      (i = pr(i, function (g) {
        return g !== o && g !== l
      }))
    var h = kX(e, i)
    rt(h, function (g) {
      if (e.children(g.v).length) {
        var y = Y5(e, g.v, r, n)
        ;(u[g.v] = y), Object.prototype.hasOwnProperty.call(y, 'barycenter') && GEt(g, y)
      }
    })
    var f = SX(h, r)
    $Et(f, u)
    var d = wX(f, n)
    if (o && ((d.vs = dr([o, d.vs, l])), e.predecessors(o).length)) {
      var p = e.node(e.predecessors(o)[0]),
        m = e.node(e.predecessors(l)[0])
      Object.prototype.hasOwnProperty.call(d, 'barycenter') || ((d.barycenter = 0), (d.weight = 0)),
        (d.barycenter = (d.barycenter * d.weight + p.order + m.order) / (d.weight + 2)),
        (d.weight += 2)
    }
    return d
  }
  function $Et(e, t) {
    rt(e, function (r) {
      r.vs = dr(
        r.vs.map(function (n) {
          return t[n] ? t[n].vs : n
        }),
      )
    })
  }
  function GEt(e, t) {
    Fe(e.barycenter)
      ? ((e.barycenter = t.barycenter), (e.weight = t.weight))
      : ((e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight)),
        (e.weight += t.weight))
  }
  var vX = x(() => {
    'use strict'
    fe()
    TX()
    _X()
    EX()
    a(Y5, 'sortSubgraph')
    a($Et, 'expandSubgraphs')
    a(GEt, 'mergeBarycenters')
  })
  function RX(e) {
    var t = D5(e),
      r = AX(e, sa(1, t + 1), 'inEdges'),
      n = AX(e, sa(t - 1, -1, -1), 'outEdges'),
      i = xX(e)
    LX(e, i)
    for (var s = Number.POSITIVE_INFINITY, o, l = 0, u = 0; u < 4; ++l, ++u) {
      VEt(l % 2 ? r : n, l % 4 >= 2), (i = Bc(e))
      var h = gX(e, i)
      h < s && ((u = 0), (o = ZA(i)), (s = h))
    }
    LX(e, o)
  }
  function AX(e, t, r) {
    return Dt(t, function (n) {
      return pX(e, n, r)
    })
  }
  function VEt(e, t) {
    var r = new _r()
    rt(e, function (n) {
      var i = n.graph().root,
        s = Y5(n, i, r, t)
      rt(s.vs, function (o, l) {
        n.node(o).order = l
      }),
        fX(n, r, s.vs)
    })
  }
  function LX(e, t) {
    rt(t, function (r) {
      rt(r, function (n, i) {
        e.node(n).order = i
      })
    })
  }
  var DX = x(() => {
    'use strict'
    fe()
    aa()
    Ro()
    dX()
    mX()
    yX()
    bX()
    vX()
    a(RX, 'order')
    a(AX, 'buildLayerGraphs')
    a(VEt, 'sweepLayerGraphs')
    a(LX, 'assignOrder')
  })
  function NX(e) {
    var t = WEt(e)
    rt(e.graph().dummyChains, function (r) {
      for (
        var n = e.node(r), i = n.edgeObj, s = zEt(e, t, i.v, i.w), o = s.path, l = s.lca, u = 0, h = o[u], f = !0;
        r !== i.w;

      ) {
        if (((n = e.node(r)), f)) {
          for (; (h = o[u]) !== l && e.node(h).maxRank < n.rank; ) u++
          h === l && (f = !1)
        }
        if (!f) {
          for (; u < o.length - 1 && e.node((h = o[u + 1])).minRank <= n.rank; ) u++
          h = o[u]
        }
        e.setParent(r, h), (r = e.successors(r)[0])
      }
    })
  }
  function zEt(e, t, r, n) {
    var i = [],
      s = [],
      o = Math.min(t[r].low, t[n].low),
      l = Math.max(t[r].lim, t[n].lim),
      u,
      h
    u = r
    do (u = e.parent(u)), i.push(u)
    while (u && (t[u].low > o || l > t[u].lim))
    for (h = u, u = n; (u = e.parent(u)) !== h; ) s.push(u)
    return { path: i.concat(s.reverse()), lca: h }
  }
  function WEt(e) {
    var t = {},
      r = 0
    function n(i) {
      var s = r
      rt(e.children(i), n), (t[i] = { low: s, lim: r++ })
    }
    return a(n, 'dfs'), rt(e.children(), n), t
  }
  var IX = x(() => {
    'use strict'
    fe()
    a(NX, 'parentDummyChains')
    a(zEt, 'findPath')
    a(WEt, 'postorder')
  })
  function UEt(e, t) {
    var r = {}
    function n(i, s) {
      var o = 0,
        l = 0,
        u = i.length,
        h = oi(s)
      return (
        rt(s, function (f, d) {
          var p = qEt(e, f),
            m = p ? e.node(p).order : u
          ;(p || f === h) &&
            (rt(s.slice(l, d + 1), function (g) {
              rt(e.predecessors(g), function (y) {
                var b = e.node(y),
                  k = b.order
                ;(k < o || m < k) && !(b.dummy && e.node(g).dummy) && MX(r, y, g)
              })
            }),
            (l = d + 1),
            (o = m))
        }),
        s
      )
    }
    return a(n, 'visitLayer'), mr(t, n), r
  }
  function jEt(e, t) {
    var r = {}
    function n(s, o, l, u, h) {
      var f
      rt(sa(o, l), function (d) {
        ;(f = s[d]),
          e.node(f).dummy &&
            rt(e.predecessors(f), function (p) {
              var m = e.node(p)
              m.dummy && (m.order < u || m.order > h) && MX(r, p, f)
            })
      })
    }
    a(n, 'scan')
    function i(s, o) {
      var l = -1,
        u,
        h = 0
      return (
        rt(o, function (f, d) {
          if (e.node(f).dummy === 'border') {
            var p = e.predecessors(f)
            p.length && ((u = e.node(p[0]).order), n(o, h, d, l, u), (h = d), (l = u))
          }
          n(o, h, o.length, u, s.length)
        }),
        o
      )
    }
    return a(i, 'visitLayer'), mr(t, i), r
  }
  function qEt(e, t) {
    if (e.node(t).dummy)
      return Vi(e.predecessors(t), function (r) {
        return e.node(r).dummy
      })
  }
  function MX(e, t, r) {
    if (t > r) {
      var n = t
      ;(t = r), (r = n)
    }
    var i = e[t]
    i || (e[t] = i = {}), (i[r] = !0)
  }
  function HEt(e, t, r) {
    if (t > r) {
      var n = t
      ;(t = r), (r = n)
    }
    return !!e[t] && Object.prototype.hasOwnProperty.call(e[t], r)
  }
  function YEt(e, t, r, n) {
    var i = {},
      s = {},
      o = {}
    return (
      rt(t, function (l) {
        rt(l, function (u, h) {
          ;(i[u] = u), (s[u] = u), (o[u] = h)
        })
      }),
      rt(t, function (l) {
        var u = -1
        rt(l, function (h) {
          var f = n(h)
          if (f.length) {
            f = Ao(f, function (y) {
              return o[y]
            })
            for (var d = (f.length - 1) / 2, p = Math.floor(d), m = Math.ceil(d); p <= m; ++p) {
              var g = f[p]
              s[h] === h && u < o[g] && !HEt(r, h, g) && ((s[g] = h), (s[h] = i[h] = i[g]), (u = o[g]))
            }
          }
        })
      }),
      { root: i, align: s }
    )
  }
  function XEt(e, t, r, n, i) {
    var s = {},
      o = KEt(e, t, r, i),
      l = i ? 'borderLeft' : 'borderRight'
    function u(d, p) {
      for (var m = o.nodes(), g = m.pop(), y = {}; g; )
        y[g] ? d(g) : ((y[g] = !0), m.push(g), (m = m.concat(p(g)))), (g = m.pop())
    }
    a(u, 'iterate')
    function h(d) {
      s[d] = o.inEdges(d).reduce(function (p, m) {
        return Math.max(p, s[m.v] + o.edge(m))
      }, 0)
    }
    a(h, 'pass1')
    function f(d) {
      var p = o.outEdges(d).reduce(function (g, y) {
          return Math.min(g, s[y.w] - o.edge(y))
        }, Number.POSITIVE_INFINITY),
        m = e.node(d)
      p !== Number.POSITIVE_INFINITY && m.borderType !== l && (s[d] = Math.max(s[d], p))
    }
    return (
      a(f, 'pass2'),
      u(h, o.predecessors.bind(o)),
      u(f, o.successors.bind(o)),
      rt(n, function (d) {
        s[d] = s[r[d]]
      }),
      s
    )
  }
  function KEt(e, t, r, n) {
    var i = new _r(),
      s = e.graph(),
      o = tvt(s.nodesep, s.edgesep, n)
    return (
      rt(t, function (l) {
        var u
        rt(l, function (h) {
          var f = r[h]
          if ((i.setNode(f), u)) {
            var d = r[u],
              p = i.edge(d, f)
            i.setEdge(d, f, Math.max(o(e, h, u), p || 0))
          }
          u = h
        })
      }),
      i
    )
  }
  function QEt(e, t) {
    return lh(We(t), function (r) {
      var n = Number.NEGATIVE_INFINITY,
        i = Number.POSITIVE_INFINITY
      return (
        d5(r, function (s, o) {
          var l = evt(e, o) / 2
          ;(n = Math.max(s + l, n)), (i = Math.min(s - l, i))
        }),
        n - i
      )
    })
  }
  function ZEt(e, t) {
    var r = We(t),
      n = Ga(r),
      i = ds(r)
    rt(['u', 'd'], function (s) {
      rt(['l', 'r'], function (o) {
        var l = s + o,
          u = e[l],
          h
        if (u !== t) {
          var f = We(u)
          ;(h = o === 'l' ? n - Ga(f) : i - ds(f)),
            h &&
              (e[l] = oh(u, function (d) {
                return d + h
              }))
        }
      })
    })
  }
  function JEt(e, t) {
    return oh(e.ul, function (r, n) {
      if (t) return e[t.toLowerCase()][n]
      var i = Ao(Dt(e, n))
      return (i[1] + i[2]) / 2
    })
  }
  function OX(e) {
    var t = Bc(e),
      r = bc(UEt(e, t), jEt(e, t)),
      n = {},
      i
    rt(['u', 'd'], function (o) {
      ;(i = o === 'u' ? t : We(t).reverse()),
        rt(['l', 'r'], function (l) {
          l === 'r' &&
            (i = Dt(i, function (d) {
              return We(d).reverse()
            }))
          var u = (o === 'u' ? e.predecessors : e.successors).bind(e),
            h = YEt(e, i, r, u),
            f = XEt(e, i, h.root, h.align, l === 'r')
          l === 'r' &&
            (f = oh(f, function (d) {
              return -d
            })),
            (n[o + l] = f)
        })
    })
    var s = QEt(e, n)
    return ZEt(n, s), JEt(n, e.graph().align)
  }
  function tvt(e, t, r) {
    return function (n, i, s) {
      var o = n.node(i),
        l = n.node(s),
        u = 0,
        h
      if (((u += o.width / 2), Object.prototype.hasOwnProperty.call(o, 'labelpos')))
        switch (o.labelpos.toLowerCase()) {
          case 'l':
            h = -o.width / 2
            break
          case 'r':
            h = o.width / 2
            break
        }
      if (
        (h && (u += r ? h : -h),
        (h = 0),
        (u += (o.dummy ? t : e) / 2),
        (u += (l.dummy ? t : e) / 2),
        (u += l.width / 2),
        Object.prototype.hasOwnProperty.call(l, 'labelpos'))
      )
        switch (l.labelpos.toLowerCase()) {
          case 'l':
            h = l.width / 2
            break
          case 'r':
            h = -l.width / 2
            break
        }
      return h && (u += r ? h : -h), (h = 0), u
    }
  }
  function evt(e, t) {
    return e.node(t).width
  }
  var PX = x(() => {
    'use strict'
    fe()
    aa()
    Ro()
    a(UEt, 'findType1Conflicts')
    a(jEt, 'findType2Conflicts')
    a(qEt, 'findOtherInnerSegmentNode')
    a(MX, 'addConflict')
    a(HEt, 'hasConflict')
    a(YEt, 'verticalAlignment')
    a(XEt, 'horizontalCompaction')
    a(KEt, 'buildBlockGraph')
    a(QEt, 'findSmallestWidthAlignment')
    a(ZEt, 'alignCoordinates')
    a(JEt, 'balance')
    a(OX, 'positionX')
    a(tvt, 'sep')
    a(evt, 'width')
  })
  function BX(e) {
    ;(e = nT(e)),
      rvt(e),
      p5(OX(e), function (t, r) {
        e.node(r).x = t
      })
  }
  function rvt(e) {
    var t = Bc(e),
      r = e.graph().ranksep,
      n = 0
    rt(t, function (i) {
      var s = ds(
        Dt(i, function (o) {
          return e.node(o).height
        }),
      )
      rt(i, function (o) {
        e.node(o).y = n + s / 2
      }),
        (n += s + r)
    })
  }
  var FX = x(() => {
    'use strict'
    fe()
    Ro()
    PX()
    a(BX, 'position')
    a(rvt, 'positionY')
  })
  function Y0(e, t) {
    var r = t && t.debugTiming ? DY : NY
    r('layout', () => {
      var n = r('  buildLayoutGraph', () => dvt(e))
      r('  runLayout', () => nvt(n, r)), r('  updateInputGraph', () => ivt(e, n))
    })
  }
  function nvt(e, t) {
    t('    makeSpaceForEdgeLabels', () => pvt(e)),
      t('    removeSelfEdges', () => _vt(e)),
      t('    acyclic', () => CY(e)),
      t('    nestingGraph.run', () => lX(e)),
      t('    rank', () => q5(nT(e))),
      t('    injectEdgeLabelProxies', () => mvt(e)),
      t('    removeEmptyRanks', () => LY(e)),
      t('    nestingGraph.cleanup', () => uX(e)),
      t('    normalizeRanks', () => AY(e)),
      t('    assignRankMinMax', () => gvt(e)),
      t('    removeEdgeLabelProxies', () => yvt(e)),
      t('    normalize.run', () => VY(e)),
      t('    parentDummyChains', () => NX(e)),
      t('    addBorderSegments', () => MY(e)),
      t('    order', () => RX(e)),
      t('    insertSelfEdges', () => Cvt(e)),
      t('    adjustCoordinateSystem', () => BY(e)),
      t('    position', () => BX(e)),
      t('    positionSelfEdges', () => wvt(e)),
      t('    removeBorderNodes', () => Svt(e)),
      t('    normalize.undo', () => zY(e)),
      t('    fixupEdgeLabelCoords', () => kvt(e)),
      t('    undoCoordinateSystem', () => FY(e)),
      t('    translateGraph', () => xvt(e)),
      t('    assignNodeIntersects', () => bvt(e)),
      t('    reversePoints', () => Tvt(e)),
      t('    acyclic.undo', () => wY(e))
  }
  function ivt(e, t) {
    rt(e.nodes(), function (r) {
      var n = e.node(r),
        i = t.node(r)
      n && ((n.x = i.x), (n.y = i.y), t.children(r).length && ((n.width = i.width), (n.height = i.height)))
    }),
      rt(e.edges(), function (r) {
        var n = e.edge(r),
          i = t.edge(r)
        ;(n.points = i.points), Object.prototype.hasOwnProperty.call(i, 'x') && ((n.x = i.x), (n.y = i.y))
      }),
      (e.graph().width = t.graph().width),
      (e.graph().height = t.graph().height)
  }
  function dvt(e) {
    var t = new _r({ multigraph: !0, compound: !0 }),
      r = K5(e.graph())
    return (
      t.setGraph(bc({}, avt, X5(r, svt), ch(r, ovt))),
      rt(e.nodes(), function (n) {
        var i = K5(e.node(n))
        t.setNode(n, Mc(X5(i, lvt), cvt)), t.setParent(n, e.parent(n))
      }),
      rt(e.edges(), function (n) {
        var i = K5(e.edge(n))
        t.setEdge(n, bc({}, hvt, X5(i, uvt), ch(i, fvt)))
      }),
      t
    )
  }
  function pvt(e) {
    var t = e.graph()
    ;(t.ranksep /= 2),
      rt(e.edges(), function (r) {
        var n = e.edge(r)
        ;(n.minlen *= 2),
          n.labelpos.toLowerCase() !== 'c' &&
            (t.rankdir === 'TB' || t.rankdir === 'BT' ? (n.width += n.labeloffset) : (n.height += n.labeloffset))
      })
  }
  function mvt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t)
      if (r.width && r.height) {
        var n = e.node(t.v),
          i = e.node(t.w),
          s = { rank: (i.rank - n.rank) / 2 + n.rank, e: t }
        Lo(e, 'edge-proxy', s, '_ep')
      }
    })
  }
  function gvt(e) {
    var t = 0
    rt(e.nodes(), function (r) {
      var n = e.node(r)
      n.borderTop &&
        ((n.minRank = e.node(n.borderTop).rank), (n.maxRank = e.node(n.borderBottom).rank), (t = ds(t, n.maxRank)))
    }),
      (e.graph().maxRank = t)
  }
  function yvt(e) {
    rt(e.nodes(), function (t) {
      var r = e.node(t)
      r.dummy === 'edge-proxy' && ((e.edge(r.e).labelRank = r.rank), e.removeNode(t))
    })
  }
  function xvt(e) {
    var t = Number.POSITIVE_INFINITY,
      r = 0,
      n = Number.POSITIVE_INFINITY,
      i = 0,
      s = e.graph(),
      o = s.marginx || 0,
      l = s.marginy || 0
    function u(h) {
      var f = h.x,
        d = h.y,
        p = h.width,
        m = h.height
      ;(t = Math.min(t, f - p / 2)),
        (r = Math.max(r, f + p / 2)),
        (n = Math.min(n, d - m / 2)),
        (i = Math.max(i, d + m / 2))
    }
    a(u, 'getExtremes'),
      rt(e.nodes(), function (h) {
        u(e.node(h))
      }),
      rt(e.edges(), function (h) {
        var f = e.edge(h)
        Object.prototype.hasOwnProperty.call(f, 'x') && u(f)
      }),
      (t -= o),
      (n -= l),
      rt(e.nodes(), function (h) {
        var f = e.node(h)
        ;(f.x -= t), (f.y -= n)
      }),
      rt(e.edges(), function (h) {
        var f = e.edge(h)
        rt(f.points, function (d) {
          ;(d.x -= t), (d.y -= n)
        }),
          Object.prototype.hasOwnProperty.call(f, 'x') && (f.x -= t),
          Object.prototype.hasOwnProperty.call(f, 'y') && (f.y -= n)
      }),
      (s.width = r - t + o),
      (s.height = i - n + l)
  }
  function bvt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t),
        n = e.node(t.v),
        i = e.node(t.w),
        s,
        o
      r.points ? ((s = r.points[0]), (o = r.points[r.points.length - 1])) : ((r.points = []), (s = i), (o = n)),
        r.points.unshift(L5(n, s)),
        r.points.push(L5(i, o))
    })
  }
  function kvt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t)
      if (Object.prototype.hasOwnProperty.call(r, 'x'))
        switch (((r.labelpos === 'l' || r.labelpos === 'r') && (r.width -= r.labeloffset), r.labelpos)) {
          case 'l':
            r.x -= r.width / 2 + r.labeloffset
            break
          case 'r':
            r.x += r.width / 2 + r.labeloffset
            break
        }
    })
  }
  function Tvt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t)
      r.reversed && r.points.reverse()
    })
  }
  function Svt(e) {
    rt(e.nodes(), function (t) {
      if (e.children(t).length) {
        var r = e.node(t),
          n = e.node(r.borderTop),
          i = e.node(r.borderBottom),
          s = e.node(oi(r.borderLeft)),
          o = e.node(oi(r.borderRight))
        ;(r.width = Math.abs(o.x - s.x)),
          (r.height = Math.abs(i.y - n.y)),
          (r.x = s.x + r.width / 2),
          (r.y = n.y + r.height / 2)
      }
    }),
      rt(e.nodes(), function (t) {
        e.node(t).dummy === 'border' && e.removeNode(t)
      })
  }
  function _vt(e) {
    rt(e.edges(), function (t) {
      if (t.v === t.w) {
        var r = e.node(t.v)
        r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t)
      }
    })
  }
  function Cvt(e) {
    var t = Bc(e)
    rt(t, function (r) {
      var n = 0
      rt(r, function (i, s) {
        var o = e.node(i)
        ;(o.order = s + n),
          rt(o.selfEdges, function (l) {
            Lo(
              e,
              'selfedge',
              { width: l.label.width, height: l.label.height, rank: o.rank, order: s + ++n, e: l.e, label: l.label },
              '_se',
            )
          }),
          delete o.selfEdges
      })
    })
  }
  function wvt(e) {
    rt(e.nodes(), function (t) {
      var r = e.node(t)
      if (r.dummy === 'selfedge') {
        var n = e.node(r.e.v),
          i = n.x + n.width / 2,
          s = n.y,
          o = r.x - i,
          l = n.height / 2
        e.setEdge(r.e, r.label),
          e.removeNode(t),
          (r.label.points = [
            { x: i + (2 * o) / 3, y: s - l },
            { x: i + (5 * o) / 6, y: s - l },
            { x: i + o, y: s },
            { x: i + (5 * o) / 6, y: s + l },
            { x: i + (2 * o) / 3, y: s + l },
          ]),
          (r.label.x = r.x),
          (r.label.y = r.y)
      }
    })
  }
  function X5(e, t) {
    return oh(ch(e, t), Number)
  }
  function K5(e) {
    var t = {}
    return (
      rt(e, function (r, n) {
        t[n.toLowerCase()] = r
      }),
      t
    )
  }
  var svt,
    avt,
    ovt,
    lvt,
    cvt,
    uvt,
    hvt,
    fvt,
    $X = x(() => {
      'use strict'
      fe()
      aa()
      OY()
      GY()
      A5()
      M5()
      H5()
      hX()
      DX()
      IX()
      FX()
      Ro()
      a(Y0, 'layout')
      a(nvt, 'runLayout')
      a(ivt, 'updateInputGraph')
      ;(svt = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy']),
        (avt = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' }),
        (ovt = ['acyclicer', 'ranker', 'rankdir', 'align']),
        (lvt = ['width', 'height']),
        (cvt = { width: 0, height: 0 }),
        (uvt = ['minlen', 'weight', 'width', 'height', 'labeloffset']),
        (hvt = { minlen: 1, weight: 1, width: 0, height: 0, labeloffset: 10, labelpos: 'r' }),
        (fvt = ['labelpos'])
      a(dvt, 'buildLayoutGraph')
      a(pvt, 'makeSpaceForEdgeLabels')
      a(mvt, 'injectEdgeLabelProxies')
      a(gvt, 'assignRankMinMax')
      a(yvt, 'removeEdgeLabelProxies')
      a(xvt, 'translateGraph')
      a(bvt, 'assignNodeIntersects')
      a(kvt, 'fixupEdgeLabelCoords')
      a(Tvt, 'reversePointsForReversedEdges')
      a(Svt, 'removeBorderNodes')
      a(_vt, 'removeSelfEdges')
      a(Cvt, 'insertSelfEdges')
      a(wvt, 'positionSelfEdges')
      a(X5, 'selectNumberAttrs')
      a(K5, 'canonicalize')
    })
  var Q5 = x(() => {
    'use strict'
    A5()
    $X()
    M5()
    H5()
  })
  function oa(e) {
    var t = {
      options: { directed: e.isDirected(), multigraph: e.isMultigraph(), compound: e.isCompound() },
      nodes: Evt(e),
      edges: vvt(e),
    }
    return Fe(e.graph()) || (t.value = Sr(e.graph())), t
  }
  function Evt(e) {
    return Dt(e.nodes(), function (t) {
      var r = e.node(t),
        n = e.parent(t),
        i = { v: t }
      return Fe(r) || (i.value = r), Fe(n) || (i.parent = n), i
    })
  }
  function vvt(e) {
    return Dt(e.edges(), function (t) {
      var r = e.edge(t),
        n = { v: t.v, w: t.w }
      return Fe(t.name) || (n.name = t.name), Fe(r) || (n.value = r), n
    })
  }
  var Z5 = x(() => {
    'use strict'
    fe()
    tT()
    a(oa, 'write')
    a(Evt, 'writeNodes')
    a(vvt, 'writeEdges')
  })
  var Ue,
    dh,
    zX,
    WX,
    oT,
    Avt,
    UX,
    jX,
    Lvt,
    Id,
    VX,
    qX,
    HX,
    YX,
    XX,
    KX = x(() => {
      'use strict'
      Vt()
      aa()
      Z5()
      ;(Ue = new Map()),
        (dh = new Map()),
        (zX = new Map()),
        (WX = a(() => {
          dh.clear(), zX.clear(), Ue.clear()
        }, 'clear')),
        (oT = a((e, t) => {
          let r = dh.get(t) || []
          return B.trace('In isDescendant', t, ' ', e, ' = ', r.includes(e)), r.includes(e)
        }, 'isDescendant')),
        (Avt = a((e, t) => {
          let r = dh.get(t) || []
          return (
            B.info('Descendants of ', t, ' is ', r),
            B.info('Edge is ', e),
            e.v === t || e.w === t
              ? !1
              : r
                ? r.includes(e.v) || oT(e.v, t) || oT(e.w, t) || r.includes(e.w)
                : (B.debug('Tilt, ', t, ',not in descendants'), !1)
          )
        }, 'edgeInCluster')),
        (UX = a((e, t, r, n) => {
          B.warn('Copying children of ', e, 'root', n, 'data', t.node(e), n)
          let i = t.children(e) || []
          e !== n && i.push(e),
            B.warn('Copying (nodes) clusterId', e, 'nodes', i),
            i.forEach((s) => {
              if (t.children(s).length > 0) UX(s, t, r, n)
              else {
                let o = t.node(s)
                B.info('cp ', s, ' to ', n, ' with parent ', e),
                  r.setNode(s, o),
                  n !== t.parent(s) && (B.warn('Setting parent', s, t.parent(s)), r.setParent(s, t.parent(s))),
                  e !== n && s !== e
                    ? (B.debug('Setting parent', s, e), r.setParent(s, e))
                    : (B.info('In copy ', e, 'root', n, 'data', t.node(e), n),
                      B.debug(
                        'Not Setting parent for node=',
                        s,
                        'cluster!==rootId',
                        e !== n,
                        'node!==clusterId',
                        s !== e,
                      ))
                let l = t.edges(s)
                B.debug('Copying Edges', l),
                  l.forEach((u) => {
                    B.info('Edge', u)
                    let h = t.edge(u.v, u.w, u.name)
                    B.info('Edge data', h, n)
                    try {
                      Avt(u, n)
                        ? (B.info('Copying as ', u.v, u.w, h, u.name),
                          r.setEdge(u.v, u.w, h, u.name),
                          B.info('newGraph edges ', r.edges(), r.edge(r.edges()[0])))
                        : B.info('Skipping copy of edge ', u.v, '-->', u.w, ' rootId: ', n, ' clusterId:', e)
                    } catch (f) {
                      B.error(f)
                    }
                  })
              }
              B.debug('Removing node', s), t.removeNode(s)
            })
        }, 'copy')),
        (jX = a((e, t) => {
          let r = t.children(e),
            n = [...r]
          for (let i of r) zX.set(i, e), (n = [...n, ...jX(i, t)])
          return n
        }, 'extractDescendants')),
        (Lvt = a((e, t, r) => {
          let n = e.edges().filter((u) => u.v === t || u.w === t),
            i = e.edges().filter((u) => u.v === r || u.w === r),
            s = n.map((u) => ({ v: u.v === t ? r : u.v, w: u.w === t ? t : u.w })),
            o = i.map((u) => ({ v: u.v, w: u.w }))
          return s.filter((u) => o.some((h) => u.v === h.v && u.w === h.w))
        }, 'findCommonEdges')),
        (Id = a((e, t, r) => {
          let n = t.children(e)
          if ((B.trace('Searching children of id ', e, n), n.length < 1)) return e
          let i
          for (let s of n) {
            let o = Id(s, t, r),
              l = Lvt(t, r, o)
            if (o)
              if (l.length > 0) i = o
              else return o
          }
          return i
        }, 'findNonClusterChild')),
        (VX = a(
          (e) => (!Ue.has(e) || !Ue.get(e).externalConnections ? e : Ue.has(e) ? Ue.get(e).id : e),
          'getAnchorId',
        )),
        (qX = a((e, t) => {
          if (!e || t > 10) {
            B.debug('Opting out, no graph ')
            return
          } else B.debug('Opting in, graph ')
          e.nodes().forEach(function (r) {
            e.children(r).length > 0 &&
              (B.warn('Cluster identified', r, ' Replacement id in edges: ', Id(r, e, r)),
              dh.set(r, jX(r, e)),
              Ue.set(r, { id: Id(r, e, r), clusterData: e.node(r) }))
          }),
            e.nodes().forEach(function (r) {
              let n = e.children(r),
                i = e.edges()
              n.length > 0
                ? (B.debug('Cluster identified', r, dh),
                  i.forEach((s) => {
                    let o = oT(s.v, r),
                      l = oT(s.w, r)
                    o ^ l &&
                      (B.warn('Edge: ', s, ' leaves cluster ', r),
                      B.warn('Descendants of XXX ', r, ': ', dh.get(r)),
                      (Ue.get(r).externalConnections = !0))
                  }))
                : B.debug('Not a cluster ', r, dh)
            })
          for (let r of Ue.keys()) {
            let n = Ue.get(r).id,
              i = e.parent(n)
            i !== r && Ue.has(i) && !Ue.get(i).externalConnections && (Ue.get(r).id = i)
          }
          e.edges().forEach(function (r) {
            let n = e.edge(r)
            B.warn('Edge ' + r.v + ' -> ' + r.w + ': ' + JSON.stringify(r)),
              B.warn('Edge ' + r.v + ' -> ' + r.w + ': ' + JSON.stringify(e.edge(r)))
            let i = r.v,
              s = r.w
            if (
              (B.warn('Fix XXX', Ue, 'ids:', r.v, r.w, 'Translating: ', Ue.get(r.v), ' --- ', Ue.get(r.w)),
              Ue.get(r.v) || Ue.get(r.w))
            ) {
              if (
                (B.warn('Fixing and trying - removing XXX', r.v, r.w, r.name),
                (i = VX(r.v)),
                (s = VX(r.w)),
                e.removeEdge(r.v, r.w, r.name),
                i !== r.v)
              ) {
                let o = e.parent(i)
                ;(Ue.get(o).externalConnections = !0), (n.fromCluster = r.v)
              }
              if (s !== r.w) {
                let o = e.parent(s)
                ;(Ue.get(o).externalConnections = !0), (n.toCluster = r.w)
              }
              B.warn('Fix Replacing with XXX', i, s, r.name), e.setEdge(i, s, n, r.name)
            }
          }),
            B.warn('Adjusted Graph', oa(e)),
            HX(e, 0),
            B.trace(Ue)
        }, 'adjustClustersAndEdges')),
        (HX = a((e, t) => {
          if ((B.warn('extractor - ', t, oa(e), e.children('D')), t > 10)) {
            B.error('Bailing out')
            return
          }
          let r = e.nodes(),
            n = !1
          for (let i of r) {
            let s = e.children(i)
            n = n || s.length > 0
          }
          if (!n) {
            B.debug('Done, no node has children', e.nodes())
            return
          }
          B.debug('Nodes = ', r, t)
          for (let i of r)
            if (
              (B.debug(
                'Extracting node',
                i,
                Ue,
                Ue.has(i) && !Ue.get(i).externalConnections,
                !e.parent(i),
                e.node(i),
                e.children('D'),
                ' Depth ',
                t,
              ),
              !Ue.has(i))
            )
              B.debug('Not a cluster', i, t)
            else if (!Ue.get(i).externalConnections && e.children(i) && e.children(i).length > 0) {
              B.warn('Cluster without external connections, without a parent and with children', i, t)
              let o = e.graph().rankdir === 'TB' ? 'LR' : 'TB'
              Ue.get(i)?.clusterData?.dir &&
                ((o = Ue.get(i).clusterData.dir), B.warn('Fixing dir', Ue.get(i).clusterData.dir, o))
              let l = new _r({ multigraph: !0, compound: !0 })
                .setGraph({ rankdir: o, nodesep: 50, ranksep: 50, marginx: 8, marginy: 8 })
                .setDefaultEdgeLabel(function () {
                  return {}
                })
              B.warn('Old graph before copy', oa(e)),
                UX(i, e, l, i),
                e.setNode(i, {
                  clusterNode: !0,
                  id: i,
                  clusterData: Ue.get(i).clusterData,
                  label: Ue.get(i).label,
                  graph: l,
                }),
                B.warn('New graph after copy node: (', i, ')', oa(l)),
                B.debug('Old graph after copy', oa(e))
            } else
              B.warn(
                'Cluster ** ',
                i,
                ' **not meeting the criteria !externalConnections:',
                !Ue.get(i).externalConnections,
                ' no parent: ',
                !e.parent(i),
                ' children ',
                e.children(i) && e.children(i).length > 0,
                e.children('D'),
                t,
              ),
                B.debug(Ue)
          ;(r = e.nodes()), B.warn('New list of nodes', r)
          for (let i of r) {
            let s = e.node(i)
            B.warn(' Now next level', i, s), s?.clusterNode && HX(s.graph, t + 1)
          }
        }, 'extractor')),
        (YX = a((e, t) => {
          if (t.length === 0) return []
          let r = Object.assign([], t)
          return (
            t.forEach((n) => {
              let i = e.children(n),
                s = YX(e, i)
              r = [...r, ...s]
            }),
            r
          )
        }, 'sorter')),
        (XX = a((e) => YX(e, e.children()), 'sortNodesByHierarchy'))
    })
  var ZX = {}
  Oe(ZX, { render: () => Rvt })
  var QX,
    Rvt,
    JX = x(() => {
      'use strict'
      Q5()
      Z5()
      aa()
      PA()
      Qt()
      KX()
      ik()
      Hb()
      OA()
      Vt()
      $0()
      pe()
      ;(QX = a(async (e, t, r, n, i, s) => {
        B.warn('Graph in recursive render:XAX', oa(t), i)
        let o = t.graph().rankdir
        B.trace('Dir in recursive render - dir:', o)
        let l = e.insert('g').attr('class', 'root')
        t.nodes() ? B.info('Recursive render XXX', t.nodes()) : B.info('No nodes found for', t),
          t.edges().length > 0 && B.info('Recursive edges', t.edge(t.edges()[0]))
        let u = l.insert('g').attr('class', 'clusters'),
          h = l.insert('g').attr('class', 'edgePaths'),
          f = l.insert('g').attr('class', 'edgeLabels'),
          d = l.insert('g').attr('class', 'nodes')
        await Promise.all(
          t.nodes().map(async function (y) {
            let b = t.node(y)
            if (i !== void 0) {
              let k = JSON.parse(JSON.stringify(i.clusterData))
              B.trace(
                `Setting data for parent cluster XXX
 Node.id = `,
                y,
                `
 data=`,
                k.height,
                `
Parent cluster`,
                i.height,
              ),
                t.setNode(i.id, k),
                t.parent(y) || (B.trace('Setting parent', y, i.id), t.setParent(y, i.id, k))
            }
            if ((B.info('(Insert) Node XXX' + y + ': ' + JSON.stringify(t.node(y))), b?.clusterNode)) {
              B.info('Cluster identified XBX', y, b.width, t.node(y))
              let { ranksep: k, nodesep: T } = t.graph()
              b.graph.setGraph({ ...b.graph.graph(), ranksep: k + 25, nodesep: T })
              let C = await QX(d, b.graph, r, n, t.node(y), s),
                A = C.elem
              Ct(b, A),
                (b.diff = C.diff || 0),
                B.info('New compound node after recursive render XAX', y, 'width', b.width, 'height', b.height),
                gU(A, b)
            } else
              t.children(y).length > 0
                ? (B.trace('Cluster - the non recursive path XBX', y, b.id, b, b.width, 'Graph:', t),
                  B.trace(Id(b.id, t)),
                  Ue.set(b.id, { id: Id(b.id, t), node: b }))
                : (B.trace('Node - the non recursive path XAX', y, d, t.node(y), o),
                  await dd(d, t.node(y), { config: s, dir: o }))
          }),
        ),
          await a(async () => {
            let y = t.edges().map(async function (b) {
              let k = t.edge(b.v, b.w, b.name)
              B.info('Edge ' + b.v + ' -> ' + b.w + ': ' + JSON.stringify(b)),
                B.info('Edge ' + b.v + ' -> ' + b.w + ': ', b, ' ', JSON.stringify(t.edge(b))),
                B.info('Fix', Ue, 'ids:', b.v, b.w, 'Translating: ', Ue.get(b.v), Ue.get(b.w)),
                await Jb(f, k)
            })
            await Promise.all(y)
          }, 'processEdges')(),
          B.info('Graph before layout:', JSON.stringify(oa(t))),
          B.info('############################################# XXX'),
          B.info('###                Layout                 ### XXX'),
          B.info('############################################# XXX'),
          Y0(t),
          B.info('Graph after layout:', JSON.stringify(oa(t)))
        let m = 0,
          { subGraphTitleTotalMargin: g } = kl(s)
        return (
          await Promise.all(
            XX(t).map(async function (y) {
              let b = t.node(y)
              if (
                (B.info('Position XBX => ' + y + ': (' + b.x, ',' + b.y, ') width: ', b.width, ' height: ', b.height),
                b?.clusterNode)
              )
                (b.y += g),
                  B.info('A tainted cluster node XBX1', y, b.id, b.width, b.height, b.x, b.y, t.parent(y)),
                  (Ue.get(b.id).node = b),
                  G0(b)
              else if (t.children(y).length > 0) {
                B.info('A pure cluster node XBX1', y, b.id, b.x, b.y, b.width, b.height, t.parent(y)),
                  (b.height += g),
                  t.node(b.parentId)
                let k = b?.padding / 2 || 0,
                  T = b?.labelBBox?.height || 0,
                  C = T - k || 0
                B.debug('OffsetY', C, 'labelHeight', T, 'halfPadding', k), await fd(u, b), (Ue.get(b.id).node = b)
              } else {
                let k = t.node(b.parentId)
                ;(b.y += g / 2),
                  B.info(
                    'A regular node XBX1 - using the padding',
                    b.id,
                    'parent',
                    b.parentId,
                    b.width,
                    b.height,
                    b.x,
                    b.y,
                    'offsetY',
                    b.offsetY,
                    'parent',
                    k,
                    k?.offsetY,
                    b,
                  ),
                  G0(b)
              }
            }),
          ),
          t.edges().forEach(function (y) {
            let b = t.edge(y)
            B.info('Edge ' + y.v + ' -> ' + y.w + ': ' + JSON.stringify(b), b), b.points.forEach((A) => (A.y += g / 2))
            let k = t.node(y.v)
            var T = t.node(y.w)
            let C = ek(h, b, Ue, r, k, T, n)
            tk(b, C)
          }),
          t.nodes().forEach(function (y) {
            let b = t.node(y)
            B.info(y, b.type, b.diff), b.isGroup && (m = b.diff)
          }),
          B.warn('Returning from recursive render XAX', l, m),
          { elem: l, diff: m }
        )
      }, 'recursiveRender')),
        (Rvt = a(async (e, t) => {
          let r = new _r({ multigraph: !0, compound: !0 })
              .setGraph({
                rankdir: e.direction,
                nodesep: e.config?.nodeSpacing || e.config?.flowchart?.nodeSpacing || e.nodeSpacing,
                ranksep: e.config?.rankSpacing || e.config?.flowchart?.rankSpacing || e.rankSpacing,
                marginx: 8,
                marginy: 8,
              })
              .setDefaultEdgeLabel(function () {
                return {}
              }),
            n = t.select('g')
          rk(n, e.markers, e.type, e.diagramId),
            yU(),
            mU(),
            lU(),
            WX(),
            e.nodes.forEach((s) => {
              r.setNode(s.id, { ...s }), s.parentId && r.setParent(s.id, s.parentId)
            }),
            B.debug('Edges:', e.edges),
            e.edges.forEach((s) => {
              if (s.start === s.end) {
                let o = s.start,
                  l = o + '---' + o + '---1',
                  u = o + '---' + o + '---2',
                  h = r.node(o)
                r.setNode(l, {
                  domId: l,
                  id: l,
                  parentId: h.parentId,
                  labelStyle: '',
                  label: '',
                  padding: 0,
                  shape: 'labelRect',
                  style: '',
                  width: 10,
                  height: 10,
                }),
                  r.setParent(l, h.parentId),
                  r.setNode(u, {
                    domId: u,
                    id: u,
                    parentId: h.parentId,
                    labelStyle: '',
                    padding: 0,
                    shape: 'labelRect',
                    label: '',
                    style: '',
                    width: 10,
                    height: 10,
                  }),
                  r.setParent(u, h.parentId)
                let f = structuredClone(s),
                  d = structuredClone(s),
                  p = structuredClone(s)
                ;(f.label = ''),
                  (f.arrowTypeEnd = 'none'),
                  (f.id = o + '-cyclic-special-1'),
                  (d.arrowTypeStart = 'none'),
                  (d.arrowTypeEnd = 'none'),
                  (d.id = o + '-cyclic-special-mid'),
                  (p.label = ''),
                  h.isGroup && ((f.fromCluster = o), (p.toCluster = o)),
                  (p.id = o + '-cyclic-special-2'),
                  (p.arrowTypeStart = 'none'),
                  r.setEdge(o, l, f, o + '-cyclic-special-0'),
                  r.setEdge(l, u, d, o + '-cyclic-special-1'),
                  r.setEdge(u, o, p, o + '-cyc<lic-special-2')
              } else r.setEdge(s.start, s.end, { ...s }, s.id)
            }),
            B.warn('Graph at first:', JSON.stringify(oa(r))),
            qX(r),
            B.warn('Graph after XAX:', JSON.stringify(oa(r)))
          let i = K()
          await QX(n, r, e.type, e.diagramId, void 0, i)
        }, 'render'))
    })
  var X0,
    J5,
    Dvt,
    Do,
    Gc,
    ph = x(() => {
      'use strict'
      bU()
      Vt()
      ;(X0 = {}),
        (J5 = a((e) => {
          for (let t of e) X0[t.name] = t
        }, 'registerLayoutLoaders')),
        (Dvt = a(() => {
          J5([{ name: 'dagre', loader: a(async () => await Promise.resolve().then(() => (JX(), ZX)), 'loader') }])
        }, 'registerDefaultLayoutLoaders'))
      Dvt()
      ;(Do = a(async (e, t) => {
        if (!(e.layoutAlgorithm in X0)) throw new Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`)
        let r = X0[e.layoutAlgorithm]
        return (await r.loader()).render(e, t, xU, { algorithm: r.algorithm })
      }, 'render')),
        (Gc = a((e = '', { fallback: t = 'dagre' } = {}) => {
          if (e in X0) return e
          if (t in X0) return B.warn(`Layout algorithm ${e} is not registered. Using ${t} as fallback.`), t
          throw new Error(`Both layout algorithms ${e} and ${t} are not registered.`)
        }, 'getRegisteredLayoutAlgorithm'))
    })
  var la,
    Nvt,
    Ivt,
    mh = x(() => {
      'use strict'
      On()
      Vt()
      ;(la = a((e, t, r, n) => {
        e.attr('class', r)
        let { width: i, height: s, x: o, y: l } = Nvt(e, t)
        Ar(e, s, i, n)
        let u = Ivt(o, l, i, s, t)
        e.attr('viewBox', u), B.debug(`viewBox configured: ${u} with padding: ${t}`)
      }, 'setupViewPortForSVG')),
        (Nvt = a((e, t) => {
          let r = e.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 }
          return { width: r.width + t * 2, height: r.height + t * 2, x: r.x, y: r.y }
        }, 'calculateDimensionsWithPadding')),
        (Ivt = a((e, t, r, n, i) => `${e - i} ${t - i} ${r} ${n}`, 'createViewBox'))
    })
  var Mvt,
    Ovt,
    tK,
    eK = x(() => {
      'use strict'
      Ge()
      pe()
      Vt()
      hd()
      ph()
      mh()
      Ce()
      ;(Mvt = a(function (e, t) {
        return t.db.getClasses()
      }, 'getClasses')),
        (Ovt = a(async function (e, t, r, n) {
          B.info('REF0:'), B.info('Drawing state diagram (v2)', t)
          let { securityLevel: i, flowchart: s, layout: o } = K(),
            l
          i === 'sandbox' && (l = xt('#i' + t))
          let u = i === 'sandbox' ? l.nodes()[0].contentDocument : document
          B.debug('Before getData: ')
          let h = n.db.getData()
          B.debug('Data: ', h)
          let f = So(t, i),
            d = n.db.getDirection()
          ;(h.type = n.type),
            (h.layoutAlgorithm = Gc(o)),
            h.layoutAlgorithm === 'dagre' &&
              o === 'elk' &&
              B.warn(
                'flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback.',
              ),
            (h.direction = d),
            (h.nodeSpacing = s?.nodeSpacing || 50),
            (h.rankSpacing = s?.rankSpacing || 50),
            (h.markers = ['point', 'circle', 'cross']),
            (h.diagramId = t),
            B.debug('REF1:', h),
            await Do(h, f)
          let p = h.config.flowchart?.diagramPadding ?? 8
          le.insertTitle(f, 'flowchartTitleText', s?.titleTopMargin || 0, n.db.getDiagramTitle()),
            la(f, p, 'flowchart', s?.useMaxWidth || !1)
          for (let m of h.nodes) {
            let g = xt(`#${t} [id="${m.id}"]`)
            if (!g || !m.link) continue
            let y = u.createElementNS('http://www.w3.org/2000/svg', 'a')
            y.setAttributeNS('http://www.w3.org/2000/svg', 'class', m.cssClasses),
              y.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener'),
              i === 'sandbox'
                ? y.setAttributeNS('http://www.w3.org/2000/svg', 'target', '_top')
                : m.linkTarget && y.setAttributeNS('http://www.w3.org/2000/svg', 'target', m.linkTarget)
            let b = g.insert(function () {
                return y
              }, ':first-child'),
              k = g.select('.label-container')
            k &&
              b.append(function () {
                return k.node()
              })
            let T = g.select('.label')
            T &&
              b.append(function () {
                return T.node()
              })
          }
        }, 'draw')),
        (tK = { getClasses: Mvt, draw: Ovt })
    })
  var t6,
    e6,
    rK = x(() => {
      'use strict'
      t6 = (function () {
        var e = a(function (qr, ue, ke, Ne) {
            for (ke = ke || {}, Ne = qr.length; Ne--; ke[qr[Ne]] = ue);
            return ke
          }, 'o'),
          t = [1, 4],
          r = [1, 3],
          n = [1, 5],
          i = [
            1, 8, 9, 10, 11, 27, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116,
            121, 122, 123, 124,
          ],
          s = [2, 2],
          o = [1, 13],
          l = [1, 14],
          u = [1, 15],
          h = [1, 16],
          f = [1, 23],
          d = [1, 25],
          p = [1, 26],
          m = [1, 27],
          g = [1, 49],
          y = [1, 48],
          b = [1, 29],
          k = [1, 30],
          T = [1, 31],
          C = [1, 32],
          A = [1, 33],
          w = [1, 44],
          D = [1, 46],
          G = [1, 42],
          v = [1, 47],
          R = [1, 43],
          F = [1, 50],
          S = [1, 45],
          O = [1, 51],
          E = [1, 52],
          _ = [1, 34],
          L = [1, 35],
          N = [1, 36],
          P = [1, 37],
          I = [1, 57],
          M = [
            1, 8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116,
            121, 122, 123, 124,
          ],
          V = [1, 61],
          $ = [1, 60],
          q = [1, 62],
          tt = [8, 9, 11, 75, 77, 78],
          ft = [1, 78],
          H = [1, 91],
          kt = [1, 96],
          ht = [1, 95],
          yt = [1, 92],
          ot = [1, 88],
          dt = [1, 94],
          it = [1, 90],
          Q = [1, 97],
          et = [1, 93],
          X = [1, 98],
          st = [1, 89],
          U = [8, 9, 10, 11, 40, 75, 77, 78],
          gt = [8, 9, 10, 11, 40, 46, 75, 77, 78],
          z = [
            8, 9, 10, 11, 29, 40, 44, 46, 48, 50, 52, 54, 56, 58, 60, 63, 65, 67, 68, 70, 75, 77, 78, 89, 102, 105, 106,
            109, 111, 114, 115, 116,
          ],
          ge = [8, 9, 11, 44, 60, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116],
          lt = [44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116],
          jt = [1, 121],
          Me = [1, 122],
          se = [1, 124],
          Nt = [1, 123],
          At = [44, 60, 62, 74, 89, 102, 105, 106, 109, 111, 114, 115, 116],
          bt = [1, 133],
          ct = [1, 147],
          Lt = [1, 148],
          Z = [1, 149],
          Mt = [1, 150],
          W = [1, 135],
          Gt = [1, 137],
          j = [1, 141],
          vt = [1, 142],
          mt = [1, 143],
          Xt = [1, 144],
          Ft = [1, 145],
          _t = [1, 146],
          Qe = [1, 151],
          It = [1, 152],
          xr = [1, 131],
          Ze = [1, 132],
          yn = [1, 139],
          Ae = [1, 134],
          Se = [1, 138],
          Je = [1, 136],
          _e = [
            8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116,
            121, 122, 123, 124,
          ],
          hr = [1, 154],
          Cn = [1, 156],
          ve = [8, 9, 11],
          $e = [8, 9, 10, 11, 14, 44, 60, 89, 105, 106, 109, 111, 114, 115, 116],
          Le = [1, 176],
          xe = [1, 172],
          ce = [1, 173],
          ye = [1, 177],
          be = [1, 174],
          Ht = [1, 175],
          Nn = [77, 116, 119],
          ne = [8, 9, 10, 11, 12, 14, 27, 29, 32, 44, 60, 75, 84, 85, 86, 87, 88, 89, 90, 105, 109, 111, 114, 115, 116],
          Ri = [10, 106],
          xn = [31, 49, 51, 53, 55, 57, 62, 64, 66, 67, 69, 71, 116, 117, 118],
          Br = [1, 247],
          vr = [1, 245],
          mi = [1, 249],
          Zt = [1, 243],
          nt = [1, 244],
          $t = [1, 246],
          Kt = [1, 248],
          or = [1, 250],
          an = [1, 268],
          hn = [8, 9, 11, 106],
          jr = [8, 9, 10, 11, 60, 84, 105, 106, 109, 110, 111, 112],
          ks = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              graphConfig: 4,
              document: 5,
              line: 6,
              statement: 7,
              SEMI: 8,
              NEWLINE: 9,
              SPACE: 10,
              EOF: 11,
              GRAPH: 12,
              NODIR: 13,
              DIR: 14,
              FirstStmtSeparator: 15,
              ending: 16,
              endToken: 17,
              spaceList: 18,
              spaceListNewline: 19,
              vertexStatement: 20,
              separator: 21,
              styleStatement: 22,
              linkStyleStatement: 23,
              classDefStatement: 24,
              classStatement: 25,
              clickStatement: 26,
              subgraph: 27,
              textNoTags: 28,
              SQS: 29,
              text: 30,
              SQE: 31,
              end: 32,
              direction: 33,
              acc_title: 34,
              acc_title_value: 35,
              acc_descr: 36,
              acc_descr_value: 37,
              acc_descr_multiline_value: 38,
              shapeData: 39,
              SHAPE_DATA: 40,
              link: 41,
              node: 42,
              styledVertex: 43,
              AMP: 44,
              vertex: 45,
              STYLE_SEPARATOR: 46,
              idString: 47,
              DOUBLECIRCLESTART: 48,
              DOUBLECIRCLEEND: 49,
              PS: 50,
              PE: 51,
              '(-': 52,
              '-)': 53,
              STADIUMSTART: 54,
              STADIUMEND: 55,
              SUBROUTINESTART: 56,
              SUBROUTINEEND: 57,
              VERTEX_WITH_PROPS_START: 58,
              'NODE_STRING[field]': 59,
              COLON: 60,
              'NODE_STRING[value]': 61,
              PIPE: 62,
              CYLINDERSTART: 63,
              CYLINDEREND: 64,
              DIAMOND_START: 65,
              DIAMOND_STOP: 66,
              TAGEND: 67,
              TRAPSTART: 68,
              TRAPEND: 69,
              INVTRAPSTART: 70,
              INVTRAPEND: 71,
              linkStatement: 72,
              arrowText: 73,
              TESTSTR: 74,
              START_LINK: 75,
              edgeText: 76,
              LINK: 77,
              LINK_ID: 78,
              edgeTextToken: 79,
              STR: 80,
              MD_STR: 81,
              textToken: 82,
              keywords: 83,
              STYLE: 84,
              LINKSTYLE: 85,
              CLASSDEF: 86,
              CLASS: 87,
              CLICK: 88,
              DOWN: 89,
              UP: 90,
              textNoTagsToken: 91,
              stylesOpt: 92,
              'idString[vertex]': 93,
              'idString[class]': 94,
              CALLBACKNAME: 95,
              CALLBACKARGS: 96,
              HREF: 97,
              LINK_TARGET: 98,
              'STR[link]': 99,
              'STR[tooltip]': 100,
              alphaNum: 101,
              DEFAULT: 102,
              numList: 103,
              INTERPOLATE: 104,
              NUM: 105,
              COMMA: 106,
              style: 107,
              styleComponent: 108,
              NODE_STRING: 109,
              UNIT: 110,
              BRKT: 111,
              PCT: 112,
              idStringToken: 113,
              MINUS: 114,
              MULT: 115,
              UNICODE_TEXT: 116,
              TEXT: 117,
              TAGSTART: 118,
              EDGE_TEXT: 119,
              alphaNumToken: 120,
              direction_tb: 121,
              direction_bt: 122,
              direction_rl: 123,
              direction_lr: 124,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              8: 'SEMI',
              9: 'NEWLINE',
              10: 'SPACE',
              11: 'EOF',
              12: 'GRAPH',
              13: 'NODIR',
              14: 'DIR',
              27: 'subgraph',
              29: 'SQS',
              31: 'SQE',
              32: 'end',
              34: 'acc_title',
              35: 'acc_title_value',
              36: 'acc_descr',
              37: 'acc_descr_value',
              38: 'acc_descr_multiline_value',
              40: 'SHAPE_DATA',
              44: 'AMP',
              46: 'STYLE_SEPARATOR',
              48: 'DOUBLECIRCLESTART',
              49: 'DOUBLECIRCLEEND',
              50: 'PS',
              51: 'PE',
              52: '(-',
              53: '-)',
              54: 'STADIUMSTART',
              55: 'STADIUMEND',
              56: 'SUBROUTINESTART',
              57: 'SUBROUTINEEND',
              58: 'VERTEX_WITH_PROPS_START',
              59: 'NODE_STRING[field]',
              60: 'COLON',
              61: 'NODE_STRING[value]',
              62: 'PIPE',
              63: 'CYLINDERSTART',
              64: 'CYLINDEREND',
              65: 'DIAMOND_START',
              66: 'DIAMOND_STOP',
              67: 'TAGEND',
              68: 'TRAPSTART',
              69: 'TRAPEND',
              70: 'INVTRAPSTART',
              71: 'INVTRAPEND',
              74: 'TESTSTR',
              75: 'START_LINK',
              77: 'LINK',
              78: 'LINK_ID',
              80: 'STR',
              81: 'MD_STR',
              84: 'STYLE',
              85: 'LINKSTYLE',
              86: 'CLASSDEF',
              87: 'CLASS',
              88: 'CLICK',
              89: 'DOWN',
              90: 'UP',
              93: 'idString[vertex]',
              94: 'idString[class]',
              95: 'CALLBACKNAME',
              96: 'CALLBACKARGS',
              97: 'HREF',
              98: 'LINK_TARGET',
              99: 'STR[link]',
              100: 'STR[tooltip]',
              102: 'DEFAULT',
              104: 'INTERPOLATE',
              105: 'NUM',
              106: 'COMMA',
              109: 'NODE_STRING',
              110: 'UNIT',
              111: 'BRKT',
              112: 'PCT',
              114: 'MINUS',
              115: 'MULT',
              116: 'UNICODE_TEXT',
              117: 'TEXT',
              118: 'TAGSTART',
              119: 'EDGE_TEXT',
              121: 'direction_tb',
              122: 'direction_bt',
              123: 'direction_rl',
              124: 'direction_lr',
            },
            productions_: [
              0,
              [3, 2],
              [5, 0],
              [5, 2],
              [6, 1],
              [6, 1],
              [6, 1],
              [6, 1],
              [6, 1],
              [4, 2],
              [4, 2],
              [4, 2],
              [4, 3],
              [16, 2],
              [16, 1],
              [17, 1],
              [17, 1],
              [17, 1],
              [15, 1],
              [15, 1],
              [15, 2],
              [19, 2],
              [19, 2],
              [19, 1],
              [19, 1],
              [18, 2],
              [18, 1],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 9],
              [7, 6],
              [7, 4],
              [7, 1],
              [7, 2],
              [7, 2],
              [7, 1],
              [21, 1],
              [21, 1],
              [21, 1],
              [39, 2],
              [39, 1],
              [20, 4],
              [20, 3],
              [20, 4],
              [20, 2],
              [20, 2],
              [20, 1],
              [42, 1],
              [42, 6],
              [42, 5],
              [43, 1],
              [43, 3],
              [45, 4],
              [45, 4],
              [45, 6],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 8],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 6],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 1],
              [41, 2],
              [41, 3],
              [41, 3],
              [41, 1],
              [41, 3],
              [41, 4],
              [76, 1],
              [76, 2],
              [76, 1],
              [76, 1],
              [72, 1],
              [72, 2],
              [73, 3],
              [30, 1],
              [30, 2],
              [30, 1],
              [30, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [28, 1],
              [28, 2],
              [28, 1],
              [28, 1],
              [24, 5],
              [25, 5],
              [26, 2],
              [26, 4],
              [26, 3],
              [26, 5],
              [26, 3],
              [26, 5],
              [26, 5],
              [26, 7],
              [26, 2],
              [26, 4],
              [26, 2],
              [26, 4],
              [26, 4],
              [26, 6],
              [22, 5],
              [23, 5],
              [23, 5],
              [23, 9],
              [23, 9],
              [23, 7],
              [23, 7],
              [103, 1],
              [103, 3],
              [92, 1],
              [92, 3],
              [107, 1],
              [107, 2],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [82, 1],
              [82, 1],
              [82, 1],
              [82, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [79, 1],
              [79, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [47, 1],
              [47, 2],
              [101, 1],
              [101, 2],
              [33, 1],
              [33, 1],
              [33, 1],
              [33, 1],
            ],
            performAction: a(function (ue, ke, Ne, Wt, Fr, Y, fu) {
              var J = Y.length - 1
              switch (Fr) {
                case 2:
                  this.$ = []
                  break
                case 3:
                  ;(!Array.isArray(Y[J]) || Y[J].length > 0) && Y[J - 1].push(Y[J]), (this.$ = Y[J - 1])
                  break
                case 4:
                case 183:
                  this.$ = Y[J]
                  break
                case 11:
                  Wt.setDirection('TB'), (this.$ = 'TB')
                  break
                case 12:
                  Wt.setDirection(Y[J - 1]), (this.$ = Y[J - 1])
                  break
                case 27:
                  this.$ = Y[J - 1].nodes
                  break
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                  this.$ = []
                  break
                case 33:
                  this.$ = Wt.addSubGraph(Y[J - 6], Y[J - 1], Y[J - 4])
                  break
                case 34:
                  this.$ = Wt.addSubGraph(Y[J - 3], Y[J - 1], Y[J - 3])
                  break
                case 35:
                  this.$ = Wt.addSubGraph(void 0, Y[J - 1], void 0)
                  break
                case 37:
                  ;(this.$ = Y[J].trim()), Wt.setAccTitle(this.$)
                  break
                case 38:
                case 39:
                  ;(this.$ = Y[J].trim()), Wt.setAccDescription(this.$)
                  break
                case 43:
                  this.$ = Y[J - 1] + Y[J]
                  break
                case 44:
                  this.$ = Y[J]
                  break
                case 45:
                  Wt.addVertex(Y[J - 1][Y[J - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, Y[J]),
                    Wt.addLink(Y[J - 3].stmt, Y[J - 1], Y[J - 2]),
                    (this.$ = { stmt: Y[J - 1], nodes: Y[J - 1].concat(Y[J - 3].nodes) })
                  break
                case 46:
                  Wt.addLink(Y[J - 2].stmt, Y[J], Y[J - 1]),
                    (this.$ = { stmt: Y[J], nodes: Y[J].concat(Y[J - 2].nodes) })
                  break
                case 47:
                  Wt.addLink(Y[J - 3].stmt, Y[J - 1], Y[J - 2]),
                    (this.$ = { stmt: Y[J - 1], nodes: Y[J - 1].concat(Y[J - 3].nodes) })
                  break
                case 48:
                  this.$ = { stmt: Y[J - 1], nodes: Y[J - 1] }
                  break
                case 49:
                  Wt.addVertex(Y[J - 1][Y[J - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, Y[J]),
                    (this.$ = { stmt: Y[J - 1], nodes: Y[J - 1], shapeData: Y[J] })
                  break
                case 50:
                  this.$ = { stmt: Y[J], nodes: Y[J] }
                  break
                case 51:
                  this.$ = [Y[J]]
                  break
                case 52:
                  Wt.addVertex(Y[J - 5][Y[J - 5].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, Y[J - 4]),
                    (this.$ = Y[J - 5].concat(Y[J]))
                  break
                case 53:
                  this.$ = Y[J - 4].concat(Y[J])
                  break
                case 54:
                  this.$ = Y[J]
                  break
                case 55:
                  ;(this.$ = Y[J - 2]), Wt.setClass(Y[J - 2], Y[J])
                  break
                case 56:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'square')
                  break
                case 57:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'doublecircle')
                  break
                case 58:
                  ;(this.$ = Y[J - 5]), Wt.addVertex(Y[J - 5], Y[J - 2], 'circle')
                  break
                case 59:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'ellipse')
                  break
                case 60:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'stadium')
                  break
                case 61:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'subroutine')
                  break
                case 62:
                  ;(this.$ = Y[J - 7]),
                    Wt.addVertex(
                      Y[J - 7],
                      Y[J - 1],
                      'rect',
                      void 0,
                      void 0,
                      void 0,
                      Object.fromEntries([[Y[J - 5], Y[J - 3]]]),
                    )
                  break
                case 63:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'cylinder')
                  break
                case 64:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'round')
                  break
                case 65:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'diamond')
                  break
                case 66:
                  ;(this.$ = Y[J - 5]), Wt.addVertex(Y[J - 5], Y[J - 2], 'hexagon')
                  break
                case 67:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'odd')
                  break
                case 68:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'trapezoid')
                  break
                case 69:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'inv_trapezoid')
                  break
                case 70:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'lean_right')
                  break
                case 71:
                  ;(this.$ = Y[J - 3]), Wt.addVertex(Y[J - 3], Y[J - 1], 'lean_left')
                  break
                case 72:
                  ;(this.$ = Y[J]), Wt.addVertex(Y[J])
                  break
                case 73:
                  ;(Y[J - 1].text = Y[J]), (this.$ = Y[J - 1])
                  break
                case 74:
                case 75:
                  ;(Y[J - 2].text = Y[J - 1]), (this.$ = Y[J - 2])
                  break
                case 76:
                  this.$ = Y[J]
                  break
                case 77:
                  var wn = Wt.destructLink(Y[J], Y[J - 2])
                  this.$ = { type: wn.type, stroke: wn.stroke, length: wn.length, text: Y[J - 1] }
                  break
                case 78:
                  var wn = Wt.destructLink(Y[J], Y[J - 2])
                  this.$ = { type: wn.type, stroke: wn.stroke, length: wn.length, text: Y[J - 1], id: Y[J - 3] }
                  break
                case 79:
                  this.$ = { text: Y[J], type: 'text' }
                  break
                case 80:
                  this.$ = { text: Y[J - 1].text + '' + Y[J], type: Y[J - 1].type }
                  break
                case 81:
                  this.$ = { text: Y[J], type: 'string' }
                  break
                case 82:
                  this.$ = { text: Y[J], type: 'markdown' }
                  break
                case 83:
                  var wn = Wt.destructLink(Y[J])
                  this.$ = { type: wn.type, stroke: wn.stroke, length: wn.length }
                  break
                case 84:
                  var wn = Wt.destructLink(Y[J])
                  this.$ = { type: wn.type, stroke: wn.stroke, length: wn.length, id: Y[J - 1] }
                  break
                case 85:
                  this.$ = Y[J - 1]
                  break
                case 86:
                  this.$ = { text: Y[J], type: 'text' }
                  break
                case 87:
                  this.$ = { text: Y[J - 1].text + '' + Y[J], type: Y[J - 1].type }
                  break
                case 88:
                  this.$ = { text: Y[J], type: 'string' }
                  break
                case 89:
                case 104:
                  this.$ = { text: Y[J], type: 'markdown' }
                  break
                case 101:
                  this.$ = { text: Y[J], type: 'text' }
                  break
                case 102:
                  this.$ = { text: Y[J - 1].text + '' + Y[J], type: Y[J - 1].type }
                  break
                case 103:
                  this.$ = { text: Y[J], type: 'text' }
                  break
                case 105:
                  ;(this.$ = Y[J - 4]), Wt.addClass(Y[J - 2], Y[J])
                  break
                case 106:
                  ;(this.$ = Y[J - 4]), Wt.setClass(Y[J - 2], Y[J])
                  break
                case 107:
                case 115:
                  ;(this.$ = Y[J - 1]), Wt.setClickEvent(Y[J - 1], Y[J])
                  break
                case 108:
                case 116:
                  ;(this.$ = Y[J - 3]), Wt.setClickEvent(Y[J - 3], Y[J - 2]), Wt.setTooltip(Y[J - 3], Y[J])
                  break
                case 109:
                  ;(this.$ = Y[J - 2]), Wt.setClickEvent(Y[J - 2], Y[J - 1], Y[J])
                  break
                case 110:
                  ;(this.$ = Y[J - 4]), Wt.setClickEvent(Y[J - 4], Y[J - 3], Y[J - 2]), Wt.setTooltip(Y[J - 4], Y[J])
                  break
                case 111:
                  ;(this.$ = Y[J - 2]), Wt.setLink(Y[J - 2], Y[J])
                  break
                case 112:
                  ;(this.$ = Y[J - 4]), Wt.setLink(Y[J - 4], Y[J - 2]), Wt.setTooltip(Y[J - 4], Y[J])
                  break
                case 113:
                  ;(this.$ = Y[J - 4]), Wt.setLink(Y[J - 4], Y[J - 2], Y[J])
                  break
                case 114:
                  ;(this.$ = Y[J - 6]), Wt.setLink(Y[J - 6], Y[J - 4], Y[J]), Wt.setTooltip(Y[J - 6], Y[J - 2])
                  break
                case 117:
                  ;(this.$ = Y[J - 1]), Wt.setLink(Y[J - 1], Y[J])
                  break
                case 118:
                  ;(this.$ = Y[J - 3]), Wt.setLink(Y[J - 3], Y[J - 2]), Wt.setTooltip(Y[J - 3], Y[J])
                  break
                case 119:
                  ;(this.$ = Y[J - 3]), Wt.setLink(Y[J - 3], Y[J - 2], Y[J])
                  break
                case 120:
                  ;(this.$ = Y[J - 5]), Wt.setLink(Y[J - 5], Y[J - 4], Y[J]), Wt.setTooltip(Y[J - 5], Y[J - 2])
                  break
                case 121:
                  ;(this.$ = Y[J - 4]), Wt.addVertex(Y[J - 2], void 0, void 0, Y[J])
                  break
                case 122:
                  ;(this.$ = Y[J - 4]), Wt.updateLink([Y[J - 2]], Y[J])
                  break
                case 123:
                  ;(this.$ = Y[J - 4]), Wt.updateLink(Y[J - 2], Y[J])
                  break
                case 124:
                  ;(this.$ = Y[J - 8]), Wt.updateLinkInterpolate([Y[J - 6]], Y[J - 2]), Wt.updateLink([Y[J - 6]], Y[J])
                  break
                case 125:
                  ;(this.$ = Y[J - 8]), Wt.updateLinkInterpolate(Y[J - 6], Y[J - 2]), Wt.updateLink(Y[J - 6], Y[J])
                  break
                case 126:
                  ;(this.$ = Y[J - 6]), Wt.updateLinkInterpolate([Y[J - 4]], Y[J])
                  break
                case 127:
                  ;(this.$ = Y[J - 6]), Wt.updateLinkInterpolate(Y[J - 4], Y[J])
                  break
                case 128:
                case 130:
                  this.$ = [Y[J]]
                  break
                case 129:
                case 131:
                  Y[J - 2].push(Y[J]), (this.$ = Y[J - 2])
                  break
                case 133:
                  this.$ = Y[J - 1] + Y[J]
                  break
                case 181:
                  this.$ = Y[J]
                  break
                case 182:
                  this.$ = Y[J - 1] + '' + Y[J]
                  break
                case 184:
                  this.$ = Y[J - 1] + '' + Y[J]
                  break
                case 185:
                  this.$ = { stmt: 'dir', value: 'TB' }
                  break
                case 186:
                  this.$ = { stmt: 'dir', value: 'BT' }
                  break
                case 187:
                  this.$ = { stmt: 'dir', value: 'RL' }
                  break
                case 188:
                  this.$ = { stmt: 'dir', value: 'LR' }
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: 2, 9: t, 10: r, 12: n },
              { 1: [3] },
              e(i, s, { 5: 6 }),
              { 4: 7, 9: t, 10: r, 12: n },
              { 4: 8, 9: t, 10: r, 12: n },
              { 13: [1, 9], 14: [1, 10] },
              {
                1: [2, 1],
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: A,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
                121: _,
                122: L,
                123: N,
                124: P,
              },
              e(i, [2, 9]),
              e(i, [2, 10]),
              e(i, [2, 11]),
              { 8: [1, 54], 9: [1, 55], 10: I, 15: 53, 18: 56 },
              e(M, [2, 3]),
              e(M, [2, 4]),
              e(M, [2, 5]),
              e(M, [2, 6]),
              e(M, [2, 7]),
              e(M, [2, 8]),
              { 8: V, 9: $, 11: q, 21: 58, 41: 59, 72: 63, 75: [1, 64], 77: [1, 66], 78: [1, 65] },
              { 8: V, 9: $, 11: q, 21: 67 },
              { 8: V, 9: $, 11: q, 21: 68 },
              { 8: V, 9: $, 11: q, 21: 69 },
              { 8: V, 9: $, 11: q, 21: 70 },
              { 8: V, 9: $, 11: q, 21: 71 },
              { 8: V, 9: $, 10: [1, 72], 11: q, 21: 73 },
              e(M, [2, 36]),
              { 35: [1, 74] },
              { 37: [1, 75] },
              e(M, [2, 39]),
              e(tt, [2, 50], { 18: 76, 39: 77, 10: I, 40: ft }),
              { 10: [1, 79] },
              { 10: [1, 80] },
              { 10: [1, 81] },
              { 10: [1, 82] },
              {
                14: H,
                44: kt,
                60: ht,
                80: [1, 86],
                89: yt,
                95: [1, 83],
                97: [1, 84],
                101: 85,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              e(M, [2, 185]),
              e(M, [2, 186]),
              e(M, [2, 187]),
              e(M, [2, 188]),
              e(U, [2, 51]),
              e(U, [2, 54], { 46: [1, 99] }),
              e(gt, [2, 72], {
                113: 112,
                29: [1, 100],
                44: g,
                48: [1, 101],
                50: [1, 102],
                52: [1, 103],
                54: [1, 104],
                56: [1, 105],
                58: [1, 106],
                60: y,
                63: [1, 107],
                65: [1, 108],
                67: [1, 109],
                68: [1, 110],
                70: [1, 111],
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                114: S,
                115: O,
                116: E,
              }),
              e(z, [2, 181]),
              e(z, [2, 142]),
              e(z, [2, 143]),
              e(z, [2, 144]),
              e(z, [2, 145]),
              e(z, [2, 146]),
              e(z, [2, 147]),
              e(z, [2, 148]),
              e(z, [2, 149]),
              e(z, [2, 150]),
              e(z, [2, 151]),
              e(z, [2, 152]),
              e(i, [2, 12]),
              e(i, [2, 18]),
              e(i, [2, 19]),
              { 9: [1, 113] },
              e(ge, [2, 26], { 18: 114, 10: I }),
              e(M, [2, 27]),
              {
                42: 115,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
              },
              e(M, [2, 40]),
              e(M, [2, 41]),
              e(M, [2, 42]),
              e(lt, [2, 76], { 73: 116, 62: [1, 118], 74: [1, 117] }),
              { 76: 119, 79: 120, 80: jt, 81: Me, 116: se, 119: Nt },
              { 75: [1, 125], 77: [1, 126] },
              e(At, [2, 83]),
              e(M, [2, 28]),
              e(M, [2, 29]),
              e(M, [2, 30]),
              e(M, [2, 31]),
              e(M, [2, 32]),
              {
                10: bt,
                12: ct,
                14: Lt,
                27: Z,
                28: 127,
                32: Mt,
                44: W,
                60: Gt,
                75: j,
                80: [1, 129],
                81: [1, 130],
                83: 140,
                84: vt,
                85: mt,
                86: Xt,
                87: Ft,
                88: _t,
                89: Qe,
                90: It,
                91: 128,
                105: xr,
                109: Ze,
                111: yn,
                114: Ae,
                115: Se,
                116: Je,
              },
              e(_e, s, { 5: 153 }),
              e(M, [2, 37]),
              e(M, [2, 38]),
              e(tt, [2, 48], { 44: hr }),
              e(tt, [2, 49], { 18: 155, 10: I, 40: Cn }),
              e(U, [2, 44]),
              { 44: g, 47: 157, 60: y, 89: w, 102: D, 105: G, 106: v, 109: R, 111: F, 113: 41, 114: S, 115: O, 116: E },
              { 102: [1, 158], 103: 159, 105: [1, 160] },
              { 44: g, 47: 161, 60: y, 89: w, 102: D, 105: G, 106: v, 109: R, 111: F, 113: 41, 114: S, 115: O, 116: E },
              { 44: g, 47: 162, 60: y, 89: w, 102: D, 105: G, 106: v, 109: R, 111: F, 113: 41, 114: S, 115: O, 116: E },
              e(ve, [2, 107], { 10: [1, 163], 96: [1, 164] }),
              { 80: [1, 165] },
              e(ve, [2, 115], {
                120: 167,
                10: [1, 166],
                14: H,
                44: kt,
                60: ht,
                89: yt,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(ve, [2, 117], { 10: [1, 168] }),
              e($e, [2, 183]),
              e($e, [2, 170]),
              e($e, [2, 171]),
              e($e, [2, 172]),
              e($e, [2, 173]),
              e($e, [2, 174]),
              e($e, [2, 175]),
              e($e, [2, 176]),
              e($e, [2, 177]),
              e($e, [2, 178]),
              e($e, [2, 179]),
              e($e, [2, 180]),
              { 44: g, 47: 169, 60: y, 89: w, 102: D, 105: G, 106: v, 109: R, 111: F, 113: 41, 114: S, 115: O, 116: E },
              { 30: 170, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 178, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 180, 50: [1, 179], 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 181, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 182, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 183, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 109: [1, 184] },
              { 30: 185, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 186, 65: [1, 187], 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 188, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 189, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 30: 190, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              e(z, [2, 182]),
              e(i, [2, 20]),
              e(ge, [2, 25]),
              e(tt, [2, 46], { 39: 191, 18: 192, 10: I, 40: ft }),
              e(lt, [2, 73], { 10: [1, 193] }),
              { 10: [1, 194] },
              { 30: 195, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 77: [1, 196], 79: 197, 116: se, 119: Nt },
              e(Nn, [2, 79]),
              e(Nn, [2, 81]),
              e(Nn, [2, 82]),
              e(Nn, [2, 168]),
              e(Nn, [2, 169]),
              { 76: 198, 79: 120, 80: jt, 81: Me, 116: se, 119: Nt },
              e(At, [2, 84]),
              {
                8: V,
                9: $,
                10: bt,
                11: q,
                12: ct,
                14: Lt,
                21: 200,
                27: Z,
                29: [1, 199],
                32: Mt,
                44: W,
                60: Gt,
                75: j,
                83: 140,
                84: vt,
                85: mt,
                86: Xt,
                87: Ft,
                88: _t,
                89: Qe,
                90: It,
                91: 201,
                105: xr,
                109: Ze,
                111: yn,
                114: Ae,
                115: Se,
                116: Je,
              },
              e(ne, [2, 101]),
              e(ne, [2, 103]),
              e(ne, [2, 104]),
              e(ne, [2, 157]),
              e(ne, [2, 158]),
              e(ne, [2, 159]),
              e(ne, [2, 160]),
              e(ne, [2, 161]),
              e(ne, [2, 162]),
              e(ne, [2, 163]),
              e(ne, [2, 164]),
              e(ne, [2, 165]),
              e(ne, [2, 166]),
              e(ne, [2, 167]),
              e(ne, [2, 90]),
              e(ne, [2, 91]),
              e(ne, [2, 92]),
              e(ne, [2, 93]),
              e(ne, [2, 94]),
              e(ne, [2, 95]),
              e(ne, [2, 96]),
              e(ne, [2, 97]),
              e(ne, [2, 98]),
              e(ne, [2, 99]),
              e(ne, [2, 100]),
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 202],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: A,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
                121: _,
                122: L,
                123: N,
                124: P,
              },
              { 10: I, 18: 203 },
              { 44: [1, 204] },
              e(U, [2, 43]),
              {
                10: [1, 205],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: E,
              },
              { 10: [1, 206] },
              { 10: [1, 207], 106: [1, 208] },
              e(Ri, [2, 128]),
              {
                10: [1, 209],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: E,
              },
              {
                10: [1, 210],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: E,
              },
              { 80: [1, 211] },
              e(ve, [2, 109], { 10: [1, 212] }),
              e(ve, [2, 111], { 10: [1, 213] }),
              { 80: [1, 214] },
              e($e, [2, 184]),
              { 80: [1, 215], 98: [1, 216] },
              e(U, [2, 55], {
                113: 112,
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                114: S,
                115: O,
                116: E,
              }),
              { 31: [1, 217], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(xn, [2, 86]),
              e(xn, [2, 88]),
              e(xn, [2, 89]),
              e(xn, [2, 153]),
              e(xn, [2, 154]),
              e(xn, [2, 155]),
              e(xn, [2, 156]),
              { 49: [1, 219], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 30: 220, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 51: [1, 221], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 53: [1, 222], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 55: [1, 223], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 57: [1, 224], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 60: [1, 225] },
              { 64: [1, 226], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 66: [1, 227], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 30: 228, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              { 31: [1, 229], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 67: Le, 69: [1, 230], 71: [1, 231], 82: 218, 116: ye, 117: be, 118: Ht },
              { 67: Le, 69: [1, 233], 71: [1, 232], 82: 218, 116: ye, 117: be, 118: Ht },
              e(tt, [2, 45], { 18: 155, 10: I, 40: Cn }),
              e(tt, [2, 47], { 44: hr }),
              e(lt, [2, 75]),
              e(lt, [2, 74]),
              { 62: [1, 234], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(lt, [2, 77]),
              e(Nn, [2, 80]),
              { 77: [1, 235], 79: 197, 116: se, 119: Nt },
              { 30: 236, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              e(_e, s, { 5: 237 }),
              e(ne, [2, 102]),
              e(M, [2, 35]),
              {
                43: 238,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
              },
              { 10: I, 18: 239 },
              { 10: Br, 60: vr, 84: mi, 92: 240, 105: Zt, 107: 241, 108: 242, 109: nt, 110: $t, 111: Kt, 112: or },
              {
                10: Br,
                60: vr,
                84: mi,
                92: 251,
                104: [1, 252],
                105: Zt,
                107: 241,
                108: 242,
                109: nt,
                110: $t,
                111: Kt,
                112: or,
              },
              {
                10: Br,
                60: vr,
                84: mi,
                92: 253,
                104: [1, 254],
                105: Zt,
                107: 241,
                108: 242,
                109: nt,
                110: $t,
                111: Kt,
                112: or,
              },
              { 105: [1, 255] },
              { 10: Br, 60: vr, 84: mi, 92: 256, 105: Zt, 107: 241, 108: 242, 109: nt, 110: $t, 111: Kt, 112: or },
              { 44: g, 47: 257, 60: y, 89: w, 102: D, 105: G, 106: v, 109: R, 111: F, 113: 41, 114: S, 115: O, 116: E },
              e(ve, [2, 108]),
              { 80: [1, 258] },
              { 80: [1, 259], 98: [1, 260] },
              e(ve, [2, 116]),
              e(ve, [2, 118], { 10: [1, 261] }),
              e(ve, [2, 119]),
              e(gt, [2, 56]),
              e(xn, [2, 87]),
              e(gt, [2, 57]),
              { 51: [1, 262], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(gt, [2, 64]),
              e(gt, [2, 59]),
              e(gt, [2, 60]),
              e(gt, [2, 61]),
              { 109: [1, 263] },
              e(gt, [2, 63]),
              e(gt, [2, 65]),
              { 66: [1, 264], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(gt, [2, 67]),
              e(gt, [2, 68]),
              e(gt, [2, 70]),
              e(gt, [2, 69]),
              e(gt, [2, 71]),
              e([10, 44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], [2, 85]),
              e(lt, [2, 78]),
              { 31: [1, 265], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 266],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: A,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
                121: _,
                122: L,
                123: N,
                124: P,
              },
              e(U, [2, 53]),
              {
                43: 267,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
              },
              e(ve, [2, 121], { 106: an }),
              e(hn, [2, 130], { 108: 269, 10: Br, 60: vr, 84: mi, 105: Zt, 109: nt, 110: $t, 111: Kt, 112: or }),
              e(jr, [2, 132]),
              e(jr, [2, 134]),
              e(jr, [2, 135]),
              e(jr, [2, 136]),
              e(jr, [2, 137]),
              e(jr, [2, 138]),
              e(jr, [2, 139]),
              e(jr, [2, 140]),
              e(jr, [2, 141]),
              e(ve, [2, 122], { 106: an }),
              { 10: [1, 270] },
              e(ve, [2, 123], { 106: an }),
              { 10: [1, 271] },
              e(Ri, [2, 129]),
              e(ve, [2, 105], { 106: an }),
              e(ve, [2, 106], {
                113: 112,
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                114: S,
                115: O,
                116: E,
              }),
              e(ve, [2, 110]),
              e(ve, [2, 112], { 10: [1, 272] }),
              e(ve, [2, 113]),
              { 98: [1, 273] },
              { 51: [1, 274] },
              { 62: [1, 275] },
              { 66: [1, 276] },
              { 8: V, 9: $, 11: q, 21: 277 },
              e(M, [2, 34]),
              e(U, [2, 52]),
              { 10: Br, 60: vr, 84: mi, 105: Zt, 107: 278, 108: 242, 109: nt, 110: $t, 111: Kt, 112: or },
              e(jr, [2, 133]),
              {
                14: H,
                44: kt,
                60: ht,
                89: yt,
                101: 279,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              {
                14: H,
                44: kt,
                60: ht,
                89: yt,
                101: 280,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              { 98: [1, 281] },
              e(ve, [2, 120]),
              e(gt, [2, 58]),
              { 30: 282, 67: Le, 80: xe, 81: ce, 82: 171, 116: ye, 117: be, 118: Ht },
              e(gt, [2, 66]),
              e(_e, s, { 5: 283 }),
              e(hn, [2, 131], { 108: 269, 10: Br, 60: vr, 84: mi, 105: Zt, 109: nt, 110: $t, 111: Kt, 112: or }),
              e(ve, [2, 126], {
                120: 167,
                10: [1, 284],
                14: H,
                44: kt,
                60: ht,
                89: yt,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(ve, [2, 127], {
                120: 167,
                10: [1, 285],
                14: H,
                44: kt,
                60: ht,
                89: yt,
                105: ot,
                106: dt,
                109: it,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(ve, [2, 114]),
              { 31: [1, 286], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 287],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: A,
                89: w,
                102: D,
                105: G,
                106: v,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: E,
                121: _,
                122: L,
                123: N,
                124: P,
              },
              { 10: Br, 60: vr, 84: mi, 92: 288, 105: Zt, 107: 241, 108: 242, 109: nt, 110: $t, 111: Kt, 112: or },
              { 10: Br, 60: vr, 84: mi, 92: 289, 105: Zt, 107: 241, 108: 242, 109: nt, 110: $t, 111: Kt, 112: or },
              e(gt, [2, 62]),
              e(M, [2, 33]),
              e(ve, [2, 124], { 106: an }),
              e(ve, [2, 125], { 106: an }),
            ],
            defaultActions: {},
            parseError: a(function (ue, ke) {
              if (ke.recoverable) this.trace(ue)
              else {
                var Ne = new Error(ue)
                throw ((Ne.hash = ke), Ne)
              }
            }, 'parseError'),
            parse: a(function (ue) {
              var ke = this,
                Ne = [0],
                Wt = [],
                Fr = [null],
                Y = [],
                fu = this.table,
                J = '',
                wn = 0,
                G8 = 0,
                V8 = 0,
                Ult = 2,
                z8 = 1,
                jlt = Y.slice.call(arguments, 1),
                Vn = Object.create(this.lexer),
                du = { yy: {} }
              for (var wC in this.yy) Object.prototype.hasOwnProperty.call(this.yy, wC) && (du.yy[wC] = this.yy[wC])
              Vn.setInput(ue, du.yy),
                (du.yy.lexer = Vn),
                (du.yy.parser = this),
                typeof Vn.yylloc > 'u' && (Vn.yylloc = {})
              var EC = Vn.yylloc
              Y.push(EC)
              var qlt = Vn.options && Vn.options.ranges
              typeof du.yy.parseError == 'function'
                ? (this.parseError = du.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function VMt(Ts) {
                ;(Ne.length = Ne.length - 2 * Ts), (Fr.length = Fr.length - Ts), (Y.length = Y.length - Ts)
              }
              a(VMt, 'popStack')
              function Hlt() {
                var Ts
                return (
                  (Ts = Wt.pop() || Vn.lex() || z8),
                  typeof Ts != 'number' &&
                    (Ts instanceof Array && ((Wt = Ts), (Ts = Wt.pop())), (Ts = ke.symbols_[Ts] || Ts)),
                  Ts
                )
              }
              a(Hlt, 'lex')
              for (var Di, vC, pu, Ws, zMt, AC, sf = {}, rx, Xo, W8, nx; ; ) {
                if (
                  ((pu = Ne[Ne.length - 1]),
                  this.defaultActions[pu]
                    ? (Ws = this.defaultActions[pu])
                    : ((Di === null || typeof Di > 'u') && (Di = Hlt()), (Ws = fu[pu] && fu[pu][Di])),
                  typeof Ws > 'u' || !Ws.length || !Ws[0])
                ) {
                  var LC = ''
                  nx = []
                  for (rx in fu[pu]) this.terminals_[rx] && rx > Ult && nx.push("'" + this.terminals_[rx] + "'")
                  Vn.showPosition
                    ? (LC =
                        'Parse error on line ' +
                        (wn + 1) +
                        `:
` +
                        Vn.showPosition() +
                        `
Expecting ` +
                        nx.join(', ') +
                        ", got '" +
                        (this.terminals_[Di] || Di) +
                        "'")
                    : (LC =
                        'Parse error on line ' +
                        (wn + 1) +
                        ': Unexpected ' +
                        (Di == z8 ? 'end of input' : "'" + (this.terminals_[Di] || Di) + "'")),
                    this.parseError(LC, {
                      text: Vn.match,
                      token: this.terminals_[Di] || Di,
                      line: Vn.yylineno,
                      loc: EC,
                      expected: nx,
                    })
                }
                if (Ws[0] instanceof Array && Ws.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + pu + ', token: ' + Di)
                switch (Ws[0]) {
                  case 1:
                    Ne.push(Di),
                      Fr.push(Vn.yytext),
                      Y.push(Vn.yylloc),
                      Ne.push(Ws[1]),
                      (Di = null),
                      vC
                        ? ((Di = vC), (vC = null))
                        : ((G8 = Vn.yyleng), (J = Vn.yytext), (wn = Vn.yylineno), (EC = Vn.yylloc), V8 > 0 && V8--)
                    break
                  case 2:
                    if (
                      ((Xo = this.productions_[Ws[1]][1]),
                      (sf.$ = Fr[Fr.length - Xo]),
                      (sf._$ = {
                        first_line: Y[Y.length - (Xo || 1)].first_line,
                        last_line: Y[Y.length - 1].last_line,
                        first_column: Y[Y.length - (Xo || 1)].first_column,
                        last_column: Y[Y.length - 1].last_column,
                      }),
                      qlt && (sf._$.range = [Y[Y.length - (Xo || 1)].range[0], Y[Y.length - 1].range[1]]),
                      (AC = this.performAction.apply(sf, [J, G8, wn, du.yy, Ws[1], Fr, Y].concat(jlt))),
                      typeof AC < 'u')
                    )
                      return AC
                    Xo && ((Ne = Ne.slice(0, -1 * Xo * 2)), (Fr = Fr.slice(0, -1 * Xo)), (Y = Y.slice(0, -1 * Xo))),
                      Ne.push(this.productions_[Ws[1]][0]),
                      Fr.push(sf.$),
                      Y.push(sf._$),
                      (W8 = fu[Ne[Ne.length - 2]][Ne[Ne.length - 1]]),
                      Ne.push(W8)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          uu = (function () {
            var qr = {
              EOF: 1,
              parseError: a(function (ke, Ne) {
                if (this.yy.parser) this.yy.parser.parseError(ke, Ne)
                else throw new Error(ke)
              }, 'parseError'),
              setInput: a(function (ue, ke) {
                return (
                  (this.yy = ke || this.yy || {}),
                  (this._input = ue),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var ue = this._input[0]
                ;(this.yytext += ue), this.yyleng++, this.offset++, (this.match += ue), (this.matched += ue)
                var ke = ue.match(/(?:\r\n?|\n).*/g)
                return (
                  ke ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  ue
                )
              }, 'input'),
              unput: a(function (ue) {
                var ke = ue.length,
                  Ne = ue.split(/(?:\r\n?|\n)/g)
                ;(this._input = ue + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - ke)),
                  (this.offset -= ke)
                var Wt = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  Ne.length - 1 && (this.yylineno -= Ne.length - 1)
                var Fr = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Ne
                      ? (Ne.length === Wt.length ? this.yylloc.first_column : 0) +
                        Wt[Wt.length - Ne.length].length -
                        Ne[0].length
                      : this.yylloc.first_column - ke,
                  }),
                  this.options.ranges && (this.yylloc.range = [Fr[0], Fr[0] + this.yyleng - ke]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (ue) {
                this.unput(this.match.slice(ue))
              }, 'less'),
              pastInput: a(function () {
                var ue = this.matched.substr(0, this.matched.length - this.match.length)
                return (ue.length > 20 ? '...' : '') + ue.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var ue = this.match
                return (
                  ue.length < 20 && (ue += this._input.substr(0, 20 - ue.length)),
                  (ue.substr(0, 20) + (ue.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var ue = this.pastInput(),
                  ke = new Array(ue.length + 1).join('-')
                return (
                  ue +
                  this.upcomingInput() +
                  `
` +
                  ke +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (ue, ke) {
                var Ne, Wt, Fr
                if (
                  (this.options.backtrack_lexer &&
                    ((Fr = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (Fr.yylloc.range = this.yylloc.range.slice(0))),
                  (Wt = ue[0].match(/(?:\r\n?|\n).*/g)),
                  Wt && (this.yylineno += Wt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Wt
                      ? Wt[Wt.length - 1].length - Wt[Wt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + ue[0].length,
                  }),
                  (this.yytext += ue[0]),
                  (this.match += ue[0]),
                  (this.matches = ue),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(ue[0].length)),
                  (this.matched += ue[0]),
                  (Ne = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    ke,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Ne)
                )
                  return Ne
                if (this._backtrack) {
                  for (var Y in Fr) this[Y] = Fr[Y]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var ue, ke, Ne, Wt
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var Fr = this._currentRules(), Y = 0; Y < Fr.length; Y++)
                  if (((Ne = this._input.match(this.rules[Fr[Y]])), Ne && (!ke || Ne[0].length > ke[0].length))) {
                    if (((ke = Ne), (Wt = Y), this.options.backtrack_lexer)) {
                      if (((ue = this.test_match(Ne, Fr[Y])), ue !== !1)) return ue
                      if (this._backtrack) {
                        ke = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return ke
                  ? ((ue = this.test_match(ke, Fr[Wt])), ue !== !1 ? ue : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var ke = this.next()
                return ke || this.lex()
              }, 'lex'),
              begin: a(function (ke) {
                this.conditionStack.push(ke)
              }, 'begin'),
              popState: a(function () {
                var ke = this.conditionStack.length - 1
                return ke > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (ke) {
                return (
                  (ke = this.conditionStack.length - 1 - Math.abs(ke || 0)),
                  ke >= 0 ? this.conditionStack[ke] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (ke) {
                this.begin(ke)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: {},
              performAction: a(function (ke, Ne, Wt, Fr) {
                var Y = Fr
                switch (Wt) {
                  case 0:
                    return this.begin('acc_title'), 34
                    break
                  case 1:
                    return this.popState(), 'acc_title_value'
                    break
                  case 2:
                    return this.begin('acc_descr'), 36
                    break
                  case 3:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 4:
                    this.begin('acc_descr_multiline')
                    break
                  case 5:
                    this.popState()
                    break
                  case 6:
                    return 'acc_descr_multiline_value'
                  case 7:
                    return this.pushState('shapeData'), (Ne.yytext = ''), 40
                    break
                  case 8:
                    return this.pushState('shapeDataStr'), 40
                    break
                  case 9:
                    return this.popState(), 40
                    break
                  case 10:
                    let fu = /\n\s*/g
                    return (Ne.yytext = Ne.yytext.replace(fu, '<br/>')), 40
                    break
                  case 11:
                    return 40
                  case 12:
                    this.popState()
                    break
                  case 13:
                    this.begin('callbackname')
                    break
                  case 14:
                    this.popState()
                    break
                  case 15:
                    this.popState(), this.begin('callbackargs')
                    break
                  case 16:
                    return 95
                  case 17:
                    this.popState()
                    break
                  case 18:
                    return 96
                  case 19:
                    return 'MD_STR'
                  case 20:
                    this.popState()
                    break
                  case 21:
                    this.begin('md_string')
                    break
                  case 22:
                    return 'STR'
                  case 23:
                    this.popState()
                    break
                  case 24:
                    this.pushState('string')
                    break
                  case 25:
                    return 84
                  case 26:
                    return 102
                  case 27:
                    return 85
                  case 28:
                    return 104
                  case 29:
                    return 86
                  case 30:
                    return 87
                  case 31:
                    return 97
                  case 32:
                    this.begin('click')
                    break
                  case 33:
                    this.popState()
                    break
                  case 34:
                    return 88
                  case 35:
                    return ke.lex.firstGraph() && this.begin('dir'), 12
                    break
                  case 36:
                    return ke.lex.firstGraph() && this.begin('dir'), 12
                    break
                  case 37:
                    return ke.lex.firstGraph() && this.begin('dir'), 12
                    break
                  case 38:
                    return 27
                  case 39:
                    return 32
                  case 40:
                    return 98
                  case 41:
                    return 98
                  case 42:
                    return 98
                  case 43:
                    return 98
                  case 44:
                    return this.popState(), 13
                    break
                  case 45:
                    return this.popState(), 14
                    break
                  case 46:
                    return this.popState(), 14
                    break
                  case 47:
                    return this.popState(), 14
                    break
                  case 48:
                    return this.popState(), 14
                    break
                  case 49:
                    return this.popState(), 14
                    break
                  case 50:
                    return this.popState(), 14
                    break
                  case 51:
                    return this.popState(), 14
                    break
                  case 52:
                    return this.popState(), 14
                    break
                  case 53:
                    return this.popState(), 14
                    break
                  case 54:
                    return this.popState(), 14
                    break
                  case 55:
                    return 121
                  case 56:
                    return 122
                  case 57:
                    return 123
                  case 58:
                    return 124
                  case 59:
                    return 78
                  case 60:
                    return 105
                  case 61:
                    return 111
                  case 62:
                    return 46
                  case 63:
                    return 60
                  case 64:
                    return 44
                  case 65:
                    return 8
                  case 66:
                    return 106
                  case 67:
                    return 115
                  case 68:
                    return this.popState(), 77
                    break
                  case 69:
                    return this.pushState('edgeText'), 75
                    break
                  case 70:
                    return 119
                  case 71:
                    return this.popState(), 77
                    break
                  case 72:
                    return this.pushState('thickEdgeText'), 75
                    break
                  case 73:
                    return 119
                  case 74:
                    return this.popState(), 77
                    break
                  case 75:
                    return this.pushState('dottedEdgeText'), 75
                    break
                  case 76:
                    return 119
                  case 77:
                    return 77
                  case 78:
                    return this.popState(), 53
                    break
                  case 79:
                    return 'TEXT'
                  case 80:
                    return this.pushState('ellipseText'), 52
                    break
                  case 81:
                    return this.popState(), 55
                    break
                  case 82:
                    return this.pushState('text'), 54
                    break
                  case 83:
                    return this.popState(), 57
                    break
                  case 84:
                    return this.pushState('text'), 56
                    break
                  case 85:
                    return 58
                  case 86:
                    return this.pushState('text'), 67
                    break
                  case 87:
                    return this.popState(), 64
                    break
                  case 88:
                    return this.pushState('text'), 63
                    break
                  case 89:
                    return this.popState(), 49
                    break
                  case 90:
                    return this.pushState('text'), 48
                    break
                  case 91:
                    return this.popState(), 69
                    break
                  case 92:
                    return this.popState(), 71
                    break
                  case 93:
                    return 117
                  case 94:
                    return this.pushState('trapText'), 68
                    break
                  case 95:
                    return this.pushState('trapText'), 70
                    break
                  case 96:
                    return 118
                  case 97:
                    return 67
                  case 98:
                    return 90
                  case 99:
                    return 'SEP'
                  case 100:
                    return 89
                  case 101:
                    return 115
                  case 102:
                    return 111
                  case 103:
                    return 44
                  case 104:
                    return 109
                  case 105:
                    return 114
                  case 106:
                    return 116
                  case 107:
                    return this.popState(), 62
                    break
                  case 108:
                    return this.pushState('text'), 62
                    break
                  case 109:
                    return this.popState(), 51
                    break
                  case 110:
                    return this.pushState('text'), 50
                    break
                  case 111:
                    return this.popState(), 31
                    break
                  case 112:
                    return this.pushState('text'), 29
                    break
                  case 113:
                    return this.popState(), 66
                    break
                  case 114:
                    return this.pushState('text'), 65
                    break
                  case 115:
                    return 'TEXT'
                  case 116:
                    return 'QUOTE'
                  case 117:
                    return 9
                  case 118:
                    return 10
                  case 119:
                    return 11
                }
              }, 'anonymous'),
              rules: [
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:@\{)/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^\"]+)/,
                /^(?:[^}^"]+)/,
                /^(?:\})/,
                /^(?:call[\s]+)/,
                /^(?:\([\s]*\))/,
                /^(?:\()/,
                /^(?:[^(]*)/,
                /^(?:\))/,
                /^(?:[^)]*)/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["][`])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:style\b)/,
                /^(?:default\b)/,
                /^(?:linkStyle\b)/,
                /^(?:interpolate\b)/,
                /^(?:classDef\b)/,
                /^(?:class\b)/,
                /^(?:href[\s])/,
                /^(?:click[\s]+)/,
                /^(?:[\s\n])/,
                /^(?:[^\s\n]*)/,
                /^(?:flowchart-elk\b)/,
                /^(?:graph\b)/,
                /^(?:flowchart\b)/,
                /^(?:subgraph\b)/,
                /^(?:end\b\s*)/,
                /^(?:_self\b)/,
                /^(?:_blank\b)/,
                /^(?:_parent\b)/,
                /^(?:_top\b)/,
                /^(?:(\r?\n)*\s*\n)/,
                /^(?:\s*LR\b)/,
                /^(?:\s*RL\b)/,
                /^(?:\s*TB\b)/,
                /^(?:\s*BT\b)/,
                /^(?:\s*TD\b)/,
                /^(?:\s*BR\b)/,
                /^(?:\s*<)/,
                /^(?:\s*>)/,
                /^(?:\s*\^)/,
                /^(?:\s*v\b)/,
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:[^\s\"]+@(?=[^\{\"]))/,
                /^(?:[0-9]+)/,
                /^(?:#)/,
                /^(?::::)/,
                /^(?::)/,
                /^(?:&)/,
                /^(?:;)/,
                /^(?:,)/,
                /^(?:\*)/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?--\s*)/,
                /^(?:[^-]|-(?!-)+)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?==\s*)/,
                /^(?:[^=]|=(?!))/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?:\s*[xo<]?-\.\s*)/,
                /^(?:[^\.]|\.(?!))/,
                /^(?:\s*~~[\~]+\s*)/,
                /^(?:[-/\)][\)])/,
                /^(?:[^\(\)\[\]\{\}]|!\)+)/,
                /^(?:\(-)/,
                /^(?:\]\))/,
                /^(?:\(\[)/,
                /^(?:\]\])/,
                /^(?:\[\[)/,
                /^(?:\[\|)/,
                /^(?:>)/,
                /^(?:\)\])/,
                /^(?:\[\()/,
                /^(?:\)\)\))/,
                /^(?:\(\(\()/,
                /^(?:[\\(?=\])][\]])/,
                /^(?:\/(?=\])\])/,
                /^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/,
                /^(?:\[\/)/,
                /^(?:\[\\)/,
                /^(?:<)/,
                /^(?:>)/,
                /^(?:\^)/,
                /^(?:\\\|)/,
                /^(?:v\b)/,
                /^(?:\*)/,
                /^(?:#)/,
                /^(?:&)/,
                /^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/,
                /^(?:-)/,
                /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
                /^(?:\|)/,
                /^(?:\|)/,
                /^(?:\))/,
                /^(?:\()/,
                /^(?:\])/,
                /^(?:\[)/,
                /^(?:(\}))/,
                /^(?:\{)/,
                /^(?:[^\[\]\(\)\{\}\|\"]+)/,
                /^(?:")/,
                /^(?:(\r?\n)+)/,
                /^(?:\s)/,
                /^(?:$)/,
              ],
              conditions: {
                shapeDataEndBracket: {
                  rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                shapeDataStr: {
                  rules: [9, 10, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                shapeData: {
                  rules: [8, 11, 12, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                callbackargs: {
                  rules: [17, 18, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                callbackname: {
                  rules: [14, 15, 16, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                href: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                click: { rules: [21, 24, 33, 34, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                dottedEdgeText: {
                  rules: [21, 24, 74, 76, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                thickEdgeText: {
                  rules: [21, 24, 71, 73, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                edgeText: {
                  rules: [21, 24, 68, 70, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                trapText: {
                  rules: [21, 24, 77, 80, 82, 84, 88, 90, 91, 92, 93, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                ellipseText: {
                  rules: [21, 24, 77, 78, 79, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                text: {
                  rules: [
                    21, 24, 77, 80, 81, 82, 83, 84, 87, 88, 89, 90, 94, 95, 107, 108, 109, 110, 111, 112, 113, 114, 115,
                  ],
                  inclusive: !1,
                },
                vertex: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                dir: {
                  rules: [
                    21, 24, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112,
                    114,
                  ],
                  inclusive: !1,
                },
                acc_descr_multiline: {
                  rules: [5, 6, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                acc_descr: { rules: [3, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                acc_title: { rules: [1, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                md_string: {
                  rules: [19, 20, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114],
                  inclusive: !1,
                },
                string: { rules: [21, 22, 23, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 2, 4, 7, 13, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56,
                    57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 74, 75, 77, 80, 82, 84, 85, 86, 88, 90,
                    94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 110, 112, 114, 116, 117, 118, 119,
                  ],
                  inclusive: !0,
                },
              },
            }
            return qr
          })()
        ks.lexer = uu
        function hu() {
          this.yy = {}
        }
        return a(hu, 'Parser'), (hu.prototype = ks), (ks.Parser = hu), new hu()
      })()
      t6.parser = t6
      e6 = t6
    })
  var nK,
    iK,
    sK = x(() => {
      'use strict'
      rK()
      nK = Object.assign({}, e6)
      nK.parse = (e) => {
        let t = e.replace(
          /}\s*\n/g,
          `}
`,
        )
        return e6.parse(t)
      }
      iK = nK
    })
  var No,
    Md = x(() => {
      'use strict'
      No = a(
        () => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }

  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`,
        'getIconStyles',
      )
    })
  var Pvt,
    Bvt,
    aK,
    oK = x(() => {
      'use strict'
      js()
      Md()
      ;(Pvt = a((e, t) => {
        let r = gu,
          n = r(e, 'r'),
          i = r(e, 'g'),
          s = r(e, 'b')
        return Ni(n, i, s, t)
      }, 'fade')),
        (Bvt = a(
          (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span {
    color: ${e.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${e.lineColor} !important;
    stroke-width: 0;
    stroke: ${e.lineColor};
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${Pvt(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .cluster rect {
    fill: ${e.clusterBkg};
    stroke: ${e.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }
  ${No()}
`,
          'getStyles',
        )),
        (aK = Bvt)
    })
  var r6 = {}
  Oe(r6, { diagram: () => Fvt })
  var Fvt,
    n6 = x(() => {
      'use strict'
      pe()
      sU()
      eK()
      sK()
      oK()
      Fvt = {
        parser: iK,
        get db() {
          return new qb()
        },
        renderer: tK,
        styles: aK,
        init: a((e) => {
          e.flowchart || (e.flowchart = {}),
            e.layout && og({ layout: e.layout }),
            (e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute),
            og({ flowchart: { arrowMarkerAbsolute: e.arrowMarkerAbsolute } })
        }, 'init'),
      }
    })
  var i6,
    fK,
    dK = x(() => {
      'use strict'
      i6 = (function () {
        var e = a(function (Q, et, X, st) {
            for (X = X || {}, st = Q.length; st--; X[Q[st]] = et);
            return X
          }, 'o'),
          t = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50],
          r = [1, 10],
          n = [1, 11],
          i = [1, 12],
          s = [1, 13],
          o = [1, 20],
          l = [1, 21],
          u = [1, 22],
          h = [1, 23],
          f = [1, 24],
          d = [1, 19],
          p = [1, 25],
          m = [1, 26],
          g = [1, 18],
          y = [1, 33],
          b = [1, 34],
          k = [1, 35],
          T = [1, 36],
          C = [1, 37],
          A = [6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50, 63, 64, 65, 66, 67],
          w = [1, 42],
          D = [1, 43],
          G = [1, 52],
          v = [40, 50, 68, 69],
          R = [1, 63],
          F = [1, 61],
          S = [1, 58],
          O = [1, 62],
          E = [1, 64],
          _ = [
            6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 48, 49, 50, 63, 64, 65, 66, 67,
          ],
          L = [63, 64, 65, 66, 67],
          N = [1, 81],
          P = [1, 80],
          I = [1, 78],
          M = [1, 79],
          V = [6, 10, 42, 47],
          $ = [6, 10, 13, 41, 42, 47, 48, 49],
          q = [1, 89],
          tt = [1, 88],
          ft = [1, 87],
          H = [19, 56],
          kt = [1, 98],
          ht = [1, 97],
          yt = [19, 56, 58, 60],
          ot = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              ER_DIAGRAM: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              entityName: 11,
              relSpec: 12,
              COLON: 13,
              role: 14,
              STYLE_SEPARATOR: 15,
              idList: 16,
              BLOCK_START: 17,
              attributes: 18,
              BLOCK_STOP: 19,
              SQS: 20,
              SQE: 21,
              title: 22,
              title_value: 23,
              acc_title: 24,
              acc_title_value: 25,
              acc_descr: 26,
              acc_descr_value: 27,
              acc_descr_multiline_value: 28,
              direction: 29,
              classDefStatement: 30,
              classStatement: 31,
              styleStatement: 32,
              direction_tb: 33,
              direction_bt: 34,
              direction_rl: 35,
              direction_lr: 36,
              CLASSDEF: 37,
              stylesOpt: 38,
              separator: 39,
              UNICODE_TEXT: 40,
              STYLE_TEXT: 41,
              COMMA: 42,
              CLASS: 43,
              STYLE: 44,
              style: 45,
              styleComponent: 46,
              SEMI: 47,
              NUM: 48,
              BRKT: 49,
              ENTITY_NAME: 50,
              attribute: 51,
              attributeType: 52,
              attributeName: 53,
              attributeKeyTypeList: 54,
              attributeComment: 55,
              ATTRIBUTE_WORD: 56,
              attributeKeyType: 57,
              ',': 58,
              ATTRIBUTE_KEY: 59,
              COMMENT: 60,
              cardinality: 61,
              relType: 62,
              ZERO_OR_ONE: 63,
              ZERO_OR_MORE: 64,
              ONE_OR_MORE: 65,
              ONLY_ONE: 66,
              MD_PARENT: 67,
              NON_IDENTIFYING: 68,
              IDENTIFYING: 69,
              WORD: 70,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'ER_DIAGRAM',
              6: 'EOF',
              8: 'SPACE',
              10: 'NEWLINE',
              13: 'COLON',
              15: 'STYLE_SEPARATOR',
              17: 'BLOCK_START',
              19: 'BLOCK_STOP',
              20: 'SQS',
              21: 'SQE',
              22: 'title',
              23: 'title_value',
              24: 'acc_title',
              25: 'acc_title_value',
              26: 'acc_descr',
              27: 'acc_descr_value',
              28: 'acc_descr_multiline_value',
              33: 'direction_tb',
              34: 'direction_bt',
              35: 'direction_rl',
              36: 'direction_lr',
              37: 'CLASSDEF',
              40: 'UNICODE_TEXT',
              41: 'STYLE_TEXT',
              42: 'COMMA',
              43: 'CLASS',
              44: 'STYLE',
              47: 'SEMI',
              48: 'NUM',
              49: 'BRKT',
              50: 'ENTITY_NAME',
              56: 'ATTRIBUTE_WORD',
              58: ',',
              59: 'ATTRIBUTE_KEY',
              60: 'COMMENT',
              63: 'ZERO_OR_ONE',
              64: 'ZERO_OR_MORE',
              65: 'ONE_OR_MORE',
              66: 'ONLY_ONE',
              67: 'MD_PARENT',
              68: 'NON_IDENTIFYING',
              69: 'IDENTIFYING',
              70: 'WORD',
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 5],
              [9, 9],
              [9, 7],
              [9, 7],
              [9, 4],
              [9, 6],
              [9, 3],
              [9, 5],
              [9, 1],
              [9, 3],
              [9, 7],
              [9, 9],
              [9, 6],
              [9, 8],
              [9, 4],
              [9, 6],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [29, 1],
              [29, 1],
              [29, 1],
              [29, 1],
              [30, 4],
              [16, 1],
              [16, 1],
              [16, 3],
              [16, 3],
              [31, 3],
              [32, 4],
              [38, 1],
              [38, 3],
              [45, 1],
              [45, 2],
              [39, 1],
              [39, 1],
              [39, 1],
              [46, 1],
              [46, 1],
              [46, 1],
              [46, 1],
              [11, 1],
              [11, 1],
              [18, 1],
              [18, 2],
              [51, 2],
              [51, 3],
              [51, 3],
              [51, 4],
              [52, 1],
              [53, 1],
              [54, 1],
              [54, 3],
              [57, 1],
              [55, 1],
              [12, 3],
              [61, 1],
              [61, 1],
              [61, 1],
              [61, 1],
              [61, 1],
              [62, 1],
              [62, 1],
              [14, 1],
              [14, 1],
              [14, 1],
            ],
            performAction: a(function (et, X, st, U, gt, z, ge) {
              var lt = z.length - 1
              switch (gt) {
                case 1:
                  break
                case 2:
                  this.$ = []
                  break
                case 3:
                  z[lt - 1].push(z[lt]), (this.$ = z[lt - 1])
                  break
                case 4:
                case 5:
                  this.$ = z[lt]
                  break
                case 6:
                case 7:
                  this.$ = []
                  break
                case 8:
                  U.addEntity(z[lt - 4]),
                    U.addEntity(z[lt - 2]),
                    U.addRelationship(z[lt - 4], z[lt], z[lt - 2], z[lt - 3])
                  break
                case 9:
                  U.addEntity(z[lt - 8]),
                    U.addEntity(z[lt - 4]),
                    U.addRelationship(z[lt - 8], z[lt], z[lt - 4], z[lt - 5]),
                    U.setClass([z[lt - 8]], z[lt - 6]),
                    U.setClass([z[lt - 4]], z[lt - 2])
                  break
                case 10:
                  U.addEntity(z[lt - 6]),
                    U.addEntity(z[lt - 2]),
                    U.addRelationship(z[lt - 6], z[lt], z[lt - 2], z[lt - 3]),
                    U.setClass([z[lt - 6]], z[lt - 4])
                  break
                case 11:
                  U.addEntity(z[lt - 6]),
                    U.addEntity(z[lt - 4]),
                    U.addRelationship(z[lt - 6], z[lt], z[lt - 4], z[lt - 5]),
                    U.setClass([z[lt - 4]], z[lt - 2])
                  break
                case 12:
                  U.addEntity(z[lt - 3]), U.addAttributes(z[lt - 3], z[lt - 1])
                  break
                case 13:
                  U.addEntity(z[lt - 5]), U.addAttributes(z[lt - 5], z[lt - 1]), U.setClass([z[lt - 5]], z[lt - 3])
                  break
                case 14:
                  U.addEntity(z[lt - 2])
                  break
                case 15:
                  U.addEntity(z[lt - 4]), U.setClass([z[lt - 4]], z[lt - 2])
                  break
                case 16:
                  U.addEntity(z[lt])
                  break
                case 17:
                  U.addEntity(z[lt - 2]), U.setClass([z[lt - 2]], z[lt])
                  break
                case 18:
                  U.addEntity(z[lt - 6], z[lt - 4]), U.addAttributes(z[lt - 6], z[lt - 1])
                  break
                case 19:
                  U.addEntity(z[lt - 8], z[lt - 6]),
                    U.addAttributes(z[lt - 8], z[lt - 1]),
                    U.setClass([z[lt - 8]], z[lt - 3])
                  break
                case 20:
                  U.addEntity(z[lt - 5], z[lt - 3])
                  break
                case 21:
                  U.addEntity(z[lt - 7], z[lt - 5]), U.setClass([z[lt - 7]], z[lt - 2])
                  break
                case 22:
                  U.addEntity(z[lt - 3], z[lt - 1])
                  break
                case 23:
                  U.addEntity(z[lt - 5], z[lt - 3]), U.setClass([z[lt - 5]], z[lt])
                  break
                case 24:
                case 25:
                  ;(this.$ = z[lt].trim()), U.setAccTitle(this.$)
                  break
                case 26:
                case 27:
                  ;(this.$ = z[lt].trim()), U.setAccDescription(this.$)
                  break
                case 32:
                  U.setDirection('TB')
                  break
                case 33:
                  U.setDirection('BT')
                  break
                case 34:
                  U.setDirection('RL')
                  break
                case 35:
                  U.setDirection('LR')
                  break
                case 36:
                  ;(this.$ = z[lt - 3]), U.addClass(z[lt - 2], z[lt - 1])
                  break
                case 37:
                case 38:
                case 56:
                case 64:
                  this.$ = [z[lt]]
                  break
                case 39:
                case 40:
                  this.$ = z[lt - 2].concat([z[lt]])
                  break
                case 41:
                  ;(this.$ = z[lt - 2]), U.setClass(z[lt - 1], z[lt])
                  break
                case 42:
                  ;(this.$ = z[lt - 3]), U.addCssStyles(z[lt - 2], z[lt - 1])
                  break
                case 43:
                  this.$ = [z[lt]]
                  break
                case 44:
                  z[lt - 2].push(z[lt]), (this.$ = z[lt - 2])
                  break
                case 46:
                  this.$ = z[lt - 1] + z[lt]
                  break
                case 54:
                case 76:
                case 77:
                  this.$ = z[lt].replace(/"/g, '')
                  break
                case 55:
                case 78:
                  this.$ = z[lt]
                  break
                case 57:
                  z[lt].push(z[lt - 1]), (this.$ = z[lt])
                  break
                case 58:
                  this.$ = { type: z[lt - 1], name: z[lt] }
                  break
                case 59:
                  this.$ = { type: z[lt - 2], name: z[lt - 1], keys: z[lt] }
                  break
                case 60:
                  this.$ = { type: z[lt - 2], name: z[lt - 1], comment: z[lt] }
                  break
                case 61:
                  this.$ = { type: z[lt - 3], name: z[lt - 2], keys: z[lt - 1], comment: z[lt] }
                  break
                case 62:
                case 63:
                case 66:
                  this.$ = z[lt]
                  break
                case 65:
                  z[lt - 2].push(z[lt]), (this.$ = z[lt - 2])
                  break
                case 67:
                  this.$ = z[lt].replace(/"/g, '')
                  break
                case 68:
                  this.$ = { cardA: z[lt], relType: z[lt - 1], cardB: z[lt - 2] }
                  break
                case 69:
                  this.$ = U.Cardinality.ZERO_OR_ONE
                  break
                case 70:
                  this.$ = U.Cardinality.ZERO_OR_MORE
                  break
                case 71:
                  this.$ = U.Cardinality.ONE_OR_MORE
                  break
                case 72:
                  this.$ = U.Cardinality.ONLY_ONE
                  break
                case 73:
                  this.$ = U.Cardinality.MD_PARENT
                  break
                case 74:
                  this.$ = U.Identification.NON_IDENTIFYING
                  break
                case 75:
                  this.$ = U.Identification.IDENTIFYING
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: 9,
                22: r,
                24: n,
                26: i,
                28: s,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: o,
                34: l,
                35: u,
                36: h,
                37: f,
                40: d,
                43: p,
                44: m,
                50: g,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              {
                9: 27,
                11: 9,
                22: r,
                24: n,
                26: i,
                28: s,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: o,
                34: l,
                35: u,
                36: h,
                37: f,
                40: d,
                43: p,
                44: m,
                50: g,
              },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 16], {
                12: 28,
                61: 32,
                15: [1, 29],
                17: [1, 30],
                20: [1, 31],
                63: y,
                64: b,
                65: k,
                66: T,
                67: C,
              }),
              { 23: [1, 38] },
              { 25: [1, 39] },
              { 27: [1, 40] },
              e(t, [2, 27]),
              e(t, [2, 28]),
              e(t, [2, 29]),
              e(t, [2, 30]),
              e(t, [2, 31]),
              e(A, [2, 54]),
              e(A, [2, 55]),
              e(t, [2, 32]),
              e(t, [2, 33]),
              e(t, [2, 34]),
              e(t, [2, 35]),
              { 16: 41, 40: w, 41: D },
              { 16: 44, 40: w, 41: D },
              { 16: 45, 40: w, 41: D },
              e(t, [2, 4]),
              { 11: 46, 40: d, 50: g },
              { 16: 47, 40: w, 41: D },
              { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: G },
              { 11: 53, 40: d, 50: g },
              { 62: 54, 68: [1, 55], 69: [1, 56] },
              e(v, [2, 69]),
              e(v, [2, 70]),
              e(v, [2, 71]),
              e(v, [2, 72]),
              e(v, [2, 73]),
              e(t, [2, 24]),
              e(t, [2, 25]),
              e(t, [2, 26]),
              { 13: R, 38: 57, 41: F, 42: S, 45: 59, 46: 60, 48: O, 49: E },
              e(_, [2, 37]),
              e(_, [2, 38]),
              { 16: 65, 40: w, 41: D, 42: S },
              { 13: R, 38: 66, 41: F, 42: S, 45: 59, 46: 60, 48: O, 49: E },
              { 13: [1, 67], 15: [1, 68] },
              e(t, [2, 17], { 61: 32, 12: 69, 17: [1, 70], 42: S, 63: y, 64: b, 65: k, 66: T, 67: C }),
              { 19: [1, 71] },
              e(t, [2, 14]),
              { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: G },
              { 53: 73, 56: [1, 74] },
              { 56: [2, 62] },
              { 21: [1, 75] },
              { 61: 76, 63: y, 64: b, 65: k, 66: T, 67: C },
              e(L, [2, 74]),
              e(L, [2, 75]),
              { 6: N, 10: P, 39: 77, 42: I, 47: M },
              { 40: [1, 82], 41: [1, 83] },
              e(V, [2, 43], { 46: 84, 13: R, 41: F, 48: O, 49: E }),
              e($, [2, 45]),
              e($, [2, 50]),
              e($, [2, 51]),
              e($, [2, 52]),
              e($, [2, 53]),
              e(t, [2, 41], { 42: S }),
              { 6: N, 10: P, 39: 85, 42: I, 47: M },
              { 14: 86, 40: q, 50: tt, 70: ft },
              { 16: 90, 40: w, 41: D },
              { 11: 91, 40: d, 50: g },
              { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: G },
              e(t, [2, 12]),
              { 19: [2, 57] },
              e(H, [2, 58], { 54: 94, 55: 95, 57: 96, 59: kt, 60: ht }),
              e([19, 56, 59, 60], [2, 63]),
              e(t, [2, 22], { 15: [1, 100], 17: [1, 99] }),
              e([40, 50], [2, 68]),
              e(t, [2, 36]),
              { 13: R, 41: F, 45: 101, 46: 60, 48: O, 49: E },
              e(t, [2, 47]),
              e(t, [2, 48]),
              e(t, [2, 49]),
              e(_, [2, 39]),
              e(_, [2, 40]),
              e($, [2, 46]),
              e(t, [2, 42]),
              e(t, [2, 8]),
              e(t, [2, 76]),
              e(t, [2, 77]),
              e(t, [2, 78]),
              { 13: [1, 102], 42: S },
              { 13: [1, 104], 15: [1, 103] },
              { 19: [1, 105] },
              e(t, [2, 15]),
              e(H, [2, 59], { 55: 106, 58: [1, 107], 60: ht }),
              e(H, [2, 60]),
              e(yt, [2, 64]),
              e(H, [2, 67]),
              e(yt, [2, 66]),
              { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: G },
              { 16: 110, 40: w, 41: D },
              e(V, [2, 44], { 46: 84, 13: R, 41: F, 48: O, 49: E }),
              { 14: 111, 40: q, 50: tt, 70: ft },
              { 16: 112, 40: w, 41: D },
              { 14: 113, 40: q, 50: tt, 70: ft },
              e(t, [2, 13]),
              e(H, [2, 61]),
              { 57: 114, 59: kt },
              { 19: [1, 115] },
              e(t, [2, 20]),
              e(t, [2, 23], { 17: [1, 116], 42: S }),
              e(t, [2, 11]),
              { 13: [1, 117], 42: S },
              e(t, [2, 10]),
              e(yt, [2, 65]),
              e(t, [2, 18]),
              { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: G },
              { 14: 120, 40: q, 50: tt, 70: ft },
              { 19: [1, 121] },
              e(t, [2, 21]),
              e(t, [2, 9]),
              e(t, [2, 19]),
            ],
            defaultActions: { 52: [2, 62], 72: [2, 57] },
            parseError: a(function (et, X) {
              if (X.recoverable) this.trace(et)
              else {
                var st = new Error(et)
                throw ((st.hash = X), st)
              }
            }, 'parseError'),
            parse: a(function (et) {
              var X = this,
                st = [0],
                U = [],
                gt = [null],
                z = [],
                ge = this.table,
                lt = '',
                jt = 0,
                Me = 0,
                se = 0,
                Nt = 2,
                At = 1,
                bt = z.slice.call(arguments, 1),
                ct = Object.create(this.lexer),
                Lt = { yy: {} }
              for (var Z in this.yy) Object.prototype.hasOwnProperty.call(this.yy, Z) && (Lt.yy[Z] = this.yy[Z])
              ct.setInput(et, Lt.yy),
                (Lt.yy.lexer = ct),
                (Lt.yy.parser = this),
                typeof ct.yylloc > 'u' && (ct.yylloc = {})
              var Mt = ct.yylloc
              z.push(Mt)
              var W = ct.options && ct.options.ranges
              typeof Lt.yy.parseError == 'function'
                ? (this.parseError = Lt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function Gt(Je) {
                ;(st.length = st.length - 2 * Je), (gt.length = gt.length - Je), (z.length = z.length - Je)
              }
              a(Gt, 'popStack')
              function j() {
                var Je
                return (
                  (Je = U.pop() || ct.lex() || At),
                  typeof Je != 'number' &&
                    (Je instanceof Array && ((U = Je), (Je = U.pop())), (Je = X.symbols_[Je] || Je)),
                  Je
                )
              }
              a(j, 'lex')
              for (var vt, mt, Xt, Ft, _t, Qe, It = {}, xr, Ze, yn, Ae; ; ) {
                if (
                  ((Xt = st[st.length - 1]),
                  this.defaultActions[Xt]
                    ? (Ft = this.defaultActions[Xt])
                    : ((vt === null || typeof vt > 'u') && (vt = j()), (Ft = ge[Xt] && ge[Xt][vt])),
                  typeof Ft > 'u' || !Ft.length || !Ft[0])
                ) {
                  var Se = ''
                  Ae = []
                  for (xr in ge[Xt]) this.terminals_[xr] && xr > Nt && Ae.push("'" + this.terminals_[xr] + "'")
                  ct.showPosition
                    ? (Se =
                        'Parse error on line ' +
                        (jt + 1) +
                        `:
` +
                        ct.showPosition() +
                        `
Expecting ` +
                        Ae.join(', ') +
                        ", got '" +
                        (this.terminals_[vt] || vt) +
                        "'")
                    : (Se =
                        'Parse error on line ' +
                        (jt + 1) +
                        ': Unexpected ' +
                        (vt == At ? 'end of input' : "'" + (this.terminals_[vt] || vt) + "'")),
                    this.parseError(Se, {
                      text: ct.match,
                      token: this.terminals_[vt] || vt,
                      line: ct.yylineno,
                      loc: Mt,
                      expected: Ae,
                    })
                }
                if (Ft[0] instanceof Array && Ft.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + Xt + ', token: ' + vt)
                switch (Ft[0]) {
                  case 1:
                    st.push(vt),
                      gt.push(ct.yytext),
                      z.push(ct.yylloc),
                      st.push(Ft[1]),
                      (vt = null),
                      mt
                        ? ((vt = mt), (mt = null))
                        : ((Me = ct.yyleng), (lt = ct.yytext), (jt = ct.yylineno), (Mt = ct.yylloc), se > 0 && se--)
                    break
                  case 2:
                    if (
                      ((Ze = this.productions_[Ft[1]][1]),
                      (It.$ = gt[gt.length - Ze]),
                      (It._$ = {
                        first_line: z[z.length - (Ze || 1)].first_line,
                        last_line: z[z.length - 1].last_line,
                        first_column: z[z.length - (Ze || 1)].first_column,
                        last_column: z[z.length - 1].last_column,
                      }),
                      W && (It._$.range = [z[z.length - (Ze || 1)].range[0], z[z.length - 1].range[1]]),
                      (Qe = this.performAction.apply(It, [lt, Me, jt, Lt.yy, Ft[1], gt, z].concat(bt))),
                      typeof Qe < 'u')
                    )
                      return Qe
                    Ze && ((st = st.slice(0, -1 * Ze * 2)), (gt = gt.slice(0, -1 * Ze)), (z = z.slice(0, -1 * Ze))),
                      st.push(this.productions_[Ft[1]][0]),
                      gt.push(It.$),
                      z.push(It._$),
                      (yn = ge[st[st.length - 2]][st[st.length - 1]]),
                      st.push(yn)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          dt = (function () {
            var Q = {
              EOF: 1,
              parseError: a(function (X, st) {
                if (this.yy.parser) this.yy.parser.parseError(X, st)
                else throw new Error(X)
              }, 'parseError'),
              setInput: a(function (et, X) {
                return (
                  (this.yy = X || this.yy || {}),
                  (this._input = et),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var et = this._input[0]
                ;(this.yytext += et), this.yyleng++, this.offset++, (this.match += et), (this.matched += et)
                var X = et.match(/(?:\r\n?|\n).*/g)
                return (
                  X ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  et
                )
              }, 'input'),
              unput: a(function (et) {
                var X = et.length,
                  st = et.split(/(?:\r\n?|\n)/g)
                ;(this._input = et + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - X)),
                  (this.offset -= X)
                var U = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  st.length - 1 && (this.yylineno -= st.length - 1)
                var gt = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: st
                      ? (st.length === U.length ? this.yylloc.first_column : 0) +
                        U[U.length - st.length].length -
                        st[0].length
                      : this.yylloc.first_column - X,
                  }),
                  this.options.ranges && (this.yylloc.range = [gt[0], gt[0] + this.yyleng - X]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (et) {
                this.unput(this.match.slice(et))
              }, 'less'),
              pastInput: a(function () {
                var et = this.matched.substr(0, this.matched.length - this.match.length)
                return (et.length > 20 ? '...' : '') + et.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var et = this.match
                return (
                  et.length < 20 && (et += this._input.substr(0, 20 - et.length)),
                  (et.substr(0, 20) + (et.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var et = this.pastInput(),
                  X = new Array(et.length + 1).join('-')
                return (
                  et +
                  this.upcomingInput() +
                  `
` +
                  X +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (et, X) {
                var st, U, gt
                if (
                  (this.options.backtrack_lexer &&
                    ((gt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (gt.yylloc.range = this.yylloc.range.slice(0))),
                  (U = et[0].match(/(?:\r\n?|\n).*/g)),
                  U && (this.yylineno += U.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: U
                      ? U[U.length - 1].length - U[U.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + et[0].length,
                  }),
                  (this.yytext += et[0]),
                  (this.match += et[0]),
                  (this.matches = et),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(et[0].length)),
                  (this.matched += et[0]),
                  (st = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    X,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  st)
                )
                  return st
                if (this._backtrack) {
                  for (var z in gt) this[z] = gt[z]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var et, X, st, U
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var gt = this._currentRules(), z = 0; z < gt.length; z++)
                  if (((st = this._input.match(this.rules[gt[z]])), st && (!X || st[0].length > X[0].length))) {
                    if (((X = st), (U = z), this.options.backtrack_lexer)) {
                      if (((et = this.test_match(st, gt[z])), et !== !1)) return et
                      if (this._backtrack) {
                        X = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return X
                  ? ((et = this.test_match(X, gt[U])), et !== !1 ? et : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var X = this.next()
                return X || this.lex()
              }, 'lex'),
              begin: a(function (X) {
                this.conditionStack.push(X)
              }, 'begin'),
              popState: a(function () {
                var X = this.conditionStack.length - 1
                return X > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (X) {
                return (
                  (X = this.conditionStack.length - 1 - Math.abs(X || 0)), X >= 0 ? this.conditionStack[X] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (X) {
                this.begin(X)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (X, st, U, gt) {
                var z = gt
                switch (U) {
                  case 0:
                    return this.begin('acc_title'), 24
                    break
                  case 1:
                    return this.popState(), 'acc_title_value'
                    break
                  case 2:
                    return this.begin('acc_descr'), 26
                    break
                  case 3:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 4:
                    this.begin('acc_descr_multiline')
                    break
                  case 5:
                    this.popState()
                    break
                  case 6:
                    return 'acc_descr_multiline_value'
                  case 7:
                    return 33
                  case 8:
                    return 34
                  case 9:
                    return 35
                  case 10:
                    return 36
                  case 11:
                    return 10
                  case 12:
                    break
                  case 13:
                    return 8
                  case 14:
                    return 50
                  case 15:
                    return 70
                  case 16:
                    return 4
                  case 17:
                    return this.begin('block'), 17
                    break
                  case 18:
                    return 49
                  case 19:
                    return 49
                  case 20:
                    return 42
                  case 21:
                    return 15
                  case 22:
                    return 13
                  case 23:
                    break
                  case 24:
                    return 59
                  case 25:
                    return 56
                  case 26:
                    return 56
                  case 27:
                    return 60
                  case 28:
                    break
                  case 29:
                    return this.popState(), 19
                    break
                  case 30:
                    return st.yytext[0]
                  case 31:
                    return 20
                  case 32:
                    return 21
                  case 33:
                    return this.begin('style'), 44
                    break
                  case 34:
                    return this.popState(), 10
                    break
                  case 35:
                    break
                  case 36:
                    return 13
                  case 37:
                    return 42
                  case 38:
                    return 49
                  case 39:
                    return this.begin('style'), 37
                    break
                  case 40:
                    return 43
                  case 41:
                    return 63
                  case 42:
                    return 65
                  case 43:
                    return 65
                  case 44:
                    return 65
                  case 45:
                    return 63
                  case 46:
                    return 63
                  case 47:
                    return 64
                  case 48:
                    return 64
                  case 49:
                    return 64
                  case 50:
                    return 64
                  case 51:
                    return 64
                  case 52:
                    return 65
                  case 53:
                    return 64
                  case 54:
                    return 65
                  case 55:
                    return 66
                  case 56:
                    return 66
                  case 57:
                    return 66
                  case 58:
                    return 66
                  case 59:
                    return 63
                  case 60:
                    return 64
                  case 61:
                    return 65
                  case 62:
                    return 67
                  case 63:
                    return 68
                  case 64:
                    return 69
                  case 65:
                    return 69
                  case 66:
                    return 68
                  case 67:
                    return 68
                  case 68:
                    return 68
                  case 69:
                    return 41
                  case 70:
                    return 47
                  case 71:
                    return 40
                  case 72:
                    return 48
                  case 73:
                    return st.yytext[0]
                  case 74:
                    return 6
                }
              }, 'anonymous'),
              rules: [
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:[\s]+)/i,
                /^(?:"[^"%\r\n\v\b\\]+")/i,
                /^(?:"[^"]*")/i,
                /^(?:erDiagram\b)/i,
                /^(?:\{)/i,
                /^(?:#)/i,
                /^(?:#)/i,
                /^(?:,)/i,
                /^(?::::)/i,
                /^(?::)/i,
                /^(?:\s+)/i,
                /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i,
                /^(?:([^\s]*)[~].*[~]([^\s]*))/i,
                /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i,
                /^(?:"[^"]*")/i,
                /^(?:[\n]+)/i,
                /^(?:\})/i,
                /^(?:.)/i,
                /^(?:\[)/i,
                /^(?:\])/i,
                /^(?:style\b)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?::)/i,
                /^(?:,)/i,
                /^(?:#)/i,
                /^(?:classDef\b)/i,
                /^(?:class\b)/i,
                /^(?:one or zero\b)/i,
                /^(?:one or more\b)/i,
                /^(?:one or many\b)/i,
                /^(?:1\+)/i,
                /^(?:\|o\b)/i,
                /^(?:zero or one\b)/i,
                /^(?:zero or more\b)/i,
                /^(?:zero or many\b)/i,
                /^(?:0\+)/i,
                /^(?:\}o\b)/i,
                /^(?:many\(0\))/i,
                /^(?:many\(1\))/i,
                /^(?:many\b)/i,
                /^(?:\}\|)/i,
                /^(?:one\b)/i,
                /^(?:only one\b)/i,
                /^(?:1\b)/i,
                /^(?:\|\|)/i,
                /^(?:o\|)/i,
                /^(?:o\{)/i,
                /^(?:\|\{)/i,
                /^(?:\s*u\b)/i,
                /^(?:\.\.)/i,
                /^(?:--)/i,
                /^(?:to\b)/i,
                /^(?:optionally to\b)/i,
                /^(?:\.-)/i,
                /^(?:-\.)/i,
                /^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
                /^(?:;)/i,
                /^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
                /^(?:[0-9])/i,
                /^(?:.)/i,
                /^(?:$)/i,
              ],
              conditions: {
                style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: !1 },
                acc_descr_multiline: { rules: [5, 6], inclusive: !1 },
                acc_descr: { rules: [3], inclusive: !1 },
                acc_title: { rules: [1], inclusive: !1 },
                block: { rules: [23, 24, 25, 26, 27, 28, 29, 30], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 31, 32, 33, 39, 40, 41, 42,
                    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                    68, 71, 72, 73, 74,
                  ],
                  inclusive: !0,
                },
              },
            }
            return Q
          })()
        ot.lexer = dt
        function it() {
          this.yy = {}
        }
        return a(it, 'Parser'), (it.prototype = ot), (ot.Parser = it), new it()
      })()
      i6.parser = i6
      fK = i6
    })
  var lT,
    pK = x(() => {
      'use strict'
      Vt()
      pe()
      bn()
      Ce()
      lT = class {
        constructor() {
          this.entities = new Map()
          this.relationships = []
          this.classes = new Map()
          this.direction = 'TB'
          this.Cardinality = {
            ZERO_OR_ONE: 'ZERO_OR_ONE',
            ZERO_OR_MORE: 'ZERO_OR_MORE',
            ONE_OR_MORE: 'ONE_OR_MORE',
            ONLY_ONE: 'ONLY_ONE',
            MD_PARENT: 'MD_PARENT',
          }
          this.Identification = { NON_IDENTIFYING: 'NON_IDENTIFYING', IDENTIFYING: 'IDENTIFYING' }
          this.setAccTitle = Xe
          this.getAccTitle = tr
          this.setAccDescription = er
          this.getAccDescription = rr
          this.setDiagramTitle = lr
          this.getDiagramTitle = nr
          this.getConfig = a(() => K().er, 'getConfig')
          this.clear(),
            (this.addEntity = this.addEntity.bind(this)),
            (this.addAttributes = this.addAttributes.bind(this)),
            (this.addRelationship = this.addRelationship.bind(this)),
            (this.setDirection = this.setDirection.bind(this)),
            (this.addCssStyles = this.addCssStyles.bind(this)),
            (this.addClass = this.addClass.bind(this)),
            (this.setClass = this.setClass.bind(this)),
            (this.setAccTitle = this.setAccTitle.bind(this)),
            (this.setAccDescription = this.setAccDescription.bind(this))
        }
        static {
          a(this, 'ErDB')
        }
        addEntity(t, r = '') {
          return (
            this.entities.has(t)
              ? !this.entities.get(t)?.alias &&
                r &&
                ((this.entities.get(t).alias = r), B.info(`Add alias '${r}' to entity '${t}'`))
              : (this.entities.set(t, {
                  id: `entity-${t}-${this.entities.size}`,
                  label: t,
                  attributes: [],
                  alias: r,
                  shape: 'erBox',
                  look: K().look ?? 'default',
                  cssClasses: 'default',
                  cssStyles: [],
                }),
                B.info('Added new entity :', t)),
            this.entities.get(t)
          )
        }
        getEntity(t) {
          return this.entities.get(t)
        }
        getEntities() {
          return this.entities
        }
        getClasses() {
          return this.classes
        }
        addAttributes(t, r) {
          let n = this.addEntity(t),
            i
          for (i = r.length - 1; i >= 0; i--)
            r[i].keys || (r[i].keys = []),
              r[i].comment || (r[i].comment = ''),
              n.attributes.push(r[i]),
              B.debug('Added attribute ', r[i].name)
        }
        addRelationship(t, r, n, i) {
          let s = this.entities.get(t),
            o = this.entities.get(n)
          if (!s || !o) return
          let l = { entityA: s.id, roleA: r, entityB: o.id, relSpec: i }
          this.relationships.push(l), B.debug('Added new relationship :', l)
        }
        getRelationships() {
          return this.relationships
        }
        getDirection() {
          return this.direction
        }
        setDirection(t) {
          this.direction = t
        }
        getCompiledStyles(t) {
          let r = []
          for (let n of t) {
            let i = this.classes.get(n)
            i?.styles && (r = [...r, ...(i.styles ?? [])].map((s) => s.trim())),
              i?.textStyles && (r = [...r, ...(i.textStyles ?? [])].map((s) => s.trim()))
          }
          return r
        }
        addCssStyles(t, r) {
          for (let n of t) {
            let i = this.entities.get(n)
            if (!r || !i) return
            for (let s of r) i.cssStyles.push(s)
          }
        }
        addClass(t, r) {
          t.forEach((n) => {
            let i = this.classes.get(n)
            i === void 0 && ((i = { id: n, styles: [], textStyles: [] }), this.classes.set(n, i)),
              r &&
                r.forEach(function (s) {
                  if (/color/.exec(s)) {
                    let o = s.replace('fill', 'bgFill')
                    i.textStyles.push(o)
                  }
                  i.styles.push(s)
                })
          })
        }
        setClass(t, r) {
          for (let n of t) {
            let i = this.entities.get(n)
            if (i) for (let s of r) i.cssClasses += ' ' + s
          }
        }
        clear() {
          ;(this.entities = new Map()), (this.classes = new Map()), (this.relationships = []), Ye()
        }
        getData() {
          let t = [],
            r = [],
            n = K()
          for (let s of this.entities.keys()) {
            let o = this.entities.get(s)
            o && ((o.cssCompiledStyles = this.getCompiledStyles(o.cssClasses.split(' '))), t.push(o))
          }
          let i = 0
          for (let s of this.relationships) {
            let o = {
              id: kc(s.entityA, s.entityB, { prefix: 'id', counter: i++ }),
              type: 'normal',
              curve: 'basis',
              start: s.entityA,
              end: s.entityB,
              label: s.roleA,
              labelpos: 'c',
              thickness: 'normal',
              classes: 'relationshipLine',
              arrowTypeStart: s.relSpec.cardB.toLowerCase(),
              arrowTypeEnd: s.relSpec.cardA.toLowerCase(),
              pattern: s.relSpec.relType == 'IDENTIFYING' ? 'solid' : 'dashed',
              look: n.look,
            }
            r.push(o)
          }
          return { nodes: t, edges: r, other: {}, config: n, direction: 'TB' }
        }
      }
    })
  var s6 = {}
  Oe(s6, { draw: () => jvt })
  var jvt,
    mK = x(() => {
      'use strict'
      pe()
      Vt()
      hd()
      ph()
      mh()
      Ce()
      Ge()
      jvt = a(async function (e, t, r, n) {
        B.info('REF0:'), B.info('Drawing er diagram (unified)', t)
        let { securityLevel: i, er: s, layout: o } = K(),
          l = n.db.getData(),
          u = So(t, i)
        ;(l.type = n.type),
          (l.layoutAlgorithm = Gc(o)),
          (l.config.flowchart.nodeSpacing = s?.nodeSpacing || 140),
          (l.config.flowchart.rankSpacing = s?.rankSpacing || 80),
          (l.direction = n.db.getDirection()),
          (l.markers = ['only_one', 'zero_or_one', 'one_or_more', 'zero_or_more']),
          (l.diagramId = t),
          await Do(l, u),
          l.layoutAlgorithm === 'elk' && u.select('.edges').lower()
        let h = u.selectAll('[id*="-background"]')
        Array.from(h).length > 0 &&
          h.each(function () {
            let d = xt(this),
              m = d.attr('id').replace('-background', ''),
              g = u.select(`#${CSS.escape(m)}`)
            if (!g.empty()) {
              let y = g.attr('transform')
              d.attr('transform', y)
            }
          })
        let f = 8
        le.insertTitle(u, 'erDiagramTitleText', s?.titleTopMargin ?? 25, n.db.getDiagramTitle()),
          la(u, f, 'erDiagram', s?.useMaxWidth ?? !0)
      }, 'draw')
    })
  var qvt,
    Hvt,
    gK,
    yK = x(() => {
      'use strict'
      js()
      ;(qvt = a((e, t) => {
        let r = gu,
          n = r(e, 'r'),
          i = r(e, 'g'),
          s = r(e, 'b')
        return Ni(n, i, s, t)
      }, 'fade')),
        (Hvt = a(
          (e) => `
  .entityBox {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e.tertiaryColor};
    opacity: 0.7;
    background-color: ${e.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${qvt(e.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${e.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${e.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${e.lineColor} !important;
    stroke-width: 1;
  }
`,
          'getStyles',
        )),
        (gK = Hvt)
    })
  var xK = {}
  Oe(xK, { diagram: () => Yvt })
  var Yvt,
    bK = x(() => {
      'use strict'
      dK()
      pK()
      mK()
      yK()
      Yvt = {
        parser: fK,
        get db() {
          return new lT()
        },
        renderer: s6,
        styles: gK,
      }
    })
  function un(e) {
    return typeof e == 'object' && e !== null && typeof e.$type == 'string'
  }
  function ci(e) {
    return typeof e == 'object' && e !== null && typeof e.$refText == 'string'
  }
  function a6(e) {
    return (
      typeof e == 'object' &&
      e !== null &&
      typeof e.name == 'string' &&
      typeof e.type == 'string' &&
      typeof e.path == 'string'
    )
  }
  function yh(e) {
    return typeof e == 'object' && e !== null && un(e.container) && ci(e.reference) && typeof e.message == 'string'
  }
  function Va(e) {
    return typeof e == 'object' && e !== null && Array.isArray(e.content)
  }
  function Vc(e) {
    return typeof e == 'object' && e !== null && typeof e.tokenType == 'object'
  }
  function K0(e) {
    return Va(e) && typeof e.fullText == 'string'
  }
  var gh,
    za = x(() => {
      'use strict'
      a(un, 'isAstNode')
      a(ci, 'isReference')
      a(a6, 'isAstNodeDescription')
      a(yh, 'isLinkingError')
      gh = class {
        static {
          a(this, 'AbstractAstReflection')
        }
        constructor() {
          ;(this.subtypes = {}), (this.allSubtypes = {})
        }
        isInstance(t, r) {
          return un(t) && this.isSubtype(t.$type, r)
        }
        isSubtype(t, r) {
          if (t === r) return !0
          let n = this.subtypes[t]
          n || (n = this.subtypes[t] = {})
          let i = n[r]
          if (i !== void 0) return i
          {
            let s = this.computeIsSubtype(t, r)
            return (n[r] = s), s
          }
        }
        getAllSubTypes(t) {
          let r = this.allSubtypes[t]
          if (r) return r
          {
            let n = this.getAllTypes(),
              i = []
            for (let s of n) this.isSubtype(s, t) && i.push(s)
            return (this.allSubtypes[t] = i), i
          }
        }
      }
      a(Va, 'isCompositeCstNode')
      a(Vc, 'isLeafCstNode')
      a(K0, 'isRootCstNode')
    })
  function Zvt(e) {
    return typeof e == 'string'
      ? e
      : typeof e > 'u'
        ? 'undefined'
        : typeof e.toString == 'function'
          ? e.toString()
          : Object.prototype.toString.call(e)
  }
  function cT(e) {
    return !!e && typeof e[Symbol.iterator] == 'function'
  }
  function kr(...e) {
    if (e.length === 1) {
      let t = e[0]
      if (t instanceof Is) return t
      if (cT(t))
        return new Is(
          () => t[Symbol.iterator](),
          (r) => r.next(),
        )
      if (typeof t.length == 'number')
        return new Is(
          () => ({ index: 0 }),
          (r) => (r.index < t.length ? { done: !1, value: t[r.index++] } : Ti),
        )
    }
    return e.length > 1
      ? new Is(
          () => ({ collIndex: 0, arrIndex: 0 }),
          (t) => {
            do {
              if (t.iterator) {
                let r = t.iterator.next()
                if (!r.done) return r
                t.iterator = void 0
              }
              if (t.array) {
                if (t.arrIndex < t.array.length) return { done: !1, value: t.array[t.arrIndex++] }
                ;(t.array = void 0), (t.arrIndex = 0)
              }
              if (t.collIndex < e.length) {
                let r = e[t.collIndex++]
                cT(r) ? (t.iterator = r[Symbol.iterator]()) : r && typeof r.length == 'number' && (t.array = r)
              }
            } while (t.iterator || t.array || t.collIndex < e.length)
            return Ti
          },
        )
      : Q0
  }
  var Is,
    Q0,
    Ti,
    Io,
    Od,
    ms = x(() => {
      'use strict'
      Is = class e {
        static {
          a(this, 'StreamImpl')
        }
        constructor(t, r) {
          ;(this.startFn = t), (this.nextFn = r)
        }
        iterator() {
          let t = { state: this.startFn(), next: a(() => this.nextFn(t.state), 'next'), [Symbol.iterator]: () => t }
          return t
        }
        [Symbol.iterator]() {
          return this.iterator()
        }
        isEmpty() {
          return !!this.iterator().next().done
        }
        count() {
          let t = this.iterator(),
            r = 0,
            n = t.next()
          for (; !n.done; ) r++, (n = t.next())
          return r
        }
        toArray() {
          let t = [],
            r = this.iterator(),
            n
          do (n = r.next()), n.value !== void 0 && t.push(n.value)
          while (!n.done)
          return t
        }
        toSet() {
          return new Set(this)
        }
        toMap(t, r) {
          let n = this.map((i) => [t ? t(i) : i, r ? r(i) : i])
          return new Map(n)
        }
        toString() {
          return this.join()
        }
        concat(t) {
          return new e(
            () => ({ first: this.startFn(), firstDone: !1, iterator: t[Symbol.iterator]() }),
            (r) => {
              let n
              if (!r.firstDone) {
                do if (((n = this.nextFn(r.first)), !n.done)) return n
                while (!n.done)
                r.firstDone = !0
              }
              do if (((n = r.iterator.next()), !n.done)) return n
              while (!n.done)
              return Ti
            },
          )
        }
        join(t = ',') {
          let r = this.iterator(),
            n = '',
            i,
            s = !1
          do (i = r.next()), i.done || (s && (n += t), (n += Zvt(i.value))), (s = !0)
          while (!i.done)
          return n
        }
        indexOf(t, r = 0) {
          let n = this.iterator(),
            i = 0,
            s = n.next()
          for (; !s.done; ) {
            if (i >= r && s.value === t) return i
            ;(s = n.next()), i++
          }
          return -1
        }
        every(t) {
          let r = this.iterator(),
            n = r.next()
          for (; !n.done; ) {
            if (!t(n.value)) return !1
            n = r.next()
          }
          return !0
        }
        some(t) {
          let r = this.iterator(),
            n = r.next()
          for (; !n.done; ) {
            if (t(n.value)) return !0
            n = r.next()
          }
          return !1
        }
        forEach(t) {
          let r = this.iterator(),
            n = 0,
            i = r.next()
          for (; !i.done; ) t(i.value, n), (i = r.next()), n++
        }
        map(t) {
          return new e(this.startFn, (r) => {
            let { done: n, value: i } = this.nextFn(r)
            return n ? Ti : { done: !1, value: t(i) }
          })
        }
        filter(t) {
          return new e(this.startFn, (r) => {
            let n
            do if (((n = this.nextFn(r)), !n.done && t(n.value))) return n
            while (!n.done)
            return Ti
          })
        }
        nonNullable() {
          return this.filter((t) => t != null)
        }
        reduce(t, r) {
          let n = this.iterator(),
            i = r,
            s = n.next()
          for (; !s.done; ) i === void 0 ? (i = s.value) : (i = t(i, s.value)), (s = n.next())
          return i
        }
        reduceRight(t, r) {
          return this.recursiveReduce(this.iterator(), t, r)
        }
        recursiveReduce(t, r, n) {
          let i = t.next()
          if (i.done) return n
          let s = this.recursiveReduce(t, r, n)
          return s === void 0 ? i.value : r(s, i.value)
        }
        find(t) {
          let r = this.iterator(),
            n = r.next()
          for (; !n.done; ) {
            if (t(n.value)) return n.value
            n = r.next()
          }
        }
        findIndex(t) {
          let r = this.iterator(),
            n = 0,
            i = r.next()
          for (; !i.done; ) {
            if (t(i.value)) return n
            ;(i = r.next()), n++
          }
          return -1
        }
        includes(t) {
          let r = this.iterator(),
            n = r.next()
          for (; !n.done; ) {
            if (n.value === t) return !0
            n = r.next()
          }
          return !1
        }
        flatMap(t) {
          return new e(
            () => ({ this: this.startFn() }),
            (r) => {
              do {
                if (r.iterator) {
                  let s = r.iterator.next()
                  if (s.done) r.iterator = void 0
                  else return s
                }
                let { done: n, value: i } = this.nextFn(r.this)
                if (!n) {
                  let s = t(i)
                  if (cT(s)) r.iterator = s[Symbol.iterator]()
                  else return { done: !1, value: s }
                }
              } while (r.iterator)
              return Ti
            },
          )
        }
        flat(t) {
          if ((t === void 0 && (t = 1), t <= 0)) return this
          let r = t > 1 ? this.flat(t - 1) : this
          return new e(
            () => ({ this: r.startFn() }),
            (n) => {
              do {
                if (n.iterator) {
                  let o = n.iterator.next()
                  if (o.done) n.iterator = void 0
                  else return o
                }
                let { done: i, value: s } = r.nextFn(n.this)
                if (!i)
                  if (cT(s)) n.iterator = s[Symbol.iterator]()
                  else return { done: !1, value: s }
              } while (n.iterator)
              return Ti
            },
          )
        }
        head() {
          let r = this.iterator().next()
          if (!r.done) return r.value
        }
        tail(t = 1) {
          return new e(() => {
            let r = this.startFn()
            for (let n = 0; n < t; n++) if (this.nextFn(r).done) return r
            return r
          }, this.nextFn)
        }
        limit(t) {
          return new e(
            () => ({ size: 0, state: this.startFn() }),
            (r) => (r.size++, r.size > t ? Ti : this.nextFn(r.state)),
          )
        }
        distinct(t) {
          return new e(
            () => ({ set: new Set(), internalState: this.startFn() }),
            (r) => {
              let n
              do
                if (((n = this.nextFn(r.internalState)), !n.done)) {
                  let i = t ? t(n.value) : n.value
                  if (!r.set.has(i)) return r.set.add(i), n
                }
              while (!n.done)
              return Ti
            },
          )
        }
        exclude(t, r) {
          let n = new Set()
          for (let i of t) {
            let s = r ? r(i) : i
            n.add(s)
          }
          return this.filter((i) => {
            let s = r ? r(i) : i
            return !n.has(s)
          })
        }
      }
      a(Zvt, 'toString')
      a(cT, 'isIterable')
      ;(Q0 = new Is(
        () => {},
        () => Ti,
      )),
        (Ti = Object.freeze({ done: !0, value: void 0 }))
      a(kr, 'stream')
      Io = class extends Is {
        static {
          a(this, 'TreeStreamImpl')
        }
        constructor(t, r, n) {
          super(
            () => ({ iterators: n?.includeRoot ? [[t][Symbol.iterator]()] : [r(t)[Symbol.iterator]()], pruned: !1 }),
            (i) => {
              for (i.pruned && (i.iterators.pop(), (i.pruned = !1)); i.iterators.length > 0; ) {
                let o = i.iterators[i.iterators.length - 1].next()
                if (o.done) i.iterators.pop()
                else return i.iterators.push(r(o.value)[Symbol.iterator]()), o
              }
              return Ti
            },
          )
        }
        iterator() {
          let t = {
            state: this.startFn(),
            next: a(() => this.nextFn(t.state), 'next'),
            prune: a(() => {
              t.state.pruned = !0
            }, 'prune'),
            [Symbol.iterator]: () => t,
          }
          return t
        }
      }
      ;(function (e) {
        function t(s) {
          return s.reduce((o, l) => o + l, 0)
        }
        a(t, 'sum'), (e.sum = t)
        function r(s) {
          return s.reduce((o, l) => o * l, 0)
        }
        a(r, 'product'), (e.product = r)
        function n(s) {
          return s.reduce((o, l) => Math.min(o, l))
        }
        a(n, 'min'), (e.min = n)
        function i(s) {
          return s.reduce((o, l) => Math.max(o, l))
        }
        a(i, 'max'), (e.max = i)
      })(Od || (Od = {}))
    })
  var hT = {}
  Oe(hT, {
    DefaultNameRegexp: () => uT,
    RangeComparison: () => Mo,
    compareRange: () => SK,
    findCommentNode: () => u6,
    findDeclarationNodeAtOffset: () => t3t,
    findLeafNodeAtOffset: () => h6,
    findLeafNodeBeforeOffset: () => _K,
    flattenCst: () => Jvt,
    getInteriorNodes: () => n3t,
    getNextNode: () => e3t,
    getPreviousNode: () => wK,
    getStartlineNode: () => r3t,
    inRange: () => c6,
    isChildNode: () => l6,
    isCommentNode: () => o6,
    streamCst: () => xh,
    toDocumentSegment: () => bh,
    tokenToRange: () => Pd,
  })
  function xh(e) {
    return new Io(e, (t) => (Va(t) ? t.content : []), { includeRoot: !0 })
  }
  function Jvt(e) {
    return xh(e).filter(Vc)
  }
  function l6(e, t) {
    for (; e.container; ) if (((e = e.container), e === t)) return !0
    return !1
  }
  function Pd(e) {
    return {
      start: { character: e.startColumn - 1, line: e.startLine - 1 },
      end: { character: e.endColumn, line: e.endLine - 1 },
    }
  }
  function bh(e) {
    if (!e) return
    let { offset: t, end: r, range: n } = e
    return { range: n, offset: t, end: r, length: r - t }
  }
  function SK(e, t) {
    if (e.end.line < t.start.line || (e.end.line === t.start.line && e.end.character <= t.start.character))
      return Mo.Before
    if (e.start.line > t.end.line || (e.start.line === t.end.line && e.start.character >= t.end.character))
      return Mo.After
    let r = e.start.line > t.start.line || (e.start.line === t.start.line && e.start.character >= t.start.character),
      n = e.end.line < t.end.line || (e.end.line === t.end.line && e.end.character <= t.end.character)
    return r && n ? Mo.Inside : r ? Mo.OverlapBack : n ? Mo.OverlapFront : Mo.Outside
  }
  function c6(e, t) {
    return SK(e, t) > Mo.After
  }
  function t3t(e, t, r = uT) {
    if (e) {
      if (t > 0) {
        let n = t - e.offset,
          i = e.text.charAt(n)
        r.test(i) || t--
      }
      return h6(e, t)
    }
  }
  function u6(e, t) {
    if (e) {
      let r = wK(e, !0)
      if (r && o6(r, t)) return r
      if (K0(e)) {
        let n = e.content.findIndex((i) => !i.hidden)
        for (let i = n - 1; i >= 0; i--) {
          let s = e.content[i]
          if (o6(s, t)) return s
        }
      }
    }
  }
  function o6(e, t) {
    return Vc(e) && t.includes(e.tokenType.name)
  }
  function h6(e, t) {
    if (Vc(e)) return e
    if (Va(e)) {
      let r = CK(e, t, !1)
      if (r) return h6(r, t)
    }
  }
  function _K(e, t) {
    if (Vc(e)) return e
    if (Va(e)) {
      let r = CK(e, t, !0)
      if (r) return _K(r, t)
    }
  }
  function CK(e, t, r) {
    let n = 0,
      i = e.content.length - 1,
      s
    for (; n <= i; ) {
      let o = Math.floor((n + i) / 2),
        l = e.content[o]
      if (l.offset <= t && l.end > t) return l
      l.end <= t ? ((s = r ? l : void 0), (n = o + 1)) : (i = o - 1)
    }
    return s
  }
  function wK(e, t = !0) {
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e)
      for (; n > 0; ) {
        n--
        let i = r.content[n]
        if (t || !i.hidden) return i
      }
      e = r
    }
  }
  function e3t(e, t = !0) {
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e),
        i = r.content.length - 1
      for (; n < i; ) {
        n++
        let s = r.content[n]
        if (t || !s.hidden) return s
      }
      e = r
    }
  }
  function r3t(e) {
    if (e.range.start.character === 0) return e
    let t = e.range.start.line,
      r = e,
      n
    for (; e.container; ) {
      let i = e.container,
        s = n ?? i.content.indexOf(e)
      if ((s === 0 ? ((e = i), (n = void 0)) : ((n = s - 1), (e = i.content[n])), e.range.start.line !== t)) break
      r = e
    }
    return r
  }
  function n3t(e, t) {
    let r = i3t(e, t)
    return r ? r.parent.content.slice(r.a + 1, r.b) : []
  }
  function i3t(e, t) {
    let r = TK(e),
      n = TK(t),
      i
    for (let s = 0; s < r.length && s < n.length; s++) {
      let o = r[s],
        l = n[s]
      if (o.parent === l.parent) i = { parent: o.parent, a: o.index, b: l.index }
      else break
    }
    return i
  }
  function TK(e) {
    let t = []
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e)
      t.push({ parent: r, index: n }), (e = r)
    }
    return t.reverse()
  }
  var Mo,
    uT,
    Wa = x(() => {
      'use strict'
      za()
      ms()
      a(xh, 'streamCst')
      a(Jvt, 'flattenCst')
      a(l6, 'isChildNode')
      a(Pd, 'tokenToRange')
      a(bh, 'toDocumentSegment')
      ;(function (e) {
        ;(e[(e.Before = 0)] = 'Before'),
          (e[(e.After = 1)] = 'After'),
          (e[(e.OverlapFront = 2)] = 'OverlapFront'),
          (e[(e.OverlapBack = 3)] = 'OverlapBack'),
          (e[(e.Inside = 4)] = 'Inside'),
          (e[(e.Outside = 5)] = 'Outside')
      })(Mo || (Mo = {}))
      a(SK, 'compareRange')
      a(c6, 'inRange')
      uT = /^[\w\p{L}]$/u
      a(t3t, 'findDeclarationNodeAtOffset')
      a(u6, 'findCommentNode')
      a(o6, 'isCommentNode')
      a(h6, 'findLeafNodeAtOffset')
      a(_K, 'findLeafNodeBeforeOffset')
      a(CK, 'binarySearch')
      a(wK, 'getPreviousNode')
      a(e3t, 'getNextNode')
      a(r3t, 'getStartlineNode')
      a(n3t, 'getInteriorNodes')
      a(i3t, 'getCommonParent')
      a(TK, 'getParentChain')
    })
  function Oo(e) {
    throw new Error('Error! The input value was not handled.')
  }
  var kh,
    fT = x(() => {
      'use strict'
      kh = class extends Error {
        static {
          a(this, 'ErrorWithLocation')
        }
        constructor(t, r) {
          super(t ? `${r} at ${t.range.start.line}:${t.range.start.character}` : r)
        }
      }
      a(Oo, 'assertUnreachable')
    })
  var a1 = {}
  Oe(a1, {
    AbstractElement: () => $d,
    AbstractRule: () => Bd,
    AbstractType: () => Fd,
    Action: () => ip,
    Alternatives: () => sp,
    ArrayLiteral: () => Gd,
    ArrayType: () => Vd,
    Assignment: () => ap,
    BooleanLiteral: () => zd,
    CharacterRange: () => op,
    Condition: () => Z0,
    Conjunction: () => Wd,
    CrossReference: () => lp,
    Disjunction: () => Ud,
    EndOfFile: () => cp,
    Grammar: () => jd,
    GrammarImport: () => t1,
    Group: () => up,
    InferredType: () => qd,
    Interface: () => Hd,
    Keyword: () => hp,
    LangiumGrammarAstReflection: () => Tp,
    LangiumGrammarTerminals: () => s3t,
    NamedArgument: () => e1,
    NegatedToken: () => fp,
    Negation: () => Yd,
    NumberLiteral: () => Xd,
    Parameter: () => Kd,
    ParameterReference: () => Qd,
    ParserRule: () => Zd,
    ReferenceType: () => Jd,
    RegexToken: () => dp,
    ReturnType: () => r1,
    RuleCall: () => pp,
    SimpleType: () => tp,
    StringLiteral: () => ep,
    TerminalAlternatives: () => mp,
    TerminalGroup: () => gp,
    TerminalRule: () => Th,
    TerminalRuleCall: () => yp,
    Type: () => rp,
    TypeAttribute: () => n1,
    TypeDefinition: () => dT,
    UnionType: () => np,
    UnorderedGroup: () => xp,
    UntilToken: () => bp,
    ValueLiteral: () => J0,
    Wildcard: () => kp,
    isAbstractElement: () => i1,
    isAbstractRule: () => a3t,
    isAbstractType: () => o3t,
    isAction: () => Sl,
    isAlternatives: () => yT,
    isArrayLiteral: () => f3t,
    isArrayType: () => f6,
    isAssignment: () => Ua,
    isBooleanLiteral: () => d6,
    isCharacterRange: () => T6,
    isCondition: () => l3t,
    isConjunction: () => p6,
    isCrossReference: () => Sh,
    isDisjunction: () => m6,
    isEndOfFile: () => S6,
    isFeatureName: () => c3t,
    isGrammar: () => d3t,
    isGrammarImport: () => p3t,
    isGroup: () => zc,
    isInferredType: () => pT,
    isInterface: () => mT,
    isKeyword: () => ca,
    isNamedArgument: () => m3t,
    isNegatedToken: () => _6,
    isNegation: () => g6,
    isNumberLiteral: () => g3t,
    isParameter: () => y3t,
    isParameterReference: () => y6,
    isParserRule: () => Si,
    isPrimitiveType: () => EK,
    isReferenceType: () => x6,
    isRegexToken: () => C6,
    isReturnType: () => b6,
    isRuleCall: () => ja,
    isSimpleType: () => gT,
    isStringLiteral: () => x3t,
    isTerminalAlternatives: () => w6,
    isTerminalGroup: () => E6,
    isTerminalRule: () => Ms,
    isTerminalRuleCall: () => xT,
    isType: () => s1,
    isTypeAttribute: () => b3t,
    isTypeDefinition: () => u3t,
    isUnionType: () => k6,
    isUnorderedGroup: () => bT,
    isUntilToken: () => v6,
    isValueLiteral: () => h3t,
    isWildcard: () => A6,
    reflection: () => Re,
  })
  function a3t(e) {
    return Re.isInstance(e, Bd)
  }
  function o3t(e) {
    return Re.isInstance(e, Fd)
  }
  function l3t(e) {
    return Re.isInstance(e, Z0)
  }
  function c3t(e) {
    return (
      EK(e) ||
      e === 'current' ||
      e === 'entry' ||
      e === 'extends' ||
      e === 'false' ||
      e === 'fragment' ||
      e === 'grammar' ||
      e === 'hidden' ||
      e === 'import' ||
      e === 'interface' ||
      e === 'returns' ||
      e === 'terminal' ||
      e === 'true' ||
      e === 'type' ||
      e === 'infer' ||
      e === 'infers' ||
      e === 'with' ||
      (typeof e == 'string' && /\^?[_a-zA-Z][\w_]*/.test(e))
    )
  }
  function EK(e) {
    return e === 'string' || e === 'number' || e === 'boolean' || e === 'Date' || e === 'bigint'
  }
  function u3t(e) {
    return Re.isInstance(e, dT)
  }
  function h3t(e) {
    return Re.isInstance(e, J0)
  }
  function i1(e) {
    return Re.isInstance(e, $d)
  }
  function f3t(e) {
    return Re.isInstance(e, Gd)
  }
  function f6(e) {
    return Re.isInstance(e, Vd)
  }
  function d6(e) {
    return Re.isInstance(e, zd)
  }
  function p6(e) {
    return Re.isInstance(e, Wd)
  }
  function m6(e) {
    return Re.isInstance(e, Ud)
  }
  function d3t(e) {
    return Re.isInstance(e, jd)
  }
  function p3t(e) {
    return Re.isInstance(e, t1)
  }
  function pT(e) {
    return Re.isInstance(e, qd)
  }
  function mT(e) {
    return Re.isInstance(e, Hd)
  }
  function m3t(e) {
    return Re.isInstance(e, e1)
  }
  function g6(e) {
    return Re.isInstance(e, Yd)
  }
  function g3t(e) {
    return Re.isInstance(e, Xd)
  }
  function y3t(e) {
    return Re.isInstance(e, Kd)
  }
  function y6(e) {
    return Re.isInstance(e, Qd)
  }
  function Si(e) {
    return Re.isInstance(e, Zd)
  }
  function x6(e) {
    return Re.isInstance(e, Jd)
  }
  function b6(e) {
    return Re.isInstance(e, r1)
  }
  function gT(e) {
    return Re.isInstance(e, tp)
  }
  function x3t(e) {
    return Re.isInstance(e, ep)
  }
  function Ms(e) {
    return Re.isInstance(e, Th)
  }
  function s1(e) {
    return Re.isInstance(e, rp)
  }
  function b3t(e) {
    return Re.isInstance(e, n1)
  }
  function k6(e) {
    return Re.isInstance(e, np)
  }
  function Sl(e) {
    return Re.isInstance(e, ip)
  }
  function yT(e) {
    return Re.isInstance(e, sp)
  }
  function Ua(e) {
    return Re.isInstance(e, ap)
  }
  function T6(e) {
    return Re.isInstance(e, op)
  }
  function Sh(e) {
    return Re.isInstance(e, lp)
  }
  function S6(e) {
    return Re.isInstance(e, cp)
  }
  function zc(e) {
    return Re.isInstance(e, up)
  }
  function ca(e) {
    return Re.isInstance(e, hp)
  }
  function _6(e) {
    return Re.isInstance(e, fp)
  }
  function C6(e) {
    return Re.isInstance(e, dp)
  }
  function ja(e) {
    return Re.isInstance(e, pp)
  }
  function w6(e) {
    return Re.isInstance(e, mp)
  }
  function E6(e) {
    return Re.isInstance(e, gp)
  }
  function xT(e) {
    return Re.isInstance(e, yp)
  }
  function bT(e) {
    return Re.isInstance(e, xp)
  }
  function v6(e) {
    return Re.isInstance(e, bp)
  }
  function A6(e) {
    return Re.isInstance(e, kp)
  }
  var s3t,
    Bd,
    Fd,
    Z0,
    dT,
    J0,
    $d,
    Gd,
    Vd,
    zd,
    Wd,
    Ud,
    jd,
    t1,
    qd,
    Hd,
    e1,
    Yd,
    Xd,
    Kd,
    Qd,
    Zd,
    Jd,
    r1,
    tp,
    ep,
    Th,
    rp,
    n1,
    np,
    ip,
    sp,
    ap,
    op,
    lp,
    cp,
    up,
    hp,
    fp,
    dp,
    pp,
    mp,
    gp,
    yp,
    xp,
    bp,
    kp,
    Tp,
    Re,
    Po = x(() => {
      'use strict'
      za()
      ;(s3t = {
        ID: /\^?[_a-zA-Z][\w_]*/,
        STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
        NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
        RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
        WS: /\s+/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
      }),
        (Bd = 'AbstractRule')
      a(a3t, 'isAbstractRule')
      Fd = 'AbstractType'
      a(o3t, 'isAbstractType')
      Z0 = 'Condition'
      a(l3t, 'isCondition')
      a(c3t, 'isFeatureName')
      a(EK, 'isPrimitiveType')
      dT = 'TypeDefinition'
      a(u3t, 'isTypeDefinition')
      J0 = 'ValueLiteral'
      a(h3t, 'isValueLiteral')
      $d = 'AbstractElement'
      a(i1, 'isAbstractElement')
      Gd = 'ArrayLiteral'
      a(f3t, 'isArrayLiteral')
      Vd = 'ArrayType'
      a(f6, 'isArrayType')
      zd = 'BooleanLiteral'
      a(d6, 'isBooleanLiteral')
      Wd = 'Conjunction'
      a(p6, 'isConjunction')
      Ud = 'Disjunction'
      a(m6, 'isDisjunction')
      jd = 'Grammar'
      a(d3t, 'isGrammar')
      t1 = 'GrammarImport'
      a(p3t, 'isGrammarImport')
      qd = 'InferredType'
      a(pT, 'isInferredType')
      Hd = 'Interface'
      a(mT, 'isInterface')
      e1 = 'NamedArgument'
      a(m3t, 'isNamedArgument')
      Yd = 'Negation'
      a(g6, 'isNegation')
      Xd = 'NumberLiteral'
      a(g3t, 'isNumberLiteral')
      Kd = 'Parameter'
      a(y3t, 'isParameter')
      Qd = 'ParameterReference'
      a(y6, 'isParameterReference')
      Zd = 'ParserRule'
      a(Si, 'isParserRule')
      Jd = 'ReferenceType'
      a(x6, 'isReferenceType')
      r1 = 'ReturnType'
      a(b6, 'isReturnType')
      tp = 'SimpleType'
      a(gT, 'isSimpleType')
      ep = 'StringLiteral'
      a(x3t, 'isStringLiteral')
      Th = 'TerminalRule'
      a(Ms, 'isTerminalRule')
      rp = 'Type'
      a(s1, 'isType')
      n1 = 'TypeAttribute'
      a(b3t, 'isTypeAttribute')
      np = 'UnionType'
      a(k6, 'isUnionType')
      ip = 'Action'
      a(Sl, 'isAction')
      sp = 'Alternatives'
      a(yT, 'isAlternatives')
      ap = 'Assignment'
      a(Ua, 'isAssignment')
      op = 'CharacterRange'
      a(T6, 'isCharacterRange')
      lp = 'CrossReference'
      a(Sh, 'isCrossReference')
      cp = 'EndOfFile'
      a(S6, 'isEndOfFile')
      up = 'Group'
      a(zc, 'isGroup')
      hp = 'Keyword'
      a(ca, 'isKeyword')
      fp = 'NegatedToken'
      a(_6, 'isNegatedToken')
      dp = 'RegexToken'
      a(C6, 'isRegexToken')
      pp = 'RuleCall'
      a(ja, 'isRuleCall')
      mp = 'TerminalAlternatives'
      a(w6, 'isTerminalAlternatives')
      gp = 'TerminalGroup'
      a(E6, 'isTerminalGroup')
      yp = 'TerminalRuleCall'
      a(xT, 'isTerminalRuleCall')
      xp = 'UnorderedGroup'
      a(bT, 'isUnorderedGroup')
      bp = 'UntilToken'
      a(v6, 'isUntilToken')
      kp = 'Wildcard'
      a(A6, 'isWildcard')
      ;(Tp = class extends gh {
        static {
          a(this, 'LangiumGrammarAstReflection')
        }
        getAllTypes() {
          return [
            $d,
            Bd,
            Fd,
            ip,
            sp,
            Gd,
            Vd,
            ap,
            zd,
            op,
            Z0,
            Wd,
            lp,
            Ud,
            cp,
            jd,
            t1,
            up,
            qd,
            Hd,
            hp,
            e1,
            fp,
            Yd,
            Xd,
            Kd,
            Qd,
            Zd,
            Jd,
            dp,
            r1,
            pp,
            tp,
            ep,
            mp,
            gp,
            Th,
            yp,
            rp,
            n1,
            dT,
            np,
            xp,
            bp,
            J0,
            kp,
          ]
        }
        computeIsSubtype(t, r) {
          switch (t) {
            case ip:
            case sp:
            case ap:
            case op:
            case lp:
            case cp:
            case up:
            case hp:
            case fp:
            case dp:
            case pp:
            case mp:
            case gp:
            case yp:
            case xp:
            case bp:
            case kp:
              return this.isSubtype($d, r)
            case Gd:
            case Xd:
            case ep:
              return this.isSubtype(J0, r)
            case Vd:
            case Jd:
            case tp:
            case np:
              return this.isSubtype(dT, r)
            case zd:
              return this.isSubtype(Z0, r) || this.isSubtype(J0, r)
            case Wd:
            case Ud:
            case Yd:
            case Qd:
              return this.isSubtype(Z0, r)
            case qd:
            case Hd:
            case rp:
              return this.isSubtype(Fd, r)
            case Zd:
              return this.isSubtype(Bd, r) || this.isSubtype(Fd, r)
            case Th:
              return this.isSubtype(Bd, r)
            default:
              return !1
          }
        }
        getReferenceType(t) {
          let r = `${t.container.$type}:${t.property}`
          switch (r) {
            case 'Action:type':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType':
            case 'SimpleType:typeRef':
              return Fd
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule':
              return Bd
            case 'Grammar:usedGrammars':
              return jd
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter':
              return Kd
            case 'TerminalRuleCall:rule':
              return Th
            default:
              throw new Error(`${r} is not a valid reference id.`)
          }
        }
        getTypeMetaData(t) {
          switch (t) {
            case $d:
              return { name: $d, properties: [{ name: 'cardinality' }, { name: 'lookahead' }] }
            case Gd:
              return { name: Gd, properties: [{ name: 'elements', defaultValue: [] }] }
            case Vd:
              return { name: Vd, properties: [{ name: 'elementType' }] }
            case zd:
              return { name: zd, properties: [{ name: 'true', defaultValue: !1 }] }
            case Wd:
              return { name: Wd, properties: [{ name: 'left' }, { name: 'right' }] }
            case Ud:
              return { name: Ud, properties: [{ name: 'left' }, { name: 'right' }] }
            case jd:
              return {
                name: jd,
                properties: [
                  { name: 'definesHiddenTokens', defaultValue: !1 },
                  { name: 'hiddenTokens', defaultValue: [] },
                  { name: 'imports', defaultValue: [] },
                  { name: 'interfaces', defaultValue: [] },
                  { name: 'isDeclared', defaultValue: !1 },
                  { name: 'name' },
                  { name: 'rules', defaultValue: [] },
                  { name: 'types', defaultValue: [] },
                  { name: 'usedGrammars', defaultValue: [] },
                ],
              }
            case t1:
              return { name: t1, properties: [{ name: 'path' }] }
            case qd:
              return { name: qd, properties: [{ name: 'name' }] }
            case Hd:
              return {
                name: Hd,
                properties: [
                  { name: 'attributes', defaultValue: [] },
                  { name: 'name' },
                  { name: 'superTypes', defaultValue: [] },
                ],
              }
            case e1:
              return {
                name: e1,
                properties: [{ name: 'calledByName', defaultValue: !1 }, { name: 'parameter' }, { name: 'value' }],
              }
            case Yd:
              return { name: Yd, properties: [{ name: 'value' }] }
            case Xd:
              return { name: Xd, properties: [{ name: 'value' }] }
            case Kd:
              return { name: Kd, properties: [{ name: 'name' }] }
            case Qd:
              return { name: Qd, properties: [{ name: 'parameter' }] }
            case Zd:
              return {
                name: Zd,
                properties: [
                  { name: 'dataType' },
                  { name: 'definesHiddenTokens', defaultValue: !1 },
                  { name: 'definition' },
                  { name: 'entry', defaultValue: !1 },
                  { name: 'fragment', defaultValue: !1 },
                  { name: 'hiddenTokens', defaultValue: [] },
                  { name: 'inferredType' },
                  { name: 'name' },
                  { name: 'parameters', defaultValue: [] },
                  { name: 'returnType' },
                  { name: 'wildcard', defaultValue: !1 },
                ],
              }
            case Jd:
              return { name: Jd, properties: [{ name: 'referenceType' }] }
            case r1:
              return { name: r1, properties: [{ name: 'name' }] }
            case tp:
              return { name: tp, properties: [{ name: 'primitiveType' }, { name: 'stringType' }, { name: 'typeRef' }] }
            case ep:
              return { name: ep, properties: [{ name: 'value' }] }
            case Th:
              return {
                name: Th,
                properties: [
                  { name: 'definition' },
                  { name: 'fragment', defaultValue: !1 },
                  { name: 'hidden', defaultValue: !1 },
                  { name: 'name' },
                  { name: 'type' },
                ],
              }
            case rp:
              return { name: rp, properties: [{ name: 'name' }, { name: 'type' }] }
            case n1:
              return {
                name: n1,
                properties: [
                  { name: 'defaultValue' },
                  { name: 'isOptional', defaultValue: !1 },
                  { name: 'name' },
                  { name: 'type' },
                ],
              }
            case np:
              return { name: np, properties: [{ name: 'types', defaultValue: [] }] }
            case ip:
              return {
                name: ip,
                properties: [
                  { name: 'cardinality' },
                  { name: 'feature' },
                  { name: 'inferredType' },
                  { name: 'lookahead' },
                  { name: 'operator' },
                  { name: 'type' },
                ],
              }
            case sp:
              return {
                name: sp,
                properties: [{ name: 'cardinality' }, { name: 'elements', defaultValue: [] }, { name: 'lookahead' }],
              }
            case ap:
              return {
                name: ap,
                properties: [
                  { name: 'cardinality' },
                  { name: 'feature' },
                  { name: 'lookahead' },
                  { name: 'operator' },
                  { name: 'terminal' },
                ],
              }
            case op:
              return {
                name: op,
                properties: [{ name: 'cardinality' }, { name: 'left' }, { name: 'lookahead' }, { name: 'right' }],
              }
            case lp:
              return {
                name: lp,
                properties: [
                  { name: 'cardinality' },
                  { name: 'deprecatedSyntax', defaultValue: !1 },
                  { name: 'lookahead' },
                  { name: 'terminal' },
                  { name: 'type' },
                ],
              }
            case cp:
              return { name: cp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }] }
            case up:
              return {
                name: up,
                properties: [
                  { name: 'cardinality' },
                  { name: 'elements', defaultValue: [] },
                  { name: 'guardCondition' },
                  { name: 'lookahead' },
                ],
              }
            case hp:
              return { name: hp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }, { name: 'value' }] }
            case fp:
              return { name: fp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }, { name: 'terminal' }] }
            case dp:
              return { name: dp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }, { name: 'regex' }] }
            case pp:
              return {
                name: pp,
                properties: [
                  { name: 'arguments', defaultValue: [] },
                  { name: 'cardinality' },
                  { name: 'lookahead' },
                  { name: 'rule' },
                ],
              }
            case mp:
              return {
                name: mp,
                properties: [{ name: 'cardinality' }, { name: 'elements', defaultValue: [] }, { name: 'lookahead' }],
              }
            case gp:
              return {
                name: gp,
                properties: [{ name: 'cardinality' }, { name: 'elements', defaultValue: [] }, { name: 'lookahead' }],
              }
            case yp:
              return { name: yp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }, { name: 'rule' }] }
            case xp:
              return {
                name: xp,
                properties: [{ name: 'cardinality' }, { name: 'elements', defaultValue: [] }, { name: 'lookahead' }],
              }
            case bp:
              return { name: bp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }, { name: 'terminal' }] }
            case kp:
              return { name: kp, properties: [{ name: 'cardinality' }, { name: 'lookahead' }] }
            default:
              return { name: t, properties: [] }
          }
        }
      }),
        (Re = new Tp())
    })
  var TT = {}
  Oe(TT, {
    assignMandatoryProperties: () => D6,
    copyAstNode: () => R6,
    findLocalReferences: () => T3t,
    findRootNode: () => o1,
    getContainerOfType: () => _h,
    getDocument: () => _i,
    hasContainerOfType: () => k3t,
    linkContentToContainer: () => kT,
    streamAllContents: () => Bo,
    streamAst: () => ua,
    streamContents: () => l1,
    streamReferences: () => Sp,
  })
  function kT(e) {
    for (let [t, r] of Object.entries(e))
      t.startsWith('$') ||
        (Array.isArray(r)
          ? r.forEach((n, i) => {
              un(n) && ((n.$container = e), (n.$containerProperty = t), (n.$containerIndex = i))
            })
          : un(r) && ((r.$container = e), (r.$containerProperty = t)))
  }
  function _h(e, t) {
    let r = e
    for (; r; ) {
      if (t(r)) return r
      r = r.$container
    }
  }
  function k3t(e, t) {
    let r = e
    for (; r; ) {
      if (t(r)) return !0
      r = r.$container
    }
    return !1
  }
  function _i(e) {
    let r = o1(e).$document
    if (!r) throw new Error('AST node has no document.')
    return r
  }
  function o1(e) {
    for (; e.$container; ) e = e.$container
    return e
  }
  function l1(e, t) {
    if (!e) throw new Error('Node must be an AstNode.')
    let r = t?.range
    return new Is(
      () => ({ keys: Object.keys(e), keyIndex: 0, arrayIndex: 0 }),
      (n) => {
        for (; n.keyIndex < n.keys.length; ) {
          let i = n.keys[n.keyIndex]
          if (!i.startsWith('$')) {
            let s = e[i]
            if (un(s)) {
              if ((n.keyIndex++, L6(s, r))) return { done: !1, value: s }
            } else if (Array.isArray(s)) {
              for (; n.arrayIndex < s.length; ) {
                let o = n.arrayIndex++,
                  l = s[o]
                if (un(l) && L6(l, r)) return { done: !1, value: l }
              }
              n.arrayIndex = 0
            }
          }
          n.keyIndex++
        }
        return Ti
      },
    )
  }
  function Bo(e, t) {
    if (!e) throw new Error('Root node must be an AstNode.')
    return new Io(e, (r) => l1(r, t))
  }
  function ua(e, t) {
    if (e) {
      if (t?.range && !L6(e, t.range)) return new Io(e, () => [])
    } else throw new Error('Root node must be an AstNode.')
    return new Io(e, (r) => l1(r, t), { includeRoot: !0 })
  }
  function L6(e, t) {
    var r
    if (!t) return !0
    let n = (r = e.$cstNode) === null || r === void 0 ? void 0 : r.range
    return n ? c6(n, t) : !1
  }
  function Sp(e) {
    return new Is(
      () => ({ keys: Object.keys(e), keyIndex: 0, arrayIndex: 0 }),
      (t) => {
        for (; t.keyIndex < t.keys.length; ) {
          let r = t.keys[t.keyIndex]
          if (!r.startsWith('$')) {
            let n = e[r]
            if (ci(n)) return t.keyIndex++, { done: !1, value: { reference: n, container: e, property: r } }
            if (Array.isArray(n)) {
              for (; t.arrayIndex < n.length; ) {
                let i = t.arrayIndex++,
                  s = n[i]
                if (ci(s)) return { done: !1, value: { reference: s, container: e, property: r, index: i } }
              }
              t.arrayIndex = 0
            }
          }
          t.keyIndex++
        }
        return Ti
      },
    )
  }
  function T3t(e, t = _i(e).parseResult.value) {
    let r = []
    return (
      ua(t).forEach((n) => {
        Sp(n).forEach((i) => {
          i.reference.ref === e && r.push(i.reference)
        })
      }),
      kr(r)
    )
  }
  function D6(e, t) {
    let r = e.getTypeMetaData(t.$type),
      n = t
    for (let i of r.properties) i.defaultValue !== void 0 && n[i.name] === void 0 && (n[i.name] = vK(i.defaultValue))
  }
  function vK(e) {
    return Array.isArray(e) ? [...e.map(vK)] : e
  }
  function R6(e, t) {
    let r = { $type: e.$type }
    for (let [n, i] of Object.entries(e))
      if (!n.startsWith('$'))
        if (un(i)) r[n] = R6(i, t)
        else if (ci(i)) r[n] = t(r, n, i.$refNode, i.$refText)
        else if (Array.isArray(i)) {
          let s = []
          for (let o of i) un(o) ? s.push(R6(o, t)) : ci(o) ? s.push(t(r, n, o.$refNode, o.$refText)) : s.push(o)
          r[n] = s
        } else r[n] = i
    return kT(r), r
  }
  var zi = x(() => {
    'use strict'
    za()
    ms()
    Wa()
    a(kT, 'linkContentToContainer')
    a(_h, 'getContainerOfType')
    a(k3t, 'hasContainerOfType')
    a(_i, 'getDocument')
    a(o1, 'findRootNode')
    a(l1, 'streamContents')
    a(Bo, 'streamAllContents')
    a(ua, 'streamAst')
    a(L6, 'isAstNodeInRange')
    a(Sp, 'streamReferences')
    a(T3t, 'findLocalReferences')
    a(D6, 'assignMandatoryProperties')
    a(vK, 'copyDefaultValue')
    a(R6, 'copyAstNode')
  })
  function Ee(e) {
    return e.charCodeAt(0)
  }
  function ST(e, t) {
    Array.isArray(e)
      ? e.forEach(function (r) {
          t.push(r)
        })
      : t.push(e)
  }
  function _p(e, t) {
    if (e[t] === !0) throw 'duplicate flag ' + t
    let r = e[t]
    e[t] = !0
  }
  function Ch(e) {
    if (e === void 0) throw Error('Internal Error - Should never get here!')
    return !0
  }
  function c1() {
    throw Error('Internal Error - Should never get here!')
  }
  function N6(e) {
    return e.type === 'Character'
  }
  var I6 = x(() => {
    'use strict'
    a(Ee, 'cc')
    a(ST, 'insertToSet')
    a(_p, 'addFlag')
    a(Ch, 'ASSERT_EXISTS')
    a(c1, 'ASSERT_NEVER_REACH_HERE')
    a(N6, 'isCharacter')
  })
  var u1,
    h1,
    M6,
    AK = x(() => {
      'use strict'
      I6()
      u1 = []
      for (let e = Ee('0'); e <= Ee('9'); e++) u1.push(e)
      h1 = [Ee('_')].concat(u1)
      for (let e = Ee('a'); e <= Ee('z'); e++) h1.push(e)
      for (let e = Ee('A'); e <= Ee('Z'); e++) h1.push(e)
      M6 = [
        Ee(' '),
        Ee('\f'),
        Ee(`
`),
        Ee('\r'),
        Ee('	'),
        Ee('\v'),
        Ee('	'),
        Ee('\xA0'),
        Ee('\u1680'),
        Ee('\u2000'),
        Ee('\u2001'),
        Ee('\u2002'),
        Ee('\u2003'),
        Ee('\u2004'),
        Ee('\u2005'),
        Ee('\u2006'),
        Ee('\u2007'),
        Ee('\u2008'),
        Ee('\u2009'),
        Ee('\u200A'),
        Ee('\u2028'),
        Ee('\u2029'),
        Ee('\u202F'),
        Ee('\u205F'),
        Ee('\u3000'),
        Ee('\uFEFF'),
      ]
    })
  var S3t,
    _T,
    _3t,
    wh,
    LK = x(() => {
      'use strict'
      I6()
      AK()
      ;(S3t = /[0-9a-fA-F]/),
        (_T = /[0-9]/),
        (_3t = /[1-9]/),
        (wh = class {
          static {
            a(this, 'RegExpParser')
          }
          constructor() {
            ;(this.idx = 0), (this.input = ''), (this.groupIdx = 0)
          }
          saveState() {
            return { idx: this.idx, input: this.input, groupIdx: this.groupIdx }
          }
          restoreState(t) {
            ;(this.idx = t.idx), (this.input = t.input), (this.groupIdx = t.groupIdx)
          }
          pattern(t) {
            ;(this.idx = 0), (this.input = t), (this.groupIdx = 0), this.consumeChar('/')
            let r = this.disjunction()
            this.consumeChar('/')
            let n = {
              type: 'Flags',
              loc: { begin: this.idx, end: t.length },
              global: !1,
              ignoreCase: !1,
              multiLine: !1,
              unicode: !1,
              sticky: !1,
            }
            for (; this.isRegExpFlag(); )
              switch (this.popChar()) {
                case 'g':
                  _p(n, 'global')
                  break
                case 'i':
                  _p(n, 'ignoreCase')
                  break
                case 'm':
                  _p(n, 'multiLine')
                  break
                case 'u':
                  _p(n, 'unicode')
                  break
                case 'y':
                  _p(n, 'sticky')
                  break
              }
            if (this.idx !== this.input.length) throw Error('Redundant input: ' + this.input.substring(this.idx))
            return { type: 'Pattern', flags: n, value: r, loc: this.loc(0) }
          }
          disjunction() {
            let t = [],
              r = this.idx
            for (t.push(this.alternative()); this.peekChar() === '|'; )
              this.consumeChar('|'), t.push(this.alternative())
            return { type: 'Disjunction', value: t, loc: this.loc(r) }
          }
          alternative() {
            let t = [],
              r = this.idx
            for (; this.isTerm(); ) t.push(this.term())
            return { type: 'Alternative', value: t, loc: this.loc(r) }
          }
          term() {
            return this.isAssertion() ? this.assertion() : this.atom()
          }
          assertion() {
            let t = this.idx
            switch (this.popChar()) {
              case '^':
                return { type: 'StartAnchor', loc: this.loc(t) }
              case '$':
                return { type: 'EndAnchor', loc: this.loc(t) }
              case '\\':
                switch (this.popChar()) {
                  case 'b':
                    return { type: 'WordBoundary', loc: this.loc(t) }
                  case 'B':
                    return { type: 'NonWordBoundary', loc: this.loc(t) }
                }
                throw Error('Invalid Assertion Escape')
              case '(':
                this.consumeChar('?')
                let r
                switch (this.popChar()) {
                  case '=':
                    r = 'Lookahead'
                    break
                  case '!':
                    r = 'NegativeLookahead'
                    break
                }
                Ch(r)
                let n = this.disjunction()
                return this.consumeChar(')'), { type: r, value: n, loc: this.loc(t) }
            }
            return c1()
          }
          quantifier(t = !1) {
            let r,
              n = this.idx
            switch (this.popChar()) {
              case '*':
                r = { atLeast: 0, atMost: 1 / 0 }
                break
              case '+':
                r = { atLeast: 1, atMost: 1 / 0 }
                break
              case '?':
                r = { atLeast: 0, atMost: 1 }
                break
              case '{':
                let i = this.integerIncludingZero()
                switch (this.popChar()) {
                  case '}':
                    r = { atLeast: i, atMost: i }
                    break
                  case ',':
                    let s
                    this.isDigit()
                      ? ((s = this.integerIncludingZero()), (r = { atLeast: i, atMost: s }))
                      : (r = { atLeast: i, atMost: 1 / 0 }),
                      this.consumeChar('}')
                    break
                }
                if (t === !0 && r === void 0) return
                Ch(r)
                break
            }
            if (!(t === !0 && r === void 0) && Ch(r))
              return (
                this.peekChar(0) === '?' ? (this.consumeChar('?'), (r.greedy = !1)) : (r.greedy = !0),
                (r.type = 'Quantifier'),
                (r.loc = this.loc(n)),
                r
              )
          }
          atom() {
            let t,
              r = this.idx
            switch (this.peekChar()) {
              case '.':
                t = this.dotAll()
                break
              case '\\':
                t = this.atomEscape()
                break
              case '[':
                t = this.characterClass()
                break
              case '(':
                t = this.group()
                break
            }
            return (
              t === void 0 && this.isPatternCharacter() && (t = this.patternCharacter()),
              Ch(t) ? ((t.loc = this.loc(r)), this.isQuantifier() && (t.quantifier = this.quantifier()), t) : c1()
            )
          }
          dotAll() {
            return (
              this.consumeChar('.'),
              {
                type: 'Set',
                complement: !0,
                value: [
                  Ee(`
`),
                  Ee('\r'),
                  Ee('\u2028'),
                  Ee('\u2029'),
                ],
              }
            )
          }
          atomEscape() {
            switch ((this.consumeChar('\\'), this.peekChar())) {
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                return this.decimalEscapeAtom()
              case 'd':
              case 'D':
              case 's':
              case 'S':
              case 'w':
              case 'W':
                return this.characterClassEscape()
              case 'f':
              case 'n':
              case 'r':
              case 't':
              case 'v':
                return this.controlEscapeAtom()
              case 'c':
                return this.controlLetterEscapeAtom()
              case '0':
                return this.nulCharacterAtom()
              case 'x':
                return this.hexEscapeSequenceAtom()
              case 'u':
                return this.regExpUnicodeEscapeSequenceAtom()
              default:
                return this.identityEscapeAtom()
            }
          }
          decimalEscapeAtom() {
            return { type: 'GroupBackReference', value: this.positiveInteger() }
          }
          characterClassEscape() {
            let t,
              r = !1
            switch (this.popChar()) {
              case 'd':
                t = u1
                break
              case 'D':
                ;(t = u1), (r = !0)
                break
              case 's':
                t = M6
                break
              case 'S':
                ;(t = M6), (r = !0)
                break
              case 'w':
                t = h1
                break
              case 'W':
                ;(t = h1), (r = !0)
                break
            }
            return Ch(t) ? { type: 'Set', value: t, complement: r } : c1()
          }
          controlEscapeAtom() {
            let t
            switch (this.popChar()) {
              case 'f':
                t = Ee('\f')
                break
              case 'n':
                t = Ee(`
`)
                break
              case 'r':
                t = Ee('\r')
                break
              case 't':
                t = Ee('	')
                break
              case 'v':
                t = Ee('\v')
                break
            }
            return Ch(t) ? { type: 'Character', value: t } : c1()
          }
          controlLetterEscapeAtom() {
            this.consumeChar('c')
            let t = this.popChar()
            if (/[a-zA-Z]/.test(t) === !1) throw Error('Invalid ')
            return { type: 'Character', value: t.toUpperCase().charCodeAt(0) - 64 }
          }
          nulCharacterAtom() {
            return this.consumeChar('0'), { type: 'Character', value: Ee('\0') }
          }
          hexEscapeSequenceAtom() {
            return this.consumeChar('x'), this.parseHexDigits(2)
          }
          regExpUnicodeEscapeSequenceAtom() {
            return this.consumeChar('u'), this.parseHexDigits(4)
          }
          identityEscapeAtom() {
            let t = this.popChar()
            return { type: 'Character', value: Ee(t) }
          }
          classPatternCharacterAtom() {
            switch (this.peekChar()) {
              case `
`:
              case '\r':
              case '\u2028':
              case '\u2029':
              case '\\':
              case ']':
                throw Error('TBD')
              default:
                let t = this.popChar()
                return { type: 'Character', value: Ee(t) }
            }
          }
          characterClass() {
            let t = [],
              r = !1
            for (
              this.consumeChar('['), this.peekChar(0) === '^' && (this.consumeChar('^'), (r = !0));
              this.isClassAtom();

            ) {
              let n = this.classAtom(),
                i = n.type === 'Character'
              if (N6(n) && this.isRangeDash()) {
                this.consumeChar('-')
                let s = this.classAtom(),
                  o = s.type === 'Character'
                if (N6(s)) {
                  if (s.value < n.value) throw Error('Range out of order in character class')
                  t.push({ from: n.value, to: s.value })
                } else ST(n.value, t), t.push(Ee('-')), ST(s.value, t)
              } else ST(n.value, t)
            }
            return this.consumeChar(']'), { type: 'Set', complement: r, value: t }
          }
          classAtom() {
            switch (this.peekChar()) {
              case ']':
              case `
`:
              case '\r':
              case '\u2028':
              case '\u2029':
                throw Error('TBD')
              case '\\':
                return this.classEscape()
              default:
                return this.classPatternCharacterAtom()
            }
          }
          classEscape() {
            switch ((this.consumeChar('\\'), this.peekChar())) {
              case 'b':
                return this.consumeChar('b'), { type: 'Character', value: Ee('\b') }
              case 'd':
              case 'D':
              case 's':
              case 'S':
              case 'w':
              case 'W':
                return this.characterClassEscape()
              case 'f':
              case 'n':
              case 'r':
              case 't':
              case 'v':
                return this.controlEscapeAtom()
              case 'c':
                return this.controlLetterEscapeAtom()
              case '0':
                return this.nulCharacterAtom()
              case 'x':
                return this.hexEscapeSequenceAtom()
              case 'u':
                return this.regExpUnicodeEscapeSequenceAtom()
              default:
                return this.identityEscapeAtom()
            }
          }
          group() {
            let t = !0
            switch ((this.consumeChar('('), this.peekChar(0))) {
              case '?':
                this.consumeChar('?'), this.consumeChar(':'), (t = !1)
                break
              default:
                this.groupIdx++
                break
            }
            let r = this.disjunction()
            this.consumeChar(')')
            let n = { type: 'Group', capturing: t, value: r }
            return t && (n.idx = this.groupIdx), n
          }
          positiveInteger() {
            let t = this.popChar()
            if (_3t.test(t) === !1) throw Error('Expecting a positive integer')
            for (; _T.test(this.peekChar(0)); ) t += this.popChar()
            return parseInt(t, 10)
          }
          integerIncludingZero() {
            let t = this.popChar()
            if (_T.test(t) === !1) throw Error('Expecting an integer')
            for (; _T.test(this.peekChar(0)); ) t += this.popChar()
            return parseInt(t, 10)
          }
          patternCharacter() {
            let t = this.popChar()
            switch (t) {
              case `
`:
              case '\r':
              case '\u2028':
              case '\u2029':
              case '^':
              case '$':
              case '\\':
              case '.':
              case '*':
              case '+':
              case '?':
              case '(':
              case ')':
              case '[':
              case '|':
                throw Error('TBD')
              default:
                return { type: 'Character', value: Ee(t) }
            }
          }
          isRegExpFlag() {
            switch (this.peekChar(0)) {
              case 'g':
              case 'i':
              case 'm':
              case 'u':
              case 'y':
                return !0
              default:
                return !1
            }
          }
          isRangeDash() {
            return this.peekChar() === '-' && this.isClassAtom(1)
          }
          isDigit() {
            return _T.test(this.peekChar(0))
          }
          isClassAtom(t = 0) {
            switch (this.peekChar(t)) {
              case ']':
              case `
`:
              case '\r':
              case '\u2028':
              case '\u2029':
                return !1
              default:
                return !0
            }
          }
          isTerm() {
            return this.isAtom() || this.isAssertion()
          }
          isAtom() {
            if (this.isPatternCharacter()) return !0
            switch (this.peekChar(0)) {
              case '.':
              case '\\':
              case '[':
              case '(':
                return !0
              default:
                return !1
            }
          }
          isAssertion() {
            switch (this.peekChar(0)) {
              case '^':
              case '$':
                return !0
              case '\\':
                switch (this.peekChar(1)) {
                  case 'b':
                  case 'B':
                    return !0
                  default:
                    return !1
                }
              case '(':
                return this.peekChar(1) === '?' && (this.peekChar(2) === '=' || this.peekChar(2) === '!')
              default:
                return !1
            }
          }
          isQuantifier() {
            let t = this.saveState()
            try {
              return this.quantifier(!0) !== void 0
            } catch {
              return !1
            } finally {
              this.restoreState(t)
            }
          }
          isPatternCharacter() {
            switch (this.peekChar()) {
              case '^':
              case '$':
              case '\\':
              case '.':
              case '*':
              case '+':
              case '?':
              case '(':
              case ')':
              case '[':
              case '|':
              case '/':
              case `
`:
              case '\r':
              case '\u2028':
              case '\u2029':
                return !1
              default:
                return !0
            }
          }
          parseHexDigits(t) {
            let r = ''
            for (let i = 0; i < t; i++) {
              let s = this.popChar()
              if (S3t.test(s) === !1) throw Error('Expecting a HexDecimal digits')
              r += s
            }
            return { type: 'Character', value: parseInt(r, 16) }
          }
          peekChar(t = 0) {
            return this.input[this.idx + t]
          }
          popChar() {
            let t = this.peekChar(0)
            return this.consumeChar(void 0), t
          }
          consumeChar(t) {
            if (t !== void 0 && this.input[this.idx] !== t)
              throw Error("Expected: '" + t + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx)
            if (this.idx >= this.input.length) throw Error('Unexpected end of input')
            this.idx++
          }
          loc(t) {
            return { begin: t, end: this.idx }
          }
        })
    })
  var Fo,
    RK = x(() => {
      'use strict'
      Fo = class {
        static {
          a(this, 'BaseRegExpVisitor')
        }
        visitChildren(t) {
          for (let r in t) {
            let n = t[r]
            t.hasOwnProperty(r) &&
              (n.type !== void 0
                ? this.visit(n)
                : Array.isArray(n) &&
                  n.forEach((i) => {
                    this.visit(i)
                  }, this))
          }
        }
        visit(t) {
          switch (t.type) {
            case 'Pattern':
              this.visitPattern(t)
              break
            case 'Flags':
              this.visitFlags(t)
              break
            case 'Disjunction':
              this.visitDisjunction(t)
              break
            case 'Alternative':
              this.visitAlternative(t)
              break
            case 'StartAnchor':
              this.visitStartAnchor(t)
              break
            case 'EndAnchor':
              this.visitEndAnchor(t)
              break
            case 'WordBoundary':
              this.visitWordBoundary(t)
              break
            case 'NonWordBoundary':
              this.visitNonWordBoundary(t)
              break
            case 'Lookahead':
              this.visitLookahead(t)
              break
            case 'NegativeLookahead':
              this.visitNegativeLookahead(t)
              break
            case 'Character':
              this.visitCharacter(t)
              break
            case 'Set':
              this.visitSet(t)
              break
            case 'Group':
              this.visitGroup(t)
              break
            case 'GroupBackReference':
              this.visitGroupBackReference(t)
              break
            case 'Quantifier':
              this.visitQuantifier(t)
              break
          }
          this.visitChildren(t)
        }
        visitPattern(t) {}
        visitFlags(t) {}
        visitDisjunction(t) {}
        visitAlternative(t) {}
        visitStartAnchor(t) {}
        visitEndAnchor(t) {}
        visitWordBoundary(t) {}
        visitNonWordBoundary(t) {}
        visitLookahead(t) {}
        visitNegativeLookahead(t) {}
        visitCharacter(t) {}
        visitSet(t) {}
        visitGroup(t) {}
        visitGroupBackReference(t) {}
        visitQuantifier(t) {}
      }
    })
  var f1 = x(() => {
    'use strict'
    LK()
    RK()
  })
  var CT = {}
  Oe(CT, {
    NEWLINE_REGEXP: () => P6,
    escapeRegExp: () => vh,
    getCaseInsensitivePattern: () => F6,
    getTerminalParts: () => C3t,
    isMultilineComment: () => B6,
    isWhitespace: () => Cp,
    partialMatches: () => $6,
    partialRegExp: () => IK,
    whitespaceCharacters: () => NK,
  })
  function C3t(e) {
    try {
      typeof e != 'string' && (e = e.source), (e = `/${e}/`)
      let t = DK.pattern(e),
        r = []
      for (let n of t.value.value) Eh.reset(e), Eh.visit(n), r.push({ start: Eh.startRegexp, end: Eh.endRegex })
      return r
    } catch {
      return []
    }
  }
  function B6(e) {
    try {
      return (
        typeof e == 'string' && (e = new RegExp(e)),
        (e = e.toString()),
        Eh.reset(e),
        Eh.visit(DK.pattern(e)),
        Eh.multiline
      )
    } catch {
      return !1
    }
  }
  function Cp(e) {
    let t = typeof e == 'string' ? new RegExp(e) : e
    return NK.some((r) => t.test(r))
  }
  function vh(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  }
  function F6(e) {
    return Array.prototype.map
      .call(e, (t) => (/\w/.test(t) ? `[${t.toLowerCase()}${t.toUpperCase()}]` : vh(t)))
      .join('')
  }
  function $6(e, t) {
    let r = IK(e),
      n = t.match(r)
    return !!n && n[0].length > 0
  }
  function IK(e) {
    typeof e == 'string' && (e = new RegExp(e))
    let t = e,
      r = e.source,
      n = 0
    function i() {
      let s = '',
        o
      function l(h) {
        ;(s += r.substr(n, h)), (n += h)
      }
      a(l, 'appendRaw')
      function u(h) {
        ;(s += '(?:' + r.substr(n, h) + '|$)'), (n += h)
      }
      for (a(u, 'appendOptional'); n < r.length; )
        switch (r[n]) {
          case '\\':
            switch (r[n + 1]) {
              case 'c':
                u(3)
                break
              case 'x':
                u(4)
                break
              case 'u':
                t.unicode ? (r[n + 2] === '{' ? u(r.indexOf('}', n) - n + 1) : u(6)) : u(2)
                break
              case 'p':
              case 'P':
                t.unicode ? u(r.indexOf('}', n) - n + 1) : u(2)
                break
              case 'k':
                u(r.indexOf('>', n) - n + 1)
                break
              default:
                u(2)
                break
            }
            break
          case '[':
            ;(o = /\[(?:\\.|.)*?\]/g), (o.lastIndex = n), (o = o.exec(r) || []), u(o[0].length)
            break
          case '|':
          case '^':
          case '$':
          case '*':
          case '+':
          case '?':
            l(1)
            break
          case '{':
            ;(o = /\{\d+,?\d*\}/g), (o.lastIndex = n), (o = o.exec(r)), o ? l(o[0].length) : u(1)
            break
          case '(':
            if (r[n + 1] === '?')
              switch (r[n + 2]) {
                case ':':
                  ;(s += '(?:'), (n += 3), (s += i() + '|$)')
                  break
                case '=':
                  ;(s += '(?='), (n += 3), (s += i() + ')')
                  break
                case '!':
                  ;(o = n), (n += 3), i(), (s += r.substr(o, n - o))
                  break
                case '<':
                  switch (r[n + 3]) {
                    case '=':
                    case '!':
                      ;(o = n), (n += 4), i(), (s += r.substr(o, n - o))
                      break
                    default:
                      l(r.indexOf('>', n) - n + 1), (s += i() + '|$)')
                      break
                  }
                  break
              }
            else l(1), (s += i() + '|$)')
            break
          case ')':
            return ++n, s
          default:
            u(1)
            break
        }
      return s
    }
    return a(i, 'process'), new RegExp(i(), e.flags)
  }
  var P6,
    DK,
    O6,
    Eh,
    NK,
    wp = x(() => {
      'use strict'
      f1()
      ;(P6 = /\r?\n/gm),
        (DK = new wh()),
        (O6 = class extends Fo {
          static {
            a(this, 'TerminalRegExpVisitor')
          }
          constructor() {
            super(...arguments), (this.isStarting = !0), (this.endRegexpStack = []), (this.multiline = !1)
          }
          get endRegex() {
            return this.endRegexpStack.join('')
          }
          reset(t) {
            ;(this.multiline = !1),
              (this.regex = t),
              (this.startRegexp = ''),
              (this.isStarting = !0),
              (this.endRegexpStack = [])
          }
          visitGroup(t) {
            t.quantifier && ((this.isStarting = !1), (this.endRegexpStack = []))
          }
          visitCharacter(t) {
            let r = String.fromCharCode(t.value)
            if (
              (!this.multiline &&
                r ===
                  `
` &&
                (this.multiline = !0),
              t.quantifier)
            )
              (this.isStarting = !1), (this.endRegexpStack = [])
            else {
              let n = vh(r)
              this.endRegexpStack.push(n), this.isStarting && (this.startRegexp += n)
            }
          }
          visitSet(t) {
            if (!this.multiline) {
              let r = this.regex.substring(t.loc.begin, t.loc.end),
                n = new RegExp(r)
              this.multiline = !!`
`.match(n)
            }
            if (t.quantifier) (this.isStarting = !1), (this.endRegexpStack = [])
            else {
              let r = this.regex.substring(t.loc.begin, t.loc.end)
              this.endRegexpStack.push(r), this.isStarting && (this.startRegexp += r)
            }
          }
          visitChildren(t) {
            ;(t.type === 'Group' && t.quantifier) || super.visitChildren(t)
          }
        }),
        (Eh = new O6())
      a(C3t, 'getTerminalParts')
      a(B6, 'isMultilineComment')
      NK = `\f
\r	\v \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`.split(
        '',
      )
      a(Cp, 'isWhitespace')
      a(vh, 'escapeRegExp')
      a(F6, 'getCaseInsensitivePattern')
      a($6, 'partialMatches')
      a(IK, 'partialRegExp')
    })
  var ET = {}
  Oe(ET, {
    findAssignment: () => Y6,
    findNameAssignment: () => wT,
    findNodeForKeyword: () => q6,
    findNodeForProperty: () => p1,
    findNodesForKeyword: () => w3t,
    findNodesForKeywordInternal: () => H6,
    findNodesForProperty: () => U6,
    getActionAtElement: () => FK,
    getActionType: () => GK,
    getAllReachableRules: () => d1,
    getCrossReferenceTerminal: () => z6,
    getEntryRule: () => MK,
    getExplicitRuleType: () => Ep,
    getHiddenRules: () => OK,
    getRuleType: () => X6,
    getRuleTypeName: () => R3t,
    getTypeName: () => g1,
    isArrayCardinality: () => v3t,
    isArrayOperator: () => A3t,
    isCommentTerminal: () => W6,
    isDataType: () => L3t,
    isDataTypeRule: () => m1,
    isOptionalCardinality: () => E3t,
    terminalRegex: () => vp,
  })
  function MK(e) {
    return e.rules.find((t) => Si(t) && t.entry)
  }
  function OK(e) {
    return e.rules.filter((t) => Ms(t) && t.hidden)
  }
  function d1(e, t) {
    let r = new Set(),
      n = MK(e)
    if (!n) return new Set(e.rules)
    let i = [n].concat(OK(e))
    for (let o of i) PK(o, r, t)
    let s = new Set()
    for (let o of e.rules) (r.has(o.name) || (Ms(o) && o.hidden)) && s.add(o)
    return s
  }
  function PK(e, t, r) {
    t.add(e.name),
      Bo(e).forEach((n) => {
        if (ja(n) || (r && xT(n))) {
          let i = n.rule.ref
          i && !t.has(i.name) && PK(i, t, r)
        }
      })
  }
  function z6(e) {
    if (e.terminal) return e.terminal
    if (e.type.ref) {
      let t = wT(e.type.ref)
      return t?.terminal
    }
  }
  function W6(e) {
    return e.hidden && !Cp(vp(e))
  }
  function U6(e, t) {
    return !e || !t ? [] : j6(e, t, e.astNode, !0)
  }
  function p1(e, t, r) {
    if (!e || !t) return
    let n = j6(e, t, e.astNode, !0)
    if (n.length !== 0) return r !== void 0 ? (r = Math.max(0, Math.min(r, n.length - 1))) : (r = 0), n[r]
  }
  function j6(e, t, r, n) {
    if (!n) {
      let i = _h(e.grammarSource, Ua)
      if (i && i.feature === t) return [e]
    }
    return Va(e) && e.astNode === r ? e.content.flatMap((i) => j6(i, t, r, !1)) : []
  }
  function w3t(e, t) {
    return e ? H6(e, t, e?.astNode) : []
  }
  function q6(e, t, r) {
    if (!e) return
    let n = H6(e, t, e?.astNode)
    if (n.length !== 0) return r !== void 0 ? (r = Math.max(0, Math.min(r, n.length - 1))) : (r = 0), n[r]
  }
  function H6(e, t, r) {
    if (e.astNode !== r) return []
    if (ca(e.grammarSource) && e.grammarSource.value === t) return [e]
    let n = xh(e).iterator(),
      i,
      s = []
    do
      if (((i = n.next()), !i.done)) {
        let o = i.value
        o.astNode === r ? ca(o.grammarSource) && o.grammarSource.value === t && s.push(o) : n.prune()
      }
    while (!i.done)
    return s
  }
  function Y6(e) {
    var t
    let r = e.astNode
    for (; r === ((t = e.container) === null || t === void 0 ? void 0 : t.astNode); ) {
      let n = _h(e.grammarSource, Ua)
      if (n) return n
      e = e.container
    }
  }
  function wT(e) {
    let t = e
    return (
      pT(t) &&
        (Sl(t.$container) ? (t = t.$container.$container) : Si(t.$container) ? (t = t.$container) : Oo(t.$container)),
      BK(e, t, new Map())
    )
  }
  function BK(e, t, r) {
    var n
    function i(s, o) {
      let l
      return _h(s, Ua) || (l = BK(o, o, r)), r.set(e, l), l
    }
    if ((a(i, 'go'), r.has(e))) return r.get(e)
    r.set(e, void 0)
    for (let s of Bo(t)) {
      if (Ua(s) && s.feature.toLowerCase() === 'name') return r.set(e, s), s
      if (ja(s) && Si(s.rule.ref)) return i(s, s.rule.ref)
      if (gT(s) && !((n = s.typeRef) === null || n === void 0) && n.ref) return i(s, s.typeRef.ref)
    }
  }
  function FK(e) {
    let t = e.$container
    if (zc(t)) {
      let r = t.elements,
        n = r.indexOf(e)
      for (let i = n - 1; i >= 0; i--) {
        let s = r[i]
        if (Sl(s)) return s
        {
          let o = Bo(r[i]).find(Sl)
          if (o) return o
        }
      }
    }
    if (i1(t)) return FK(t)
  }
  function E3t(e, t) {
    return e === '?' || e === '*' || (zc(t) && !!t.guardCondition)
  }
  function v3t(e) {
    return e === '*' || e === '+'
  }
  function A3t(e) {
    return e === '+='
  }
  function m1(e) {
    return $K(e, new Set())
  }
  function $K(e, t) {
    if (t.has(e)) return !0
    t.add(e)
    for (let r of Bo(e))
      if (ja(r)) {
        if (!r.rule.ref || (Si(r.rule.ref) && !$K(r.rule.ref, t))) return !1
      } else {
        if (Ua(r)) return !1
        if (Sl(r)) return !1
      }
    return !!e.definition
  }
  function L3t(e) {
    return V6(e.type, new Set())
  }
  function V6(e, t) {
    if (t.has(e)) return !0
    if ((t.add(e), f6(e))) return !1
    if (x6(e)) return !1
    if (k6(e)) return e.types.every((r) => V6(r, t))
    if (gT(e)) {
      if (e.primitiveType !== void 0) return !0
      if (e.stringType !== void 0) return !0
      if (e.typeRef !== void 0) {
        let r = e.typeRef.ref
        return s1(r) ? V6(r.type, t) : !1
      } else return !1
    } else return !1
  }
  function Ep(e) {
    if (e.inferredType) return e.inferredType.name
    if (e.dataType) return e.dataType
    if (e.returnType) {
      let t = e.returnType.ref
      if (t) {
        if (Si(t)) return t.name
        if (mT(t) || s1(t)) return t.name
      }
    }
  }
  function g1(e) {
    var t
    if (Si(e)) return m1(e) ? e.name : (t = Ep(e)) !== null && t !== void 0 ? t : e.name
    if (mT(e) || s1(e) || b6(e)) return e.name
    if (Sl(e)) {
      let r = GK(e)
      if (r) return r
    } else if (pT(e)) return e.name
    throw new Error('Cannot get name of Unknown Type')
  }
  function GK(e) {
    var t
    if (e.inferredType) return e.inferredType.name
    if (!((t = e.type) === null || t === void 0) && t.ref) return g1(e.type.ref)
  }
  function R3t(e) {
    var t, r, n
    return Ms(e)
      ? (r = (t = e.type) === null || t === void 0 ? void 0 : t.name) !== null && r !== void 0
        ? r
        : 'string'
      : m1(e)
        ? e.name
        : (n = Ep(e)) !== null && n !== void 0
          ? n
          : e.name
  }
  function X6(e) {
    var t, r, n
    return Ms(e)
      ? (r = (t = e.type) === null || t === void 0 ? void 0 : t.name) !== null && r !== void 0
        ? r
        : 'string'
      : (n = Ep(e)) !== null && n !== void 0
        ? n
        : e.name
  }
  function vp(e) {
    let t = { s: !1, i: !1, u: !1 },
      r = Ap(e.definition, t),
      n = Object.entries(t)
        .filter(([, i]) => i)
        .map(([i]) => i)
        .join('')
    return new RegExp(r, n)
  }
  function Ap(e, t) {
    if (w6(e)) return D3t(e)
    if (E6(e)) return N3t(e)
    if (T6(e)) return O3t(e)
    if (xT(e)) {
      let r = e.rule.ref
      if (!r) throw new Error('Missing rule reference.')
      return _l(Ap(r.definition), { cardinality: e.cardinality, lookahead: e.lookahead })
    } else {
      if (_6(e)) return M3t(e)
      if (v6(e)) return I3t(e)
      if (C6(e)) {
        let r = e.regex.lastIndexOf('/'),
          n = e.regex.substring(1, r),
          i = e.regex.substring(r + 1)
        return (
          t && ((t.i = i.includes('i')), (t.s = i.includes('s')), (t.u = i.includes('u'))),
          _l(n, { cardinality: e.cardinality, lookahead: e.lookahead, wrap: !1 })
        )
      } else {
        if (A6(e)) return _l(K6, { cardinality: e.cardinality, lookahead: e.lookahead })
        throw new Error(`Invalid terminal element: ${e?.$type}`)
      }
    }
  }
  function D3t(e) {
    return _l(e.elements.map((t) => Ap(t)).join('|'), { cardinality: e.cardinality, lookahead: e.lookahead })
  }
  function N3t(e) {
    return _l(e.elements.map((t) => Ap(t)).join(''), { cardinality: e.cardinality, lookahead: e.lookahead })
  }
  function I3t(e) {
    return _l(`${K6}*?${Ap(e.terminal)}`, { cardinality: e.cardinality, lookahead: e.lookahead })
  }
  function M3t(e) {
    return _l(`(?!${Ap(e.terminal)})${K6}*?`, { cardinality: e.cardinality, lookahead: e.lookahead })
  }
  function O3t(e) {
    return e.right
      ? _l(`[${G6(e.left)}-${G6(e.right)}]`, { cardinality: e.cardinality, lookahead: e.lookahead, wrap: !1 })
      : _l(G6(e.left), { cardinality: e.cardinality, lookahead: e.lookahead, wrap: !1 })
  }
  function G6(e) {
    return vh(e.value)
  }
  function _l(e, t) {
    var r
    return (
      (t.wrap !== !1 || t.lookahead) && (e = `(${(r = t.lookahead) !== null && r !== void 0 ? r : ''}${e})`),
      t.cardinality ? `${e}${t.cardinality}` : e
    )
  }
  var K6,
    qa = x(() => {
      'use strict'
      fT()
      Po()
      za()
      zi()
      Wa()
      wp()
      a(MK, 'getEntryRule')
      a(OK, 'getHiddenRules')
      a(d1, 'getAllReachableRules')
      a(PK, 'ruleDfs')
      a(z6, 'getCrossReferenceTerminal')
      a(W6, 'isCommentTerminal')
      a(U6, 'findNodesForProperty')
      a(p1, 'findNodeForProperty')
      a(j6, 'findNodesForPropertyInternal')
      a(w3t, 'findNodesForKeyword')
      a(q6, 'findNodeForKeyword')
      a(H6, 'findNodesForKeywordInternal')
      a(Y6, 'findAssignment')
      a(wT, 'findNameAssignment')
      a(BK, 'findNameAssignmentInternal')
      a(FK, 'getActionAtElement')
      a(E3t, 'isOptionalCardinality')
      a(v3t, 'isArrayCardinality')
      a(A3t, 'isArrayOperator')
      a(m1, 'isDataTypeRule')
      a($K, 'isDataTypeRuleInternal')
      a(L3t, 'isDataType')
      a(V6, 'isDataTypeInternal')
      a(Ep, 'getExplicitRuleType')
      a(g1, 'getTypeName')
      a(GK, 'getActionType')
      a(R3t, 'getRuleTypeName')
      a(X6, 'getRuleType')
      a(vp, 'terminalRegex')
      K6 = /[\s\S]/.source
      a(Ap, 'abstractElementToRegex')
      a(D3t, 'terminalAlternativesToRegex')
      a(N3t, 'terminalGroupToRegex')
      a(I3t, 'untilTokenToRegex')
      a(M3t, 'negateTokenToRegex')
      a(O3t, 'characterRangeToRegex')
      a(G6, 'keywordToRegex')
      a(_l, 'withCardinality')
    })
  function Q6(e) {
    let t = [],
      r = e.Grammar
    for (let n of r.rules) Ms(n) && W6(n) && B6(vp(n)) && t.push(n.name)
    return { multilineCommentRules: t, nameRegexp: uT }
  }
  var Z6 = x(() => {
    'use strict'
    Wa()
    qa()
    wp()
    Po()
    a(Q6, 'createGrammarConfig')
  })
  var J6 = x(() => {
    'use strict'
  })
  function Lp(e) {
    console && console.error && console.error(`Error: ${e}`)
  }
  function y1(e) {
    console && console.warn && console.warn(`Warning: ${e}`)
  }
  var VK = x(() => {
    'use strict'
    a(Lp, 'PRINT_ERROR')
    a(y1, 'PRINT_WARNING')
  })
  function x1(e) {
    let t = new Date().getTime(),
      r = e()
    return { time: new Date().getTime() - t, value: r }
  }
  var zK = x(() => {
    'use strict'
    a(x1, 'timer')
  })
  function b1(e) {
    function t() {}
    a(t, 'FakeConstructor'), (t.prototype = e)
    let r = new t()
    function n() {
      return typeof r.bar
    }
    return a(n, 'fakeAccess'), n(), n(), e
    ;(0, eval)(e)
  }
  var WK = x(() => {
    'use strict'
    a(b1, 'toFastProperties')
  })
  var Rp = x(() => {
    'use strict'
    VK()
    zK()
    WK()
  })
  function P3t(e) {
    return B3t(e) ? e.LABEL : e.name
  }
  function B3t(e) {
    return Tn(e.LABEL) && e.LABEL !== ''
  }
  function vT(e) {
    return Dt(e, Dp)
  }
  function Dp(e) {
    function t(r) {
      return Dt(r, Dp)
    }
    if ((a(t, 'convertDefinition'), e instanceof Cr)) {
      let r = { type: 'NonTerminal', name: e.nonTerminalName, idx: e.idx }
      return Tn(e.label) && (r.label = e.label), r
    } else {
      if (e instanceof Vr) return { type: 'Alternative', definition: t(e.definition) }
      if (e instanceof wr) return { type: 'Option', idx: e.idx, definition: t(e.definition) }
      if (e instanceof zr) return { type: 'RepetitionMandatory', idx: e.idx, definition: t(e.definition) }
      if (e instanceof Wr)
        return {
          type: 'RepetitionMandatoryWithSeparator',
          idx: e.idx,
          separator: Dp(new je({ terminalType: e.separator })),
          definition: t(e.definition),
        }
      if (e instanceof Mr)
        return {
          type: 'RepetitionWithSeparator',
          idx: e.idx,
          separator: Dp(new je({ terminalType: e.separator })),
          definition: t(e.definition),
        }
      if (e instanceof ir) return { type: 'Repetition', idx: e.idx, definition: t(e.definition) }
      if (e instanceof Or) return { type: 'Alternation', idx: e.idx, definition: t(e.definition) }
      if (e instanceof je) {
        let r = { type: 'Terminal', name: e.terminalType.name, label: P3t(e.terminalType), idx: e.idx }
        Tn(e.label) && (r.terminalLabel = e.label)
        let n = e.terminalType.PATTERN
        return e.terminalType.PATTERN && (r.pattern = ia(n) ? n.source : n), r
      } else {
        if (e instanceof Wi) return { type: 'Rule', name: e.name, orgText: e.orgText, definition: t(e.definition) }
        throw Error('non exhaustive match')
      }
    }
  }
  var Os,
    Cr,
    Wi,
    Vr,
    wr,
    zr,
    Wr,
    ir,
    Mr,
    Or,
    je,
    AT = x(() => {
      'use strict'
      fe()
      a(P3t, 'tokenLabel')
      a(B3t, 'hasTokenLabel')
      ;(Os = class {
        static {
          a(this, 'AbstractProduction')
        }
        get definition() {
          return this._definition
        }
        set definition(t) {
          this._definition = t
        }
        constructor(t) {
          this._definition = t
        }
        accept(t) {
          t.visit(this),
            rt(this.definition, (r) => {
              r.accept(t)
            })
        }
      }),
        (Cr = class extends Os {
          static {
            a(this, 'NonTerminal')
          }
          constructor(t) {
            super([]),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
          set definition(t) {}
          get definition() {
            return this.referencedRule !== void 0 ? this.referencedRule.definition : []
          }
          accept(t) {
            t.visit(this)
          }
        }),
        (Wi = class extends Os {
          static {
            a(this, 'Rule')
          }
          constructor(t) {
            super(t.definition),
              (this.orgText = ''),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (Vr = class extends Os {
          static {
            a(this, 'Alternative')
          }
          constructor(t) {
            super(t.definition),
              (this.ignoreAmbiguities = !1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (wr = class extends Os {
          static {
            a(this, 'Option')
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (zr = class extends Os {
          static {
            a(this, 'RepetitionMandatory')
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (Wr = class extends Os {
          static {
            a(this, 'RepetitionMandatoryWithSeparator')
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (ir = class extends Os {
          static {
            a(this, 'Repetition')
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (Mr = class extends Os {
          static {
            a(this, 'RepetitionWithSeparator')
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (Or = class extends Os {
          static {
            a(this, 'Alternation')
          }
          get definition() {
            return this._definition
          }
          set definition(t) {
            this._definition = t
          }
          constructor(t) {
            super(t.definition),
              (this.idx = 1),
              (this.ignoreAmbiguities = !1),
              (this.hasPredicates = !1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
        }),
        (je = class {
          static {
            a(this, 'Terminal')
          }
          constructor(t) {
            ;(this.idx = 1),
              ai(
                this,
                ps(t, (r) => r !== void 0),
              )
          }
          accept(t) {
            t.visit(this)
          }
        })
      a(vT, 'serializeGrammar')
      a(Dp, 'serializeProduction')
    })
  var Ui,
    UK = x(() => {
      'use strict'
      AT()
      Ui = class {
        static {
          a(this, 'GAstVisitor')
        }
        visit(t) {
          let r = t
          switch (r.constructor) {
            case Cr:
              return this.visitNonTerminal(r)
            case Vr:
              return this.visitAlternative(r)
            case wr:
              return this.visitOption(r)
            case zr:
              return this.visitRepetitionMandatory(r)
            case Wr:
              return this.visitRepetitionMandatoryWithSeparator(r)
            case Mr:
              return this.visitRepetitionWithSeparator(r)
            case ir:
              return this.visitRepetition(r)
            case Or:
              return this.visitAlternation(r)
            case je:
              return this.visitTerminal(r)
            case Wi:
              return this.visitRule(r)
            default:
              throw Error('non exhaustive match')
          }
        }
        visitNonTerminal(t) {}
        visitAlternative(t) {}
        visitOption(t) {}
        visitRepetition(t) {}
        visitRepetitionMandatory(t) {}
        visitRepetitionMandatoryWithSeparator(t) {}
        visitRepetitionWithSeparator(t) {}
        visitAlternation(t) {}
        visitTerminal(t) {}
        visitRule(t) {}
      }
    })
  function tL(e) {
    return (
      e instanceof Vr ||
      e instanceof wr ||
      e instanceof ir ||
      e instanceof zr ||
      e instanceof Wr ||
      e instanceof Mr ||
      e instanceof je ||
      e instanceof Wi
    )
  }
  function Ah(e, t = []) {
    return e instanceof wr || e instanceof ir || e instanceof Mr
      ? !0
      : e instanceof Or
        ? U0(e.definition, (n) => Ah(n, t))
        : e instanceof Cr && Jr(t, e)
          ? !1
          : e instanceof Os
            ? (e instanceof Cr && t.push(e), ki(e.definition, (n) => Ah(n, t)))
            : !1
  }
  function eL(e) {
    return e instanceof Or
  }
  function gs(e) {
    if (e instanceof Cr) return 'SUBRULE'
    if (e instanceof wr) return 'OPTION'
    if (e instanceof Or) return 'OR'
    if (e instanceof zr) return 'AT_LEAST_ONE'
    if (e instanceof Wr) return 'AT_LEAST_ONE_SEP'
    if (e instanceof Mr) return 'MANY_SEP'
    if (e instanceof ir) return 'MANY'
    if (e instanceof je) return 'CONSUME'
    throw Error('non exhaustive match')
  }
  var jK = x(() => {
    'use strict'
    fe()
    AT()
    a(tL, 'isSequenceProd')
    a(Ah, 'isOptionalProd')
    a(eL, 'isBranchingProd')
    a(gs, 'getProductionDslName')
  })
  var ji = x(() => {
    'use strict'
    AT()
    UK()
    jK()
  })
  function qK(e, t, r) {
    return [new wr({ definition: [new je({ terminalType: e.separator })].concat(e.definition) })].concat(t, r)
  }
  var Cl,
    LT = x(() => {
      'use strict'
      fe()
      ji()
      Cl = class {
        static {
          a(this, 'RestWalker')
        }
        walk(t, r = []) {
          rt(t.definition, (n, i) => {
            let s = kn(t.definition, i + 1)
            if (n instanceof Cr) this.walkProdRef(n, s, r)
            else if (n instanceof je) this.walkTerminal(n, s, r)
            else if (n instanceof Vr) this.walkFlat(n, s, r)
            else if (n instanceof wr) this.walkOption(n, s, r)
            else if (n instanceof zr) this.walkAtLeastOne(n, s, r)
            else if (n instanceof Wr) this.walkAtLeastOneSep(n, s, r)
            else if (n instanceof Mr) this.walkManySep(n, s, r)
            else if (n instanceof ir) this.walkMany(n, s, r)
            else if (n instanceof Or) this.walkOr(n, s, r)
            else throw Error('non exhaustive match')
          })
        }
        walkTerminal(t, r, n) {}
        walkProdRef(t, r, n) {}
        walkFlat(t, r, n) {
          let i = r.concat(n)
          this.walk(t, i)
        }
        walkOption(t, r, n) {
          let i = r.concat(n)
          this.walk(t, i)
        }
        walkAtLeastOne(t, r, n) {
          let i = [new wr({ definition: t.definition })].concat(r, n)
          this.walk(t, i)
        }
        walkAtLeastOneSep(t, r, n) {
          let i = qK(t, r, n)
          this.walk(t, i)
        }
        walkMany(t, r, n) {
          let i = [new wr({ definition: t.definition })].concat(r, n)
          this.walk(t, i)
        }
        walkManySep(t, r, n) {
          let i = qK(t, r, n)
          this.walk(t, i)
        }
        walkOr(t, r, n) {
          let i = r.concat(n)
          rt(t.definition, (s) => {
            let o = new Vr({ definition: [s] })
            this.walk(o, i)
          })
        }
      }
      a(qK, 'restForRepetitionWithSeparator')
    })
  function Lh(e) {
    if (e instanceof Cr) return Lh(e.referencedRule)
    if (e instanceof je) return G3t(e)
    if (tL(e)) return F3t(e)
    if (eL(e)) return $3t(e)
    throw Error('non exhaustive match')
  }
  function F3t(e) {
    let t = [],
      r = e.definition,
      n = 0,
      i = r.length > n,
      s,
      o = !0
    for (; i && o; ) (s = r[n]), (o = Ah(s)), (t = t.concat(Lh(s))), (n = n + 1), (i = r.length > n)
    return Nd(t)
  }
  function $3t(e) {
    let t = Dt(e.definition, (r) => Lh(r))
    return Nd(dr(t))
  }
  function G3t(e) {
    return [e.terminalType]
  }
  var rL = x(() => {
    'use strict'
    fe()
    ji()
    a(Lh, 'first')
    a(F3t, 'firstForSequence')
    a($3t, 'firstForBranching')
    a(G3t, 'firstForTerminal')
  })
  var RT,
    nL = x(() => {
      'use strict'
      RT = '_~IN~_'
    })
  function HK(e) {
    let t = {}
    return (
      rt(e, (r) => {
        let n = new iL(r).startWalking()
        ai(t, n)
      }),
      t
    )
  }
  function V3t(e, t) {
    return e.name + t + RT
  }
  var iL,
    YK = x(() => {
      'use strict'
      LT()
      rL()
      fe()
      nL()
      ji()
      iL = class extends Cl {
        static {
          a(this, 'ResyncFollowsWalker')
        }
        constructor(t) {
          super(), (this.topProd = t), (this.follows = {})
        }
        startWalking() {
          return this.walk(this.topProd), this.follows
        }
        walkTerminal(t, r, n) {}
        walkProdRef(t, r, n) {
          let i = V3t(t.referencedRule, t.idx) + this.topProd.name,
            s = r.concat(n),
            o = new Vr({ definition: s }),
            l = Lh(o)
          this.follows[i] = l
        }
      }
      a(HK, 'computeAllProdsFollows')
      a(V3t, 'buildBetweenProdsFollowPrefix')
    })
  function Np(e) {
    let t = e.toString()
    if (DT.hasOwnProperty(t)) return DT[t]
    {
      let r = z3t.pattern(t)
      return (DT[t] = r), r
    }
  }
  function XK() {
    DT = {}
  }
  var DT,
    z3t,
    NT = x(() => {
      'use strict'
      f1()
      ;(DT = {}), (z3t = new wh())
      a(Np, 'getRegExpAst')
      a(XK, 'clearRegExpParserCache')
    })
  function ZK(e, t = !1) {
    try {
      let r = Np(e)
      return sL(r.value, {}, r.flags.ignoreCase)
    } catch (r) {
      if (r.message === QK)
        t &&
          y1(`${k1}	Unable to optimize: < ${e.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`)
      else {
        let n = ''
        t &&
          (n = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`),
          Lp(
            `${k1}
	Failed parsing: < ${e.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + n,
          )
      }
    }
    return []
  }
  function sL(e, t, r) {
    switch (e.type) {
      case 'Disjunction':
        for (let i = 0; i < e.value.length; i++) sL(e.value[i], t, r)
        break
      case 'Alternative':
        let n = e.value
        for (let i = 0; i < n.length; i++) {
          let s = n[i]
          switch (s.type) {
            case 'EndAnchor':
            case 'GroupBackReference':
            case 'Lookahead':
            case 'NegativeLookahead':
            case 'StartAnchor':
            case 'WordBoundary':
            case 'NonWordBoundary':
              continue
          }
          let o = s
          switch (o.type) {
            case 'Character':
              IT(o.value, t, r)
              break
            case 'Set':
              if (o.complement === !0) throw Error(QK)
              rt(o.value, (u) => {
                if (typeof u == 'number') IT(u, t, r)
                else {
                  let h = u
                  if (r === !0) for (let f = h.from; f <= h.to; f++) IT(f, t, r)
                  else {
                    for (let f = h.from; f <= h.to && f < Ip; f++) IT(f, t, r)
                    if (h.to >= Ip) {
                      let f = h.from >= Ip ? h.from : Ip,
                        d = h.to,
                        p = $o(f),
                        m = $o(d)
                      for (let g = p; g <= m; g++) t[g] = g
                    }
                  }
                }
              })
              break
            case 'Group':
              sL(o.value, t, r)
              break
            default:
              throw Error('Non Exhaustive Match')
          }
          let l = o.quantifier !== void 0 && o.quantifier.atLeast === 0
          if ((o.type === 'Group' && aL(o) === !1) || (o.type !== 'Group' && l === !1)) break
        }
        break
      default:
        throw Error('non exhaustive match!')
    }
    return We(t)
  }
  function IT(e, t, r) {
    let n = $o(e)
    ;(t[n] = n), r === !0 && W3t(e, t)
  }
  function W3t(e, t) {
    let r = String.fromCharCode(e),
      n = r.toUpperCase()
    if (n !== r) {
      let i = $o(n.charCodeAt(0))
      t[i] = i
    } else {
      let i = r.toLowerCase()
      if (i !== r) {
        let s = $o(i.charCodeAt(0))
        t[s] = s
      }
    }
  }
  function KK(e, t) {
    return Vi(e.value, (r) => {
      if (typeof r == 'number') return Jr(t, r)
      {
        let n = r
        return Vi(t, (i) => n.from <= i && i <= n.to) !== void 0
      }
    })
  }
  function aL(e) {
    let t = e.quantifier
    return t && t.atLeast === 0 ? !0 : e.value ? (Jt(e.value) ? ki(e.value, aL) : aL(e.value)) : !1
  }
  function MT(e, t) {
    if (t instanceof RegExp) {
      let r = Np(t),
        n = new oL(e)
      return n.visit(r), n.found
    } else return Vi(t, (r) => Jr(e, r.charCodeAt(0))) !== void 0
  }
  var QK,
    k1,
    oL,
    JK = x(() => {
      'use strict'
      f1()
      fe()
      Rp()
      NT()
      lL()
      ;(QK = 'Complement Sets are not supported for first char optimization'),
        (k1 = `Unable to use "first char" lexer optimizations:
`)
      a(ZK, 'getOptimizedStartCodesIndices')
      a(sL, 'firstCharOptimizedIndices')
      a(IT, 'addOptimizedIdxToResult')
      a(W3t, 'handleIgnoreCase')
      a(KK, 'findCode')
      a(aL, 'isWholeOptional')
      oL = class extends Fo {
        static {
          a(this, 'CharCodeFinder')
        }
        constructor(t) {
          super(), (this.targetCharCodes = t), (this.found = !1)
        }
        visitChildren(t) {
          if (this.found !== !0) {
            switch (t.type) {
              case 'Lookahead':
                this.visitLookahead(t)
                return
              case 'NegativeLookahead':
                this.visitNegativeLookahead(t)
                return
            }
            super.visitChildren(t)
          }
        }
        visitCharacter(t) {
          Jr(this.targetCharCodes, t.value) && (this.found = !0)
        }
        visitSet(t) {
          t.complement
            ? KK(t, this.targetCharCodes) === void 0 && (this.found = !0)
            : KK(t, this.targetCharCodes) !== void 0 && (this.found = !0)
        }
      }
      a(MT, 'canMatchCharCode')
    })
  function rQ(e, t) {
    t = Mc(t, {
      useSticky: uL,
      debug: !1,
      safeMode: !1,
      positionTracking: 'full',
      lineTerminatorCharacters: [
        '\r',
        `
`,
      ],
      tracer: a((T, C) => C(), 'tracer'),
    })
    let r = t.tracer
    r('initCharCodeToOptimizedIndexMap', () => {
      o4t()
    })
    let n
    r('Reject Lexer.NA', () => {
      n = Pc(e, (T) => T[Rh] === en.NA)
    })
    let i = !1,
      s
    r('Transform Patterns', () => {
      ;(i = !1),
        (s = Dt(n, (T) => {
          let C = T[Rh]
          if (ia(C)) {
            let A = C.source
            return A.length === 1 && A !== '^' && A !== '$' && A !== '.' && !C.ignoreCase
              ? A
              : A.length === 2 &&
                  A[0] === '\\' &&
                  !Jr(['d', 'D', 's', 'S', 't', 'r', 'n', 't', '0', 'c', 'b', 'B', 'f', 'v', 'w', 'W'], A[1])
                ? A[1]
                : t.useSticky
                  ? eQ(C)
                  : tQ(C)
          } else {
            if (vn(C)) return (i = !0), { exec: C }
            if (typeof C == 'object') return (i = !0), C
            if (typeof C == 'string') {
              if (C.length === 1) return C
              {
                let A = C.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'),
                  w = new RegExp(A)
                return t.useSticky ? eQ(w) : tQ(w)
              }
            } else throw Error('non exhaustive match')
          }
        }))
    })
    let o, l, u, h, f
    r('misc mapping', () => {
      ;(o = Dt(n, (T) => T.tokenTypeIdx)),
        (l = Dt(n, (T) => {
          let C = T.GROUP
          if (C !== en.SKIPPED) {
            if (Tn(C)) return C
            if (Fe(C)) return !1
            throw Error('non exhaustive match')
          }
        })),
        (u = Dt(n, (T) => {
          let C = T.LONGER_ALT
          if (C) return Jt(C) ? Dt(C, (w) => Hk(n, w)) : [Hk(n, C)]
        })),
        (h = Dt(n, (T) => T.PUSH_MODE)),
        (f = Dt(n, (T) => te(T, 'POP_MODE')))
    })
    let d
    r('Line Terminator Handling', () => {
      let T = uQ(t.lineTerminatorCharacters)
      ;(d = Dt(n, (C) => !1)),
        t.positionTracking !== 'onlyOffset' &&
          (d = Dt(n, (C) => (te(C, 'LINE_BREAKS') ? !!C.LINE_BREAKS : cQ(C, T) === !1 && MT(T, C.PATTERN))))
    })
    let p, m, g, y
    r('Misc Mapping #2', () => {
      ;(p = Dt(n, oQ)),
        (m = Dt(s, s4t)),
        (g = mr(
          n,
          (T, C) => {
            let A = C.GROUP
            return Tn(A) && A !== en.SKIPPED && (T[A] = []), T
          },
          {},
        )),
        (y = Dt(s, (T, C) => ({
          pattern: s[C],
          longerAlt: u[C],
          canLineTerminator: d[C],
          isCustom: p[C],
          short: m[C],
          group: l[C],
          push: h[C],
          pop: f[C],
          tokenTypeIdx: o[C],
          tokenType: n[C],
        })))
    })
    let b = !0,
      k = []
    return (
      t.safeMode ||
        r('First Char Optimization', () => {
          k = mr(
            n,
            (T, C, A) => {
              if (typeof C.PATTERN == 'string') {
                let w = C.PATTERN.charCodeAt(0),
                  D = $o(w)
                cL(T, D, y[A])
              } else if (Jt(C.START_CHARS_HINT)) {
                let w
                rt(C.START_CHARS_HINT, (D) => {
                  let G = typeof D == 'string' ? D.charCodeAt(0) : D,
                    v = $o(G)
                  w !== v && ((w = v), cL(T, v, y[A]))
                })
              } else if (ia(C.PATTERN))
                if (C.PATTERN.unicode)
                  (b = !1),
                    t.ensureOptimizations &&
                      Lp(`${k1}	Unable to analyze < ${C.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`)
                else {
                  let w = ZK(C.PATTERN, t.ensureOptimizations)
                  De(w) && (b = !1),
                    rt(w, (D) => {
                      cL(T, D, y[A])
                    })
                }
              else
                t.ensureOptimizations &&
                  Lp(`${k1}	TokenType: <${C.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),
                  (b = !1)
              return T
            },
            [],
          )
        }),
      { emptyGroups: g, patternIdxToConfig: y, charCodeToPatternIdxToConfig: k, hasCustom: i, canBeOptimized: b }
    )
  }
  function nQ(e, t) {
    let r = [],
      n = j3t(e)
    r = r.concat(n.errors)
    let i = q3t(n.valid),
      s = i.valid
    return (
      (r = r.concat(i.errors)),
      (r = r.concat(U3t(s))),
      (r = r.concat(t4t(s))),
      (r = r.concat(e4t(s, t))),
      (r = r.concat(r4t(s))),
      r
    )
  }
  function U3t(e) {
    let t = [],
      r = pr(e, (n) => ia(n[Rh]))
    return (
      (t = t.concat(Y3t(r))),
      (t = t.concat(Q3t(r))),
      (t = t.concat(Z3t(r))),
      (t = t.concat(J3t(r))),
      (t = t.concat(X3t(r))),
      t
    )
  }
  function j3t(e) {
    let t = pr(e, (i) => !te(i, Rh)),
      r = Dt(t, (i) => ({
        message: 'Token Type: ->' + i.name + "<- missing static 'PATTERN' property",
        type: tn.MISSING_PATTERN,
        tokenTypes: [i],
      })),
      n = Oc(e, t)
    return { errors: r, valid: n }
  }
  function q3t(e) {
    let t = pr(e, (i) => {
        let s = i[Rh]
        return !ia(s) && !vn(s) && !te(s, 'exec') && !Tn(s)
      }),
      r = Dt(t, (i) => ({
        message:
          'Token Type: ->' +
          i.name +
          "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
        type: tn.INVALID_PATTERN,
        tokenTypes: [i],
      })),
      n = Oc(e, t)
    return { errors: r, valid: n }
  }
  function Y3t(e) {
    class t extends Fo {
      static {
        a(this, 'EndAnchorFinder')
      }
      constructor() {
        super(...arguments), (this.found = !1)
      }
      visitEndAnchor(s) {
        this.found = !0
      }
    }
    let r = pr(e, (i) => {
      let s = i.PATTERN
      try {
        let o = Np(s),
          l = new t()
        return l.visit(o), l.found
      } catch {
        return H3t.test(s.source)
      }
    })
    return Dt(r, (i) => ({
      message:
        `Unexpected RegExp Anchor Error:
	Token Type: ->` +
        i.name +
        `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
      type: tn.EOI_ANCHOR_FOUND,
      tokenTypes: [i],
    }))
  }
  function X3t(e) {
    let t = pr(e, (n) => n.PATTERN.test(''))
    return Dt(t, (n) => ({
      message: 'Token Type: ->' + n.name + "<- static 'PATTERN' must not match an empty string",
      type: tn.EMPTY_MATCH_PATTERN,
      tokenTypes: [n],
    }))
  }
  function Q3t(e) {
    class t extends Fo {
      static {
        a(this, 'StartAnchorFinder')
      }
      constructor() {
        super(...arguments), (this.found = !1)
      }
      visitStartAnchor(s) {
        this.found = !0
      }
    }
    let r = pr(e, (i) => {
      let s = i.PATTERN
      try {
        let o = Np(s),
          l = new t()
        return l.visit(o), l.found
      } catch {
        return K3t.test(s.source)
      }
    })
    return Dt(r, (i) => ({
      message:
        `Unexpected RegExp Anchor Error:
	Token Type: ->` +
        i.name +
        `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
      type: tn.SOI_ANCHOR_FOUND,
      tokenTypes: [i],
    }))
  }
  function Z3t(e) {
    let t = pr(e, (n) => {
      let i = n[Rh]
      return i instanceof RegExp && (i.multiline || i.global)
    })
    return Dt(t, (n) => ({
      message: 'Token Type: ->' + n.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
      type: tn.UNSUPPORTED_FLAGS_FOUND,
      tokenTypes: [n],
    }))
  }
  function J3t(e) {
    let t = [],
      r = Dt(e, (s) =>
        mr(
          e,
          (o, l) => (
            s.PATTERN.source === l.PATTERN.source && !Jr(t, l) && l.PATTERN !== en.NA && (t.push(l), o.push(l)), o
          ),
          [],
        ),
      )
    r = vo(r)
    let n = pr(r, (s) => s.length > 1)
    return Dt(n, (s) => {
      let o = Dt(s, (u) => u.name)
      return {
        message: `The same RegExp pattern ->${Qn(s).PATTERN}<-has been used in all of the following Token Types: ${o.join(', ')} <-`,
        type: tn.DUPLICATE_PATTERNS_FOUND,
        tokenTypes: s,
      }
    })
  }
  function t4t(e) {
    let t = pr(e, (n) => {
      if (!te(n, 'GROUP')) return !1
      let i = n.GROUP
      return i !== en.SKIPPED && i !== en.NA && !Tn(i)
    })
    return Dt(t, (n) => ({
      message: 'Token Type: ->' + n.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
      type: tn.INVALID_GROUP_TYPE_FOUND,
      tokenTypes: [n],
    }))
  }
  function e4t(e, t) {
    let r = pr(e, (i) => i.PUSH_MODE !== void 0 && !Jr(t, i.PUSH_MODE))
    return Dt(r, (i) => ({
      message: `Token Type: ->${i.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${i.PUSH_MODE}<-which does not exist`,
      type: tn.PUSH_MODE_DOES_NOT_EXIST,
      tokenTypes: [i],
    }))
  }
  function r4t(e) {
    let t = [],
      r = mr(
        e,
        (n, i, s) => {
          let o = i.PATTERN
          return (
            o === en.NA ||
              (Tn(o)
                ? n.push({ str: o, idx: s, tokenType: i })
                : ia(o) && i4t(o) && n.push({ str: o.source, idx: s, tokenType: i })),
            n
          )
        },
        [],
      )
    return (
      rt(e, (n, i) => {
        rt(r, ({ str: s, idx: o, tokenType: l }) => {
          if (i < o && n4t(s, n.PATTERN)) {
            let u = `Token: ->${l.name}<- can never be matched.
Because it appears AFTER the Token Type ->${n.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`
            t.push({ message: u, type: tn.UNREACHABLE_PATTERN, tokenTypes: [n, l] })
          }
        })
      }),
      t
    )
  }
  function n4t(e, t) {
    if (ia(t)) {
      let r = t.exec(e)
      return r !== null && r.index === 0
    } else {
      if (vn(t)) return t(e, 0, [], {})
      if (te(t, 'exec')) return t.exec(e, 0, [], {})
      if (typeof t == 'string') return t === e
      throw Error('non exhaustive match')
    }
  }
  function i4t(e) {
    return (
      Vi(['.', '\\', '[', ']', '|', '^', '$', '(', ')', '?', '*', '+', '{'], (r) => e.source.indexOf(r) !== -1) ===
      void 0
    )
  }
  function tQ(e) {
    let t = e.ignoreCase ? 'i' : ''
    return new RegExp(`^(?:${e.source})`, t)
  }
  function eQ(e) {
    let t = e.ignoreCase ? 'iy' : 'y'
    return new RegExp(`${e.source}`, t)
  }
  function iQ(e, t, r) {
    let n = []
    return (
      te(e, Mp) ||
        n.push({
          message:
            'A MultiMode Lexer cannot be initialized without a <' +
            Mp +
            `> property in its definition
`,
          type: tn.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,
        }),
      te(e, OT) ||
        n.push({
          message:
            'A MultiMode Lexer cannot be initialized without a <' +
            OT +
            `> property in its definition
`,
          type: tn.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,
        }),
      te(e, OT) &&
        te(e, Mp) &&
        !te(e.modes, e.defaultMode) &&
        n.push({
          message: `A MultiMode Lexer cannot be initialized with a ${Mp}: <${e.defaultMode}>which does not exist
`,
          type: tn.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,
        }),
      te(e, OT) &&
        rt(e.modes, (i, s) => {
          rt(i, (o, l) => {
            if (Fe(o))
              n.push({
                message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${s}> at index: <${l}>
`,
                type: tn.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,
              })
            else if (te(o, 'LONGER_ALT')) {
              let u = Jt(o.LONGER_ALT) ? o.LONGER_ALT : [o.LONGER_ALT]
              rt(u, (h) => {
                !Fe(h) &&
                  !Jr(i, h) &&
                  n.push({
                    message: `A MultiMode Lexer cannot be initialized with a longer_alt <${h.name}> on token <${o.name}> outside of mode <${s}>
`,
                    type: tn.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,
                  })
              })
            }
          })
        }),
      n
    )
  }
  function sQ(e, t, r) {
    let n = [],
      i = !1,
      s = vo(dr(We(e.modes))),
      o = Pc(s, (u) => u[Rh] === en.NA),
      l = uQ(r)
    return (
      t &&
        rt(o, (u) => {
          let h = cQ(u, l)
          if (h !== !1) {
            let d = { message: a4t(u, h), type: h.issue, tokenType: u }
            n.push(d)
          } else te(u, 'LINE_BREAKS') ? u.LINE_BREAKS === !0 && (i = !0) : MT(l, u.PATTERN) && (i = !0)
        }),
      t &&
        !i &&
        n.push({
          message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS
	for details.`,
          type: tn.NO_LINE_BREAKS_FLAGS,
        }),
      n
    )
  }
  function aQ(e) {
    let t = {},
      r = cr(e)
    return (
      rt(r, (n) => {
        let i = e[n]
        if (Jt(i)) t[n] = []
        else throw Error('non exhaustive match')
      }),
      t
    )
  }
  function oQ(e) {
    let t = e.PATTERN
    if (ia(t)) return !1
    if (vn(t)) return !0
    if (te(t, 'exec')) return !0
    if (Tn(t)) return !1
    throw Error('non exhaustive match')
  }
  function s4t(e) {
    return Tn(e) && e.length === 1 ? e.charCodeAt(0) : !1
  }
  function cQ(e, t) {
    if (te(e, 'LINE_BREAKS')) return !1
    if (ia(e.PATTERN)) {
      try {
        MT(t, e.PATTERN)
      } catch (r) {
        return { issue: tn.IDENTIFY_TERMINATOR, errMsg: r.message }
      }
      return !1
    } else {
      if (Tn(e.PATTERN)) return !1
      if (oQ(e)) return { issue: tn.CUSTOM_LINE_BREAK }
      throw Error('non exhaustive match')
    }
  }
  function a4t(e, t) {
    if (t.issue === tn.IDENTIFY_TERMINATOR)
      return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${e.name}> Token Type
	 Root cause: ${t.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`
    if (t.issue === tn.CUSTOM_LINE_BREAK)
      return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${e.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`
    throw Error('non exhaustive match')
  }
  function uQ(e) {
    return Dt(e, (r) => (Tn(r) ? r.charCodeAt(0) : r))
  }
  function cL(e, t, r) {
    e[t] === void 0 ? (e[t] = [r]) : e[t].push(r)
  }
  function $o(e) {
    return e < Ip ? e : PT[e]
  }
  function o4t() {
    if (De(PT)) {
      PT = new Array(65536)
      for (let e = 0; e < 65536; e++) PT[e] = e > 255 ? 255 + ~~(e / 255) : e
    }
  }
  var Rh,
    Mp,
    OT,
    uL,
    H3t,
    K3t,
    lQ,
    Ip,
    PT,
    lL = x(() => {
      'use strict'
      f1()
      T1()
      fe()
      Rp()
      JK()
      NT()
      ;(Rh = 'PATTERN'), (Mp = 'defaultMode'), (OT = 'modes'), (uL = typeof new RegExp('(?:)').sticky == 'boolean')
      a(rQ, 'analyzeTokenTypes')
      a(nQ, 'validatePatterns')
      a(U3t, 'validateRegExpPattern')
      a(j3t, 'findMissingPatterns')
      a(q3t, 'findInvalidPatterns')
      H3t = /[^\\][$]/
      a(Y3t, 'findEndOfInputAnchor')
      a(X3t, 'findEmptyMatchRegExps')
      K3t = /[^\\[][\^]|^\^/
      a(Q3t, 'findStartOfInputAnchor')
      a(Z3t, 'findUnsupportedFlags')
      a(J3t, 'findDuplicatePatterns')
      a(t4t, 'findInvalidGroupType')
      a(e4t, 'findModesThatDoNotExist')
      a(r4t, 'findUnreachablePatterns')
      a(n4t, 'testTokenType')
      a(i4t, 'noMetaChar')
      a(tQ, 'addStartOfInput')
      a(eQ, 'addStickyFlag')
      a(iQ, 'performRuntimeChecks')
      a(sQ, 'performWarningRuntimeChecks')
      a(aQ, 'cloneEmptyGroups')
      a(oQ, 'isCustomPattern')
      a(s4t, 'isShortPattern')
      lQ = {
        test: a(function (e) {
          let t = e.length
          for (let r = this.lastIndex; r < t; r++) {
            let n = e.charCodeAt(r)
            if (n === 10) return (this.lastIndex = r + 1), !0
            if (n === 13) return e.charCodeAt(r + 1) === 10 ? (this.lastIndex = r + 2) : (this.lastIndex = r + 1), !0
          }
          return !1
        }, 'test'),
        lastIndex: 0,
      }
      a(cQ, 'checkLineBreaksIssues')
      a(a4t, 'buildLineBreakIssueMessage')
      a(uQ, 'getCharCodes')
      a(cL, 'addToMapOfArrays')
      ;(Ip = 256), (PT = [])
      a($o, 'charCodeToOptimizedIndex')
      a(o4t, 'initCharCodeToOptimizedIndexMap')
    })
  function wl(e, t) {
    let r = e.tokenTypeIdx
    return r === t.tokenTypeIdx ? !0 : t.isParent === !0 && t.categoryMatchesMap[r] === !0
  }
  function Op(e, t) {
    return e.tokenTypeIdx === t.tokenTypeIdx
  }
  function El(e) {
    let t = l4t(e)
    c4t(t),
      h4t(t),
      u4t(t),
      rt(t, (r) => {
        r.isParent = r.categoryMatches.length > 0
      })
  }
  function l4t(e) {
    let t = Sr(e),
      r = e,
      n = !0
    for (; n; ) {
      r = vo(dr(Dt(r, (s) => s.CATEGORIES)))
      let i = Oc(r, t)
      ;(t = t.concat(i)), De(i) ? (n = !1) : (r = i)
    }
    return t
  }
  function c4t(e) {
    rt(e, (t) => {
      hL(t) || ((dQ[hQ] = t), (t.tokenTypeIdx = hQ++)),
        fQ(t) && !Jt(t.CATEGORIES) && (t.CATEGORIES = [t.CATEGORIES]),
        fQ(t) || (t.CATEGORIES = []),
        f4t(t) || (t.categoryMatches = []),
        d4t(t) || (t.categoryMatchesMap = {})
    })
  }
  function u4t(e) {
    rt(e, (t) => {
      ;(t.categoryMatches = []),
        rt(t.categoryMatchesMap, (r, n) => {
          t.categoryMatches.push(dQ[n].tokenTypeIdx)
        })
    })
  }
  function h4t(e) {
    rt(e, (t) => {
      pQ([], t)
    })
  }
  function pQ(e, t) {
    rt(e, (r) => {
      t.categoryMatchesMap[r.tokenTypeIdx] = !0
    }),
      rt(t.CATEGORIES, (r) => {
        let n = e.concat(t)
        Jr(n, r) || pQ(n, r)
      })
  }
  function hL(e) {
    return te(e, 'tokenTypeIdx')
  }
  function fQ(e) {
    return te(e, 'CATEGORIES')
  }
  function f4t(e) {
    return te(e, 'categoryMatches')
  }
  function d4t(e) {
    return te(e, 'categoryMatchesMap')
  }
  function mQ(e) {
    return te(e, 'tokenTypeIdx')
  }
  var hQ,
    dQ,
    Dh = x(() => {
      'use strict'
      fe()
      a(wl, 'tokenStructuredMatcher')
      a(Op, 'tokenStructuredMatcherNoCategories')
      ;(hQ = 1), (dQ = {})
      a(El, 'augmentTokenTypes')
      a(l4t, 'expandCategories')
      a(c4t, 'assignTokenDefaultProps')
      a(u4t, 'assignCategoriesTokensProp')
      a(h4t, 'assignCategoriesMapProp')
      a(pQ, 'singleAssignCategoriesToksMap')
      a(hL, 'hasShortKeyProperty')
      a(fQ, 'hasCategoriesProperty')
      a(f4t, 'hasExtendingTokensTypesProperty')
      a(d4t, 'hasExtendingTokensTypesMapProperty')
      a(mQ, 'isTokenType')
    })
  var Pp,
    fL = x(() => {
      'use strict'
      Pp = {
        buildUnableToPopLexerModeMessage(e) {
          return `Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`
        },
        buildUnexpectedCharactersMessage(e, t, r, n, i) {
          return `unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${r} characters.`
        },
      }
    })
  var tn,
    S1,
    en,
    T1 = x(() => {
      'use strict'
      lL()
      fe()
      Rp()
      Dh()
      fL()
      NT()
      ;(function (e) {
        ;(e[(e.MISSING_PATTERN = 0)] = 'MISSING_PATTERN'),
          (e[(e.INVALID_PATTERN = 1)] = 'INVALID_PATTERN'),
          (e[(e.EOI_ANCHOR_FOUND = 2)] = 'EOI_ANCHOR_FOUND'),
          (e[(e.UNSUPPORTED_FLAGS_FOUND = 3)] = 'UNSUPPORTED_FLAGS_FOUND'),
          (e[(e.DUPLICATE_PATTERNS_FOUND = 4)] = 'DUPLICATE_PATTERNS_FOUND'),
          (e[(e.INVALID_GROUP_TYPE_FOUND = 5)] = 'INVALID_GROUP_TYPE_FOUND'),
          (e[(e.PUSH_MODE_DOES_NOT_EXIST = 6)] = 'PUSH_MODE_DOES_NOT_EXIST'),
          (e[(e.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7)] = 'MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'),
          (e[(e.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8)] = 'MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'),
          (e[(e.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9)] =
            'MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'),
          (e[(e.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10)] = 'LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'),
          (e[(e.SOI_ANCHOR_FOUND = 11)] = 'SOI_ANCHOR_FOUND'),
          (e[(e.EMPTY_MATCH_PATTERN = 12)] = 'EMPTY_MATCH_PATTERN'),
          (e[(e.NO_LINE_BREAKS_FLAGS = 13)] = 'NO_LINE_BREAKS_FLAGS'),
          (e[(e.UNREACHABLE_PATTERN = 14)] = 'UNREACHABLE_PATTERN'),
          (e[(e.IDENTIFY_TERMINATOR = 15)] = 'IDENTIFY_TERMINATOR'),
          (e[(e.CUSTOM_LINE_BREAK = 16)] = 'CUSTOM_LINE_BREAK'),
          (e[(e.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17)] =
            'MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE')
      })(tn || (tn = {}))
      S1 = {
        deferDefinitionErrorsHandling: !1,
        positionTracking: 'full',
        lineTerminatorsPattern: /\n|\r\n?/g,
        lineTerminatorCharacters: [
          `
`,
          '\r',
        ],
        ensureOptimizations: !1,
        safeMode: !1,
        errorMessageProvider: Pp,
        traceInitPerf: !1,
        skipValidations: !1,
        recoveryEnabled: !0,
      }
      Object.freeze(S1)
      en = class {
        static {
          a(this, 'Lexer')
        }
        constructor(t, r = S1) {
          if (
            ((this.lexerDefinition = t),
            (this.lexerDefinitionErrors = []),
            (this.lexerDefinitionWarning = []),
            (this.patternIdxToConfig = {}),
            (this.charCodeToPatternIdxToConfig = {}),
            (this.modes = []),
            (this.emptyGroups = {}),
            (this.trackStartLines = !0),
            (this.trackEndLines = !0),
            (this.hasCustom = !1),
            (this.canModeBeOptimized = {}),
            (this.TRACE_INIT = (i, s) => {
              if (this.traceInitPerf === !0) {
                this.traceInitIndent++
                let o = new Array(this.traceInitIndent + 1).join('	')
                this.traceInitIndent < this.traceInitMaxIdent && console.log(`${o}--> <${i}>`)
                let { time: l, value: u } = x1(s),
                  h = l > 10 ? console.warn : console.log
                return (
                  this.traceInitIndent < this.traceInitMaxIdent && h(`${o}<-- <${i}> time: ${l}ms`),
                  this.traceInitIndent--,
                  u
                )
              } else return s()
            }),
            typeof r == 'boolean')
          )
            throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`)
          this.config = ai({}, S1, r)
          let n = this.config.traceInitPerf
          n === !0
            ? ((this.traceInitMaxIdent = 1 / 0), (this.traceInitPerf = !0))
            : typeof n == 'number' && ((this.traceInitMaxIdent = n), (this.traceInitPerf = !0)),
            (this.traceInitIndent = -1),
            this.TRACE_INIT('Lexer Constructor', () => {
              let i,
                s = !0
              this.TRACE_INIT('Lexer Config handling', () => {
                if (this.config.lineTerminatorsPattern === S1.lineTerminatorsPattern)
                  this.config.lineTerminatorsPattern = lQ
                else if (this.config.lineTerminatorCharacters === S1.lineTerminatorCharacters)
                  throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`)
                if (r.safeMode && r.ensureOptimizations)
                  throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.')
                ;(this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking)),
                  (this.trackEndLines = /full/i.test(this.config.positionTracking)),
                  Jt(t) ? (i = { modes: { defaultMode: Sr(t) }, defaultMode: Mp }) : ((s = !1), (i = Sr(t)))
              }),
                this.config.skipValidations === !1 &&
                  (this.TRACE_INIT('performRuntimeChecks', () => {
                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(
                      iQ(i, this.trackStartLines, this.config.lineTerminatorCharacters),
                    )
                  }),
                  this.TRACE_INIT('performWarningRuntimeChecks', () => {
                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(
                      sQ(i, this.trackStartLines, this.config.lineTerminatorCharacters),
                    )
                  })),
                (i.modes = i.modes ? i.modes : {}),
                rt(i.modes, (l, u) => {
                  i.modes[u] = Pc(l, (h) => Fe(h))
                })
              let o = cr(i.modes)
              if (
                (rt(i.modes, (l, u) => {
                  this.TRACE_INIT(`Mode: <${u}> processing`, () => {
                    if (
                      (this.modes.push(u),
                      this.config.skipValidations === !1 &&
                        this.TRACE_INIT('validatePatterns', () => {
                          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(nQ(l, o))
                        }),
                      De(this.lexerDefinitionErrors))
                    ) {
                      El(l)
                      let h
                      this.TRACE_INIT('analyzeTokenTypes', () => {
                        h = rQ(l, {
                          lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                          positionTracking: r.positionTracking,
                          ensureOptimizations: r.ensureOptimizations,
                          safeMode: r.safeMode,
                          tracer: this.TRACE_INIT,
                        })
                      }),
                        (this.patternIdxToConfig[u] = h.patternIdxToConfig),
                        (this.charCodeToPatternIdxToConfig[u] = h.charCodeToPatternIdxToConfig),
                        (this.emptyGroups = ai({}, this.emptyGroups, h.emptyGroups)),
                        (this.hasCustom = h.hasCustom || this.hasCustom),
                        (this.canModeBeOptimized[u] = h.canBeOptimized)
                    }
                  })
                }),
                (this.defaultMode = i.defaultMode),
                !De(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling)
              ) {
                let u = Dt(this.lexerDefinitionErrors, (h) => h.message).join(`-----------------------
`)
                throw new Error(
                  `Errors detected in definition of Lexer:
` + u,
                )
              }
              rt(this.lexerDefinitionWarning, (l) => {
                y1(l.message)
              }),
                this.TRACE_INIT('Choosing sub-methods implementations', () => {
                  if (
                    (uL
                      ? ((this.chopInput = Hn), (this.match = this.matchWithTest))
                      : ((this.updateLastIndex = cn), (this.match = this.matchWithExec)),
                    s && (this.handleModes = cn),
                    this.trackStartLines === !1 && (this.computeNewColumn = Hn),
                    this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = cn),
                    /full/i.test(this.config.positionTracking))
                  )
                    this.createTokenInstance = this.createFullToken
                  else if (/onlyStart/i.test(this.config.positionTracking))
                    this.createTokenInstance = this.createStartOnlyToken
                  else if (/onlyOffset/i.test(this.config.positionTracking))
                    this.createTokenInstance = this.createOffsetOnlyToken
                  else throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`)
                  this.hasCustom
                    ? ((this.addToken = this.addTokenUsingPush), (this.handlePayload = this.handlePayloadWithCustom))
                    : ((this.addToken = this.addTokenUsingMemberAccess),
                      (this.handlePayload = this.handlePayloadNoCustom))
                }),
                this.TRACE_INIT('Failed Optimization Warnings', () => {
                  let l = mr(this.canModeBeOptimized, (u, h, f) => (h === !1 && u.push(f), u), [])
                  if (r.ensureOptimizations && !De(l))
                    throw Error(`Lexer Modes: < ${l.join(', ')} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)
                }),
                this.TRACE_INIT('clearRegExpParserCache', () => {
                  XK()
                }),
                this.TRACE_INIT('toFastProperties', () => {
                  b1(this)
                })
            })
        }
        tokenize(t, r = this.defaultMode) {
          if (!De(this.lexerDefinitionErrors)) {
            let i = Dt(this.lexerDefinitionErrors, (s) => s.message).join(`-----------------------
`)
            throw new Error(
              `Unable to Tokenize because Errors detected in definition of Lexer:
` + i,
            )
          }
          return this.tokenizeInternal(t, r)
        }
        tokenizeInternal(t, r) {
          let n,
            i,
            s,
            o,
            l,
            u,
            h,
            f,
            d,
            p,
            m,
            g,
            y,
            b,
            k,
            T,
            C = t,
            A = C.length,
            w = 0,
            D = 0,
            G = this.hasCustom ? 0 : Math.floor(t.length / 10),
            v = new Array(G),
            R = [],
            F = this.trackStartLines ? 1 : void 0,
            S = this.trackStartLines ? 1 : void 0,
            O = aQ(this.emptyGroups),
            E = this.trackStartLines,
            _ = this.config.lineTerminatorsPattern,
            L = 0,
            N = [],
            P = [],
            I = [],
            M = []
          Object.freeze(M)
          let V
          function $() {
            return N
          }
          a($, 'getPossiblePatternsSlow')
          function q(ht) {
            let yt = $o(ht),
              ot = P[yt]
            return ot === void 0 ? M : ot
          }
          a(q, 'getPossiblePatternsOptimized')
          let tt = a((ht) => {
            if (I.length === 1 && ht.tokenType.PUSH_MODE === void 0) {
              let yt = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(ht)
              R.push({
                offset: ht.startOffset,
                line: ht.startLine,
                column: ht.startColumn,
                length: ht.image.length,
                message: yt,
              })
            } else {
              I.pop()
              let yt = oi(I)
              ;(N = this.patternIdxToConfig[yt]), (P = this.charCodeToPatternIdxToConfig[yt]), (L = N.length)
              let ot = this.canModeBeOptimized[yt] && this.config.safeMode === !1
              P && ot ? (V = q) : (V = $)
            }
          }, 'pop_mode')
          function ft(ht) {
            I.push(ht),
              (P = this.charCodeToPatternIdxToConfig[ht]),
              (N = this.patternIdxToConfig[ht]),
              (L = N.length),
              (L = N.length)
            let yt = this.canModeBeOptimized[ht] && this.config.safeMode === !1
            P && yt ? (V = q) : (V = $)
          }
          a(ft, 'push_mode'), ft.call(this, r)
          let H,
            kt = this.config.recoveryEnabled
          for (; w < A; ) {
            u = null
            let ht = C.charCodeAt(w),
              yt = V(ht),
              ot = yt.length
            for (n = 0; n < ot; n++) {
              H = yt[n]
              let dt = H.pattern
              h = null
              let it = H.short
              if (
                (it !== !1
                  ? ht === it && (u = dt)
                  : H.isCustom === !0
                    ? ((T = dt.exec(C, w, v, O)),
                      T !== null ? ((u = T[0]), T.payload !== void 0 && (h = T.payload)) : (u = null))
                    : (this.updateLastIndex(dt, w), (u = this.match(dt, t, w))),
                u !== null)
              ) {
                if (((l = H.longerAlt), l !== void 0)) {
                  let Q = l.length
                  for (s = 0; s < Q; s++) {
                    let et = N[l[s]],
                      X = et.pattern
                    if (
                      ((f = null),
                      et.isCustom === !0
                        ? ((T = X.exec(C, w, v, O)),
                          T !== null ? ((o = T[0]), T.payload !== void 0 && (f = T.payload)) : (o = null))
                        : (this.updateLastIndex(X, w), (o = this.match(X, t, w))),
                      o && o.length > u.length)
                    ) {
                      ;(u = o), (h = f), (H = et)
                      break
                    }
                  }
                }
                break
              }
            }
            if (u !== null) {
              if (
                ((d = u.length),
                (p = H.group),
                p !== void 0 &&
                  ((m = H.tokenTypeIdx),
                  (g = this.createTokenInstance(u, w, m, H.tokenType, F, S, d)),
                  this.handlePayload(g, h),
                  p === !1 ? (D = this.addToken(v, D, g)) : O[p].push(g)),
                (t = this.chopInput(t, d)),
                (w = w + d),
                (S = this.computeNewColumn(S, d)),
                E === !0 && H.canLineTerminator === !0)
              ) {
                let dt = 0,
                  it,
                  Q
                _.lastIndex = 0
                do (it = _.test(u)), it === !0 && ((Q = _.lastIndex - 1), dt++)
                while (it === !0)
                dt !== 0 && ((F = F + dt), (S = d - Q), this.updateTokenEndLineColumnLocation(g, p, Q, dt, F, S, d))
              }
              this.handleModes(H, tt, ft, g)
            } else {
              let dt = w,
                it = F,
                Q = S,
                et = kt === !1
              for (; et === !1 && w < A; )
                for (t = this.chopInput(t, 1), w++, i = 0; i < L; i++) {
                  let X = N[i],
                    st = X.pattern,
                    U = X.short
                  if (
                    (U !== !1
                      ? C.charCodeAt(w) === U && (et = !0)
                      : X.isCustom === !0
                        ? (et = st.exec(C, w, v, O) !== null)
                        : (this.updateLastIndex(st, w), (et = st.exec(t) !== null)),
                    et === !0)
                  )
                    break
                }
              if (
                ((y = w - dt),
                (S = this.computeNewColumn(S, y)),
                (k = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(C, dt, y, it, Q)),
                R.push({ offset: dt, line: it, column: Q, length: y, message: k }),
                kt === !1)
              )
                break
            }
          }
          return this.hasCustom || (v.length = D), { tokens: v, groups: O, errors: R }
        }
        handleModes(t, r, n, i) {
          if (t.pop === !0) {
            let s = t.push
            r(i), s !== void 0 && n.call(this, s)
          } else t.push !== void 0 && n.call(this, t.push)
        }
        chopInput(t, r) {
          return t.substring(r)
        }
        updateLastIndex(t, r) {
          t.lastIndex = r
        }
        updateTokenEndLineColumnLocation(t, r, n, i, s, o, l) {
          let u, h
          r !== void 0 &&
            ((u = n === l - 1),
            (h = u ? -1 : 0),
            (i === 1 && u === !0) || ((t.endLine = s + h), (t.endColumn = o - 1 + -h)))
        }
        computeNewColumn(t, r) {
          return t + r
        }
        createOffsetOnlyToken(t, r, n, i) {
          return { image: t, startOffset: r, tokenTypeIdx: n, tokenType: i }
        }
        createStartOnlyToken(t, r, n, i, s, o) {
          return { image: t, startOffset: r, startLine: s, startColumn: o, tokenTypeIdx: n, tokenType: i }
        }
        createFullToken(t, r, n, i, s, o, l) {
          return {
            image: t,
            startOffset: r,
            endOffset: r + l - 1,
            startLine: s,
            endLine: s,
            startColumn: o,
            endColumn: o + l - 1,
            tokenTypeIdx: n,
            tokenType: i,
          }
        }
        addTokenUsingPush(t, r, n) {
          return t.push(n), r
        }
        addTokenUsingMemberAccess(t, r, n) {
          return (t[r] = n), r++, r
        }
        handlePayloadNoCustom(t, r) {}
        handlePayloadWithCustom(t, r) {
          r !== null && (t.payload = r)
        }
        matchWithTest(t, r, n) {
          return t.test(r) === !0 ? r.substring(n, t.lastIndex) : null
        }
        matchWithExec(t, r) {
          let n = t.exec(r)
          return n !== null ? n[0] : null
        }
      }
      en.SKIPPED =
        'This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.'
      en.NA = /NOT_APPLICABLE/
    })
  function vl(e) {
    return dL(e) ? e.LABEL : e.name
  }
  function dL(e) {
    return Tn(e.LABEL) && e.LABEL !== ''
  }
  function Wc(e) {
    return m4t(e)
  }
  function m4t(e) {
    let t = e.pattern,
      r = {}
    if (((r.name = e.name), Fe(t) || (r.PATTERN = t), te(e, p4t)))
      throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`
    return (
      te(e, gQ) && (r.CATEGORIES = e[gQ]),
      El([r]),
      te(e, yQ) && (r.LABEL = e[yQ]),
      te(e, xQ) && (r.GROUP = e[xQ]),
      te(e, kQ) && (r.POP_MODE = e[kQ]),
      te(e, bQ) && (r.PUSH_MODE = e[bQ]),
      te(e, TQ) && (r.LONGER_ALT = e[TQ]),
      te(e, SQ) && (r.LINE_BREAKS = e[SQ]),
      te(e, _Q) && (r.START_CHARS_HINT = e[_Q]),
      r
    )
  }
  function Al(e, t, r, n, i, s, o, l) {
    return {
      image: t,
      startOffset: r,
      endOffset: n,
      startLine: i,
      endLine: s,
      startColumn: o,
      endColumn: l,
      tokenTypeIdx: e.tokenTypeIdx,
      tokenType: e,
    }
  }
  function _1(e, t) {
    return wl(e, t)
  }
  var p4t,
    gQ,
    yQ,
    xQ,
    bQ,
    kQ,
    TQ,
    SQ,
    _Q,
    Ps,
    Nh = x(() => {
      'use strict'
      fe()
      T1()
      Dh()
      a(vl, 'tokenLabel')
      a(dL, 'hasTokenLabel')
      ;(p4t = 'parent'),
        (gQ = 'categories'),
        (yQ = 'label'),
        (xQ = 'group'),
        (bQ = 'push_mode'),
        (kQ = 'pop_mode'),
        (TQ = 'longer_alt'),
        (SQ = 'line_breaks'),
        (_Q = 'start_chars_hint')
      a(Wc, 'createToken')
      a(m4t, 'createTokenInternal')
      Ps = Wc({ name: 'EOF', pattern: en.NA })
      El([Ps])
      a(Al, 'createTokenInstance')
      a(_1, 'tokenMatcher')
    })
  var Ll,
    CQ,
    Ha,
    Bp = x(() => {
      'use strict'
      Nh()
      fe()
      ji()
      Ll = {
        buildMismatchTokenMessage({ expected: e, actual: t, previous: r, ruleName: n }) {
          return `Expecting ${dL(e) ? `--> ${vl(e)} <--` : `token of type --> ${e.name} <--`} but found --> '${t.image}' <--`
        },
        buildNotAllInputParsedMessage({ firstRedundant: e, ruleName: t }) {
          return 'Redundant input, expecting EOF but found: ' + e.image
        },
        buildNoViableAltMessage({
          expectedPathsPerAlt: e,
          actual: t,
          previous: r,
          customUserDescription: n,
          ruleName: i,
        }) {
          let s = 'Expecting: ',
            l =
              `
but found: '` +
              Qn(t).image +
              "'"
          if (n) return s + n + l
          {
            let u = mr(e, (p, m) => p.concat(m), []),
              h = Dt(u, (p) => `[${Dt(p, (m) => vl(m)).join(', ')}]`),
              d = `one of these possible Token sequences:
${Dt(h, (p, m) => `  ${m + 1}. ${p}`).join(`
`)}`
            return s + d + l
          }
        },
        buildEarlyExitMessage({ expectedIterationPaths: e, actual: t, customUserDescription: r, ruleName: n }) {
          let i = 'Expecting: ',
            o =
              `
but found: '` +
              Qn(t).image +
              "'"
          if (r) return i + r + o
          {
            let u = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${Dt(e, (h) => `[${Dt(h, (f) => vl(f)).join(',')}]`).join(' ,')}>`
            return i + u + o
          }
        },
      }
      Object.freeze(Ll)
      ;(CQ = {
        buildRuleNotFoundError(e, t) {
          return (
            'Invalid grammar, reference to a rule which is not defined: ->' +
            t.nonTerminalName +
            `<-
inside top level rule: ->` +
            e.name +
            '<-'
          )
        },
      }),
        (Ha = {
          buildDuplicateFoundError(e, t) {
            function r(f) {
              return f instanceof je ? f.terminalType.name : f instanceof Cr ? f.nonTerminalName : ''
            }
            a(r, 'getExtraProductionArgument')
            let n = e.name,
              i = Qn(t),
              s = i.idx,
              o = gs(i),
              l = r(i),
              u = s > 0,
              h = `->${o}${u ? s : ''}<- ${l ? `with argument: ->${l}<-` : ''}
                  appears more than once (${t.length} times) in the top level rule: ->${n}<-.
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES
                  `
            return (
              (h = h.replace(/[ \t]+/g, ' ')),
              (h = h.replace(
                /\s\s+/g,
                `
`,
              )),
              h
            )
          },
          buildNamespaceConflictError(e) {
            return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${e.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`
          },
          buildAlternationPrefixAmbiguityError(e) {
            let t = Dt(e.prefixPath, (i) => vl(i)).join(', '),
              r = e.alternation.idx === 0 ? '' : e.alternation.idx
            return `Ambiguous alternatives: <${e.ambiguityIndices.join(' ,')}> due to common lookahead prefix
in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`
          },
          buildAlternationAmbiguityError(e) {
            let t = Dt(e.prefixPath, (i) => vl(i)).join(', '),
              r = e.alternation.idx === 0 ? '' : e.alternation.idx,
              n = `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(' ,')}> in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`
            return (
              (n =
                n +
                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`),
              n
            )
          },
          buildEmptyRepetitionError(e) {
            let t = gs(e.repetition)
            return (
              e.repetition.idx !== 0 && (t += e.repetition.idx),
              `The repetition <${t}> within Rule <${e.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`
            )
          },
          buildTokenNameError(e) {
            return 'deprecated'
          },
          buildEmptyAlternationError(e) {
            return `Ambiguous empty alternative: <${e.emptyChoiceIdx + 1}> in <OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`
          },
          buildTooManyAlternativesError(e) {
            return `An Alternation cannot have more than 256 alternatives:
<OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
 has ${e.alternation.definition.length + 1} alternatives.`
          },
          buildLeftRecursionError(e) {
            let t = e.topLevelRule.name,
              r = Dt(e.leftRecursionPath, (s) => s.name),
              n = `${t} --> ${r.concat([t]).join(' --> ')}`
            return `Left Recursion found in grammar.
rule: <${t}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is:
 ${n}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`
          },
          buildInvalidRuleNameError(e) {
            return 'deprecated'
          },
          buildDuplicateRuleNameError(e) {
            let t
            return (
              e.topLevelRule instanceof Wi ? (t = e.topLevelRule.name) : (t = e.topLevelRule),
              `Duplicate definition, rule: ->${t}<- is already defined in the grammar: ->${e.grammarName}<-`
            )
          },
        })
    })
  function wQ(e, t) {
    let r = new pL(e, t)
    return r.resolveRefs(), r.errors
  }
  var pL,
    EQ = x(() => {
      'use strict'
      ys()
      fe()
      ji()
      a(wQ, 'resolveGrammar')
      pL = class extends Ui {
        static {
          a(this, 'GastRefResolverVisitor')
        }
        constructor(t, r) {
          super(), (this.nameToTopRule = t), (this.errMsgProvider = r), (this.errors = [])
        }
        resolveRefs() {
          rt(We(this.nameToTopRule), (t) => {
            ;(this.currTopLevel = t), t.accept(this)
          })
        }
        visitNonTerminal(t) {
          let r = this.nameToTopRule[t.nonTerminalName]
          if (r) t.referencedRule = r
          else {
            let n = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, t)
            this.errors.push({
              message: n,
              type: Fn.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: t.nonTerminalName,
            })
          }
        }
      }
    })
  function GT(e, t, r = []) {
    r = Sr(r)
    let n = [],
      i = 0
    function s(l) {
      return l.concat(kn(e, i + 1))
    }
    a(s, 'remainingPathWith')
    function o(l) {
      let u = GT(s(l), t, r)
      return n.concat(u)
    }
    for (a(o, 'getAlternativesForProd'); r.length < t && i < e.length; ) {
      let l = e[i]
      if (l instanceof Vr) return o(l.definition)
      if (l instanceof Cr) return o(l.definition)
      if (l instanceof wr) n = o(l.definition)
      else if (l instanceof zr) {
        let u = l.definition.concat([new ir({ definition: l.definition })])
        return o(u)
      } else if (l instanceof Wr) {
        let u = [
          new Vr({ definition: l.definition }),
          new ir({ definition: [new je({ terminalType: l.separator })].concat(l.definition) }),
        ]
        return o(u)
      } else if (l instanceof Mr) {
        let u = l.definition.concat([
          new ir({ definition: [new je({ terminalType: l.separator })].concat(l.definition) }),
        ])
        n = o(u)
      } else if (l instanceof ir) {
        let u = l.definition.concat([new ir({ definition: l.definition })])
        n = o(u)
      } else {
        if (l instanceof Or)
          return (
            rt(l.definition, (u) => {
              De(u.definition) === !1 && (n = o(u.definition))
            }),
            n
          )
        if (l instanceof je) r.push(l.terminalType)
        else throw Error('non exhaustive match')
      }
      i++
    }
    return n.push({ partialPath: r, suffixDef: kn(e, i) }), n
  }
  function VT(e, t, r, n) {
    let i = 'EXIT_NONE_TERMINAL',
      s = [i],
      o = 'EXIT_ALTERNATIVE',
      l = !1,
      u = t.length,
      h = u - n - 1,
      f = [],
      d = []
    for (d.push({ idx: -1, def: e, ruleStack: [], occurrenceStack: [] }); !De(d); ) {
      let p = d.pop()
      if (p === o) {
        l && oi(d).idx <= h && d.pop()
        continue
      }
      let m = p.def,
        g = p.idx,
        y = p.ruleStack,
        b = p.occurrenceStack
      if (De(m)) continue
      let k = m[0]
      if (k === i) {
        let T = { idx: g, def: kn(m), ruleStack: Tl(y), occurrenceStack: Tl(b) }
        d.push(T)
      } else if (k instanceof je)
        if (g < u - 1) {
          let T = g + 1,
            C = t[T]
          if (r(C, k.terminalType)) {
            let A = { idx: T, def: kn(m), ruleStack: y, occurrenceStack: b }
            d.push(A)
          }
        } else if (g === u - 1)
          f.push({ nextTokenType: k.terminalType, nextTokenOccurrence: k.idx, ruleStack: y, occurrenceStack: b }),
            (l = !0)
        else throw Error('non exhaustive match')
      else if (k instanceof Cr) {
        let T = Sr(y)
        T.push(k.nonTerminalName)
        let C = Sr(b)
        C.push(k.idx)
        let A = { idx: g, def: k.definition.concat(s, kn(m)), ruleStack: T, occurrenceStack: C }
        d.push(A)
      } else if (k instanceof wr) {
        let T = { idx: g, def: kn(m), ruleStack: y, occurrenceStack: b }
        d.push(T), d.push(o)
        let C = { idx: g, def: k.definition.concat(kn(m)), ruleStack: y, occurrenceStack: b }
        d.push(C)
      } else if (k instanceof zr) {
        let T = new ir({ definition: k.definition, idx: k.idx }),
          C = k.definition.concat([T], kn(m)),
          A = { idx: g, def: C, ruleStack: y, occurrenceStack: b }
        d.push(A)
      } else if (k instanceof Wr) {
        let T = new je({ terminalType: k.separator }),
          C = new ir({ definition: [T].concat(k.definition), idx: k.idx }),
          A = k.definition.concat([C], kn(m)),
          w = { idx: g, def: A, ruleStack: y, occurrenceStack: b }
        d.push(w)
      } else if (k instanceof Mr) {
        let T = { idx: g, def: kn(m), ruleStack: y, occurrenceStack: b }
        d.push(T), d.push(o)
        let C = new je({ terminalType: k.separator }),
          A = new ir({ definition: [C].concat(k.definition), idx: k.idx }),
          w = k.definition.concat([A], kn(m)),
          D = { idx: g, def: w, ruleStack: y, occurrenceStack: b }
        d.push(D)
      } else if (k instanceof ir) {
        let T = { idx: g, def: kn(m), ruleStack: y, occurrenceStack: b }
        d.push(T), d.push(o)
        let C = new ir({ definition: k.definition, idx: k.idx }),
          A = k.definition.concat([C], kn(m)),
          w = { idx: g, def: A, ruleStack: y, occurrenceStack: b }
        d.push(w)
      } else if (k instanceof Or)
        for (let T = k.definition.length - 1; T >= 0; T--) {
          let C = k.definition[T],
            A = { idx: g, def: C.definition.concat(kn(m)), ruleStack: y, occurrenceStack: b }
          d.push(A), d.push(o)
        }
      else if (k instanceof Vr) d.push({ idx: g, def: k.definition.concat(kn(m)), ruleStack: y, occurrenceStack: b })
      else if (k instanceof Wi) d.push(g4t(k, g, y, b))
      else throw Error('non exhaustive match')
    }
    return f
  }
  function g4t(e, t, r, n) {
    let i = Sr(r)
    i.push(e.name)
    let s = Sr(n)
    return s.push(1), { idx: t, def: e.definition, ruleStack: i, occurrenceStack: s }
  }
  var mL,
    BT,
    Fp,
    FT,
    C1,
    $T,
    w1,
    E1 = x(() => {
      'use strict'
      fe()
      rL()
      LT()
      ji()
      ;(mL = class extends Cl {
        static {
          a(this, 'AbstractNextPossibleTokensWalker')
        }
        constructor(t, r) {
          super(),
            (this.topProd = t),
            (this.path = r),
            (this.possibleTokTypes = []),
            (this.nextProductionName = ''),
            (this.nextProductionOccurrence = 0),
            (this.found = !1),
            (this.isAtEndOfPath = !1)
        }
        startWalking() {
          if (((this.found = !1), this.path.ruleStack[0] !== this.topProd.name))
            throw Error("The path does not start with the walker's top Rule!")
          return (
            (this.ruleStack = Sr(this.path.ruleStack).reverse()),
            (this.occurrenceStack = Sr(this.path.occurrenceStack).reverse()),
            this.ruleStack.pop(),
            this.occurrenceStack.pop(),
            this.updateExpectedNext(),
            this.walk(this.topProd),
            this.possibleTokTypes
          )
        }
        walk(t, r = []) {
          this.found || super.walk(t, r)
        }
        walkProdRef(t, r, n) {
          if (t.referencedRule.name === this.nextProductionName && t.idx === this.nextProductionOccurrence) {
            let i = r.concat(n)
            this.updateExpectedNext(), this.walk(t.referencedRule, i)
          }
        }
        updateExpectedNext() {
          De(this.ruleStack)
            ? ((this.nextProductionName = ''), (this.nextProductionOccurrence = 0), (this.isAtEndOfPath = !0))
            : ((this.nextProductionName = this.ruleStack.pop()),
              (this.nextProductionOccurrence = this.occurrenceStack.pop()))
        }
      }),
        (BT = class extends mL {
          static {
            a(this, 'NextAfterTokenWalker')
          }
          constructor(t, r) {
            super(t, r),
              (this.path = r),
              (this.nextTerminalName = ''),
              (this.nextTerminalOccurrence = 0),
              (this.nextTerminalName = this.path.lastTok.name),
              (this.nextTerminalOccurrence = this.path.lastTokOccurrence)
          }
          walkTerminal(t, r, n) {
            if (
              this.isAtEndOfPath &&
              t.terminalType.name === this.nextTerminalName &&
              t.idx === this.nextTerminalOccurrence &&
              !this.found
            ) {
              let i = r.concat(n),
                s = new Vr({ definition: i })
              ;(this.possibleTokTypes = Lh(s)), (this.found = !0)
            }
          }
        }),
        (Fp = class extends Cl {
          static {
            a(this, 'AbstractNextTerminalAfterProductionWalker')
          }
          constructor(t, r) {
            super(),
              (this.topRule = t),
              (this.occurrence = r),
              (this.result = { token: void 0, occurrence: void 0, isEndOfRule: void 0 })
          }
          startWalking() {
            return this.walk(this.topRule), this.result
          }
        }),
        (FT = class extends Fp {
          static {
            a(this, 'NextTerminalAfterManyWalker')
          }
          walkMany(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n))
              ;(this.result.isEndOfRule = i === void 0),
                i instanceof je && ((this.result.token = i.terminalType), (this.result.occurrence = i.idx))
            } else super.walkMany(t, r, n)
          }
        }),
        (C1 = class extends Fp {
          static {
            a(this, 'NextTerminalAfterManySepWalker')
          }
          walkManySep(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n))
              ;(this.result.isEndOfRule = i === void 0),
                i instanceof je && ((this.result.token = i.terminalType), (this.result.occurrence = i.idx))
            } else super.walkManySep(t, r, n)
          }
        }),
        ($T = class extends Fp {
          static {
            a(this, 'NextTerminalAfterAtLeastOneWalker')
          }
          walkAtLeastOne(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n))
              ;(this.result.isEndOfRule = i === void 0),
                i instanceof je && ((this.result.token = i.terminalType), (this.result.occurrence = i.idx))
            } else super.walkAtLeastOne(t, r, n)
          }
        }),
        (w1 = class extends Fp {
          static {
            a(this, 'NextTerminalAfterAtLeastOneSepWalker')
          }
          walkAtLeastOneSep(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n))
              ;(this.result.isEndOfRule = i === void 0),
                i instanceof je && ((this.result.token = i.terminalType), (this.result.occurrence = i.idx))
            } else super.walkAtLeastOneSep(t, r, n)
          }
        })
      a(GT, 'possiblePathsFrom')
      a(VT, 'nextPossibleTokensAfter')
      a(g4t, 'expandTopLevelRule')
    })
  function v1(e) {
    if (e instanceof wr || e === 'Option') return rn.OPTION
    if (e instanceof ir || e === 'Repetition') return rn.REPETITION
    if (e instanceof zr || e === 'RepetitionMandatory') return rn.REPETITION_MANDATORY
    if (e instanceof Wr || e === 'RepetitionMandatoryWithSeparator') return rn.REPETITION_MANDATORY_WITH_SEPARATOR
    if (e instanceof Mr || e === 'RepetitionWithSeparator') return rn.REPETITION_WITH_SEPARATOR
    if (e instanceof Or || e === 'Alternation') return rn.ALTERNATION
    throw Error('non exhaustive match')
  }
  function WT(e) {
    let { occurrence: t, rule: r, prodType: n, maxLookahead: i } = e,
      s = v1(n)
    return s === rn.ALTERNATION ? $p(t, r, i) : Gp(t, r, s, i)
  }
  function AQ(e, t, r, n, i, s) {
    let o = $p(e, t, r),
      l = MQ(o) ? Op : wl
    return s(o, n, l, i)
  }
  function LQ(e, t, r, n, i, s) {
    let o = Gp(e, t, i, r),
      l = MQ(o) ? Op : wl
    return s(o[0], l, n)
  }
  function RQ(e, t, r, n) {
    let i = e.length,
      s = ki(e, (o) => ki(o, (l) => l.length === 1))
    if (t)
      return function (o) {
        let l = Dt(o, (u) => u.GATE)
        for (let u = 0; u < i; u++) {
          let h = e[u],
            f = h.length,
            d = l[u]
          if (!(d !== void 0 && d.call(this) === !1))
            t: for (let p = 0; p < f; p++) {
              let m = h[p],
                g = m.length
              for (let y = 0; y < g; y++) {
                let b = this.LA(y + 1)
                if (r(b, m[y]) === !1) continue t
              }
              return u
            }
        }
      }
    if (s && !n) {
      let o = Dt(e, (u) => dr(u)),
        l = mr(
          o,
          (u, h, f) => (
            rt(h, (d) => {
              te(u, d.tokenTypeIdx) || (u[d.tokenTypeIdx] = f),
                rt(d.categoryMatches, (p) => {
                  te(u, p) || (u[p] = f)
                })
            }),
            u
          ),
          {},
        )
      return function () {
        let u = this.LA(1)
        return l[u.tokenTypeIdx]
      }
    } else
      return function () {
        for (let o = 0; o < i; o++) {
          let l = e[o],
            u = l.length
          t: for (let h = 0; h < u; h++) {
            let f = l[h],
              d = f.length
            for (let p = 0; p < d; p++) {
              let m = this.LA(p + 1)
              if (r(m, f[p]) === !1) continue t
            }
            return o
          }
        }
      }
  }
  function DQ(e, t, r) {
    let n = ki(e, (s) => s.length === 1),
      i = e.length
    if (n && !r) {
      let s = dr(e)
      if (s.length === 1 && De(s[0].categoryMatches)) {
        let l = s[0].tokenTypeIdx
        return function () {
          return this.LA(1).tokenTypeIdx === l
        }
      } else {
        let o = mr(
          s,
          (l, u, h) => (
            (l[u.tokenTypeIdx] = !0),
            rt(u.categoryMatches, (f) => {
              l[f] = !0
            }),
            l
          ),
          [],
        )
        return function () {
          let l = this.LA(1)
          return o[l.tokenTypeIdx] === !0
        }
      }
    } else
      return function () {
        t: for (let s = 0; s < i; s++) {
          let o = e[s],
            l = o.length
          for (let u = 0; u < l; u++) {
            let h = this.LA(u + 1)
            if (t(h, o[u]) === !1) continue t
          }
          return !0
        }
        return !1
      }
  }
  function vQ(e) {
    let t = new Array(e)
    for (let r = 0; r < e; r++) t[r] = []
    return t
  }
  function gL(e) {
    let t = ['']
    for (let r = 0; r < e.length; r++) {
      let n = e[r],
        i = []
      for (let s = 0; s < t.length; s++) {
        let o = t[s]
        i.push(o + '_' + n.tokenTypeIdx)
        for (let l = 0; l < n.categoryMatches.length; l++) {
          let u = '_' + n.categoryMatches[l]
          i.push(o + u)
        }
      }
      t = i
    }
    return t
  }
  function y4t(e, t, r) {
    for (let n = 0; n < e.length; n++) {
      if (n === r) continue
      let i = e[n]
      for (let s = 0; s < t.length; s++) {
        let o = t[s]
        if (i[o] === !0) return !1
      }
    }
    return !0
  }
  function NQ(e, t) {
    let r = Dt(e, (o) => GT([o], 1)),
      n = vQ(r.length),
      i = Dt(r, (o) => {
        let l = {}
        return (
          rt(o, (u) => {
            let h = gL(u.partialPath)
            rt(h, (f) => {
              l[f] = !0
            })
          }),
          l
        )
      }),
      s = r
    for (let o = 1; o <= t; o++) {
      let l = s
      s = vQ(l.length)
      for (let u = 0; u < l.length; u++) {
        let h = l[u]
        for (let f = 0; f < h.length; f++) {
          let d = h[f].partialPath,
            p = h[f].suffixDef,
            m = gL(d)
          if (y4t(i, m, u) || De(p) || d.length === t) {
            let y = n[u]
            if (UT(y, d) === !1) {
              y.push(d)
              for (let b = 0; b < m.length; b++) {
                let k = m[b]
                i[u][k] = !0
              }
            }
          } else {
            let y = GT(p, o + 1, d)
            ;(s[u] = s[u].concat(y)),
              rt(y, (b) => {
                let k = gL(b.partialPath)
                rt(k, (T) => {
                  i[u][T] = !0
                })
              })
          }
        }
      }
    }
    return n
  }
  function $p(e, t, r, n) {
    let i = new zT(e, rn.ALTERNATION, n)
    return t.accept(i), NQ(i.result, r)
  }
  function Gp(e, t, r, n) {
    let i = new zT(e, r)
    t.accept(i)
    let s = i.result,
      l = new yL(t, e, r).startWalking(),
      u = new Vr({ definition: s }),
      h = new Vr({ definition: l })
    return NQ([u, h], n)
  }
  function UT(e, t) {
    t: for (let r = 0; r < e.length; r++) {
      let n = e[r]
      if (n.length === t.length) {
        for (let i = 0; i < n.length; i++) {
          let s = t[i],
            o = n[i]
          if ((s === o || o.categoryMatchesMap[s.tokenTypeIdx] !== void 0) === !1) continue t
        }
        return !0
      }
    }
    return !1
  }
  function IQ(e, t) {
    return (
      e.length < t.length &&
      ki(e, (r, n) => {
        let i = t[n]
        return r === i || i.categoryMatchesMap[r.tokenTypeIdx]
      })
    )
  }
  function MQ(e) {
    return ki(e, (t) => ki(t, (r) => ki(r, (n) => De(n.categoryMatches))))
  }
  var rn,
    yL,
    zT,
    Vp = x(() => {
      'use strict'
      fe()
      E1()
      LT()
      Dh()
      ji()
      ;(function (e) {
        ;(e[(e.OPTION = 0)] = 'OPTION'),
          (e[(e.REPETITION = 1)] = 'REPETITION'),
          (e[(e.REPETITION_MANDATORY = 2)] = 'REPETITION_MANDATORY'),
          (e[(e.REPETITION_MANDATORY_WITH_SEPARATOR = 3)] = 'REPETITION_MANDATORY_WITH_SEPARATOR'),
          (e[(e.REPETITION_WITH_SEPARATOR = 4)] = 'REPETITION_WITH_SEPARATOR'),
          (e[(e.ALTERNATION = 5)] = 'ALTERNATION')
      })(rn || (rn = {}))
      a(v1, 'getProdType')
      a(WT, 'getLookaheadPaths')
      a(AQ, 'buildLookaheadFuncForOr')
      a(LQ, 'buildLookaheadFuncForOptionalProd')
      a(RQ, 'buildAlternativesLookAheadFunc')
      a(DQ, 'buildSingleAlternativeLookaheadFunction')
      ;(yL = class extends Cl {
        static {
          a(this, 'RestDefinitionFinderWalker')
        }
        constructor(t, r, n) {
          super(), (this.topProd = t), (this.targetOccurrence = r), (this.targetProdType = n)
        }
        startWalking() {
          return this.walk(this.topProd), this.restDef
        }
        checkIsTarget(t, r, n, i) {
          return t.idx === this.targetOccurrence && this.targetProdType === r ? ((this.restDef = n.concat(i)), !0) : !1
        }
        walkOption(t, r, n) {
          this.checkIsTarget(t, rn.OPTION, r, n) || super.walkOption(t, r, n)
        }
        walkAtLeastOne(t, r, n) {
          this.checkIsTarget(t, rn.REPETITION_MANDATORY, r, n) || super.walkOption(t, r, n)
        }
        walkAtLeastOneSep(t, r, n) {
          this.checkIsTarget(t, rn.REPETITION_MANDATORY_WITH_SEPARATOR, r, n) || super.walkOption(t, r, n)
        }
        walkMany(t, r, n) {
          this.checkIsTarget(t, rn.REPETITION, r, n) || super.walkOption(t, r, n)
        }
        walkManySep(t, r, n) {
          this.checkIsTarget(t, rn.REPETITION_WITH_SEPARATOR, r, n) || super.walkOption(t, r, n)
        }
      }),
        (zT = class extends Ui {
          static {
            a(this, 'InsideDefinitionFinderVisitor')
          }
          constructor(t, r, n) {
            super(), (this.targetOccurrence = t), (this.targetProdType = r), (this.targetRef = n), (this.result = [])
          }
          checkIsTarget(t, r) {
            t.idx === this.targetOccurrence &&
              this.targetProdType === r &&
              (this.targetRef === void 0 || t === this.targetRef) &&
              (this.result = t.definition)
          }
          visitOption(t) {
            this.checkIsTarget(t, rn.OPTION)
          }
          visitRepetition(t) {
            this.checkIsTarget(t, rn.REPETITION)
          }
          visitRepetitionMandatory(t) {
            this.checkIsTarget(t, rn.REPETITION_MANDATORY)
          }
          visitRepetitionMandatoryWithSeparator(t) {
            this.checkIsTarget(t, rn.REPETITION_MANDATORY_WITH_SEPARATOR)
          }
          visitRepetitionWithSeparator(t) {
            this.checkIsTarget(t, rn.REPETITION_WITH_SEPARATOR)
          }
          visitAlternation(t) {
            this.checkIsTarget(t, rn.ALTERNATION)
          }
        })
      a(vQ, 'initializeArrayOfArrays')
      a(gL, 'pathToHashKeys')
      a(y4t, 'isUniquePrefixHash')
      a(NQ, 'lookAheadSequenceFromAlternatives')
      a($p, 'getLookaheadPathsForOr')
      a(Gp, 'getLookaheadPathsForOptionalProd')
      a(UT, 'containsPath')
      a(IQ, 'isStrictPrefixOfPath')
      a(MQ, 'areTokenCategoriesNotUsed')
    })
  function OQ(e) {
    let t = e.lookaheadStrategy.validate({ rules: e.rules, tokenTypes: e.tokenTypes, grammarName: e.grammarName })
    return Dt(t, (r) => Object.assign({ type: Fn.CUSTOM_LOOKAHEAD_VALIDATION }, r))
  }
  function PQ(e, t, r, n) {
    let i = li(e, (u) => x4t(u, r)),
      s = C4t(e, t, r),
      o = li(e, (u) => T4t(u, r)),
      l = li(e, (u) => k4t(u, e, n, r))
    return i.concat(s, o, l)
  }
  function x4t(e, t) {
    let r = new xL()
    e.accept(r)
    let n = r.allProductions,
      i = m5(n, b4t),
      s = ps(i, (l) => l.length > 1)
    return Dt(We(s), (l) => {
      let u = Qn(l),
        h = t.buildDuplicateFoundError(e, l),
        f = gs(u),
        d = { message: h, type: Fn.DUPLICATE_PRODUCTIONS, ruleName: e.name, dslName: f, occurrence: u.idx },
        p = BQ(u)
      return p && (d.parameter = p), d
    })
  }
  function b4t(e) {
    return `${gs(e)}_#_${e.idx}_#_${BQ(e)}`
  }
  function BQ(e) {
    return e instanceof je ? e.terminalType.name : e instanceof Cr ? e.nonTerminalName : ''
  }
  function k4t(e, t, r, n) {
    let i = []
    if (mr(t, (o, l) => (l.name === e.name ? o + 1 : o), 0) > 1) {
      let o = n.buildDuplicateRuleNameError({ topLevelRule: e, grammarName: r })
      i.push({ message: o, type: Fn.DUPLICATE_RULE_NAME, ruleName: e.name })
    }
    return i
  }
  function FQ(e, t, r) {
    let n = [],
      i
    return (
      Jr(t, e) ||
        ((i = `Invalid rule override, rule: ->${e}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `),
        n.push({ message: i, type: Fn.INVALID_RULE_OVERRIDE, ruleName: e })),
      n
    )
  }
  function kL(e, t, r, n = []) {
    let i = [],
      s = jT(t.definition)
    if (De(s)) return []
    {
      let o = e.name
      Jr(s, e) &&
        i.push({
          message: r.buildLeftRecursionError({ topLevelRule: e, leftRecursionPath: n }),
          type: Fn.LEFT_RECURSION,
          ruleName: o,
        })
      let u = Oc(s, n.concat([e])),
        h = li(u, (f) => {
          let d = Sr(n)
          return d.push(f), kL(e, f, r, d)
        })
      return i.concat(h)
    }
  }
  function jT(e) {
    let t = []
    if (De(e)) return t
    let r = Qn(e)
    if (r instanceof Cr) t.push(r.referencedRule)
    else if (
      r instanceof Vr ||
      r instanceof wr ||
      r instanceof zr ||
      r instanceof Wr ||
      r instanceof Mr ||
      r instanceof ir
    )
      t = t.concat(jT(r.definition))
    else if (r instanceof Or) t = dr(Dt(r.definition, (s) => jT(s.definition)))
    else if (!(r instanceof je)) throw Error('non exhaustive match')
    let n = Ah(r),
      i = e.length > 1
    if (n && i) {
      let s = kn(e)
      return t.concat(jT(s))
    } else return t
  }
  function $Q(e, t) {
    let r = new A1()
    e.accept(r)
    let n = r.alternations
    return li(n, (s) => {
      let o = Tl(s.definition)
      return li(o, (l, u) => {
        let h = VT([l], [], wl, 1)
        return De(h)
          ? [
              {
                message: t.buildEmptyAlternationError({ topLevelRule: e, alternation: s, emptyChoiceIdx: u }),
                type: Fn.NONE_LAST_EMPTY_ALT,
                ruleName: e.name,
                occurrence: s.idx,
                alternative: u + 1,
              },
            ]
          : []
      })
    })
  }
  function GQ(e, t, r) {
    let n = new A1()
    e.accept(n)
    let i = n.alternations
    return (
      (i = Pc(i, (o) => o.ignoreAmbiguities === !0)),
      li(i, (o) => {
        let l = o.idx,
          u = o.maxLookahead || t,
          h = $p(l, e, u, o),
          f = S4t(h, o, e, r),
          d = _4t(h, o, e, r)
        return f.concat(d)
      })
    )
  }
  function T4t(e, t) {
    let r = new A1()
    e.accept(r)
    let n = r.alternations
    return li(n, (s) =>
      s.definition.length > 255
        ? [
            {
              message: t.buildTooManyAlternativesError({ topLevelRule: e, alternation: s }),
              type: Fn.TOO_MANY_ALTS,
              ruleName: e.name,
              occurrence: s.idx,
            },
          ]
        : [],
    )
  }
  function VQ(e, t, r) {
    let n = []
    return (
      rt(e, (i) => {
        let s = new bL()
        i.accept(s)
        let o = s.allProductions
        rt(o, (l) => {
          let u = v1(l),
            h = l.maxLookahead || t,
            f = l.idx,
            p = Gp(f, i, u, h)[0]
          if (De(dr(p))) {
            let m = r.buildEmptyRepetitionError({ topLevelRule: i, repetition: l })
            n.push({ message: m, type: Fn.NO_NON_EMPTY_LOOKAHEAD, ruleName: i.name })
          }
        })
      }),
      n
    )
  }
  function S4t(e, t, r, n) {
    let i = [],
      s = mr(
        e,
        (l, u, h) => (
          t.definition[h].ignoreAmbiguities === !0 ||
            rt(u, (f) => {
              let d = [h]
              rt(e, (p, m) => {
                h !== m && UT(p, f) && t.definition[m].ignoreAmbiguities !== !0 && d.push(m)
              }),
                d.length > 1 && !UT(i, f) && (i.push(f), l.push({ alts: d, path: f }))
            }),
          l
        ),
        [],
      )
    return Dt(s, (l) => {
      let u = Dt(l.alts, (f) => f + 1)
      return {
        message: n.buildAlternationAmbiguityError({
          topLevelRule: r,
          alternation: t,
          ambiguityIndices: u,
          prefixPath: l.path,
        }),
        type: Fn.AMBIGUOUS_ALTS,
        ruleName: r.name,
        occurrence: t.idx,
        alternatives: l.alts,
      }
    })
  }
  function _4t(e, t, r, n) {
    let i = mr(
      e,
      (o, l, u) => {
        let h = Dt(l, (f) => ({ idx: u, path: f }))
        return o.concat(h)
      },
      [],
    )
    return vo(
      li(i, (o) => {
        if (t.definition[o.idx].ignoreAmbiguities === !0) return []
        let u = o.idx,
          h = o.path,
          f = pr(i, (p) => t.definition[p.idx].ignoreAmbiguities !== !0 && p.idx < u && IQ(p.path, h))
        return Dt(f, (p) => {
          let m = [p.idx + 1, u + 1],
            g = t.idx === 0 ? '' : t.idx
          return {
            message: n.buildAlternationPrefixAmbiguityError({
              topLevelRule: r,
              alternation: t,
              ambiguityIndices: m,
              prefixPath: p.path,
            }),
            type: Fn.AMBIGUOUS_PREFIX_ALTS,
            ruleName: r.name,
            occurrence: g,
            alternatives: m,
          }
        })
      }),
    )
  }
  function C4t(e, t, r) {
    let n = [],
      i = Dt(t, (s) => s.name)
    return (
      rt(e, (s) => {
        let o = s.name
        if (Jr(i, o)) {
          let l = r.buildNamespaceConflictError(s)
          n.push({ message: l, type: Fn.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName: o })
        }
      }),
      n
    )
  }
  var xL,
    A1,
    bL,
    L1 = x(() => {
      'use strict'
      fe()
      ys()
      ji()
      Vp()
      E1()
      Dh()
      a(OQ, 'validateLookahead')
      a(PQ, 'validateGrammar')
      a(x4t, 'validateDuplicateProductions')
      a(b4t, 'identifyProductionForDuplicates')
      a(BQ, 'getExtraProductionArgument')
      xL = class extends Ui {
        static {
          a(this, 'OccurrenceValidationCollector')
        }
        constructor() {
          super(...arguments), (this.allProductions = [])
        }
        visitNonTerminal(t) {
          this.allProductions.push(t)
        }
        visitOption(t) {
          this.allProductions.push(t)
        }
        visitRepetitionWithSeparator(t) {
          this.allProductions.push(t)
        }
        visitRepetitionMandatory(t) {
          this.allProductions.push(t)
        }
        visitRepetitionMandatoryWithSeparator(t) {
          this.allProductions.push(t)
        }
        visitRepetition(t) {
          this.allProductions.push(t)
        }
        visitAlternation(t) {
          this.allProductions.push(t)
        }
        visitTerminal(t) {
          this.allProductions.push(t)
        }
      }
      a(k4t, 'validateRuleDoesNotAlreadyExist')
      a(FQ, 'validateRuleIsOverridden')
      a(kL, 'validateNoLeftRecursion')
      a(jT, 'getFirstNoneTerminal')
      A1 = class extends Ui {
        static {
          a(this, 'OrCollector')
        }
        constructor() {
          super(...arguments), (this.alternations = [])
        }
        visitAlternation(t) {
          this.alternations.push(t)
        }
      }
      a($Q, 'validateEmptyOrAlternative')
      a(GQ, 'validateAmbiguousAlternationAlternatives')
      bL = class extends Ui {
        static {
          a(this, 'RepetitionCollector')
        }
        constructor() {
          super(...arguments), (this.allProductions = [])
        }
        visitRepetitionWithSeparator(t) {
          this.allProductions.push(t)
        }
        visitRepetitionMandatory(t) {
          this.allProductions.push(t)
        }
        visitRepetitionMandatoryWithSeparator(t) {
          this.allProductions.push(t)
        }
        visitRepetition(t) {
          this.allProductions.push(t)
        }
      }
      a(T4t, 'validateTooManyAlts')
      a(VQ, 'validateSomeNonEmptyLookaheadPath')
      a(S4t, 'checkAlternativesAmbiguities')
      a(_4t, 'checkPrefixAlternativesAmbiguities')
      a(C4t, 'checkTerminalAndNoneTerminalsNameSpace')
    })
  function zQ(e) {
    let t = Mc(e, { errMsgProvider: CQ }),
      r = {}
    return (
      rt(e.rules, (n) => {
        r[n.name] = n
      }),
      wQ(r, t.errMsgProvider)
    )
  }
  function WQ(e) {
    return (e = Mc(e, { errMsgProvider: Ha })), PQ(e.rules, e.tokenTypes, e.errMsgProvider, e.grammarName)
  }
  var UQ = x(() => {
    'use strict'
    fe()
    EQ()
    L1()
    Bp()
    a(zQ, 'resolveGrammar')
    a(WQ, 'validateGrammar')
  })
  function Uc(e) {
    return Jr(XQ, e.name)
  }
  var jQ,
    qQ,
    HQ,
    YQ,
    XQ,
    zp,
    Ih,
    R1,
    D1,
    N1,
    Wp = x(() => {
      'use strict'
      fe()
      ;(jQ = 'MismatchedTokenException'),
        (qQ = 'NoViableAltException'),
        (HQ = 'EarlyExitException'),
        (YQ = 'NotAllInputParsedException'),
        (XQ = [jQ, qQ, HQ, YQ])
      Object.freeze(XQ)
      a(Uc, 'isRecognitionException')
      ;(zp = class extends Error {
        static {
          a(this, 'RecognitionException')
        }
        constructor(t, r) {
          super(t),
            (this.token = r),
            (this.resyncedTokens = []),
            Object.setPrototypeOf(this, new.target.prototype),
            Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)
        }
      }),
        (Ih = class extends zp {
          static {
            a(this, 'MismatchedTokenException')
          }
          constructor(t, r, n) {
            super(t, r), (this.previousToken = n), (this.name = jQ)
          }
        }),
        (R1 = class extends zp {
          static {
            a(this, 'NoViableAltException')
          }
          constructor(t, r, n) {
            super(t, r), (this.previousToken = n), (this.name = qQ)
          }
        }),
        (D1 = class extends zp {
          static {
            a(this, 'NotAllInputParsedException')
          }
          constructor(t, r) {
            super(t, r), (this.name = YQ)
          }
        }),
        (N1 = class extends zp {
          static {
            a(this, 'EarlyExitException')
          }
          constructor(t, r, n) {
            super(t, r), (this.previousToken = n), (this.name = HQ)
          }
        })
    })
  function w4t(e, t, r, n, i, s, o) {
    let l = this.getKeyForAutomaticLookahead(n, i),
      u = this.firstAfterRepMap[l]
    if (u === void 0) {
      let p = this.getCurrRuleFullName(),
        m = this.getGAstProductions()[p]
      ;(u = new s(m, i).startWalking()), (this.firstAfterRepMap[l] = u)
    }
    let h = u.token,
      f = u.occurrence,
      d = u.isEndOfRule
    this.RULE_STACK.length === 1 && d && h === void 0 && ((h = Ps), (f = 1)),
      !(h === void 0 || f === void 0) &&
        this.shouldInRepetitionRecoveryBeTried(h, f, o) &&
        this.tryInRepetitionRecovery(e, t, r, h)
  }
  var TL,
    _L,
    SL,
    qT,
    CL = x(() => {
      'use strict'
      Nh()
      fe()
      Wp()
      nL()
      ys()
      ;(TL = {}),
        (_L = 'InRuleRecoveryException'),
        (SL = class extends Error {
          static {
            a(this, 'InRuleRecoveryException')
          }
          constructor(t) {
            super(t), (this.name = _L)
          }
        }),
        (qT = class {
          static {
            a(this, 'Recoverable')
          }
          initRecoverable(t) {
            ;(this.firstAfterRepMap = {}),
              (this.resyncFollows = {}),
              (this.recoveryEnabled = te(t, 'recoveryEnabled') ? t.recoveryEnabled : qi.recoveryEnabled),
              this.recoveryEnabled && (this.attemptInRepetitionRecovery = w4t)
          }
          getTokenToInsert(t) {
            let r = Al(t, '', NaN, NaN, NaN, NaN, NaN, NaN)
            return (r.isInsertedInRecovery = !0), r
          }
          canTokenTypeBeInsertedInRecovery(t) {
            return !0
          }
          canTokenTypeBeDeletedInRecovery(t) {
            return !0
          }
          tryInRepetitionRecovery(t, r, n, i) {
            let s = this.findReSyncTokenType(),
              o = this.exportLexerState(),
              l = [],
              u = !1,
              h = this.LA(1),
              f = this.LA(1),
              d = a(() => {
                let p = this.LA(0),
                  m = this.errorMessageProvider.buildMismatchTokenMessage({
                    expected: i,
                    actual: h,
                    previous: p,
                    ruleName: this.getCurrRuleFullName(),
                  }),
                  g = new Ih(m, h, this.LA(0))
                ;(g.resyncedTokens = Tl(l)), this.SAVE_ERROR(g)
              }, 'generateErrorMessage')
            for (; !u; )
              if (this.tokenMatcher(f, i)) {
                d()
                return
              } else if (n.call(this)) {
                d(), t.apply(this, r)
                return
              } else this.tokenMatcher(f, s) ? (u = !0) : ((f = this.SKIP_TOKEN()), this.addToResyncTokens(f, l))
            this.importLexerState(o)
          }
          shouldInRepetitionRecoveryBeTried(t, r, n) {
            return !(
              n === !1 ||
              this.tokenMatcher(this.LA(1), t) ||
              this.isBackTracking() ||
              this.canPerformInRuleRecovery(t, this.getFollowsForInRuleRecovery(t, r))
            )
          }
          getFollowsForInRuleRecovery(t, r) {
            let n = this.getCurrentGrammarPath(t, r)
            return this.getNextPossibleTokenTypes(n)
          }
          tryInRuleRecovery(t, r) {
            if (this.canRecoverWithSingleTokenInsertion(t, r)) return this.getTokenToInsert(t)
            if (this.canRecoverWithSingleTokenDeletion(t)) {
              let n = this.SKIP_TOKEN()
              return this.consumeToken(), n
            }
            throw new SL('sad sad panda')
          }
          canPerformInRuleRecovery(t, r) {
            return this.canRecoverWithSingleTokenInsertion(t, r) || this.canRecoverWithSingleTokenDeletion(t)
          }
          canRecoverWithSingleTokenInsertion(t, r) {
            if (!this.canTokenTypeBeInsertedInRecovery(t) || De(r)) return !1
            let n = this.LA(1)
            return Vi(r, (s) => this.tokenMatcher(n, s)) !== void 0
          }
          canRecoverWithSingleTokenDeletion(t) {
            return this.canTokenTypeBeDeletedInRecovery(t) ? this.tokenMatcher(this.LA(2), t) : !1
          }
          isInCurrentRuleReSyncSet(t) {
            let r = this.getCurrFollowKey(),
              n = this.getFollowSetFromFollowKey(r)
            return Jr(n, t)
          }
          findReSyncTokenType() {
            let t = this.flattenFollowSet(),
              r = this.LA(1),
              n = 2
            for (;;) {
              let i = Vi(t, (s) => _1(r, s))
              if (i !== void 0) return i
              ;(r = this.LA(n)), n++
            }
          }
          getCurrFollowKey() {
            if (this.RULE_STACK.length === 1) return TL
            let t = this.getLastExplicitRuleShortName(),
              r = this.getLastExplicitRuleOccurrenceIndex(),
              n = this.getPreviousExplicitRuleShortName()
            return {
              ruleName: this.shortRuleNameToFullName(t),
              idxInCallingRule: r,
              inRule: this.shortRuleNameToFullName(n),
            }
          }
          buildFullFollowKeyStack() {
            let t = this.RULE_STACK,
              r = this.RULE_OCCURRENCE_STACK
            return Dt(t, (n, i) =>
              i === 0
                ? TL
                : {
                    ruleName: this.shortRuleNameToFullName(n),
                    idxInCallingRule: r[i],
                    inRule: this.shortRuleNameToFullName(t[i - 1]),
                  },
            )
          }
          flattenFollowSet() {
            let t = Dt(this.buildFullFollowKeyStack(), (r) => this.getFollowSetFromFollowKey(r))
            return dr(t)
          }
          getFollowSetFromFollowKey(t) {
            if (t === TL) return [Ps]
            let r = t.ruleName + t.idxInCallingRule + RT + t.inRule
            return this.resyncFollows[r]
          }
          addToResyncTokens(t, r) {
            return this.tokenMatcher(t, Ps) || r.push(t), r
          }
          reSyncTo(t) {
            let r = [],
              n = this.LA(1)
            for (; this.tokenMatcher(n, t) === !1; ) (n = this.SKIP_TOKEN()), this.addToResyncTokens(n, r)
            return Tl(r)
          }
          attemptInRepetitionRecovery(t, r, n, i, s, o, l) {}
          getCurrentGrammarPath(t, r) {
            let n = this.getHumanReadableRuleStack(),
              i = Sr(this.RULE_OCCURRENCE_STACK)
            return { ruleStack: n, occurrenceStack: i, lastTok: t, lastTokOccurrence: r }
          }
          getHumanReadableRuleStack() {
            return Dt(this.RULE_STACK, (t) => this.shortRuleNameToFullName(t))
          }
        })
      a(w4t, 'attemptInRepetitionRecovery')
    })
  function HT(e, t, r) {
    return r | t | e
  }
  var YT = x(() => {
    'use strict'
    a(HT, 'getKeyForAutomaticLookahead')
  })
  var Rl,
    wL = x(() => {
      'use strict'
      fe()
      Bp()
      ys()
      L1()
      Vp()
      Rl = class {
        static {
          a(this, 'LLkLookaheadStrategy')
        }
        constructor(t) {
          var r
          this.maxLookahead = (r = t?.maxLookahead) !== null && r !== void 0 ? r : qi.maxLookahead
        }
        validate(t) {
          let r = this.validateNoLeftRecursion(t.rules)
          if (De(r)) {
            let n = this.validateEmptyOrAlternatives(t.rules),
              i = this.validateAmbiguousAlternationAlternatives(t.rules, this.maxLookahead),
              s = this.validateSomeNonEmptyLookaheadPath(t.rules, this.maxLookahead)
            return [...r, ...n, ...i, ...s]
          }
          return r
        }
        validateNoLeftRecursion(t) {
          return li(t, (r) => kL(r, r, Ha))
        }
        validateEmptyOrAlternatives(t) {
          return li(t, (r) => $Q(r, Ha))
        }
        validateAmbiguousAlternationAlternatives(t, r) {
          return li(t, (n) => GQ(n, r, Ha))
        }
        validateSomeNonEmptyLookaheadPath(t, r) {
          return VQ(t, r, Ha)
        }
        buildLookaheadForAlternation(t) {
          return AQ(t.prodOccurrence, t.rule, t.maxLookahead, t.hasPredicates, t.dynamicTokensEnabled, RQ)
        }
        buildLookaheadForOptional(t) {
          return LQ(t.prodOccurrence, t.rule, t.maxLookahead, t.dynamicTokensEnabled, v1(t.prodType), DQ)
        }
      }
    })
  function E4t(e) {
    XT.reset(), e.accept(XT)
    let t = XT.dslMethods
    return XT.reset(), t
  }
  var KT,
    EL,
    XT,
    KQ = x(() => {
      'use strict'
      fe()
      ys()
      YT()
      ji()
      wL()
      ;(KT = class {
        static {
          a(this, 'LooksAhead')
        }
        initLooksAhead(t) {
          ;(this.dynamicTokensEnabled = te(t, 'dynamicTokensEnabled')
            ? t.dynamicTokensEnabled
            : qi.dynamicTokensEnabled),
            (this.maxLookahead = te(t, 'maxLookahead') ? t.maxLookahead : qi.maxLookahead),
            (this.lookaheadStrategy = te(t, 'lookaheadStrategy')
              ? t.lookaheadStrategy
              : new Rl({ maxLookahead: this.maxLookahead })),
            (this.lookAheadFuncsCache = new Map())
        }
        preComputeLookaheadFunctions(t) {
          rt(t, (r) => {
            this.TRACE_INIT(`${r.name} Rule Lookahead`, () => {
              let {
                alternation: n,
                repetition: i,
                option: s,
                repetitionMandatory: o,
                repetitionMandatoryWithSeparator: l,
                repetitionWithSeparator: u,
              } = E4t(r)
              rt(n, (h) => {
                let f = h.idx === 0 ? '' : h.idx
                this.TRACE_INIT(`${gs(h)}${f}`, () => {
                  let d = this.lookaheadStrategy.buildLookaheadForAlternation({
                      prodOccurrence: h.idx,
                      rule: r,
                      maxLookahead: h.maxLookahead || this.maxLookahead,
                      hasPredicates: h.hasPredicates,
                      dynamicTokensEnabled: this.dynamicTokensEnabled,
                    }),
                    p = HT(this.fullRuleNameToShort[r.name], 256, h.idx)
                  this.setLaFuncCache(p, d)
                })
              }),
                rt(i, (h) => {
                  this.computeLookaheadFunc(r, h.idx, 768, 'Repetition', h.maxLookahead, gs(h))
                }),
                rt(s, (h) => {
                  this.computeLookaheadFunc(r, h.idx, 512, 'Option', h.maxLookahead, gs(h))
                }),
                rt(o, (h) => {
                  this.computeLookaheadFunc(r, h.idx, 1024, 'RepetitionMandatory', h.maxLookahead, gs(h))
                }),
                rt(l, (h) => {
                  this.computeLookaheadFunc(r, h.idx, 1536, 'RepetitionMandatoryWithSeparator', h.maxLookahead, gs(h))
                }),
                rt(u, (h) => {
                  this.computeLookaheadFunc(r, h.idx, 1280, 'RepetitionWithSeparator', h.maxLookahead, gs(h))
                })
            })
          })
        }
        computeLookaheadFunc(t, r, n, i, s, o) {
          this.TRACE_INIT(`${o}${r === 0 ? '' : r}`, () => {
            let l = this.lookaheadStrategy.buildLookaheadForOptional({
                prodOccurrence: r,
                rule: t,
                maxLookahead: s || this.maxLookahead,
                dynamicTokensEnabled: this.dynamicTokensEnabled,
                prodType: i,
              }),
              u = HT(this.fullRuleNameToShort[t.name], n, r)
            this.setLaFuncCache(u, l)
          })
        }
        getKeyForAutomaticLookahead(t, r) {
          let n = this.getLastExplicitRuleShortName()
          return HT(n, t, r)
        }
        getLaFuncFromCache(t) {
          return this.lookAheadFuncsCache.get(t)
        }
        setLaFuncCache(t, r) {
          this.lookAheadFuncsCache.set(t, r)
        }
      }),
        (EL = class extends Ui {
          static {
            a(this, 'DslMethodsCollectorVisitor')
          }
          constructor() {
            super(...arguments),
              (this.dslMethods = {
                option: [],
                alternation: [],
                repetition: [],
                repetitionWithSeparator: [],
                repetitionMandatory: [],
                repetitionMandatoryWithSeparator: [],
              })
          }
          reset() {
            this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: [],
            }
          }
          visitOption(t) {
            this.dslMethods.option.push(t)
          }
          visitRepetitionWithSeparator(t) {
            this.dslMethods.repetitionWithSeparator.push(t)
          }
          visitRepetitionMandatory(t) {
            this.dslMethods.repetitionMandatory.push(t)
          }
          visitRepetitionMandatoryWithSeparator(t) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(t)
          }
          visitRepetition(t) {
            this.dslMethods.repetition.push(t)
          }
          visitAlternation(t) {
            this.dslMethods.alternation.push(t)
          }
        }),
        (XT = new EL())
      a(E4t, 'collectMethods')
    })
  function LL(e, t) {
    isNaN(e.startOffset) === !0
      ? ((e.startOffset = t.startOffset), (e.endOffset = t.endOffset))
      : e.endOffset < t.endOffset && (e.endOffset = t.endOffset)
  }
  function RL(e, t) {
    isNaN(e.startOffset) === !0
      ? ((e.startOffset = t.startOffset),
        (e.startColumn = t.startColumn),
        (e.startLine = t.startLine),
        (e.endOffset = t.endOffset),
        (e.endColumn = t.endColumn),
        (e.endLine = t.endLine))
      : e.endOffset < t.endOffset && ((e.endOffset = t.endOffset), (e.endColumn = t.endColumn), (e.endLine = t.endLine))
  }
  function QQ(e, t, r) {
    e.children[r] === void 0 ? (e.children[r] = [t]) : e.children[r].push(t)
  }
  function ZQ(e, t, r) {
    e.children[t] === void 0 ? (e.children[t] = [r]) : e.children[t].push(r)
  }
  var JQ = x(() => {
    'use strict'
    a(LL, 'setNodeLocationOnlyOffset')
    a(RL, 'setNodeLocationFull')
    a(QQ, 'addTerminalToCst')
    a(ZQ, 'addNoneTerminalToCst')
  })
  function DL(e, t) {
    Object.defineProperty(e, v4t, { enumerable: !1, configurable: !0, writable: !1, value: t })
  }
  var v4t,
    tZ = x(() => {
      'use strict'
      v4t = 'name'
      a(DL, 'defineNameProp')
    })
  function A4t(e, t) {
    let r = cr(e),
      n = r.length
    for (let i = 0; i < n; i++) {
      let s = r[i],
        o = e[s],
        l = o.length
      for (let u = 0; u < l; u++) {
        let h = o[u]
        h.tokenTypeIdx === void 0 && this[h.name](h.children, t)
      }
    }
  }
  function eZ(e, t) {
    let r = a(function () {}, 'derivedConstructor')
    DL(r, e + 'BaseSemantics')
    let n = {
      visit: a(function (i, s) {
        if ((Jt(i) && (i = i[0]), !Fe(i))) return this[i.name](i.children, s)
      }, 'visit'),
      validateVisitor: a(function () {
        let i = L4t(this, t)
        if (!De(i)) {
          let s = Dt(i, (o) => o.msg)
          throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${s
    .join(
      `

`,
    )
    .replace(
      /\n/g,
      `
	`,
    )}`)
        }
      }, 'validateVisitor'),
    }
    return (r.prototype = n), (r.prototype.constructor = r), (r._RULE_NAMES = t), r
  }
  function rZ(e, t, r) {
    let n = a(function () {}, 'derivedConstructor')
    DL(n, e + 'BaseSemanticsWithDefaults')
    let i = Object.create(r.prototype)
    return (
      rt(t, (s) => {
        i[s] = A4t
      }),
      (n.prototype = i),
      (n.prototype.constructor = n),
      n
    )
  }
  function L4t(e, t) {
    return R4t(e, t)
  }
  function R4t(e, t) {
    let r = pr(t, (i) => vn(e[i]) === !1),
      n = Dt(r, (i) => ({
        msg: `Missing visitor method: <${i}> on ${e.constructor.name} CST Visitor.`,
        type: NL.MISSING_METHOD,
        methodName: i,
      }))
    return vo(n)
  }
  var NL,
    nZ = x(() => {
      'use strict'
      fe()
      tZ()
      a(A4t, 'defaultVisit')
      a(eZ, 'createBaseSemanticVisitorConstructor')
      a(rZ, 'createBaseVisitorConstructorWithDefaults')
      ;(function (e) {
        ;(e[(e.REDUNDANT_METHOD = 0)] = 'REDUNDANT_METHOD'), (e[(e.MISSING_METHOD = 1)] = 'MISSING_METHOD')
      })(NL || (NL = {}))
      a(L4t, 'validateVisitor')
      a(R4t, 'validateMissingCstMethods')
    })
  var tS,
    iZ = x(() => {
      'use strict'
      JQ()
      fe()
      nZ()
      ys()
      tS = class {
        static {
          a(this, 'TreeBuilder')
        }
        initTreeBuilder(t) {
          if (
            ((this.CST_STACK = []),
            (this.outputCst = t.outputCst),
            (this.nodeLocationTracking = te(t, 'nodeLocationTracking')
              ? t.nodeLocationTracking
              : qi.nodeLocationTracking),
            !this.outputCst)
          )
            (this.cstInvocationStateUpdate = cn),
              (this.cstFinallyStateUpdate = cn),
              (this.cstPostTerminal = cn),
              (this.cstPostNonTerminal = cn),
              (this.cstPostRule = cn)
          else if (/full/i.test(this.nodeLocationTracking))
            this.recoveryEnabled
              ? ((this.setNodeLocationFromToken = RL),
                (this.setNodeLocationFromNode = RL),
                (this.cstPostRule = cn),
                (this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery))
              : ((this.setNodeLocationFromToken = cn),
                (this.setNodeLocationFromNode = cn),
                (this.cstPostRule = this.cstPostRuleFull),
                (this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular))
          else if (/onlyOffset/i.test(this.nodeLocationTracking))
            this.recoveryEnabled
              ? ((this.setNodeLocationFromToken = LL),
                (this.setNodeLocationFromNode = LL),
                (this.cstPostRule = cn),
                (this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery))
              : ((this.setNodeLocationFromToken = cn),
                (this.setNodeLocationFromNode = cn),
                (this.cstPostRule = this.cstPostRuleOnlyOffset),
                (this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular))
          else if (/none/i.test(this.nodeLocationTracking))
            (this.setNodeLocationFromToken = cn),
              (this.setNodeLocationFromNode = cn),
              (this.cstPostRule = cn),
              (this.setInitialNodeLocation = cn)
          else throw Error(`Invalid <nodeLocationTracking> config option: "${t.nodeLocationTracking}"`)
        }
        setInitialNodeLocationOnlyOffsetRecovery(t) {
          t.location = { startOffset: NaN, endOffset: NaN }
        }
        setInitialNodeLocationOnlyOffsetRegular(t) {
          t.location = { startOffset: this.LA(1).startOffset, endOffset: NaN }
        }
        setInitialNodeLocationFullRecovery(t) {
          t.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
          }
        }
        setInitialNodeLocationFullRegular(t) {
          let r = this.LA(1)
          t.location = {
            startOffset: r.startOffset,
            startLine: r.startLine,
            startColumn: r.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
          }
        }
        cstInvocationStateUpdate(t) {
          let r = { name: t, children: Object.create(null) }
          this.setInitialNodeLocation(r), this.CST_STACK.push(r)
        }
        cstFinallyStateUpdate() {
          this.CST_STACK.pop()
        }
        cstPostRuleFull(t) {
          let r = this.LA(0),
            n = t.location
          n.startOffset <= r.startOffset
            ? ((n.endOffset = r.endOffset), (n.endLine = r.endLine), (n.endColumn = r.endColumn))
            : ((n.startOffset = NaN), (n.startLine = NaN), (n.startColumn = NaN))
        }
        cstPostRuleOnlyOffset(t) {
          let r = this.LA(0),
            n = t.location
          n.startOffset <= r.startOffset ? (n.endOffset = r.endOffset) : (n.startOffset = NaN)
        }
        cstPostTerminal(t, r) {
          let n = this.CST_STACK[this.CST_STACK.length - 1]
          QQ(n, r, t), this.setNodeLocationFromToken(n.location, r)
        }
        cstPostNonTerminal(t, r) {
          let n = this.CST_STACK[this.CST_STACK.length - 1]
          ZQ(n, r, t), this.setNodeLocationFromNode(n.location, t.location)
        }
        getBaseCstVisitorConstructor() {
          if (Fe(this.baseCstVisitorConstructor)) {
            let t = eZ(this.className, cr(this.gastProductionsCache))
            return (this.baseCstVisitorConstructor = t), t
          }
          return this.baseCstVisitorConstructor
        }
        getBaseCstVisitorConstructorWithDefaults() {
          if (Fe(this.baseCstVisitorWithDefaultsConstructor)) {
            let t = rZ(this.className, cr(this.gastProductionsCache), this.getBaseCstVisitorConstructor())
            return (this.baseCstVisitorWithDefaultsConstructor = t), t
          }
          return this.baseCstVisitorWithDefaultsConstructor
        }
        getLastExplicitRuleShortName() {
          let t = this.RULE_STACK
          return t[t.length - 1]
        }
        getPreviousExplicitRuleShortName() {
          let t = this.RULE_STACK
          return t[t.length - 2]
        }
        getLastExplicitRuleOccurrenceIndex() {
          let t = this.RULE_OCCURRENCE_STACK
          return t[t.length - 1]
        }
      }
    })
  var eS,
    sZ = x(() => {
      'use strict'
      ys()
      eS = class {
        static {
          a(this, 'LexerAdapter')
        }
        initLexerAdapter() {
          ;(this.tokVector = []), (this.tokVectorLength = 0), (this.currIdx = -1)
        }
        set input(t) {
          if (this.selfAnalysisDone !== !0)
            throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.")
          this.reset(), (this.tokVector = t), (this.tokVectorLength = t.length)
        }
        get input() {
          return this.tokVector
        }
        SKIP_TOKEN() {
          return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : Up
        }
        LA(t) {
          let r = this.currIdx + t
          return r < 0 || this.tokVectorLength <= r ? Up : this.tokVector[r]
        }
        consumeToken() {
          this.currIdx++
        }
        exportLexerState() {
          return this.currIdx
        }
        importLexerState(t) {
          this.currIdx = t
        }
        resetLexerState() {
          this.currIdx = -1
        }
        moveToTerminatedState() {
          this.currIdx = this.tokVector.length - 1
        }
        getLexerPosition() {
          return this.exportLexerState()
        }
      }
    })
  var rS,
    aZ = x(() => {
      'use strict'
      fe()
      Wp()
      ys()
      Bp()
      L1()
      ji()
      rS = class {
        static {
          a(this, 'RecognizerApi')
        }
        ACTION(t) {
          return t.call(this)
        }
        consume(t, r, n) {
          return this.consumeInternal(r, t, n)
        }
        subrule(t, r, n) {
          return this.subruleInternal(r, t, n)
        }
        option(t, r) {
          return this.optionInternal(r, t)
        }
        or(t, r) {
          return this.orInternal(r, t)
        }
        many(t, r) {
          return this.manyInternal(t, r)
        }
        atLeastOne(t, r) {
          return this.atLeastOneInternal(t, r)
        }
        CONSUME(t, r) {
          return this.consumeInternal(t, 0, r)
        }
        CONSUME1(t, r) {
          return this.consumeInternal(t, 1, r)
        }
        CONSUME2(t, r) {
          return this.consumeInternal(t, 2, r)
        }
        CONSUME3(t, r) {
          return this.consumeInternal(t, 3, r)
        }
        CONSUME4(t, r) {
          return this.consumeInternal(t, 4, r)
        }
        CONSUME5(t, r) {
          return this.consumeInternal(t, 5, r)
        }
        CONSUME6(t, r) {
          return this.consumeInternal(t, 6, r)
        }
        CONSUME7(t, r) {
          return this.consumeInternal(t, 7, r)
        }
        CONSUME8(t, r) {
          return this.consumeInternal(t, 8, r)
        }
        CONSUME9(t, r) {
          return this.consumeInternal(t, 9, r)
        }
        SUBRULE(t, r) {
          return this.subruleInternal(t, 0, r)
        }
        SUBRULE1(t, r) {
          return this.subruleInternal(t, 1, r)
        }
        SUBRULE2(t, r) {
          return this.subruleInternal(t, 2, r)
        }
        SUBRULE3(t, r) {
          return this.subruleInternal(t, 3, r)
        }
        SUBRULE4(t, r) {
          return this.subruleInternal(t, 4, r)
        }
        SUBRULE5(t, r) {
          return this.subruleInternal(t, 5, r)
        }
        SUBRULE6(t, r) {
          return this.subruleInternal(t, 6, r)
        }
        SUBRULE7(t, r) {
          return this.subruleInternal(t, 7, r)
        }
        SUBRULE8(t, r) {
          return this.subruleInternal(t, 8, r)
        }
        SUBRULE9(t, r) {
          return this.subruleInternal(t, 9, r)
        }
        OPTION(t) {
          return this.optionInternal(t, 0)
        }
        OPTION1(t) {
          return this.optionInternal(t, 1)
        }
        OPTION2(t) {
          return this.optionInternal(t, 2)
        }
        OPTION3(t) {
          return this.optionInternal(t, 3)
        }
        OPTION4(t) {
          return this.optionInternal(t, 4)
        }
        OPTION5(t) {
          return this.optionInternal(t, 5)
        }
        OPTION6(t) {
          return this.optionInternal(t, 6)
        }
        OPTION7(t) {
          return this.optionInternal(t, 7)
        }
        OPTION8(t) {
          return this.optionInternal(t, 8)
        }
        OPTION9(t) {
          return this.optionInternal(t, 9)
        }
        OR(t) {
          return this.orInternal(t, 0)
        }
        OR1(t) {
          return this.orInternal(t, 1)
        }
        OR2(t) {
          return this.orInternal(t, 2)
        }
        OR3(t) {
          return this.orInternal(t, 3)
        }
        OR4(t) {
          return this.orInternal(t, 4)
        }
        OR5(t) {
          return this.orInternal(t, 5)
        }
        OR6(t) {
          return this.orInternal(t, 6)
        }
        OR7(t) {
          return this.orInternal(t, 7)
        }
        OR8(t) {
          return this.orInternal(t, 8)
        }
        OR9(t) {
          return this.orInternal(t, 9)
        }
        MANY(t) {
          this.manyInternal(0, t)
        }
        MANY1(t) {
          this.manyInternal(1, t)
        }
        MANY2(t) {
          this.manyInternal(2, t)
        }
        MANY3(t) {
          this.manyInternal(3, t)
        }
        MANY4(t) {
          this.manyInternal(4, t)
        }
        MANY5(t) {
          this.manyInternal(5, t)
        }
        MANY6(t) {
          this.manyInternal(6, t)
        }
        MANY7(t) {
          this.manyInternal(7, t)
        }
        MANY8(t) {
          this.manyInternal(8, t)
        }
        MANY9(t) {
          this.manyInternal(9, t)
        }
        MANY_SEP(t) {
          this.manySepFirstInternal(0, t)
        }
        MANY_SEP1(t) {
          this.manySepFirstInternal(1, t)
        }
        MANY_SEP2(t) {
          this.manySepFirstInternal(2, t)
        }
        MANY_SEP3(t) {
          this.manySepFirstInternal(3, t)
        }
        MANY_SEP4(t) {
          this.manySepFirstInternal(4, t)
        }
        MANY_SEP5(t) {
          this.manySepFirstInternal(5, t)
        }
        MANY_SEP6(t) {
          this.manySepFirstInternal(6, t)
        }
        MANY_SEP7(t) {
          this.manySepFirstInternal(7, t)
        }
        MANY_SEP8(t) {
          this.manySepFirstInternal(8, t)
        }
        MANY_SEP9(t) {
          this.manySepFirstInternal(9, t)
        }
        AT_LEAST_ONE(t) {
          this.atLeastOneInternal(0, t)
        }
        AT_LEAST_ONE1(t) {
          return this.atLeastOneInternal(1, t)
        }
        AT_LEAST_ONE2(t) {
          this.atLeastOneInternal(2, t)
        }
        AT_LEAST_ONE3(t) {
          this.atLeastOneInternal(3, t)
        }
        AT_LEAST_ONE4(t) {
          this.atLeastOneInternal(4, t)
        }
        AT_LEAST_ONE5(t) {
          this.atLeastOneInternal(5, t)
        }
        AT_LEAST_ONE6(t) {
          this.atLeastOneInternal(6, t)
        }
        AT_LEAST_ONE7(t) {
          this.atLeastOneInternal(7, t)
        }
        AT_LEAST_ONE8(t) {
          this.atLeastOneInternal(8, t)
        }
        AT_LEAST_ONE9(t) {
          this.atLeastOneInternal(9, t)
        }
        AT_LEAST_ONE_SEP(t) {
          this.atLeastOneSepFirstInternal(0, t)
        }
        AT_LEAST_ONE_SEP1(t) {
          this.atLeastOneSepFirstInternal(1, t)
        }
        AT_LEAST_ONE_SEP2(t) {
          this.atLeastOneSepFirstInternal(2, t)
        }
        AT_LEAST_ONE_SEP3(t) {
          this.atLeastOneSepFirstInternal(3, t)
        }
        AT_LEAST_ONE_SEP4(t) {
          this.atLeastOneSepFirstInternal(4, t)
        }
        AT_LEAST_ONE_SEP5(t) {
          this.atLeastOneSepFirstInternal(5, t)
        }
        AT_LEAST_ONE_SEP6(t) {
          this.atLeastOneSepFirstInternal(6, t)
        }
        AT_LEAST_ONE_SEP7(t) {
          this.atLeastOneSepFirstInternal(7, t)
        }
        AT_LEAST_ONE_SEP8(t) {
          this.atLeastOneSepFirstInternal(8, t)
        }
        AT_LEAST_ONE_SEP9(t) {
          this.atLeastOneSepFirstInternal(9, t)
        }
        RULE(t, r, n = jp) {
          if (Jr(this.definedRulesNames, t)) {
            let o = {
              message: Ha.buildDuplicateRuleNameError({ topLevelRule: t, grammarName: this.className }),
              type: Fn.DUPLICATE_RULE_NAME,
              ruleName: t,
            }
            this.definitionErrors.push(o)
          }
          this.definedRulesNames.push(t)
          let i = this.defineRule(t, r, n)
          return (this[t] = i), i
        }
        OVERRIDE_RULE(t, r, n = jp) {
          let i = FQ(t, this.definedRulesNames, this.className)
          this.definitionErrors = this.definitionErrors.concat(i)
          let s = this.defineRule(t, r, n)
          return (this[t] = s), s
        }
        BACKTRACK(t, r) {
          return function () {
            this.isBackTrackingStack.push(1)
            let n = this.saveRecogState()
            try {
              return t.apply(this, r), !0
            } catch (i) {
              if (Uc(i)) return !1
              throw i
            } finally {
              this.reloadRecogState(n), this.isBackTrackingStack.pop()
            }
          }
        }
        getGAstProductions() {
          return this.gastProductionsCache
        }
        getSerializedGastProductions() {
          return vT(We(this.gastProductionsCache))
        }
      }
    })
  var nS,
    oZ = x(() => {
      'use strict'
      fe()
      YT()
      Wp()
      Vp()
      E1()
      ys()
      CL()
      Nh()
      Dh()
      nS = class {
        static {
          a(this, 'RecognizerEngine')
        }
        initRecognizerEngine(t, r) {
          if (
            ((this.className = this.constructor.name),
            (this.shortRuleNameToFull = {}),
            (this.fullRuleNameToShort = {}),
            (this.ruleShortNameIdx = 256),
            (this.tokenMatcher = Op),
            (this.subruleIdx = 0),
            (this.definedRulesNames = []),
            (this.tokensMap = {}),
            (this.isBackTrackingStack = []),
            (this.RULE_STACK = []),
            (this.RULE_OCCURRENCE_STACK = []),
            (this.gastProductionsCache = {}),
            te(r, 'serializedGrammar'))
          )
            throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`)
          if (Jt(t)) {
            if (De(t))
              throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`)
            if (typeof t[0].startOffset == 'number')
              throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)
          }
          if (Jt(t)) this.tokensMap = mr(t, (s, o) => ((s[o.name] = o), s), {})
          else if (te(t, 'modes') && ki(dr(We(t.modes)), mQ)) {
            let s = dr(We(t.modes)),
              o = Nd(s)
            this.tokensMap = mr(o, (l, u) => ((l[u.name] = u), l), {})
          } else if (Nr(t)) this.tokensMap = Sr(t)
          else
            throw new Error(
              '<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition',
            )
          this.tokensMap.EOF = Ps
          let n = te(t, 'modes') ? dr(We(t.modes)) : We(t),
            i = ki(n, (s) => De(s.categoryMatches))
          ;(this.tokenMatcher = i ? Op : wl), El(We(this.tokensMap))
        }
        defineRule(t, r, n) {
          if (this.selfAnalysisDone)
            throw Error(`Grammar rule <${t}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`)
          let i = te(n, 'resyncEnabled') ? n.resyncEnabled : jp.resyncEnabled,
            s = te(n, 'recoveryValueFunc') ? n.recoveryValueFunc : jp.recoveryValueFunc,
            o = this.ruleShortNameIdx << 12
          this.ruleShortNameIdx++, (this.shortRuleNameToFull[o] = t), (this.fullRuleNameToShort[t] = o)
          let l
          return (
            this.outputCst === !0
              ? (l = a(function (...f) {
                  try {
                    this.ruleInvocationStateUpdate(o, t, this.subruleIdx), r.apply(this, f)
                    let d = this.CST_STACK[this.CST_STACK.length - 1]
                    return this.cstPostRule(d), d
                  } catch (d) {
                    return this.invokeRuleCatch(d, i, s)
                  } finally {
                    this.ruleFinallyStateUpdate()
                  }
                }, 'invokeRuleWithTry'))
              : (l = a(function (...f) {
                  try {
                    return this.ruleInvocationStateUpdate(o, t, this.subruleIdx), r.apply(this, f)
                  } catch (d) {
                    return this.invokeRuleCatch(d, i, s)
                  } finally {
                    this.ruleFinallyStateUpdate()
                  }
                }, 'invokeRuleWithTryCst')),
            Object.assign(l, { ruleName: t, originalGrammarAction: r })
          )
        }
        invokeRuleCatch(t, r, n) {
          let i = this.RULE_STACK.length === 1,
            s = r && !this.isBackTracking() && this.recoveryEnabled
          if (Uc(t)) {
            let o = t
            if (s) {
              let l = this.findReSyncTokenType()
              if (this.isInCurrentRuleReSyncSet(l))
                if (((o.resyncedTokens = this.reSyncTo(l)), this.outputCst)) {
                  let u = this.CST_STACK[this.CST_STACK.length - 1]
                  return (u.recoveredNode = !0), u
                } else return n(t)
              else {
                if (this.outputCst) {
                  let u = this.CST_STACK[this.CST_STACK.length - 1]
                  ;(u.recoveredNode = !0), (o.partialCstResult = u)
                }
                throw o
              }
            } else {
              if (i) return this.moveToTerminatedState(), n(t)
              throw o
            }
          } else throw t
        }
        optionInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(512, r)
          return this.optionInternalLogic(t, r, n)
        }
        optionInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s
          if (typeof t != 'function') {
            s = t.DEF
            let o = t.GATE
            if (o !== void 0) {
              let l = i
              i = a(() => o.call(this) && l.call(this), 'lookAheadFunc')
            }
          } else s = t
          if (i.call(this) === !0) return s.call(this)
        }
        atLeastOneInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1024, t)
          return this.atLeastOneInternalLogic(t, r, n)
        }
        atLeastOneInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s
          if (typeof r != 'function') {
            s = r.DEF
            let o = r.GATE
            if (o !== void 0) {
              let l = i
              i = a(() => o.call(this) && l.call(this), 'lookAheadFunc')
            }
          } else s = r
          if (i.call(this) === !0) {
            let o = this.doSingleRepetition(s)
            for (; i.call(this) === !0 && o === !0; ) o = this.doSingleRepetition(s)
          } else throw this.raiseEarlyExitException(t, rn.REPETITION_MANDATORY, r.ERR_MSG)
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [t, r], i, 1024, t, $T)
        }
        atLeastOneSepFirstInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1536, t)
          this.atLeastOneSepFirstInternalLogic(t, r, n)
        }
        atLeastOneSepFirstInternalLogic(t, r, n) {
          let i = r.DEF,
            s = r.SEP
          if (this.getLaFuncFromCache(n).call(this) === !0) {
            i.call(this)
            let l = a(() => this.tokenMatcher(this.LA(1), s), 'separatorLookAheadFunc')
            for (; this.tokenMatcher(this.LA(1), s) === !0; ) this.CONSUME(s), i.call(this)
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t, s, l, i, w1], l, 1536, t, w1)
          } else throw this.raiseEarlyExitException(t, rn.REPETITION_MANDATORY_WITH_SEPARATOR, r.ERR_MSG)
        }
        manyInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(768, t)
          return this.manyInternalLogic(t, r, n)
        }
        manyInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s
          if (typeof r != 'function') {
            s = r.DEF
            let l = r.GATE
            if (l !== void 0) {
              let u = i
              i = a(() => l.call(this) && u.call(this), 'lookaheadFunction')
            }
          } else s = r
          let o = !0
          for (; i.call(this) === !0 && o === !0; ) o = this.doSingleRepetition(s)
          this.attemptInRepetitionRecovery(this.manyInternal, [t, r], i, 768, t, FT, o)
        }
        manySepFirstInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1280, t)
          this.manySepFirstInternalLogic(t, r, n)
        }
        manySepFirstInternalLogic(t, r, n) {
          let i = r.DEF,
            s = r.SEP
          if (this.getLaFuncFromCache(n).call(this) === !0) {
            i.call(this)
            let l = a(() => this.tokenMatcher(this.LA(1), s), 'separatorLookAheadFunc')
            for (; this.tokenMatcher(this.LA(1), s) === !0; ) this.CONSUME(s), i.call(this)
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t, s, l, i, C1], l, 1280, t, C1)
          }
        }
        repetitionSepSecondInternal(t, r, n, i, s) {
          for (; n(); ) this.CONSUME(r), i.call(this)
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [t, r, n, i, s], n, 1536, t, s)
        }
        doSingleRepetition(t) {
          let r = this.getLexerPosition()
          return t.call(this), this.getLexerPosition() > r
        }
        orInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(256, r),
            i = Jt(t) ? t : t.DEF,
            o = this.getLaFuncFromCache(n).call(this, i)
          if (o !== void 0) return i[o].ALT.call(this)
          this.raiseNoAltException(r, t.ERR_MSG)
        }
        ruleFinallyStateUpdate() {
          if (
            (this.RULE_STACK.pop(),
            this.RULE_OCCURRENCE_STACK.pop(),
            this.cstFinallyStateUpdate(),
            this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1)
          ) {
            let t = this.LA(1),
              r = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: t,
                ruleName: this.getCurrRuleFullName(),
              })
            this.SAVE_ERROR(new D1(r, t))
          }
        }
        subruleInternal(t, r, n) {
          let i
          try {
            let s = n !== void 0 ? n.ARGS : void 0
            return (
              (this.subruleIdx = r),
              (i = t.apply(this, s)),
              this.cstPostNonTerminal(i, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : t.ruleName),
              i
            )
          } catch (s) {
            throw this.subruleInternalError(s, n, t.ruleName)
          }
        }
        subruleInternalError(t, r, n) {
          throw (
            (Uc(t) &&
              t.partialCstResult !== void 0 &&
              (this.cstPostNonTerminal(t.partialCstResult, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n),
              delete t.partialCstResult),
            t)
          )
        }
        consumeInternal(t, r, n) {
          let i
          try {
            let s = this.LA(1)
            this.tokenMatcher(s, t) === !0 ? (this.consumeToken(), (i = s)) : this.consumeInternalError(t, s, n)
          } catch (s) {
            i = this.consumeInternalRecovery(t, r, s)
          }
          return this.cstPostTerminal(n !== void 0 && n.LABEL !== void 0 ? n.LABEL : t.name, i), i
        }
        consumeInternalError(t, r, n) {
          let i,
            s = this.LA(0)
          throw (
            (n !== void 0 && n.ERR_MSG
              ? (i = n.ERR_MSG)
              : (i = this.errorMessageProvider.buildMismatchTokenMessage({
                  expected: t,
                  actual: r,
                  previous: s,
                  ruleName: this.getCurrRuleFullName(),
                })),
            this.SAVE_ERROR(new Ih(i, r, s)))
          )
        }
        consumeInternalRecovery(t, r, n) {
          if (this.recoveryEnabled && n.name === 'MismatchedTokenException' && !this.isBackTracking()) {
            let i = this.getFollowsForInRuleRecovery(t, r)
            try {
              return this.tryInRuleRecovery(t, i)
            } catch (s) {
              throw s.name === _L ? n : s
            }
          } else throw n
        }
        saveRecogState() {
          let t = this.errors,
            r = Sr(this.RULE_STACK)
          return { errors: t, lexerState: this.exportLexerState(), RULE_STACK: r, CST_STACK: this.CST_STACK }
        }
        reloadRecogState(t) {
          ;(this.errors = t.errors), this.importLexerState(t.lexerState), (this.RULE_STACK = t.RULE_STACK)
        }
        ruleInvocationStateUpdate(t, r, n) {
          this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(t), this.cstInvocationStateUpdate(r)
        }
        isBackTracking() {
          return this.isBackTrackingStack.length !== 0
        }
        getCurrRuleFullName() {
          let t = this.getLastExplicitRuleShortName()
          return this.shortRuleNameToFull[t]
        }
        shortRuleNameToFullName(t) {
          return this.shortRuleNameToFull[t]
        }
        isAtEndOfInput() {
          return this.tokenMatcher(this.LA(1), Ps)
        }
        reset() {
          this.resetLexerState(),
            (this.subruleIdx = 0),
            (this.isBackTrackingStack = []),
            (this.errors = []),
            (this.RULE_STACK = []),
            (this.CST_STACK = []),
            (this.RULE_OCCURRENCE_STACK = [])
        }
      }
    })
  var iS,
    lZ = x(() => {
      'use strict'
      Wp()
      fe()
      Vp()
      ys()
      iS = class {
        static {
          a(this, 'ErrorHandler')
        }
        initErrorHandler(t) {
          ;(this._errors = []),
            (this.errorMessageProvider = te(t, 'errorMessageProvider')
              ? t.errorMessageProvider
              : qi.errorMessageProvider)
        }
        SAVE_ERROR(t) {
          if (Uc(t))
            return (
              (t.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: Sr(this.RULE_OCCURRENCE_STACK),
              }),
              this._errors.push(t),
              t
            )
          throw Error('Trying to save an Error which is not a RecognitionException')
        }
        get errors() {
          return Sr(this._errors)
        }
        set errors(t) {
          this._errors = t
        }
        raiseEarlyExitException(t, r, n) {
          let i = this.getCurrRuleFullName(),
            s = this.getGAstProductions()[i],
            l = Gp(t, s, r, this.maxLookahead)[0],
            u = []
          for (let f = 1; f <= this.maxLookahead; f++) u.push(this.LA(f))
          let h = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: l,
            actual: u,
            previous: this.LA(0),
            customUserDescription: n,
            ruleName: i,
          })
          throw this.SAVE_ERROR(new N1(h, this.LA(1), this.LA(0)))
        }
        raiseNoAltException(t, r) {
          let n = this.getCurrRuleFullName(),
            i = this.getGAstProductions()[n],
            s = $p(t, i, this.maxLookahead),
            o = []
          for (let h = 1; h <= this.maxLookahead; h++) o.push(this.LA(h))
          let l = this.LA(0),
            u = this.errorMessageProvider.buildNoViableAltMessage({
              expectedPathsPerAlt: s,
              actual: o,
              previous: l,
              customUserDescription: r,
              ruleName: this.getCurrRuleFullName(),
            })
          throw this.SAVE_ERROR(new R1(u, this.LA(1), l))
        }
      }
    })
  var sS,
    cZ = x(() => {
      'use strict'
      E1()
      fe()
      sS = class {
        static {
          a(this, 'ContentAssist')
        }
        initContentAssist() {}
        computeContentAssist(t, r) {
          let n = this.gastProductionsCache[t]
          if (Fe(n)) throw Error(`Rule ->${t}<- does not exist in this grammar.`)
          return VT([n], r, this.tokenMatcher, this.maxLookahead)
        }
        getNextPossibleTokenTypes(t) {
          let r = Qn(t.ruleStack),
            i = this.getGAstProductions()[r]
          return new BT(i, t).startWalking()
        }
      }
    })
  function M1(e, t, r, n = !1) {
    oS(r)
    let i = oi(this.recordingProdStack),
      s = vn(t) ? t : t.DEF,
      o = new e({ definition: [], idx: r })
    return (
      n && (o.separator = t.SEP),
      te(t, 'MAX_LOOKAHEAD') && (o.maxLookahead = t.MAX_LOOKAHEAD),
      this.recordingProdStack.push(o),
      s.call(this),
      i.definition.push(o),
      this.recordingProdStack.pop(),
      lS
    )
  }
  function I4t(e, t) {
    oS(t)
    let r = oi(this.recordingProdStack),
      n = Jt(e) === !1,
      i = n === !1 ? e : e.DEF,
      s = new Or({ definition: [], idx: t, ignoreAmbiguities: n && e.IGNORE_AMBIGUITIES === !0 })
    te(e, 'MAX_LOOKAHEAD') && (s.maxLookahead = e.MAX_LOOKAHEAD)
    let o = U0(i, (l) => vn(l.GATE))
    return (
      (s.hasPredicates = o),
      r.definition.push(s),
      rt(i, (l) => {
        let u = new Vr({ definition: [] })
        s.definition.push(u),
          te(l, 'IGNORE_AMBIGUITIES')
            ? (u.ignoreAmbiguities = l.IGNORE_AMBIGUITIES)
            : te(l, 'GATE') && (u.ignoreAmbiguities = !0),
          this.recordingProdStack.push(u),
          l.ALT.call(this),
          this.recordingProdStack.pop()
      }),
      lS
    )
  }
  function fZ(e) {
    return e === 0 ? '' : `${e}`
  }
  function oS(e) {
    if (e < 0 || e > hZ) {
      let t = new Error(`Invalid DSL Method idx value: <${e}>
	Idx value must be a none negative value smaller than ${hZ + 1}`)
      throw ((t.KNOWN_RECORDER_ERROR = !0), t)
    }
  }
  var lS,
    uZ,
    hZ,
    dZ,
    pZ,
    N4t,
    aS,
    mZ = x(() => {
      'use strict'
      fe()
      ji()
      T1()
      Dh()
      Nh()
      ys()
      YT()
      lS = { description: 'This Object indicates the Parser is during Recording Phase' }
      Object.freeze(lS)
      ;(uZ = !0), (hZ = Math.pow(2, 8) - 1), (dZ = Wc({ name: 'RECORDING_PHASE_TOKEN', pattern: en.NA }))
      El([dZ])
      pZ = Al(
        dZ,
        `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
      )
      Object.freeze(pZ)
      ;(N4t = {
        name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
        children: {},
      }),
        (aS = class {
          static {
            a(this, 'GastRecorder')
          }
          initGastRecorder(t) {
            ;(this.recordingProdStack = []), (this.RECORDING_PHASE = !1)
          }
          enableRecording() {
            ;(this.RECORDING_PHASE = !0),
              this.TRACE_INIT('Enable Recording', () => {
                for (let t = 0; t < 10; t++) {
                  let r = t > 0 ? t : ''
                  ;(this[`CONSUME${r}`] = function (n, i) {
                    return this.consumeInternalRecord(n, t, i)
                  }),
                    (this[`SUBRULE${r}`] = function (n, i) {
                      return this.subruleInternalRecord(n, t, i)
                    }),
                    (this[`OPTION${r}`] = function (n) {
                      return this.optionInternalRecord(n, t)
                    }),
                    (this[`OR${r}`] = function (n) {
                      return this.orInternalRecord(n, t)
                    }),
                    (this[`MANY${r}`] = function (n) {
                      this.manyInternalRecord(t, n)
                    }),
                    (this[`MANY_SEP${r}`] = function (n) {
                      this.manySepFirstInternalRecord(t, n)
                    }),
                    (this[`AT_LEAST_ONE${r}`] = function (n) {
                      this.atLeastOneInternalRecord(t, n)
                    }),
                    (this[`AT_LEAST_ONE_SEP${r}`] = function (n) {
                      this.atLeastOneSepFirstInternalRecord(t, n)
                    })
                }
                ;(this.consume = function (t, r, n) {
                  return this.consumeInternalRecord(r, t, n)
                }),
                  (this.subrule = function (t, r, n) {
                    return this.subruleInternalRecord(r, t, n)
                  }),
                  (this.option = function (t, r) {
                    return this.optionInternalRecord(r, t)
                  }),
                  (this.or = function (t, r) {
                    return this.orInternalRecord(r, t)
                  }),
                  (this.many = function (t, r) {
                    this.manyInternalRecord(t, r)
                  }),
                  (this.atLeastOne = function (t, r) {
                    this.atLeastOneInternalRecord(t, r)
                  }),
                  (this.ACTION = this.ACTION_RECORD),
                  (this.BACKTRACK = this.BACKTRACK_RECORD),
                  (this.LA = this.LA_RECORD)
              })
          }
          disableRecording() {
            ;(this.RECORDING_PHASE = !1),
              this.TRACE_INIT('Deleting Recording methods', () => {
                let t = this
                for (let r = 0; r < 10; r++) {
                  let n = r > 0 ? r : ''
                  delete t[`CONSUME${n}`],
                    delete t[`SUBRULE${n}`],
                    delete t[`OPTION${n}`],
                    delete t[`OR${n}`],
                    delete t[`MANY${n}`],
                    delete t[`MANY_SEP${n}`],
                    delete t[`AT_LEAST_ONE${n}`],
                    delete t[`AT_LEAST_ONE_SEP${n}`]
                }
                delete t.consume,
                  delete t.subrule,
                  delete t.option,
                  delete t.or,
                  delete t.many,
                  delete t.atLeastOne,
                  delete t.ACTION,
                  delete t.BACKTRACK,
                  delete t.LA
              })
          }
          ACTION_RECORD(t) {}
          BACKTRACK_RECORD(t, r) {
            return () => !0
          }
          LA_RECORD(t) {
            return Up
          }
          topLevelRuleRecord(t, r) {
            try {
              let n = new Wi({ definition: [], name: t })
              return (n.name = t), this.recordingProdStack.push(n), r.call(this), this.recordingProdStack.pop(), n
            } catch (n) {
              if (n.KNOWN_RECORDER_ERROR !== !0)
                try {
                  n.message =
                    n.message +
                    `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`
                } catch {
                  throw n
                }
              throw n
            }
          }
          optionInternalRecord(t, r) {
            return M1.call(this, wr, t, r)
          }
          atLeastOneInternalRecord(t, r) {
            M1.call(this, zr, r, t)
          }
          atLeastOneSepFirstInternalRecord(t, r) {
            M1.call(this, Wr, r, t, uZ)
          }
          manyInternalRecord(t, r) {
            M1.call(this, ir, r, t)
          }
          manySepFirstInternalRecord(t, r) {
            M1.call(this, Mr, r, t, uZ)
          }
          orInternalRecord(t, r) {
            return I4t.call(this, t, r)
          }
          subruleInternalRecord(t, r, n) {
            if ((oS(r), !t || te(t, 'ruleName') === !1)) {
              let l =
                new Error(`<SUBRULE${fZ(r)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`)
              throw ((l.KNOWN_RECORDER_ERROR = !0), l)
            }
            let i = oi(this.recordingProdStack),
              s = t.ruleName,
              o = new Cr({ idx: r, nonTerminalName: s, label: n?.LABEL, referencedRule: void 0 })
            return i.definition.push(o), this.outputCst ? N4t : lS
          }
          consumeInternalRecord(t, r, n) {
            if ((oS(r), !hL(t))) {
              let o =
                new Error(`<CONSUME${fZ(r)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`)
              throw ((o.KNOWN_RECORDER_ERROR = !0), o)
            }
            let i = oi(this.recordingProdStack),
              s = new je({ idx: r, terminalType: t, label: n?.LABEL })
            return i.definition.push(s), pZ
          }
        })
      a(M1, 'recordProd')
      a(I4t, 'recordOrProd')
      a(fZ, 'getIdxSuffix')
      a(oS, 'assertMethodIdxIsValid')
    })
  var cS,
    gZ = x(() => {
      'use strict'
      fe()
      Rp()
      ys()
      cS = class {
        static {
          a(this, 'PerformanceTracer')
        }
        initPerformanceTracer(t) {
          if (te(t, 'traceInitPerf')) {
            let r = t.traceInitPerf,
              n = typeof r == 'number'
            ;(this.traceInitMaxIdent = n ? r : 1 / 0), (this.traceInitPerf = n ? r > 0 : r)
          } else (this.traceInitMaxIdent = 0), (this.traceInitPerf = qi.traceInitPerf)
          this.traceInitIndent = -1
        }
        TRACE_INIT(t, r) {
          if (this.traceInitPerf === !0) {
            this.traceInitIndent++
            let n = new Array(this.traceInitIndent + 1).join('	')
            this.traceInitIndent < this.traceInitMaxIdent && console.log(`${n}--> <${t}>`)
            let { time: i, value: s } = x1(r),
              o = i > 10 ? console.warn : console.log
            return (
              this.traceInitIndent < this.traceInitMaxIdent && o(`${n}<-- <${t}> time: ${i}ms`),
              this.traceInitIndent--,
              s
            )
          } else return r()
        }
      }
    })
  function yZ(e, t) {
    t.forEach((r) => {
      let n = r.prototype
      Object.getOwnPropertyNames(n).forEach((i) => {
        if (i === 'constructor') return
        let s = Object.getOwnPropertyDescriptor(n, i)
        s && (s.get || s.set) ? Object.defineProperty(e.prototype, i, s) : (e.prototype[i] = r.prototype[i])
      })
    })
  }
  var xZ = x(() => {
    'use strict'
    a(yZ, 'applyMixins')
  })
  function uS(e = void 0) {
    return function () {
      return e
    }
  }
  var Up,
    qi,
    jp,
    Fn,
    O1,
    P1,
    ys = x(() => {
      'use strict'
      fe()
      Rp()
      YK()
      Nh()
      Bp()
      UQ()
      CL()
      KQ()
      iZ()
      sZ()
      aZ()
      oZ()
      lZ()
      cZ()
      mZ()
      gZ()
      xZ()
      L1()
      Up = Al(Ps, '', NaN, NaN, NaN, NaN, NaN, NaN)
      Object.freeze(Up)
      ;(qi = Object.freeze({
        recoveryEnabled: !1,
        maxLookahead: 3,
        dynamicTokensEnabled: !1,
        outputCst: !0,
        errorMessageProvider: Ll,
        nodeLocationTracking: 'none',
        traceInitPerf: !1,
        skipValidations: !1,
      })),
        (jp = Object.freeze({ recoveryValueFunc: a(() => {}, 'recoveryValueFunc'), resyncEnabled: !0 }))
      ;(function (e) {
        ;(e[(e.INVALID_RULE_NAME = 0)] = 'INVALID_RULE_NAME'),
          (e[(e.DUPLICATE_RULE_NAME = 1)] = 'DUPLICATE_RULE_NAME'),
          (e[(e.INVALID_RULE_OVERRIDE = 2)] = 'INVALID_RULE_OVERRIDE'),
          (e[(e.DUPLICATE_PRODUCTIONS = 3)] = 'DUPLICATE_PRODUCTIONS'),
          (e[(e.UNRESOLVED_SUBRULE_REF = 4)] = 'UNRESOLVED_SUBRULE_REF'),
          (e[(e.LEFT_RECURSION = 5)] = 'LEFT_RECURSION'),
          (e[(e.NONE_LAST_EMPTY_ALT = 6)] = 'NONE_LAST_EMPTY_ALT'),
          (e[(e.AMBIGUOUS_ALTS = 7)] = 'AMBIGUOUS_ALTS'),
          (e[(e.CONFLICT_TOKENS_RULES_NAMESPACE = 8)] = 'CONFLICT_TOKENS_RULES_NAMESPACE'),
          (e[(e.INVALID_TOKEN_NAME = 9)] = 'INVALID_TOKEN_NAME'),
          (e[(e.NO_NON_EMPTY_LOOKAHEAD = 10)] = 'NO_NON_EMPTY_LOOKAHEAD'),
          (e[(e.AMBIGUOUS_PREFIX_ALTS = 11)] = 'AMBIGUOUS_PREFIX_ALTS'),
          (e[(e.TOO_MANY_ALTS = 12)] = 'TOO_MANY_ALTS'),
          (e[(e.CUSTOM_LOOKAHEAD_VALIDATION = 13)] = 'CUSTOM_LOOKAHEAD_VALIDATION')
      })(Fn || (Fn = {}))
      a(uS, 'EMPTY_ALT')
      O1 = class e {
        static {
          a(this, 'Parser')
        }
        static performSelfAnalysis(t) {
          throw Error(
            'The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.',
          )
        }
        performSelfAnalysis() {
          this.TRACE_INIT('performSelfAnalysis', () => {
            let t
            this.selfAnalysisDone = !0
            let r = this.className
            this.TRACE_INIT('toFastProps', () => {
              b1(this)
            }),
              this.TRACE_INIT('Grammar Recording', () => {
                try {
                  this.enableRecording(),
                    rt(this.definedRulesNames, (i) => {
                      let o = this[i].originalGrammarAction,
                        l
                      this.TRACE_INIT(`${i} Rule`, () => {
                        l = this.topLevelRuleRecord(i, o)
                      }),
                        (this.gastProductionsCache[i] = l)
                    })
                } finally {
                  this.disableRecording()
                }
              })
            let n = []
            if (
              (this.TRACE_INIT('Grammar Resolving', () => {
                ;(n = zQ({ rules: We(this.gastProductionsCache) })),
                  (this.definitionErrors = this.definitionErrors.concat(n))
              }),
              this.TRACE_INIT('Grammar Validations', () => {
                if (De(n) && this.skipValidations === !1) {
                  let i = WQ({
                      rules: We(this.gastProductionsCache),
                      tokenTypes: We(this.tokensMap),
                      errMsgProvider: Ha,
                      grammarName: r,
                    }),
                    s = OQ({
                      lookaheadStrategy: this.lookaheadStrategy,
                      rules: We(this.gastProductionsCache),
                      tokenTypes: We(this.tokensMap),
                      grammarName: r,
                    })
                  this.definitionErrors = this.definitionErrors.concat(i, s)
                }
              }),
              De(this.definitionErrors) &&
                (this.recoveryEnabled &&
                  this.TRACE_INIT('computeAllProdsFollows', () => {
                    let i = HK(We(this.gastProductionsCache))
                    this.resyncFollows = i
                  }),
                this.TRACE_INIT('ComputeLookaheadFunctions', () => {
                  var i, s
                  ;(s = (i = this.lookaheadStrategy).initialize) === null ||
                    s === void 0 ||
                    s.call(i, { rules: We(this.gastProductionsCache) }),
                    this.preComputeLookaheadFunctions(We(this.gastProductionsCache))
                })),
              !e.DEFER_DEFINITION_ERRORS_HANDLING && !De(this.definitionErrors))
            )
              throw (
                ((t = Dt(this.definitionErrors, (i) => i.message)),
                new Error(`Parser Definition Errors detected:
 ${t.join(`
-------------------------------
`)}`))
              )
          })
        }
        constructor(t, r) {
          ;(this.definitionErrors = []), (this.selfAnalysisDone = !1)
          let n = this
          if (
            (n.initErrorHandler(r),
            n.initLexerAdapter(),
            n.initLooksAhead(r),
            n.initRecognizerEngine(t, r),
            n.initRecoverable(r),
            n.initTreeBuilder(r),
            n.initContentAssist(),
            n.initGastRecorder(r),
            n.initPerformanceTracer(r),
            te(r, 'ignoredIssues'))
          )
            throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`)
          this.skipValidations = te(r, 'skipValidations') ? r.skipValidations : qi.skipValidations
        }
      }
      O1.DEFER_DEFINITION_ERRORS_HANDLING = !1
      yZ(O1, [qT, KT, tS, eS, nS, rS, iS, sS, aS, cS])
      P1 = class extends O1 {
        static {
          a(this, 'EmbeddedActionsParser')
        }
        constructor(t, r = qi) {
          let n = Sr(r)
          ;(n.outputCst = !1), super(t, n)
        }
      }
    })
  var bZ = x(() => {
    'use strict'
    ji()
  })
  var kZ = x(() => {
    'use strict'
  })
  var TZ = x(() => {
    'use strict'
    bZ()
    kZ()
  })
  var SZ = x(() => {
    'use strict'
    J6()
  })
  var jc = x(() => {
    'use strict'
    J6()
    ys()
    T1()
    Nh()
    Vp()
    wL()
    Bp()
    Wp()
    fL()
    ji()
    ji()
    TZ()
    SZ()
  })
  function Mh(e, t, r) {
    return `${e.name}_${t}_${r}`
  }
  function EZ(e) {
    let t = { decisionMap: {}, decisionStates: [], ruleToStartState: new Map(), ruleToStopState: new Map(), states: [] }
    G4t(t, e)
    let r = e.length
    for (let n = 0; n < r; n++) {
      let i = e[n],
        s = Oh(t, i, i)
      s !== void 0 && Q4t(t, i, s)
    }
    return t
  }
  function G4t(e, t) {
    let r = t.length
    for (let n = 0; n < r; n++) {
      let i = t[n],
        s = Zn(e, i, void 0, { type: O4t }),
        o = Zn(e, i, void 0, { type: Yp })
      ;(s.stop = o), e.ruleToStartState.set(i, s), e.ruleToStopState.set(i, o)
    }
  }
  function vZ(e, t, r) {
    return r instanceof je
      ? ML(e, t, r.terminalType, r)
      : r instanceof Cr
        ? K4t(e, t, r)
        : r instanceof Or
          ? j4t(e, t, r)
          : r instanceof wr
            ? q4t(e, t, r)
            : r instanceof ir
              ? V4t(e, t, r)
              : r instanceof Mr
                ? z4t(e, t, r)
                : r instanceof zr
                  ? W4t(e, t, r)
                  : r instanceof Wr
                    ? U4t(e, t, r)
                    : Oh(e, t, r)
  }
  function V4t(e, t, r) {
    let n = Zn(e, t, r, { type: CZ })
    Hc(e, n)
    let i = Xp(e, t, n, r, Oh(e, t, r))
    return LZ(e, t, r, i)
  }
  function z4t(e, t, r) {
    let n = Zn(e, t, r, { type: CZ })
    Hc(e, n)
    let i = Xp(e, t, n, r, Oh(e, t, r)),
      s = ML(e, t, r.separator, r)
    return LZ(e, t, r, i, s)
  }
  function W4t(e, t, r) {
    let n = Zn(e, t, r, { type: _Z })
    Hc(e, n)
    let i = Xp(e, t, n, r, Oh(e, t, r))
    return AZ(e, t, r, i)
  }
  function U4t(e, t, r) {
    let n = Zn(e, t, r, { type: _Z })
    Hc(e, n)
    let i = Xp(e, t, n, r, Oh(e, t, r)),
      s = ML(e, t, r.separator, r)
    return AZ(e, t, r, i, s)
  }
  function j4t(e, t, r) {
    let n = Zn(e, t, r, { type: qc })
    Hc(e, n)
    let i = Dt(r.definition, (o) => vZ(e, t, o))
    return Xp(e, t, n, r, ...i)
  }
  function q4t(e, t, r) {
    let n = Zn(e, t, r, { type: qc })
    Hc(e, n)
    let i = Xp(e, t, n, r, Oh(e, t, r))
    return H4t(e, t, r, i)
  }
  function Oh(e, t, r) {
    let n = pr(
      Dt(r.definition, (i) => vZ(e, t, i)),
      (i) => i !== void 0,
    )
    return n.length === 1 ? n[0] : n.length === 0 ? void 0 : X4t(e, n)
  }
  function AZ(e, t, r, n, i) {
    let s = n.left,
      o = n.right,
      l = Zn(e, t, r, { type: $4t })
    Hc(e, l)
    let u = Zn(e, t, r, { type: wZ })
    return (
      (s.loopback = l),
      (u.loopback = l),
      (e.decisionMap[Mh(t, i ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', r.idx)] = l),
      Ln(o, l),
      i === void 0 ? (Ln(l, s), Ln(l, u)) : (Ln(l, u), Ln(l, i.left), Ln(i.right, s)),
      { left: s, right: u }
    )
  }
  function LZ(e, t, r, n, i) {
    let s = n.left,
      o = n.right,
      l = Zn(e, t, r, { type: F4t })
    Hc(e, l)
    let u = Zn(e, t, r, { type: wZ }),
      h = Zn(e, t, r, { type: B4t })
    return (
      (l.loopback = h),
      (u.loopback = h),
      Ln(l, s),
      Ln(l, u),
      Ln(o, h),
      i !== void 0 ? (Ln(h, u), Ln(h, i.left), Ln(i.right, s)) : Ln(h, l),
      (e.decisionMap[Mh(t, i ? 'RepetitionWithSeparator' : 'Repetition', r.idx)] = l),
      { left: l, right: u }
    )
  }
  function H4t(e, t, r, n) {
    let i = n.left,
      s = n.right
    return Ln(i, s), (e.decisionMap[Mh(t, 'Option', r.idx)] = i), n
  }
  function Hc(e, t) {
    return e.decisionStates.push(t), (t.decision = e.decisionStates.length - 1), t.decision
  }
  function Xp(e, t, r, n, ...i) {
    let s = Zn(e, t, n, { type: P4t, start: r })
    r.end = s
    for (let l of i) l !== void 0 ? (Ln(r, l.left), Ln(l.right, s)) : Ln(r, s)
    let o = { left: r, right: s }
    return (e.decisionMap[Mh(t, Y4t(n), n.idx)] = r), o
  }
  function Y4t(e) {
    if (e instanceof Or) return 'Alternation'
    if (e instanceof wr) return 'Option'
    if (e instanceof ir) return 'Repetition'
    if (e instanceof Mr) return 'RepetitionWithSeparator'
    if (e instanceof zr) return 'RepetitionMandatory'
    if (e instanceof Wr) return 'RepetitionMandatoryWithSeparator'
    throw new Error('Invalid production type encountered')
  }
  function X4t(e, t) {
    let r = t.length
    for (let s = 0; s < r - 1; s++) {
      let o = t[s],
        l
      o.left.transitions.length === 1 && (l = o.left.transitions[0])
      let u = l instanceof Hp,
        h = l,
        f = t[s + 1].left
      o.left.type === qc &&
      o.right.type === qc &&
      l !== void 0 &&
      ((u && h.followState === o.right) || l.target === o.right)
        ? (u ? (h.followState = f) : (l.target = f), Z4t(e, o.right))
        : Ln(o.right, f)
    }
    let n = t[0],
      i = t[r - 1]
    return { left: n.left, right: i.right }
  }
  function ML(e, t, r, n) {
    let i = Zn(e, t, n, { type: qc }),
      s = Zn(e, t, n, { type: qc })
    return OL(i, new qp(s, r)), { left: i, right: s }
  }
  function K4t(e, t, r) {
    let n = r.referencedRule,
      i = e.ruleToStartState.get(n),
      s = Zn(e, t, r, { type: qc }),
      o = Zn(e, t, r, { type: qc }),
      l = new Hp(i, n, o)
    return OL(s, l), { left: s, right: o }
  }
  function Q4t(e, t, r) {
    let n = e.ruleToStartState.get(t)
    Ln(n, r.left)
    let i = e.ruleToStopState.get(t)
    return Ln(r.right, i), { left: n, right: i }
  }
  function Ln(e, t) {
    let r = new F1(t)
    OL(e, r)
  }
  function Zn(e, t, r, n) {
    let i = Object.assign(
      {
        atn: e,
        production: r,
        epsilonOnlyTransitions: !1,
        rule: t,
        transitions: [],
        nextTokenWithinRule: [],
        stateNumber: e.states.length,
      },
      n,
    )
    return e.states.push(i), i
  }
  function OL(e, t) {
    e.transitions.length === 0 && (e.epsilonOnlyTransitions = t.isEpsilon()), e.transitions.push(t)
  }
  function Z4t(e, t) {
    e.states.splice(e.states.indexOf(t), 1)
  }
  var qc,
    O4t,
    _Z,
    CZ,
    Yp,
    P4t,
    B4t,
    F4t,
    $4t,
    wZ,
    B1,
    qp,
    F1,
    Hp,
    RZ = x(() => {
      'use strict'
      Ld()
      u5()
      jc()
      a(Mh, 'buildATNKey')
      ;(qc = 1),
        (O4t = 2),
        (_Z = 4),
        (CZ = 5),
        (Yp = 7),
        (P4t = 8),
        (B4t = 9),
        (F4t = 10),
        ($4t = 11),
        (wZ = 12),
        (B1 = class {
          static {
            a(this, 'AbstractTransition')
          }
          constructor(t) {
            this.target = t
          }
          isEpsilon() {
            return !1
          }
        }),
        (qp = class extends B1 {
          static {
            a(this, 'AtomTransition')
          }
          constructor(t, r) {
            super(t), (this.tokenType = r)
          }
        }),
        (F1 = class extends B1 {
          static {
            a(this, 'EpsilonTransition')
          }
          constructor(t) {
            super(t)
          }
          isEpsilon() {
            return !0
          }
        }),
        (Hp = class extends B1 {
          static {
            a(this, 'RuleTransition')
          }
          constructor(t, r, n) {
            super(t), (this.rule = r), (this.followState = n)
          }
          isEpsilon() {
            return !0
          }
        })
      a(EZ, 'createATN')
      a(G4t, 'createRuleStartAndStopATNStates')
      a(vZ, 'atom')
      a(V4t, 'repetition')
      a(z4t, 'repetitionSep')
      a(W4t, 'repetitionMandatory')
      a(U4t, 'repetitionMandatorySep')
      a(j4t, 'alternation')
      a(q4t, 'option')
      a(Oh, 'block')
      a(AZ, 'plus')
      a(LZ, 'star')
      a(H4t, 'optional')
      a(Hc, 'defineDecisionState')
      a(Xp, 'makeAlts')
      a(Y4t, 'getProdType')
      a(X4t, 'makeBlock')
      a(ML, 'tokenRef')
      a(K4t, 'ruleRef')
      a(Q4t, 'buildRuleHandle')
      a(Ln, 'epsilon')
      a(Zn, 'newState')
      a(OL, 'addTransition')
      a(Z4t, 'removeState')
    })
  function PL(e, t = !0) {
    return `${t ? `a${e.alt}` : ''}s${e.state.stateNumber}:${e.stack.map((r) => r.stateNumber.toString()).join('_')}`
  }
  var $1,
    Kp,
    DZ = x(() => {
      'use strict'
      Ld()
      ;($1 = {}),
        (Kp = class {
          static {
            a(this, 'ATNConfigSet')
          }
          constructor() {
            ;(this.map = {}), (this.configs = [])
          }
          get size() {
            return this.configs.length
          }
          finalize() {
            this.map = {}
          }
          add(t) {
            let r = PL(t)
            r in this.map || ((this.map[r] = this.configs.length), this.configs.push(t))
          }
          get elements() {
            return this.configs
          }
          get alts() {
            return Dt(this.configs, (t) => t.alt)
          }
          get key() {
            let t = ''
            for (let r in this.map) t += r + ':'
            return t
          }
        })
      a(PL, 'getATNConfigKey')
    })
  function J4t(e, t) {
    let r = {}
    return (n) => {
      let i = n.toString(),
        s = r[i]
      return s !== void 0 || ((s = { atnStartState: e, decision: t, states: {} }), (r[i] = s)), s
    }
  }
  function IZ(e, t = !0) {
    let r = new Set()
    for (let n of e) {
      let i = new Set()
      for (let s of n) {
        if (s === void 0) {
          if (t) break
          return !1
        }
        let o = [s.tokenTypeIdx].concat(s.categoryMatches)
        for (let l of o)
          if (r.has(l)) {
            if (!i.has(l)) return !1
          } else r.add(l), i.add(l)
      }
    }
    return !0
  }
  function tAt(e) {
    let t = e.decisionStates.length,
      r = Array(t)
    for (let n = 0; n < t; n++) r[n] = J4t(e.decisionStates[n], n)
    return r
  }
  function BL(e, t, r, n) {
    let i = e[t](r),
      s = i.start
    if (s === void 0) {
      let l = hAt(i.atnStartState)
      ;(s = PZ(i, OZ(l))), (i.start = s)
    }
    return eAt.apply(this, [i, s, r, n])
  }
  function eAt(e, t, r, n) {
    let i = t,
      s = 1,
      o = [],
      l = this.LA(s++)
    for (;;) {
      let u = oAt(i, l)
      if ((u === void 0 && (u = rAt.apply(this, [e, i, l, s, r, n])), u === $1)) return aAt(o, i, l)
      if (u.isAcceptState === !0) return u.prediction
      ;(i = u), o.push(l), (l = this.LA(s++))
    }
  }
  function rAt(e, t, r, n, i, s) {
    let o = lAt(t.configs, r, i)
    if (o.size === 0) return MZ(e, t, r, $1), $1
    let l = OZ(o),
      u = uAt(o, i)
    if (u !== void 0) (l.isAcceptState = !0), (l.prediction = u), (l.configs.uniqueAlt = u)
    else if (mAt(o)) {
      let h = Ga(o.alts)
      ;(l.isAcceptState = !0), (l.prediction = h), (l.configs.uniqueAlt = h), nAt.apply(this, [e, n, o.alts, s])
    }
    return (l = MZ(e, t, r, l)), l
  }
  function nAt(e, t, r, n) {
    let i = []
    for (let h = 1; h <= t; h++) i.push(this.LA(h).tokenType)
    let s = e.atnStartState,
      o = s.rule,
      l = s.production,
      u = iAt({ topLevelRule: o, ambiguityIndices: r, production: l, prefixPath: i })
    n(u)
  }
  function iAt(e) {
    let t = Dt(e.prefixPath, (i) => vl(i)).join(', '),
      r = e.production.idx === 0 ? '' : e.production.idx,
      n = `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(', ')}> in <${sAt(e.production)}${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`
    return (
      (n =
        n +
        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`),
      n
    )
  }
  function sAt(e) {
    if (e instanceof Cr) return 'SUBRULE'
    if (e instanceof wr) return 'OPTION'
    if (e instanceof Or) return 'OR'
    if (e instanceof zr) return 'AT_LEAST_ONE'
    if (e instanceof Wr) return 'AT_LEAST_ONE_SEP'
    if (e instanceof Mr) return 'MANY_SEP'
    if (e instanceof ir) return 'MANY'
    if (e instanceof je) return 'CONSUME'
    throw Error('non exhaustive match')
  }
  function aAt(e, t, r) {
    let n = li(t.configs.elements, (s) => s.state.transitions),
      i = hY(
        n.filter((s) => s instanceof qp).map((s) => s.tokenType),
        (s) => s.tokenTypeIdx,
      )
    return { actualToken: r, possibleTokenTypes: i, tokenPath: e }
  }
  function oAt(e, t) {
    return e.edges[t.tokenTypeIdx]
  }
  function lAt(e, t, r) {
    let n = new Kp(),
      i = []
    for (let o of e.elements) {
      if (r.is(o.alt) === !1) continue
      if (o.state.type === Yp) {
        i.push(o)
        continue
      }
      let l = o.state.transitions.length
      for (let u = 0; u < l; u++) {
        let h = o.state.transitions[u],
          f = cAt(h, t)
        f !== void 0 && n.add({ state: f, alt: o.alt, stack: o.stack })
      }
    }
    let s
    if ((i.length === 0 && n.size === 1 && (s = n), s === void 0)) {
      s = new Kp()
      for (let o of n.elements) fS(o, s)
    }
    if (i.length > 0 && !dAt(s)) for (let o of i) s.add(o)
    return s
  }
  function cAt(e, t) {
    if (e instanceof qp && _1(t, e.tokenType)) return e.target
  }
  function uAt(e, t) {
    let r
    for (let n of e.elements)
      if (t.is(n.alt) === !0) {
        if (r === void 0) r = n.alt
        else if (r !== n.alt) return
      }
    return r
  }
  function OZ(e) {
    return { configs: e, edges: {}, isAcceptState: !1, prediction: -1 }
  }
  function MZ(e, t, r, n) {
    return (n = PZ(e, n)), (t.edges[r.tokenTypeIdx] = n), n
  }
  function PZ(e, t) {
    if (t === $1) return t
    let r = t.configs.key,
      n = e.states[r]
    return n !== void 0 ? n : (t.configs.finalize(), (e.states[r] = t), t)
  }
  function hAt(e) {
    let t = new Kp(),
      r = e.transitions.length
    for (let n = 0; n < r; n++) {
      let s = { state: e.transitions[n].target, alt: n, stack: [] }
      fS(s, t)
    }
    return t
  }
  function fS(e, t) {
    let r = e.state
    if (r.type === Yp) {
      if (e.stack.length > 0) {
        let i = [...e.stack],
          o = { state: i.pop(), alt: e.alt, stack: i }
        fS(o, t)
      } else t.add(e)
      return
    }
    r.epsilonOnlyTransitions || t.add(e)
    let n = r.transitions.length
    for (let i = 0; i < n; i++) {
      let s = r.transitions[i],
        o = fAt(e, s)
      o !== void 0 && fS(o, t)
    }
  }
  function fAt(e, t) {
    if (t instanceof F1) return { state: t.target, alt: e.alt, stack: e.stack }
    if (t instanceof Hp) {
      let r = [...e.stack, t.followState]
      return { state: t.target, alt: e.alt, stack: r }
    }
  }
  function dAt(e) {
    for (let t of e.elements) if (t.state.type === Yp) return !0
    return !1
  }
  function pAt(e) {
    for (let t of e.elements) if (t.state.type !== Yp) return !1
    return !0
  }
  function mAt(e) {
    if (pAt(e)) return !0
    let t = gAt(e.elements)
    return yAt(t) && !xAt(t)
  }
  function gAt(e) {
    let t = new Map()
    for (let r of e) {
      let n = PL(r, !1),
        i = t.get(n)
      i === void 0 && ((i = {}), t.set(n, i)), (i[r.alt] = !0)
    }
    return t
  }
  function yAt(e) {
    for (let t of Array.from(e.values())) if (Object.keys(t).length > 1) return !0
    return !1
  }
  function xAt(e) {
    for (let t of Array.from(e.values())) if (Object.keys(t).length === 1) return !0
    return !1
  }
  var hS,
    NZ,
    G1,
    BZ = x(() => {
      'use strict'
      jc()
      RZ()
      DZ()
      x5()
      f5()
      fY()
      Ld()
      pk()
      Wk()
      Yk()
      S5()
      a(J4t, 'createDFACache')
      ;(hS = class {
        static {
          a(this, 'PredicateSet')
        }
        constructor() {
          this.predicates = []
        }
        is(t) {
          return t >= this.predicates.length || this.predicates[t]
        }
        set(t, r) {
          this.predicates[t] = r
        }
        toString() {
          let t = '',
            r = this.predicates.length
          for (let n = 0; n < r; n++) t += this.predicates[n] === !0 ? '1' : '0'
          return t
        }
      }),
        (NZ = new hS()),
        (G1 = class extends Rl {
          static {
            a(this, 'LLStarLookaheadStrategy')
          }
          constructor(t) {
            var r
            super(), (this.logging = (r = t?.logging) !== null && r !== void 0 ? r : (n) => console.log(n))
          }
          initialize(t) {
            ;(this.atn = EZ(t.rules)), (this.dfas = tAt(this.atn))
          }
          validateAmbiguousAlternationAlternatives() {
            return []
          }
          validateEmptyOrAlternatives() {
            return []
          }
          buildLookaheadForAlternation(t) {
            let { prodOccurrence: r, rule: n, hasPredicates: i, dynamicTokensEnabled: s } = t,
              o = this.dfas,
              l = this.logging,
              u = Mh(n, 'Alternation', r),
              f = this.atn.decisionMap[u].decision,
              d = Dt(WT({ maxLookahead: 1, occurrence: r, prodType: 'Alternation', rule: n }), (p) =>
                Dt(p, (m) => m[0]),
              )
            if (IZ(d, !1) && !s) {
              let p = mr(
                d,
                (m, g, y) => (
                  rt(g, (b) => {
                    b &&
                      ((m[b.tokenTypeIdx] = y),
                      rt(b.categoryMatches, (k) => {
                        m[k] = y
                      }))
                  }),
                  m
                ),
                {},
              )
              return i
                ? function (m) {
                    var g
                    let y = this.LA(1),
                      b = p[y.tokenTypeIdx]
                    if (m !== void 0 && b !== void 0) {
                      let k = (g = m[b]) === null || g === void 0 ? void 0 : g.GATE
                      if (k !== void 0 && k.call(this) === !1) return
                    }
                    return b
                  }
                : function () {
                    let m = this.LA(1)
                    return p[m.tokenTypeIdx]
                  }
            } else
              return i
                ? function (p) {
                    let m = new hS(),
                      g = p === void 0 ? 0 : p.length
                    for (let b = 0; b < g; b++) {
                      let k = p?.[b].GATE
                      m.set(b, k === void 0 || k.call(this))
                    }
                    let y = BL.call(this, o, f, m, l)
                    return typeof y == 'number' ? y : void 0
                  }
                : function () {
                    let p = BL.call(this, o, f, NZ, l)
                    return typeof p == 'number' ? p : void 0
                  }
          }
          buildLookaheadForOptional(t) {
            let { prodOccurrence: r, rule: n, prodType: i, dynamicTokensEnabled: s } = t,
              o = this.dfas,
              l = this.logging,
              u = Mh(n, i, r),
              f = this.atn.decisionMap[u].decision,
              d = Dt(WT({ maxLookahead: 1, occurrence: r, prodType: i, rule: n }), (p) => Dt(p, (m) => m[0]))
            if (IZ(d) && d[0][0] && !s) {
              let p = d[0],
                m = dr(p)
              if (m.length === 1 && De(m[0].categoryMatches)) {
                let y = m[0].tokenTypeIdx
                return function () {
                  return this.LA(1).tokenTypeIdx === y
                }
              } else {
                let g = mr(
                  m,
                  (y, b) => (
                    b !== void 0 &&
                      ((y[b.tokenTypeIdx] = !0),
                      rt(b.categoryMatches, (k) => {
                        y[k] = !0
                      })),
                    y
                  ),
                  {},
                )
                return function () {
                  let y = this.LA(1)
                  return g[y.tokenTypeIdx] === !0
                }
              }
            }
            return function () {
              let p = BL.call(this, o, f, NZ, l)
              return typeof p == 'object' ? !1 : p === 0
            }
          }
        })
      a(IZ, 'isLL1Sequence')
      a(tAt, 'initATNSimulator')
      a(BL, 'adaptivePredict')
      a(eAt, 'performLookahead')
      a(rAt, 'computeLookaheadTarget')
      a(nAt, 'reportLookaheadAmbiguity')
      a(iAt, 'buildAmbiguityError')
      a(sAt, 'getProductionDslName')
      a(aAt, 'buildAdaptivePredictError')
      a(oAt, 'getExistingTargetState')
      a(lAt, 'computeReachSet')
      a(cAt, 'getReachableTarget')
      a(uAt, 'getUniqueAlt')
      a(OZ, 'newDFAState')
      a(MZ, 'addDFAEdge')
      a(PZ, 'addDFAState')
      a(hAt, 'computeStartState')
      a(fS, 'closure')
      a(fAt, 'getEpsilonTarget')
      a(dAt, 'hasConfigInRuleStopState')
      a(pAt, 'allConfigsInRuleStopStates')
      a(mAt, 'hasConflictTerminatingPrediction')
      a(gAt, 'getConflictingAltSets')
      a(yAt, 'hasConflictingAltSet')
      a(xAt, 'hasStateAssociatedWithOneAlt')
    })
  var FZ = x(() => {
    'use strict'
    BZ()
  })
  var $Z,
    FL,
    GZ,
    dS,
    gr,
    sr,
    pS,
    VZ,
    $L,
    zZ,
    WZ,
    UZ,
    jZ,
    GL,
    qZ,
    HZ,
    YZ,
    mS,
    Qp,
    Zp,
    VL,
    Jp,
    XZ,
    zL,
    WL,
    UL,
    jL,
    qL,
    KZ,
    QZ,
    HL,
    ZZ,
    YL,
    V1,
    JZ,
    tJ,
    eJ,
    rJ,
    nJ,
    iJ,
    sJ,
    aJ,
    gS,
    oJ,
    lJ,
    cJ,
    uJ,
    hJ,
    fJ,
    dJ,
    pJ,
    mJ,
    gJ,
    yJ,
    yS,
    xJ,
    bJ,
    kJ,
    TJ,
    SJ,
    _J,
    CJ,
    wJ,
    EJ,
    vJ,
    AJ,
    LJ,
    RJ,
    XL,
    KL,
    DJ,
    NJ,
    IJ,
    MJ,
    OJ,
    PJ,
    BJ,
    FJ,
    $J,
    QL,
    pt,
    ZL = x(() => {
      'use strict'
      ;(function (e) {
        function t(r) {
          return typeof r == 'string'
        }
        a(t, 'is'), (e.is = t)
      })($Z || ($Z = {}))
      ;(function (e) {
        function t(r) {
          return typeof r == 'string'
        }
        a(t, 'is'), (e.is = t)
      })(FL || (FL = {}))
      ;(function (e) {
        ;(e.MIN_VALUE = -2147483648), (e.MAX_VALUE = 2147483647)
        function t(r) {
          return typeof r == 'number' && e.MIN_VALUE <= r && r <= e.MAX_VALUE
        }
        a(t, 'is'), (e.is = t)
      })(GZ || (GZ = {}))
      ;(function (e) {
        ;(e.MIN_VALUE = 0), (e.MAX_VALUE = 2147483647)
        function t(r) {
          return typeof r == 'number' && e.MIN_VALUE <= r && r <= e.MAX_VALUE
        }
        a(t, 'is'), (e.is = t)
      })(dS || (dS = {}))
      ;(function (e) {
        function t(n, i) {
          return (
            n === Number.MAX_VALUE && (n = dS.MAX_VALUE),
            i === Number.MAX_VALUE && (i = dS.MAX_VALUE),
            { line: n, character: i }
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.objectLiteral(i) && pt.uinteger(i.line) && pt.uinteger(i.character)
        }
        a(r, 'is'), (e.is = r)
      })(gr || (gr = {}))
      ;(function (e) {
        function t(n, i, s, o) {
          if (pt.uinteger(n) && pt.uinteger(i) && pt.uinteger(s) && pt.uinteger(o))
            return { start: gr.create(n, i), end: gr.create(s, o) }
          if (gr.is(n) && gr.is(i)) return { start: n, end: i }
          throw new Error(`Range#create called with invalid arguments[${n}, ${i}, ${s}, ${o}]`)
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.objectLiteral(i) && gr.is(i.start) && gr.is(i.end)
        }
        a(r, 'is'), (e.is = r)
      })(sr || (sr = {}))
      ;(function (e) {
        function t(n, i) {
          return { uri: n, range: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.objectLiteral(i) && sr.is(i.range) && (pt.string(i.uri) || pt.undefined(i.uri))
        }
        a(r, 'is'), (e.is = r)
      })(pS || (pS = {}))
      ;(function (e) {
        function t(n, i, s, o) {
          return { targetUri: n, targetRange: i, targetSelectionRange: s, originSelectionRange: o }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            sr.is(i.targetRange) &&
            pt.string(i.targetUri) &&
            sr.is(i.targetSelectionRange) &&
            (sr.is(i.originSelectionRange) || pt.undefined(i.originSelectionRange))
          )
        }
        a(r, 'is'), (e.is = r)
      })(VZ || (VZ = {}))
      ;(function (e) {
        function t(n, i, s, o) {
          return { red: n, green: i, blue: s, alpha: o }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            pt.numberRange(i.red, 0, 1) &&
            pt.numberRange(i.green, 0, 1) &&
            pt.numberRange(i.blue, 0, 1) &&
            pt.numberRange(i.alpha, 0, 1)
          )
        }
        a(r, 'is'), (e.is = r)
      })($L || ($L = {}))
      ;(function (e) {
        function t(n, i) {
          return { range: n, color: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.objectLiteral(i) && sr.is(i.range) && $L.is(i.color)
        }
        a(r, 'is'), (e.is = r)
      })(zZ || (zZ = {}))
      ;(function (e) {
        function t(n, i, s) {
          return { label: n, textEdit: i, additionalTextEdits: s }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            pt.string(i.label) &&
            (pt.undefined(i.textEdit) || Zp.is(i)) &&
            (pt.undefined(i.additionalTextEdits) || pt.typedArray(i.additionalTextEdits, Zp.is))
          )
        }
        a(r, 'is'), (e.is = r)
      })(WZ || (WZ = {}))
      ;(function (e) {
        ;(e.Comment = 'comment'), (e.Imports = 'imports'), (e.Region = 'region')
      })(UZ || (UZ = {}))
      ;(function (e) {
        function t(n, i, s, o, l, u) {
          let h = { startLine: n, endLine: i }
          return (
            pt.defined(s) && (h.startCharacter = s),
            pt.defined(o) && (h.endCharacter = o),
            pt.defined(l) && (h.kind = l),
            pt.defined(u) && (h.collapsedText = u),
            h
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            pt.uinteger(i.startLine) &&
            pt.uinteger(i.startLine) &&
            (pt.undefined(i.startCharacter) || pt.uinteger(i.startCharacter)) &&
            (pt.undefined(i.endCharacter) || pt.uinteger(i.endCharacter)) &&
            (pt.undefined(i.kind) || pt.string(i.kind))
          )
        }
        a(r, 'is'), (e.is = r)
      })(jZ || (jZ = {}))
      ;(function (e) {
        function t(n, i) {
          return { location: n, message: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pS.is(i.location) && pt.string(i.message)
        }
        a(r, 'is'), (e.is = r)
      })(GL || (GL = {}))
      ;(function (e) {
        ;(e.Error = 1), (e.Warning = 2), (e.Information = 3), (e.Hint = 4)
      })(qZ || (qZ = {}))
      ;(function (e) {
        ;(e.Unnecessary = 1), (e.Deprecated = 2)
      })(HZ || (HZ = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return pt.objectLiteral(n) && pt.string(n.href)
        }
        a(t, 'is'), (e.is = t)
      })(YZ || (YZ = {}))
      ;(function (e) {
        function t(n, i, s, o, l, u) {
          let h = { range: n, message: i }
          return (
            pt.defined(s) && (h.severity = s),
            pt.defined(o) && (h.code = o),
            pt.defined(l) && (h.source = l),
            pt.defined(u) && (h.relatedInformation = u),
            h
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          var i
          let s = n
          return (
            pt.defined(s) &&
            sr.is(s.range) &&
            pt.string(s.message) &&
            (pt.number(s.severity) || pt.undefined(s.severity)) &&
            (pt.integer(s.code) || pt.string(s.code) || pt.undefined(s.code)) &&
            (pt.undefined(s.codeDescription) ||
              pt.string((i = s.codeDescription) === null || i === void 0 ? void 0 : i.href)) &&
            (pt.string(s.source) || pt.undefined(s.source)) &&
            (pt.undefined(s.relatedInformation) || pt.typedArray(s.relatedInformation, GL.is))
          )
        }
        a(r, 'is'), (e.is = r)
      })(mS || (mS = {}))
      ;(function (e) {
        function t(n, i, ...s) {
          let o = { title: n, command: i }
          return pt.defined(s) && s.length > 0 && (o.arguments = s), o
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pt.string(i.title) && pt.string(i.command)
        }
        a(r, 'is'), (e.is = r)
      })(Qp || (Qp = {}))
      ;(function (e) {
        function t(s, o) {
          return { range: s, newText: o }
        }
        a(t, 'replace'), (e.replace = t)
        function r(s, o) {
          return { range: { start: s, end: s }, newText: o }
        }
        a(r, 'insert'), (e.insert = r)
        function n(s) {
          return { range: s, newText: '' }
        }
        a(n, 'del'), (e.del = n)
        function i(s) {
          let o = s
          return pt.objectLiteral(o) && pt.string(o.newText) && sr.is(o.range)
        }
        a(i, 'is'), (e.is = i)
      })(Zp || (Zp = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { label: n }
          return i !== void 0 && (o.needsConfirmation = i), s !== void 0 && (o.description = s), o
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            pt.string(i.label) &&
            (pt.boolean(i.needsConfirmation) || i.needsConfirmation === void 0) &&
            (pt.string(i.description) || i.description === void 0)
          )
        }
        a(r, 'is'), (e.is = r)
      })(VL || (VL = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return pt.string(n)
        }
        a(t, 'is'), (e.is = t)
      })(Jp || (Jp = {}))
      ;(function (e) {
        function t(s, o, l) {
          return { range: s, newText: o, annotationId: l }
        }
        a(t, 'replace'), (e.replace = t)
        function r(s, o, l) {
          return { range: { start: s, end: s }, newText: o, annotationId: l }
        }
        a(r, 'insert'), (e.insert = r)
        function n(s, o) {
          return { range: s, newText: '', annotationId: o }
        }
        a(n, 'del'), (e.del = n)
        function i(s) {
          let o = s
          return Zp.is(o) && (VL.is(o.annotationId) || Jp.is(o.annotationId))
        }
        a(i, 'is'), (e.is = i)
      })(XZ || (XZ = {}))
      ;(function (e) {
        function t(n, i) {
          return { textDocument: n, edits: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && HL.is(i.textDocument) && Array.isArray(i.edits)
        }
        a(r, 'is'), (e.is = r)
      })(zL || (zL = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { kind: 'create', uri: n }
          return (
            i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (o.options = i),
            s !== void 0 && (o.annotationId = s),
            o
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i &&
            i.kind === 'create' &&
            pt.string(i.uri) &&
            (i.options === void 0 ||
              ((i.options.overwrite === void 0 || pt.boolean(i.options.overwrite)) &&
                (i.options.ignoreIfExists === void 0 || pt.boolean(i.options.ignoreIfExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          )
        }
        a(r, 'is'), (e.is = r)
      })(WL || (WL = {}))
      ;(function (e) {
        function t(n, i, s, o) {
          let l = { kind: 'rename', oldUri: n, newUri: i }
          return (
            s !== void 0 && (s.overwrite !== void 0 || s.ignoreIfExists !== void 0) && (l.options = s),
            o !== void 0 && (l.annotationId = o),
            l
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i &&
            i.kind === 'rename' &&
            pt.string(i.oldUri) &&
            pt.string(i.newUri) &&
            (i.options === void 0 ||
              ((i.options.overwrite === void 0 || pt.boolean(i.options.overwrite)) &&
                (i.options.ignoreIfExists === void 0 || pt.boolean(i.options.ignoreIfExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          )
        }
        a(r, 'is'), (e.is = r)
      })(UL || (UL = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { kind: 'delete', uri: n }
          return (
            i !== void 0 && (i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) && (o.options = i),
            s !== void 0 && (o.annotationId = s),
            o
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i &&
            i.kind === 'delete' &&
            pt.string(i.uri) &&
            (i.options === void 0 ||
              ((i.options.recursive === void 0 || pt.boolean(i.options.recursive)) &&
                (i.options.ignoreIfNotExists === void 0 || pt.boolean(i.options.ignoreIfNotExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          )
        }
        a(r, 'is'), (e.is = r)
      })(jL || (jL = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return (
            n &&
            (n.changes !== void 0 || n.documentChanges !== void 0) &&
            (n.documentChanges === void 0 ||
              n.documentChanges.every((i) => (pt.string(i.kind) ? WL.is(i) || UL.is(i) || jL.is(i) : zL.is(i))))
          )
        }
        a(t, 'is'), (e.is = t)
      })(qL || (qL = {}))
      ;(function (e) {
        function t(n) {
          return { uri: n }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pt.string(i.uri)
        }
        a(r, 'is'), (e.is = r)
      })(KZ || (KZ = {}))
      ;(function (e) {
        function t(n, i) {
          return { uri: n, version: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pt.string(i.uri) && pt.integer(i.version)
        }
        a(r, 'is'), (e.is = r)
      })(QZ || (QZ = {}))
      ;(function (e) {
        function t(n, i) {
          return { uri: n, version: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pt.string(i.uri) && (i.version === null || pt.integer(i.version))
        }
        a(r, 'is'), (e.is = r)
      })(HL || (HL = {}))
      ;(function (e) {
        function t(n, i, s, o) {
          return { uri: n, languageId: i, version: s, text: o }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.defined(i) && pt.string(i.uri) && pt.string(i.languageId) && pt.integer(i.version) && pt.string(i.text)
          )
        }
        a(r, 'is'), (e.is = r)
      })(ZZ || (ZZ = {}))
      ;(function (e) {
        ;(e.PlainText = 'plaintext'), (e.Markdown = 'markdown')
        function t(r) {
          let n = r
          return n === e.PlainText || n === e.Markdown
        }
        a(t, 'is'), (e.is = t)
      })(YL || (YL = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return pt.objectLiteral(r) && YL.is(n.kind) && pt.string(n.value)
        }
        a(t, 'is'), (e.is = t)
      })(V1 || (V1 = {}))
      ;(function (e) {
        ;(e.Text = 1),
          (e.Method = 2),
          (e.Function = 3),
          (e.Constructor = 4),
          (e.Field = 5),
          (e.Variable = 6),
          (e.Class = 7),
          (e.Interface = 8),
          (e.Module = 9),
          (e.Property = 10),
          (e.Unit = 11),
          (e.Value = 12),
          (e.Enum = 13),
          (e.Keyword = 14),
          (e.Snippet = 15),
          (e.Color = 16),
          (e.File = 17),
          (e.Reference = 18),
          (e.Folder = 19),
          (e.EnumMember = 20),
          (e.Constant = 21),
          (e.Struct = 22),
          (e.Event = 23),
          (e.Operator = 24),
          (e.TypeParameter = 25)
      })(JZ || (JZ = {}))
      ;(function (e) {
        ;(e.PlainText = 1), (e.Snippet = 2)
      })(tJ || (tJ = {}))
      ;(function (e) {
        e.Deprecated = 1
      })(eJ || (eJ = {}))
      ;(function (e) {
        function t(n, i, s) {
          return { newText: n, insert: i, replace: s }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return i && pt.string(i.newText) && sr.is(i.insert) && sr.is(i.replace)
        }
        a(r, 'is'), (e.is = r)
      })(rJ || (rJ = {}))
      ;(function (e) {
        ;(e.asIs = 1), (e.adjustIndentation = 2)
      })(nJ || (nJ = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return (
            n && (pt.string(n.detail) || n.detail === void 0) && (pt.string(n.description) || n.description === void 0)
          )
        }
        a(t, 'is'), (e.is = t)
      })(iJ || (iJ = {}))
      ;(function (e) {
        function t(r) {
          return { label: r }
        }
        a(t, 'create'), (e.create = t)
      })(sJ || (sJ = {}))
      ;(function (e) {
        function t(r, n) {
          return { items: r || [], isIncomplete: !!n }
        }
        a(t, 'create'), (e.create = t)
      })(aJ || (aJ = {}))
      ;(function (e) {
        function t(n) {
          return n.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&')
        }
        a(t, 'fromPlainText'), (e.fromPlainText = t)
        function r(n) {
          let i = n
          return pt.string(i) || (pt.objectLiteral(i) && pt.string(i.language) && pt.string(i.value))
        }
        a(r, 'is'), (e.is = r)
      })(gS || (gS = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return (
            !!n &&
            pt.objectLiteral(n) &&
            (V1.is(n.contents) || gS.is(n.contents) || pt.typedArray(n.contents, gS.is)) &&
            (r.range === void 0 || sr.is(r.range))
          )
        }
        a(t, 'is'), (e.is = t)
      })(oJ || (oJ = {}))
      ;(function (e) {
        function t(r, n) {
          return n ? { label: r, documentation: n } : { label: r }
        }
        a(t, 'create'), (e.create = t)
      })(lJ || (lJ = {}))
      ;(function (e) {
        function t(r, n, ...i) {
          let s = { label: r }
          return pt.defined(n) && (s.documentation = n), pt.defined(i) ? (s.parameters = i) : (s.parameters = []), s
        }
        a(t, 'create'), (e.create = t)
      })(cJ || (cJ = {}))
      ;(function (e) {
        ;(e.Text = 1), (e.Read = 2), (e.Write = 3)
      })(uJ || (uJ = {}))
      ;(function (e) {
        function t(r, n) {
          let i = { range: r }
          return pt.number(n) && (i.kind = n), i
        }
        a(t, 'create'), (e.create = t)
      })(hJ || (hJ = {}))
      ;(function (e) {
        ;(e.File = 1),
          (e.Module = 2),
          (e.Namespace = 3),
          (e.Package = 4),
          (e.Class = 5),
          (e.Method = 6),
          (e.Property = 7),
          (e.Field = 8),
          (e.Constructor = 9),
          (e.Enum = 10),
          (e.Interface = 11),
          (e.Function = 12),
          (e.Variable = 13),
          (e.Constant = 14),
          (e.String = 15),
          (e.Number = 16),
          (e.Boolean = 17),
          (e.Array = 18),
          (e.Object = 19),
          (e.Key = 20),
          (e.Null = 21),
          (e.EnumMember = 22),
          (e.Struct = 23),
          (e.Event = 24),
          (e.Operator = 25),
          (e.TypeParameter = 26)
      })(fJ || (fJ = {}))
      ;(function (e) {
        e.Deprecated = 1
      })(dJ || (dJ = {}))
      ;(function (e) {
        function t(r, n, i, s, o) {
          let l = { name: r, kind: n, location: { uri: s, range: i } }
          return o && (l.containerName = o), l
        }
        a(t, 'create'), (e.create = t)
      })(pJ || (pJ = {}))
      ;(function (e) {
        function t(r, n, i, s) {
          return s !== void 0
            ? { name: r, kind: n, location: { uri: i, range: s } }
            : { name: r, kind: n, location: { uri: i } }
        }
        a(t, 'create'), (e.create = t)
      })(mJ || (mJ = {}))
      ;(function (e) {
        function t(n, i, s, o, l, u) {
          let h = { name: n, detail: i, kind: s, range: o, selectionRange: l }
          return u !== void 0 && (h.children = u), h
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i &&
            pt.string(i.name) &&
            pt.number(i.kind) &&
            sr.is(i.range) &&
            sr.is(i.selectionRange) &&
            (i.detail === void 0 || pt.string(i.detail)) &&
            (i.deprecated === void 0 || pt.boolean(i.deprecated)) &&
            (i.children === void 0 || Array.isArray(i.children)) &&
            (i.tags === void 0 || Array.isArray(i.tags))
          )
        }
        a(r, 'is'), (e.is = r)
      })(gJ || (gJ = {}))
      ;(function (e) {
        ;(e.Empty = ''),
          (e.QuickFix = 'quickfix'),
          (e.Refactor = 'refactor'),
          (e.RefactorExtract = 'refactor.extract'),
          (e.RefactorInline = 'refactor.inline'),
          (e.RefactorRewrite = 'refactor.rewrite'),
          (e.Source = 'source'),
          (e.SourceOrganizeImports = 'source.organizeImports'),
          (e.SourceFixAll = 'source.fixAll')
      })(yJ || (yJ = {}))
      ;(function (e) {
        ;(e.Invoked = 1), (e.Automatic = 2)
      })(yS || (yS = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { diagnostics: n }
          return i != null && (o.only = i), s != null && (o.triggerKind = s), o
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.defined(i) &&
            pt.typedArray(i.diagnostics, mS.is) &&
            (i.only === void 0 || pt.typedArray(i.only, pt.string)) &&
            (i.triggerKind === void 0 || i.triggerKind === yS.Invoked || i.triggerKind === yS.Automatic)
          )
        }
        a(r, 'is'), (e.is = r)
      })(xJ || (xJ = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { title: n },
            l = !0
          return (
            typeof i == 'string' ? ((l = !1), (o.kind = i)) : Qp.is(i) ? (o.command = i) : (o.edit = i),
            l && s !== void 0 && (o.kind = s),
            o
          )
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i &&
            pt.string(i.title) &&
            (i.diagnostics === void 0 || pt.typedArray(i.diagnostics, mS.is)) &&
            (i.kind === void 0 || pt.string(i.kind)) &&
            (i.edit !== void 0 || i.command !== void 0) &&
            (i.command === void 0 || Qp.is(i.command)) &&
            (i.isPreferred === void 0 || pt.boolean(i.isPreferred)) &&
            (i.edit === void 0 || qL.is(i.edit))
          )
        }
        a(r, 'is'), (e.is = r)
      })(bJ || (bJ = {}))
      ;(function (e) {
        function t(n, i) {
          let s = { range: n }
          return pt.defined(i) && (s.data = i), s
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && sr.is(i.range) && (pt.undefined(i.command) || Qp.is(i.command))
        }
        a(r, 'is'), (e.is = r)
      })(kJ || (kJ = {}))
      ;(function (e) {
        function t(n, i) {
          return { tabSize: n, insertSpaces: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && pt.uinteger(i.tabSize) && pt.boolean(i.insertSpaces)
        }
        a(r, 'is'), (e.is = r)
      })(TJ || (TJ = {}))
      ;(function (e) {
        function t(n, i, s) {
          return { range: n, target: i, data: s }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && sr.is(i.range) && (pt.undefined(i.target) || pt.string(i.target))
        }
        a(r, 'is'), (e.is = r)
      })(SJ || (SJ = {}))
      ;(function (e) {
        function t(n, i) {
          return { range: n, parent: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.objectLiteral(i) && sr.is(i.range) && (i.parent === void 0 || e.is(i.parent))
        }
        a(r, 'is'), (e.is = r)
      })(_J || (_J = {}))
      ;(function (e) {
        ;(e.namespace = 'namespace'),
          (e.type = 'type'),
          (e.class = 'class'),
          (e.enum = 'enum'),
          (e.interface = 'interface'),
          (e.struct = 'struct'),
          (e.typeParameter = 'typeParameter'),
          (e.parameter = 'parameter'),
          (e.variable = 'variable'),
          (e.property = 'property'),
          (e.enumMember = 'enumMember'),
          (e.event = 'event'),
          (e.function = 'function'),
          (e.method = 'method'),
          (e.macro = 'macro'),
          (e.keyword = 'keyword'),
          (e.modifier = 'modifier'),
          (e.comment = 'comment'),
          (e.string = 'string'),
          (e.number = 'number'),
          (e.regexp = 'regexp'),
          (e.operator = 'operator'),
          (e.decorator = 'decorator')
      })(CJ || (CJ = {}))
      ;(function (e) {
        ;(e.declaration = 'declaration'),
          (e.definition = 'definition'),
          (e.readonly = 'readonly'),
          (e.static = 'static'),
          (e.deprecated = 'deprecated'),
          (e.abstract = 'abstract'),
          (e.async = 'async'),
          (e.modification = 'modification'),
          (e.documentation = 'documentation'),
          (e.defaultLibrary = 'defaultLibrary')
      })(wJ || (wJ = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return (
            pt.objectLiteral(n) &&
            (n.resultId === void 0 || typeof n.resultId == 'string') &&
            Array.isArray(n.data) &&
            (n.data.length === 0 || typeof n.data[0] == 'number')
          )
        }
        a(t, 'is'), (e.is = t)
      })(EJ || (EJ = {}))
      ;(function (e) {
        function t(n, i) {
          return { range: n, text: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return i != null && sr.is(i.range) && pt.string(i.text)
        }
        a(r, 'is'), (e.is = r)
      })(vJ || (vJ = {}))
      ;(function (e) {
        function t(n, i, s) {
          return { range: n, variableName: i, caseSensitiveLookup: s }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            i != null &&
            sr.is(i.range) &&
            pt.boolean(i.caseSensitiveLookup) &&
            (pt.string(i.variableName) || i.variableName === void 0)
          )
        }
        a(r, 'is'), (e.is = r)
      })(AJ || (AJ = {}))
      ;(function (e) {
        function t(n, i) {
          return { range: n, expression: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return i != null && sr.is(i.range) && (pt.string(i.expression) || i.expression === void 0)
        }
        a(r, 'is'), (e.is = r)
      })(LJ || (LJ = {}))
      ;(function (e) {
        function t(n, i) {
          return { frameId: n, stoppedLocation: i }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return pt.defined(i) && sr.is(n.stoppedLocation)
        }
        a(r, 'is'), (e.is = r)
      })(RJ || (RJ = {}))
      ;(function (e) {
        ;(e.Type = 1), (e.Parameter = 2)
        function t(r) {
          return r === 1 || r === 2
        }
        a(t, 'is'), (e.is = t)
      })(XL || (XL = {}))
      ;(function (e) {
        function t(n) {
          return { value: n }
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            pt.objectLiteral(i) &&
            (i.tooltip === void 0 || pt.string(i.tooltip) || V1.is(i.tooltip)) &&
            (i.location === void 0 || pS.is(i.location)) &&
            (i.command === void 0 || Qp.is(i.command))
          )
        }
        a(r, 'is'), (e.is = r)
      })(KL || (KL = {}))
      ;(function (e) {
        function t(n, i, s) {
          let o = { position: n, label: i }
          return s !== void 0 && (o.kind = s), o
        }
        a(t, 'create'), (e.create = t)
        function r(n) {
          let i = n
          return (
            (pt.objectLiteral(i) &&
              gr.is(i.position) &&
              (pt.string(i.label) || pt.typedArray(i.label, KL.is)) &&
              (i.kind === void 0 || XL.is(i.kind)) &&
              i.textEdits === void 0) ||
            (pt.typedArray(i.textEdits, Zp.is) &&
              (i.tooltip === void 0 || pt.string(i.tooltip) || V1.is(i.tooltip)) &&
              (i.paddingLeft === void 0 || pt.boolean(i.paddingLeft)) &&
              (i.paddingRight === void 0 || pt.boolean(i.paddingRight)))
          )
        }
        a(r, 'is'), (e.is = r)
      })(DJ || (DJ = {}))
      ;(function (e) {
        function t(r) {
          return { kind: 'snippet', value: r }
        }
        a(t, 'createSnippet'), (e.createSnippet = t)
      })(NJ || (NJ = {}))
      ;(function (e) {
        function t(r, n, i, s) {
          return { insertText: r, filterText: n, range: i, command: s }
        }
        a(t, 'create'), (e.create = t)
      })(IJ || (IJ = {}))
      ;(function (e) {
        function t(r) {
          return { items: r }
        }
        a(t, 'create'), (e.create = t)
      })(MJ || (MJ = {}))
      ;(function (e) {
        ;(e.Invoked = 0), (e.Automatic = 1)
      })(OJ || (OJ = {}))
      ;(function (e) {
        function t(r, n) {
          return { range: r, text: n }
        }
        a(t, 'create'), (e.create = t)
      })(PJ || (PJ = {}))
      ;(function (e) {
        function t(r, n) {
          return { triggerKind: r, selectedCompletionInfo: n }
        }
        a(t, 'create'), (e.create = t)
      })(BJ || (BJ = {}))
      ;(function (e) {
        function t(r) {
          let n = r
          return pt.objectLiteral(n) && FL.is(n.uri) && pt.string(n.name)
        }
        a(t, 'is'), (e.is = t)
      })(FJ || (FJ = {}))
      ;(function (e) {
        function t(s, o, l, u) {
          return new QL(s, o, l, u)
        }
        a(t, 'create'), (e.create = t)
        function r(s) {
          let o = s
          return !!(
            pt.defined(o) &&
            pt.string(o.uri) &&
            (pt.undefined(o.languageId) || pt.string(o.languageId)) &&
            pt.uinteger(o.lineCount) &&
            pt.func(o.getText) &&
            pt.func(o.positionAt) &&
            pt.func(o.offsetAt)
          )
        }
        a(r, 'is'), (e.is = r)
        function n(s, o) {
          let l = s.getText(),
            u = i(o, (f, d) => {
              let p = f.range.start.line - d.range.start.line
              return p === 0 ? f.range.start.character - d.range.start.character : p
            }),
            h = l.length
          for (let f = u.length - 1; f >= 0; f--) {
            let d = u[f],
              p = s.offsetAt(d.range.start),
              m = s.offsetAt(d.range.end)
            if (m <= h) l = l.substring(0, p) + d.newText + l.substring(m, l.length)
            else throw new Error('Overlapping edit')
            h = p
          }
          return l
        }
        a(n, 'applyEdits'), (e.applyEdits = n)
        function i(s, o) {
          if (s.length <= 1) return s
          let l = (s.length / 2) | 0,
            u = s.slice(0, l),
            h = s.slice(l)
          i(u, o), i(h, o)
          let f = 0,
            d = 0,
            p = 0
          for (; f < u.length && d < h.length; ) o(u[f], h[d]) <= 0 ? (s[p++] = u[f++]) : (s[p++] = h[d++])
          for (; f < u.length; ) s[p++] = u[f++]
          for (; d < h.length; ) s[p++] = h[d++]
          return s
        }
        a(i, 'mergeSort')
      })($J || ($J = {}))
      QL = class {
        static {
          a(this, 'FullTextDocument')
        }
        constructor(t, r, n, i) {
          ;(this._uri = t),
            (this._languageId = r),
            (this._version = n),
            (this._content = i),
            (this._lineOffsets = void 0)
        }
        get uri() {
          return this._uri
        }
        get languageId() {
          return this._languageId
        }
        get version() {
          return this._version
        }
        getText(t) {
          if (t) {
            let r = this.offsetAt(t.start),
              n = this.offsetAt(t.end)
            return this._content.substring(r, n)
          }
          return this._content
        }
        update(t, r) {
          ;(this._content = t.text), (this._version = r), (this._lineOffsets = void 0)
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            let t = [],
              r = this._content,
              n = !0
            for (let i = 0; i < r.length; i++) {
              n && (t.push(i), (n = !1))
              let s = r.charAt(i)
              ;(n =
                s === '\r' ||
                s ===
                  `
`),
                s === '\r' &&
                  i + 1 < r.length &&
                  r.charAt(i + 1) ===
                    `
` &&
                  i++
            }
            n && r.length > 0 && t.push(r.length), (this._lineOffsets = t)
          }
          return this._lineOffsets
        }
        positionAt(t) {
          t = Math.max(Math.min(t, this._content.length), 0)
          let r = this.getLineOffsets(),
            n = 0,
            i = r.length
          if (i === 0) return gr.create(0, t)
          for (; n < i; ) {
            let o = Math.floor((n + i) / 2)
            r[o] > t ? (i = o) : (n = o + 1)
          }
          let s = n - 1
          return gr.create(s, t - r[s])
        }
        offsetAt(t) {
          let r = this.getLineOffsets()
          if (t.line >= r.length) return this._content.length
          if (t.line < 0) return 0
          let n = r[t.line],
            i = t.line + 1 < r.length ? r[t.line + 1] : this._content.length
          return Math.max(Math.min(n + t.character, i), n)
        }
        get lineCount() {
          return this.getLineOffsets().length
        }
      }
      ;(function (e) {
        let t = Object.prototype.toString
        function r(m) {
          return typeof m < 'u'
        }
        a(r, 'defined'), (e.defined = r)
        function n(m) {
          return typeof m > 'u'
        }
        a(n, 'undefined'), (e.undefined = n)
        function i(m) {
          return m === !0 || m === !1
        }
        a(i, 'boolean'), (e.boolean = i)
        function s(m) {
          return t.call(m) === '[object String]'
        }
        a(s, 'string'), (e.string = s)
        function o(m) {
          return t.call(m) === '[object Number]'
        }
        a(o, 'number'), (e.number = o)
        function l(m, g, y) {
          return t.call(m) === '[object Number]' && g <= m && m <= y
        }
        a(l, 'numberRange'), (e.numberRange = l)
        function u(m) {
          return t.call(m) === '[object Number]' && -2147483648 <= m && m <= 2147483647
        }
        a(u, 'integer'), (e.integer = u)
        function h(m) {
          return t.call(m) === '[object Number]' && 0 <= m && m <= 2147483647
        }
        a(h, 'uinteger'), (e.uinteger = h)
        function f(m) {
          return t.call(m) === '[object Function]'
        }
        a(f, 'func'), (e.func = f)
        function d(m) {
          return m !== null && typeof m == 'object'
        }
        a(d, 'objectLiteral'), (e.objectLiteral = d)
        function p(m, g) {
          return Array.isArray(m) && m.every(g)
        }
        a(p, 'typedArray'), (e.typedArray = p)
      })(pt || (pt = {}))
    })
  var z1,
    W1,
    Ph,
    Bh,
    JL,
    tm,
    xS = x(() => {
      'use strict'
      ZL()
      Wa()
      ;(z1 = class {
        static {
          a(this, 'CstNodeBuilder')
        }
        constructor() {
          this.nodeStack = []
        }
        get current() {
          var t
          return (t = this.nodeStack[this.nodeStack.length - 1]) !== null && t !== void 0 ? t : this.rootNode
        }
        buildRootNode(t) {
          return (
            (this.rootNode = new tm(t)),
            (this.rootNode.root = this.rootNode),
            (this.nodeStack = [this.rootNode]),
            this.rootNode
          )
        }
        buildCompositeNode(t) {
          let r = new Bh()
          return (
            (r.grammarSource = t), (r.root = this.rootNode), this.current.content.push(r), this.nodeStack.push(r), r
          )
        }
        buildLeafNode(t, r) {
          let n = new Ph(t.startOffset, t.image.length, Pd(t), t.tokenType, !r)
          return (n.grammarSource = r), (n.root = this.rootNode), this.current.content.push(n), n
        }
        removeNode(t) {
          let r = t.container
          if (r) {
            let n = r.content.indexOf(t)
            n >= 0 && r.content.splice(n, 1)
          }
        }
        addHiddenNodes(t) {
          let r = []
          for (let s of t) {
            let o = new Ph(s.startOffset, s.image.length, Pd(s), s.tokenType, !0)
            ;(o.root = this.rootNode), r.push(o)
          }
          let n = this.current,
            i = !1
          if (n.content.length > 0) {
            n.content.push(...r)
            return
          }
          for (; n.container; ) {
            let s = n.container.content.indexOf(n)
            if (s > 0) {
              n.container.content.splice(s, 0, ...r), (i = !0)
              break
            }
            n = n.container
          }
          i || this.rootNode.content.unshift(...r)
        }
        construct(t) {
          let r = this.current
          typeof t.$type == 'string' && (this.current.astNode = t), (t.$cstNode = r)
          let n = this.nodeStack.pop()
          n?.content.length === 0 && this.removeNode(n)
        }
      }),
        (W1 = class {
          static {
            a(this, 'AbstractCstNode')
          }
          get parent() {
            return this.container
          }
          get feature() {
            return this.grammarSource
          }
          get hidden() {
            return !1
          }
          get astNode() {
            var t, r
            let n =
              typeof ((t = this._astNode) === null || t === void 0 ? void 0 : t.$type) == 'string'
                ? this._astNode
                : (r = this.container) === null || r === void 0
                  ? void 0
                  : r.astNode
            if (!n) throw new Error('This node has no associated AST element')
            return n
          }
          set astNode(t) {
            this._astNode = t
          }
          get element() {
            return this.astNode
          }
          get text() {
            return this.root.fullText.substring(this.offset, this.end)
          }
        }),
        (Ph = class extends W1 {
          static {
            a(this, 'LeafCstNodeImpl')
          }
          get offset() {
            return this._offset
          }
          get length() {
            return this._length
          }
          get end() {
            return this._offset + this._length
          }
          get hidden() {
            return this._hidden
          }
          get tokenType() {
            return this._tokenType
          }
          get range() {
            return this._range
          }
          constructor(t, r, n, i, s = !1) {
            super(),
              (this._hidden = s),
              (this._offset = t),
              (this._tokenType = i),
              (this._length = r),
              (this._range = n)
          }
        }),
        (Bh = class extends W1 {
          static {
            a(this, 'CompositeCstNodeImpl')
          }
          constructor() {
            super(...arguments), (this.content = new JL(this))
          }
          get children() {
            return this.content
          }
          get offset() {
            var t, r
            return (r = (t = this.firstNonHiddenNode) === null || t === void 0 ? void 0 : t.offset) !== null &&
              r !== void 0
              ? r
              : 0
          }
          get length() {
            return this.end - this.offset
          }
          get end() {
            var t, r
            return (r = (t = this.lastNonHiddenNode) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0
              ? r
              : 0
          }
          get range() {
            let t = this.firstNonHiddenNode,
              r = this.lastNonHiddenNode
            if (t && r) {
              if (this._rangeCache === void 0) {
                let { range: n } = t,
                  { range: i } = r
                this._rangeCache = { start: n.start, end: i.end.line < n.start.line ? n.start : i.end }
              }
              return this._rangeCache
            } else return { start: gr.create(0, 0), end: gr.create(0, 0) }
          }
          get firstNonHiddenNode() {
            for (let t of this.content) if (!t.hidden) return t
            return this.content[0]
          }
          get lastNonHiddenNode() {
            for (let t = this.content.length - 1; t >= 0; t--) {
              let r = this.content[t]
              if (!r.hidden) return r
            }
            return this.content[this.content.length - 1]
          }
        }),
        (JL = class e extends Array {
          static {
            a(this, 'CstNodeContainer')
          }
          constructor(t) {
            super(), (this.parent = t), Object.setPrototypeOf(this, e.prototype)
          }
          push(...t) {
            return this.addParents(t), super.push(...t)
          }
          unshift(...t) {
            return this.addParents(t), super.unshift(...t)
          }
          splice(t, r, ...n) {
            return this.addParents(n), super.splice(t, r, ...n)
          }
          addParents(t) {
            for (let r of t) r.container = this.parent
          }
        }),
        (tm = class extends Bh {
          static {
            a(this, 'RootCstNodeImpl')
          }
          get text() {
            return this._text.substring(this.offset, this.end)
          }
          get fullText() {
            return this._text
          }
          constructor(t) {
            super(), (this._text = ''), (this._text = t ?? '')
          }
        })
    })
  function tR(e) {
    return e.$type === bS
  }
  var bS,
    GJ,
    VJ,
    U1,
    j1,
    kS,
    em,
    q1,
    bAt,
    eR,
    H1 = x(() => {
      'use strict'
      jc()
      FZ()
      Po()
      qa()
      zi()
      xS()
      bS = Symbol('Datatype')
      a(tR, 'isDataTypeNode')
      ;(GJ = '\u200B'),
        (VJ = a((e) => (e.endsWith(GJ) ? e : e + GJ), 'withRuleSuffix')),
        (U1 = class {
          static {
            a(this, 'AbstractLangiumParser')
          }
          constructor(t) {
            ;(this._unorderedGroups = new Map()), (this.allRules = new Map()), (this.lexer = t.parser.Lexer)
            let r = this.lexer.definition,
              n = t.LanguageMetaData.mode === 'production'
            this.wrapper = new eR(
              r,
              Object.assign(Object.assign({}, t.parser.ParserConfig), {
                skipValidations: n,
                errorMessageProvider: t.parser.ParserErrorMessageProvider,
              }),
            )
          }
          alternatives(t, r) {
            this.wrapper.wrapOr(t, r)
          }
          optional(t, r) {
            this.wrapper.wrapOption(t, r)
          }
          many(t, r) {
            this.wrapper.wrapMany(t, r)
          }
          atLeastOne(t, r) {
            this.wrapper.wrapAtLeastOne(t, r)
          }
          getRule(t) {
            return this.allRules.get(t)
          }
          isRecording() {
            return this.wrapper.IS_RECORDING
          }
          get unorderedGroups() {
            return this._unorderedGroups
          }
          getRuleStack() {
            return this.wrapper.RULE_STACK
          }
          finalize() {
            this.wrapper.wrapSelfAnalysis()
          }
        }),
        (j1 = class extends U1 {
          static {
            a(this, 'LangiumParser')
          }
          get current() {
            return this.stack[this.stack.length - 1]
          }
          constructor(t) {
            super(t),
              (this.nodeBuilder = new z1()),
              (this.stack = []),
              (this.assignmentMap = new Map()),
              (this.linker = t.references.Linker),
              (this.converter = t.parser.ValueConverter),
              (this.astReflection = t.shared.AstReflection)
          }
          rule(t, r) {
            let n = this.computeRuleType(t),
              i = this.wrapper.DEFINE_RULE(VJ(t.name), this.startImplementation(n, r).bind(this))
            return this.allRules.set(t.name, i), t.entry && (this.mainRule = i), i
          }
          computeRuleType(t) {
            if (!t.fragment) {
              if (m1(t)) return bS
              {
                let r = Ep(t)
                return r ?? t.name
              }
            }
          }
          parse(t, r = {}) {
            this.nodeBuilder.buildRootNode(t)
            let n = (this.lexerResult = this.lexer.tokenize(t))
            this.wrapper.input = n.tokens
            let i = r.rule ? this.allRules.get(r.rule) : this.mainRule
            if (!i) throw new Error(r.rule ? `No rule found with name '${r.rule}'` : 'No main rule available.')
            let s = i.call(this.wrapper, {})
            return (
              this.nodeBuilder.addHiddenNodes(n.hidden),
              this.unorderedGroups.clear(),
              (this.lexerResult = void 0),
              { value: s, lexerErrors: n.errors, lexerReport: n.report, parserErrors: this.wrapper.errors }
            )
          }
          startImplementation(t, r) {
            return (n) => {
              let i = !this.isRecording() && t !== void 0
              if (i) {
                let o = { $type: t }
                this.stack.push(o), t === bS && (o.value = '')
              }
              let s
              try {
                s = r(n)
              } catch {
                s = void 0
              }
              return s === void 0 && i && (s = this.construct()), s
            }
          }
          extractHiddenTokens(t) {
            let r = this.lexerResult.hidden
            if (!r.length) return []
            let n = t.startOffset
            for (let i = 0; i < r.length; i++) if (r[i].startOffset > n) return r.splice(0, i)
            return r.splice(0, r.length)
          }
          consume(t, r, n) {
            let i = this.wrapper.wrapConsume(t, r)
            if (!this.isRecording() && this.isValidToken(i)) {
              let s = this.extractHiddenTokens(i)
              this.nodeBuilder.addHiddenNodes(s)
              let o = this.nodeBuilder.buildLeafNode(i, n),
                { assignment: l, isCrossRef: u } = this.getAssignment(n),
                h = this.current
              if (l) {
                let f = ca(n) ? i.image : this.converter.convert(i.image, o)
                this.assign(l.operator, l.feature, f, o, u)
              } else if (tR(h)) {
                let f = i.image
                ca(n) || (f = this.converter.convert(f, o).toString()), (h.value += f)
              }
            }
          }
          isValidToken(t) {
            return (
              !t.isInsertedInRecovery && !isNaN(t.startOffset) && typeof t.endOffset == 'number' && !isNaN(t.endOffset)
            )
          }
          subrule(t, r, n, i, s) {
            let o
            !this.isRecording() && !n && (o = this.nodeBuilder.buildCompositeNode(i))
            let l = this.wrapper.wrapSubrule(t, r, s)
            !this.isRecording() && o && o.length > 0 && this.performSubruleAssignment(l, i, o)
          }
          performSubruleAssignment(t, r, n) {
            let { assignment: i, isCrossRef: s } = this.getAssignment(r)
            if (i) this.assign(i.operator, i.feature, t, n, s)
            else if (!i) {
              let o = this.current
              if (tR(o)) o.value += t.toString()
              else if (typeof t == 'object' && t) {
                let u = this.assignWithoutOverride(t, o)
                this.stack.pop(), this.stack.push(u)
              }
            }
          }
          action(t, r) {
            if (!this.isRecording()) {
              let n = this.current
              if (r.feature && r.operator) {
                ;(n = this.construct()),
                  this.nodeBuilder.removeNode(n.$cstNode),
                  this.nodeBuilder.buildCompositeNode(r).content.push(n.$cstNode)
                let s = { $type: t }
                this.stack.push(s), this.assign(r.operator, r.feature, n, n.$cstNode, !1)
              } else n.$type = t
            }
          }
          construct() {
            if (this.isRecording()) return
            let t = this.current
            return (
              kT(t),
              this.nodeBuilder.construct(t),
              this.stack.pop(),
              tR(t) ? this.converter.convert(t.value, t.$cstNode) : (D6(this.astReflection, t), t)
            )
          }
          getAssignment(t) {
            if (!this.assignmentMap.has(t)) {
              let r = _h(t, Ua)
              this.assignmentMap.set(t, { assignment: r, isCrossRef: r ? Sh(r.terminal) : !1 })
            }
            return this.assignmentMap.get(t)
          }
          assign(t, r, n, i, s) {
            let o = this.current,
              l
            switch ((s && typeof n == 'string' ? (l = this.linker.buildReference(o, r, i, n)) : (l = n), t)) {
              case '=': {
                o[r] = l
                break
              }
              case '?=': {
                o[r] = !0
                break
              }
              case '+=':
                Array.isArray(o[r]) || (o[r] = []), o[r].push(l)
            }
          }
          assignWithoutOverride(t, r) {
            for (let [i, s] of Object.entries(r)) {
              let o = t[i]
              o === void 0 ? (t[i] = s) : Array.isArray(o) && Array.isArray(s) && (s.push(...o), (t[i] = s))
            }
            let n = t.$cstNode
            return n && ((n.astNode = void 0), (t.$cstNode = void 0)), t
          }
          get definitionErrors() {
            return this.wrapper.definitionErrors
          }
        }),
        (kS = class {
          static {
            a(this, 'AbstractParserErrorMessageProvider')
          }
          buildMismatchTokenMessage(t) {
            return Ll.buildMismatchTokenMessage(t)
          }
          buildNotAllInputParsedMessage(t) {
            return Ll.buildNotAllInputParsedMessage(t)
          }
          buildNoViableAltMessage(t) {
            return Ll.buildNoViableAltMessage(t)
          }
          buildEarlyExitMessage(t) {
            return Ll.buildEarlyExitMessage(t)
          }
        }),
        (em = class extends kS {
          static {
            a(this, 'LangiumParserErrorMessageProvider')
          }
          buildMismatchTokenMessage({ expected: t, actual: r }) {
            return `Expecting ${t.LABEL ? '`' + t.LABEL + '`' : t.name.endsWith(':KW') ? `keyword '${t.name.substring(0, t.name.length - 3)}'` : `token of type '${t.name}'`} but found \`${r.image}\`.`
          }
          buildNotAllInputParsedMessage({ firstRedundant: t }) {
            return `Expecting end of file but found \`${t.image}\`.`
          }
        }),
        (q1 = class extends U1 {
          static {
            a(this, 'LangiumCompletionParser')
          }
          constructor() {
            super(...arguments),
              (this.tokens = []),
              (this.elementStack = []),
              (this.lastElementStack = []),
              (this.nextTokenIndex = 0),
              (this.stackSize = 0)
          }
          action() {}
          construct() {}
          parse(t) {
            this.resetState()
            let r = this.lexer.tokenize(t, { mode: 'partial' })
            return (
              (this.tokens = r.tokens),
              (this.wrapper.input = [...this.tokens]),
              this.mainRule.call(this.wrapper, {}),
              this.unorderedGroups.clear(),
              { tokens: this.tokens, elementStack: [...this.lastElementStack], tokenIndex: this.nextTokenIndex }
            )
          }
          rule(t, r) {
            let n = this.wrapper.DEFINE_RULE(VJ(t.name), this.startImplementation(r).bind(this))
            return this.allRules.set(t.name, n), t.entry && (this.mainRule = n), n
          }
          resetState() {
            ;(this.elementStack = []), (this.lastElementStack = []), (this.nextTokenIndex = 0), (this.stackSize = 0)
          }
          startImplementation(t) {
            return (r) => {
              let n = this.keepStackSize()
              try {
                t(r)
              } finally {
                this.resetStackSize(n)
              }
            }
          }
          removeUnexpectedElements() {
            this.elementStack.splice(this.stackSize)
          }
          keepStackSize() {
            let t = this.elementStack.length
            return (this.stackSize = t), t
          }
          resetStackSize(t) {
            this.removeUnexpectedElements(), (this.stackSize = t)
          }
          consume(t, r, n) {
            this.wrapper.wrapConsume(t, r),
              this.isRecording() ||
                ((this.lastElementStack = [...this.elementStack, n]), (this.nextTokenIndex = this.currIdx + 1))
          }
          subrule(t, r, n, i, s) {
            this.before(i), this.wrapper.wrapSubrule(t, r, s), this.after(i)
          }
          before(t) {
            this.isRecording() || this.elementStack.push(t)
          }
          after(t) {
            if (!this.isRecording()) {
              let r = this.elementStack.lastIndexOf(t)
              r >= 0 && this.elementStack.splice(r)
            }
          }
          get currIdx() {
            return this.wrapper.currIdx
          }
        }),
        (bAt = {
          recoveryEnabled: !0,
          nodeLocationTracking: 'full',
          skipValidations: !0,
          errorMessageProvider: new em(),
        }),
        (eR = class extends P1 {
          static {
            a(this, 'ChevrotainWrapper')
          }
          constructor(t, r) {
            let n = r && 'maxLookahead' in r
            super(
              t,
              Object.assign(
                Object.assign(Object.assign({}, bAt), {
                  lookaheadStrategy: n
                    ? new Rl({ maxLookahead: r.maxLookahead })
                    : new G1({ logging: r.skipValidations ? () => {} : void 0 }),
                }),
                r,
              ),
            )
          }
          get IS_RECORDING() {
            return this.RECORDING_PHASE
          }
          DEFINE_RULE(t, r) {
            return this.RULE(t, r)
          }
          wrapSelfAnalysis() {
            this.performSelfAnalysis()
          }
          wrapConsume(t, r) {
            return this.consume(t, r)
          }
          wrapSubrule(t, r, n) {
            return this.subrule(t, r, { ARGS: [n] })
          }
          wrapOr(t, r) {
            this.or(t, r)
          }
          wrapOption(t, r) {
            this.option(t, r)
          }
          wrapMany(t, r) {
            this.many(t, r)
          }
          wrapAtLeastOne(t, r) {
            this.atLeastOne(t, r)
          }
        })
    })
  function Y1(e, t, r) {
    return kAt({ parser: t, tokens: r, ruleNames: new Map() }, e), t
  }
  function kAt(e, t) {
    let r = d1(t, !1),
      n = kr(t.rules)
        .filter(Si)
        .filter((i) => r.has(i))
    for (let i of n) {
      let s = Object.assign(Object.assign({}, e), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 })
      e.parser.rule(i, Fh(s, i.definition))
    }
  }
  function Fh(e, t, r = !1) {
    let n
    if (ca(t)) n = vAt(e, t)
    else if (Sl(t)) n = TAt(e, t)
    else if (Ua(t)) n = Fh(e, t.terminal)
    else if (Sh(t)) n = zJ(e, t)
    else if (ja(t)) n = SAt(e, t)
    else if (yT(t)) n = CAt(e, t)
    else if (bT(t)) n = wAt(e, t)
    else if (zc(t)) n = EAt(e, t)
    else if (S6(t)) {
      let i = e.consume++
      n = a(() => e.parser.consume(i, Ps, t), 'method')
    } else throw new kh(t.$cstNode, `Unexpected element type: ${t.$type}`)
    return WJ(e, r ? void 0 : TS(t), n, t.cardinality)
  }
  function TAt(e, t) {
    let r = g1(t)
    return () => e.parser.action(r, t)
  }
  function SAt(e, t) {
    let r = t.rule.ref
    if (Si(r)) {
      let n = e.subrule++,
        i = r.fragment,
        s = t.arguments.length > 0 ? _At(r, t.arguments) : () => ({})
      return (o) => e.parser.subrule(n, UJ(e, r), i, t, s(o))
    } else if (Ms(r)) {
      let n = e.consume++,
        i = rR(e, r.name)
      return () => e.parser.consume(n, i, t)
    } else if (r) Oo(r)
    else throw new kh(t.$cstNode, `Undefined rule: ${t.rule.$refText}`)
  }
  function _At(e, t) {
    let r = t.map((n) => Dl(n.value))
    return (n) => {
      let i = {}
      for (let s = 0; s < r.length; s++) {
        let o = e.parameters[s],
          l = r[s]
        i[o.name] = l(n)
      }
      return i
    }
  }
  function Dl(e) {
    if (m6(e)) {
      let t = Dl(e.left),
        r = Dl(e.right)
      return (n) => t(n) || r(n)
    } else if (p6(e)) {
      let t = Dl(e.left),
        r = Dl(e.right)
      return (n) => t(n) && r(n)
    } else if (g6(e)) {
      let t = Dl(e.value)
      return (r) => !t(r)
    } else if (y6(e)) {
      let t = e.parameter.ref.name
      return (r) => r !== void 0 && r[t] === !0
    } else if (d6(e)) {
      let t = !!e.true
      return () => t
    }
    Oo(e)
  }
  function CAt(e, t) {
    if (t.elements.length === 1) return Fh(e, t.elements[0])
    {
      let r = []
      for (let i of t.elements) {
        let s = { ALT: Fh(e, i, !0) },
          o = TS(i)
        o && (s.GATE = Dl(o)), r.push(s)
      }
      let n = e.or++
      return (i) =>
        e.parser.alternatives(
          n,
          r.map((s) => {
            let o = { ALT: a(() => s.ALT(i), 'ALT') },
              l = s.GATE
            return l && (o.GATE = () => l(i)), o
          }),
        )
    }
  }
  function wAt(e, t) {
    if (t.elements.length === 1) return Fh(e, t.elements[0])
    let r = []
    for (let l of t.elements) {
      let u = { ALT: Fh(e, l, !0) },
        h = TS(l)
      h && (u.GATE = Dl(h)), r.push(u)
    }
    let n = e.or++,
      i = a((l, u) => {
        let h = u.getRuleStack().join('-')
        return `uGroup_${l}_${h}`
      }, 'idFunc'),
      s = a(
        (l) =>
          e.parser.alternatives(
            n,
            r.map((u, h) => {
              let f = { ALT: a(() => !0, 'ALT') },
                d = e.parser
              f.ALT = () => {
                if ((u.ALT(l), !d.isRecording())) {
                  let m = i(n, d)
                  d.unorderedGroups.get(m) || d.unorderedGroups.set(m, [])
                  let g = d.unorderedGroups.get(m)
                  typeof g?.[h] > 'u' && (g[h] = !0)
                }
              }
              let p = u.GATE
              return (
                p
                  ? (f.GATE = () => p(l))
                  : (f.GATE = () => {
                      let m = d.unorderedGroups.get(i(n, d))
                      return !m?.[h]
                    }),
                f
              )
            }),
          ),
        'alternatives',
      ),
      o = WJ(e, TS(t), s, '*')
    return (l) => {
      o(l), e.parser.isRecording() || e.parser.unorderedGroups.delete(i(n, e.parser))
    }
  }
  function EAt(e, t) {
    let r = t.elements.map((n) => Fh(e, n))
    return (n) => r.forEach((i) => i(n))
  }
  function TS(e) {
    if (zc(e)) return e.guardCondition
  }
  function zJ(e, t, r = t.terminal) {
    if (r)
      if (ja(r) && Si(r.rule.ref)) {
        let n = r.rule.ref,
          i = e.subrule++
        return (s) => e.parser.subrule(i, UJ(e, n), !1, t, s)
      } else if (ja(r) && Ms(r.rule.ref)) {
        let n = e.consume++,
          i = rR(e, r.rule.ref.name)
        return () => e.parser.consume(n, i, t)
      } else if (ca(r)) {
        let n = e.consume++,
          i = rR(e, r.value)
        return () => e.parser.consume(n, i, t)
      } else throw new Error('Could not build cross reference parser')
    else {
      if (!t.type.ref) throw new Error('Could not resolve reference to type: ' + t.type.$refText)
      let n = wT(t.type.ref),
        i = n?.terminal
      if (!i) throw new Error('Could not find name assignment for type: ' + g1(t.type.ref))
      return zJ(e, t, i)
    }
  }
  function vAt(e, t) {
    let r = e.consume++,
      n = e.tokens[t.value]
    if (!n) throw new Error('Could not find token for keyword: ' + t.value)
    return () => e.parser.consume(r, n, t)
  }
  function WJ(e, t, r, n) {
    let i = t && Dl(t)
    if (!n)
      if (i) {
        let s = e.or++
        return (o) =>
          e.parser.alternatives(s, [
            { ALT: a(() => r(o), 'ALT'), GATE: a(() => i(o), 'GATE') },
            { ALT: uS(), GATE: a(() => !i(o), 'GATE') },
          ])
      } else return r
    if (n === '*') {
      let s = e.many++
      return (o) => e.parser.many(s, { DEF: a(() => r(o), 'DEF'), GATE: i ? () => i(o) : void 0 })
    } else if (n === '+') {
      let s = e.many++
      if (i) {
        let o = e.or++
        return (l) =>
          e.parser.alternatives(o, [
            { ALT: a(() => e.parser.atLeastOne(s, { DEF: a(() => r(l), 'DEF') }), 'ALT'), GATE: a(() => i(l), 'GATE') },
            { ALT: uS(), GATE: a(() => !i(l), 'GATE') },
          ])
      } else return (o) => e.parser.atLeastOne(s, { DEF: a(() => r(o), 'DEF') })
    } else if (n === '?') {
      let s = e.optional++
      return (o) => e.parser.optional(s, { DEF: a(() => r(o), 'DEF'), GATE: i ? () => i(o) : void 0 })
    } else Oo(n)
  }
  function UJ(e, t) {
    let r = AAt(e, t),
      n = e.parser.getRule(r)
    if (!n) throw new Error(`Rule "${r}" not found."`)
    return n
  }
  function AAt(e, t) {
    if (Si(t)) return t.name
    if (e.ruleNames.has(t)) return e.ruleNames.get(t)
    {
      let r = t,
        n = r.$container,
        i = t.$type
      for (; !Si(n); )
        (zc(n) || yT(n) || bT(n)) && (i = n.elements.indexOf(r).toString() + ':' + i), (r = n), (n = n.$container)
      return (i = n.name + ':' + i), e.ruleNames.set(t, i), i
    }
  }
  function rR(e, t) {
    let r = e.tokens[t]
    if (!r) throw new Error(`Token "${t}" not found."`)
    return r
  }
  var SS = x(() => {
    'use strict'
    jc()
    Po()
    fT()
    ms()
    qa()
    a(Y1, 'createParser')
    a(kAt, 'buildRules')
    a(Fh, 'buildElement')
    a(TAt, 'buildAction')
    a(SAt, 'buildRuleCall')
    a(_At, 'buildRuleCallPredicate')
    a(Dl, 'buildPredicate')
    a(CAt, 'buildAlternatives')
    a(wAt, 'buildUnorderedGroup')
    a(EAt, 'buildGroup')
    a(TS, 'getGuardCondition')
    a(zJ, 'buildCrossReference')
    a(vAt, 'buildKeyword')
    a(WJ, 'wrap')
    a(UJ, 'getRule')
    a(AAt, 'getRuleName')
    a(rR, 'getToken')
  })
  function nR(e) {
    let t = e.Grammar,
      r = e.parser.Lexer,
      n = new q1(e)
    return Y1(t, n, r.definition), n.finalize(), n
  }
  var iR = x(() => {
    'use strict'
    H1()
    SS()
    a(nR, 'createCompletionParser')
  })
  function sR(e) {
    let t = jJ(e)
    return t.finalize(), t
  }
  function jJ(e) {
    let t = e.Grammar,
      r = e.parser.Lexer,
      n = new j1(e)
    return Y1(t, n, r.definition)
  }
  var aR = x(() => {
    'use strict'
    H1()
    SS()
    a(sR, 'createLangiumParser')
    a(jJ, 'prepareLangiumParser')
  })
  var Nl,
    _S = x(() => {
      'use strict'
      jc()
      Po()
      zi()
      qa()
      wp()
      ms()
      Nl = class {
        static {
          a(this, 'DefaultTokenBuilder')
        }
        constructor() {
          this.diagnostics = []
        }
        buildTokens(t, r) {
          let n = kr(d1(t, !1)),
            i = this.buildTerminalTokens(n),
            s = this.buildKeywordTokens(n, i, r)
          return (
            i.forEach((o) => {
              let l = o.PATTERN
              typeof l == 'object' && l && 'test' in l && Cp(l) ? s.unshift(o) : s.push(o)
            }),
            s
          )
        }
        flushLexingReport(t) {
          return { diagnostics: this.popDiagnostics() }
        }
        popDiagnostics() {
          let t = [...this.diagnostics]
          return (this.diagnostics = []), t
        }
        buildTerminalTokens(t) {
          return t
            .filter(Ms)
            .filter((r) => !r.fragment)
            .map((r) => this.buildTerminalToken(r))
            .toArray()
        }
        buildTerminalToken(t) {
          let r = vp(t),
            n = this.requiresCustomPattern(r) ? this.regexPatternFunction(r) : r,
            i = { name: t.name, PATTERN: n }
          return (
            typeof n == 'function' && (i.LINE_BREAKS = !0), t.hidden && (i.GROUP = Cp(r) ? en.SKIPPED : 'hidden'), i
          )
        }
        requiresCustomPattern(t) {
          return t.flags.includes('u') || t.flags.includes('s')
            ? !0
            : !!(t.source.includes('?<=') || t.source.includes('?<!'))
        }
        regexPatternFunction(t) {
          let r = new RegExp(t, t.flags + 'y')
          return (n, i) => ((r.lastIndex = i), r.exec(n))
        }
        buildKeywordTokens(t, r, n) {
          return t
            .filter(Si)
            .flatMap((i) => Bo(i).filter(ca))
            .distinct((i) => i.value)
            .toArray()
            .sort((i, s) => s.value.length - i.value.length)
            .map((i) => this.buildKeywordToken(i, r, !!n?.caseInsensitive))
        }
        buildKeywordToken(t, r, n) {
          let i = this.buildKeywordPattern(t, n),
            s = { name: t.value, PATTERN: i, LONGER_ALT: this.findLongerAlt(t, r) }
          return typeof i == 'function' && (s.LINE_BREAKS = !0), s
        }
        buildKeywordPattern(t, r) {
          return r ? new RegExp(F6(t.value)) : t.value
        }
        findLongerAlt(t, r) {
          return r.reduce((n, i) => {
            let s = i?.PATTERN
            return s?.source && $6('^' + s.source + '$', t.value) && n.push(i), n
          }, [])
        }
      }
    })
  var $h,
    Go,
    oR = x(() => {
      'use strict'
      Po()
      qa()
      $h = class {
        static {
          a(this, 'DefaultValueConverter')
        }
        convert(t, r) {
          let n = r.grammarSource
          if ((Sh(n) && (n = z6(n)), ja(n))) {
            let i = n.rule.ref
            if (!i) throw new Error('This cst node was not parsed by a rule.')
            return this.runConverter(i, t, r)
          }
          return t
        }
        runConverter(t, r, n) {
          var i
          switch (t.name.toUpperCase()) {
            case 'INT':
              return Go.convertInt(r)
            case 'STRING':
              return Go.convertString(r)
            case 'ID':
              return Go.convertID(r)
          }
          switch ((i = X6(t)) === null || i === void 0 ? void 0 : i.toLowerCase()) {
            case 'number':
              return Go.convertNumber(r)
            case 'boolean':
              return Go.convertBoolean(r)
            case 'bigint':
              return Go.convertBigint(r)
            case 'date':
              return Go.convertDate(r)
            default:
              return r
          }
        }
      }
      ;(function (e) {
        function t(h) {
          let f = ''
          for (let d = 1; d < h.length - 1; d++) {
            let p = h.charAt(d)
            if (p === '\\') {
              let m = h.charAt(++d)
              f += r(m)
            } else f += p
          }
          return f
        }
        a(t, 'convertString'), (e.convertString = t)
        function r(h) {
          switch (h) {
            case 'b':
              return '\b'
            case 'f':
              return '\f'
            case 'n':
              return `
`
            case 'r':
              return '\r'
            case 't':
              return '	'
            case 'v':
              return '\v'
            case '0':
              return '\0'
            default:
              return h
          }
        }
        a(r, 'convertEscapeCharacter')
        function n(h) {
          return h.charAt(0) === '^' ? h.substring(1) : h
        }
        a(n, 'convertID'), (e.convertID = n)
        function i(h) {
          return parseInt(h)
        }
        a(i, 'convertInt'), (e.convertInt = i)
        function s(h) {
          return BigInt(h)
        }
        a(s, 'convertBigint'), (e.convertBigint = s)
        function o(h) {
          return new Date(h)
        }
        a(o, 'convertDate'), (e.convertDate = o)
        function l(h) {
          return Number(h)
        }
        a(l, 'convertNumber'), (e.convertNumber = l)
        function u(h) {
          return h.toLowerCase() === 'true'
        }
        a(u, 'convertBoolean'), (e.convertBoolean = u)
      })(Go || (Go = {}))
    })
  var hR = Ja((uR) => {
    'use strict'
    Object.defineProperty(uR, '__esModule', { value: !0 })
    var lR
    function cR() {
      if (lR === void 0) throw new Error('No runtime abstraction layer installed')
      return lR
    }
    a(cR, 'RAL')
    ;(function (e) {
      function t(r) {
        if (r === void 0) throw new Error('No runtime abstraction layer provided')
        lR = r
      }
      a(t, 'install'), (e.install = t)
    })(cR || (cR = {}))
    uR.default = cR
  })
  var YJ = Ja((Ci) => {
    'use strict'
    Object.defineProperty(Ci, '__esModule', { value: !0 })
    Ci.stringArray = Ci.array = Ci.func = Ci.error = Ci.number = Ci.string = Ci.boolean = void 0
    function LAt(e) {
      return e === !0 || e === !1
    }
    a(LAt, 'boolean')
    Ci.boolean = LAt
    function qJ(e) {
      return typeof e == 'string' || e instanceof String
    }
    a(qJ, 'string')
    Ci.string = qJ
    function RAt(e) {
      return typeof e == 'number' || e instanceof Number
    }
    a(RAt, 'number')
    Ci.number = RAt
    function DAt(e) {
      return e instanceof Error
    }
    a(DAt, 'error')
    Ci.error = DAt
    function NAt(e) {
      return typeof e == 'function'
    }
    a(NAt, 'func')
    Ci.func = NAt
    function HJ(e) {
      return Array.isArray(e)
    }
    a(HJ, 'array')
    Ci.array = HJ
    function IAt(e) {
      return HJ(e) && e.every((t) => qJ(t))
    }
    a(IAt, 'stringArray')
    Ci.stringArray = IAt
  })
  var dR = Ja((rm) => {
    'use strict'
    Object.defineProperty(rm, '__esModule', { value: !0 })
    rm.Emitter = rm.Event = void 0
    var MAt = hR(),
      XJ
    ;(function (e) {
      let t = { dispose() {} }
      e.None = function () {
        return t
      }
    })(XJ || (rm.Event = XJ = {}))
    var fR = class {
        static {
          a(this, 'CallbackList')
        }
        add(t, r = null, n) {
          this._callbacks || ((this._callbacks = []), (this._contexts = [])),
            this._callbacks.push(t),
            this._contexts.push(r),
            Array.isArray(n) && n.push({ dispose: a(() => this.remove(t, r), 'dispose') })
        }
        remove(t, r = null) {
          if (!this._callbacks) return
          let n = !1
          for (let i = 0, s = this._callbacks.length; i < s; i++)
            if (this._callbacks[i] === t)
              if (this._contexts[i] === r) {
                this._callbacks.splice(i, 1), this._contexts.splice(i, 1)
                return
              } else n = !0
          if (n) throw new Error('When adding a listener with a context, you should remove it with the same context')
        }
        invoke(...t) {
          if (!this._callbacks) return []
          let r = [],
            n = this._callbacks.slice(0),
            i = this._contexts.slice(0)
          for (let s = 0, o = n.length; s < o; s++)
            try {
              r.push(n[s].apply(i[s], t))
            } catch (l) {
              ;(0, MAt.default)().console.error(l)
            }
          return r
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0
        }
        dispose() {
          ;(this._callbacks = void 0), (this._contexts = void 0)
        }
      },
      CS = class e {
        static {
          a(this, 'Emitter')
        }
        constructor(t) {
          this._options = t
        }
        get event() {
          return (
            this._event ||
              (this._event = (t, r, n) => {
                this._callbacks || (this._callbacks = new fR()),
                  this._options &&
                    this._options.onFirstListenerAdd &&
                    this._callbacks.isEmpty() &&
                    this._options.onFirstListenerAdd(this),
                  this._callbacks.add(t, r)
                let i = {
                  dispose: a(() => {
                    this._callbacks &&
                      (this._callbacks.remove(t, r),
                      (i.dispose = e._noop),
                      this._options &&
                        this._options.onLastListenerRemove &&
                        this._callbacks.isEmpty() &&
                        this._options.onLastListenerRemove(this))
                  }, 'dispose'),
                }
                return Array.isArray(n) && n.push(i), i
              }),
            this._event
          )
        }
        fire(t) {
          this._callbacks && this._callbacks.invoke.call(this._callbacks, t)
        }
        dispose() {
          this._callbacks && (this._callbacks.dispose(), (this._callbacks = void 0))
        }
      }
    rm.Emitter = CS
    CS._noop = function () {}
  })
  var KJ = Ja((nm) => {
    'use strict'
    Object.defineProperty(nm, '__esModule', { value: !0 })
    nm.CancellationTokenSource = nm.CancellationToken = void 0
    var OAt = hR(),
      PAt = YJ(),
      pR = dR(),
      wS
    ;(function (e) {
      ;(e.None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: pR.Event.None })),
        (e.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: pR.Event.None }))
      function t(r) {
        let n = r
        return (
          n &&
          (n === e.None || n === e.Cancelled || (PAt.boolean(n.isCancellationRequested) && !!n.onCancellationRequested))
        )
      }
      a(t, 'is'), (e.is = t)
    })(wS || (nm.CancellationToken = wS = {}))
    var BAt = Object.freeze(function (e, t) {
        let r = (0, OAt.default)().timer.setTimeout(e.bind(t), 0)
        return {
          dispose() {
            r.dispose()
          },
        }
      }),
      ES = class {
        static {
          a(this, 'MutableToken')
        }
        constructor() {
          this._isCancelled = !1
        }
        cancel() {
          this._isCancelled || ((this._isCancelled = !0), this._emitter && (this._emitter.fire(void 0), this.dispose()))
        }
        get isCancellationRequested() {
          return this._isCancelled
        }
        get onCancellationRequested() {
          return this._isCancelled ? BAt : (this._emitter || (this._emitter = new pR.Emitter()), this._emitter.event)
        }
        dispose() {
          this._emitter && (this._emitter.dispose(), (this._emitter = void 0))
        }
      },
      mR = class {
        static {
          a(this, 'CancellationTokenSource')
        }
        get token() {
          return this._token || (this._token = new ES()), this._token
        }
        cancel() {
          this._token ? this._token.cancel() : (this._token = wS.Cancelled)
        }
        dispose() {
          this._token ? this._token instanceof ES && this._token.dispose() : (this._token = wS.None)
        }
      }
    nm.CancellationTokenSource = mR
  })
  var Ve = {}
  var ha = x(() => {
    'use strict'
    qe(Ve, Ss(KJ(), 1))
  })
  function gR() {
    return new Promise((e) => {
      typeof setImmediate > 'u' ? setTimeout(e, 0) : setImmediate(e)
    })
  }
  function AS() {
    return (vS = performance.now()), new Ve.CancellationTokenSource()
  }
  function ZJ(e) {
    QJ = e
  }
  function zo(e) {
    return e === Vo
  }
  async function Sn(e) {
    if (e === Ve.CancellationToken.None) return
    let t = performance.now()
    if ((t - vS >= QJ && ((vS = t), await gR(), (vS = performance.now())), e.isCancellationRequested)) throw Vo
  }
  var vS,
    QJ,
    Vo,
    Hi,
    fa = x(() => {
      'use strict'
      ha()
      a(gR, 'delayNextTick')
      ;(vS = 0), (QJ = 10)
      a(AS, 'startCancelableOperation')
      a(ZJ, 'setInterruptionPeriod')
      Vo = Symbol('OperationCancelled')
      a(zo, 'isOperationCancelled')
      a(Sn, 'interruptAndCheck')
      Hi = class {
        static {
          a(this, 'Deferred')
        }
        constructor() {
          this.promise = new Promise((t, r) => {
            ;(this.resolve = (n) => (t(n), this)), (this.reject = (n) => (r(n), this))
          })
        }
      }
    })
  function yR(e, t) {
    if (e.length <= 1) return e
    let r = (e.length / 2) | 0,
      n = e.slice(0, r),
      i = e.slice(r)
    yR(n, t), yR(i, t)
    let s = 0,
      o = 0,
      l = 0
    for (; s < n.length && o < i.length; ) t(n[s], i[o]) <= 0 ? (e[l++] = n[s++]) : (e[l++] = i[o++])
    for (; s < n.length; ) e[l++] = n[s++]
    for (; o < i.length; ) e[l++] = i[o++]
    return e
  }
  function JJ(e, t, r = 0) {
    let n = t ? [r] : []
    for (let i = 0; i < e.length; i++) {
      let s = e.charCodeAt(i)
      ttt(s) && (s === 13 && i + 1 < e.length && e.charCodeAt(i + 1) === 10 && i++, n.push(r + i + 1))
    }
    return n
  }
  function ttt(e) {
    return e === 13 || e === 10
  }
  function ett(e) {
    let t = e.start,
      r = e.end
    return t.line > r.line || (t.line === r.line && t.character > r.character) ? { start: r, end: t } : e
  }
  function FAt(e) {
    let t = ett(e.range)
    return t !== e.range ? { newText: e.newText, range: t } : e
  }
  var LS,
    im,
    rtt = x(() => {
      'use strict'
      LS = class e {
        static {
          a(this, 'FullTextDocument')
        }
        constructor(t, r, n, i) {
          ;(this._uri = t),
            (this._languageId = r),
            (this._version = n),
            (this._content = i),
            (this._lineOffsets = void 0)
        }
        get uri() {
          return this._uri
        }
        get languageId() {
          return this._languageId
        }
        get version() {
          return this._version
        }
        getText(t) {
          if (t) {
            let r = this.offsetAt(t.start),
              n = this.offsetAt(t.end)
            return this._content.substring(r, n)
          }
          return this._content
        }
        update(t, r) {
          for (let n of t)
            if (e.isIncremental(n)) {
              let i = ett(n.range),
                s = this.offsetAt(i.start),
                o = this.offsetAt(i.end)
              this._content = this._content.substring(0, s) + n.text + this._content.substring(o, this._content.length)
              let l = Math.max(i.start.line, 0),
                u = Math.max(i.end.line, 0),
                h = this._lineOffsets,
                f = JJ(n.text, !1, s)
              if (u - l === f.length) for (let p = 0, m = f.length; p < m; p++) h[p + l + 1] = f[p]
              else
                f.length < 1e4
                  ? h.splice(l + 1, u - l, ...f)
                  : (this._lineOffsets = h = h.slice(0, l + 1).concat(f, h.slice(u + 1)))
              let d = n.text.length - (o - s)
              if (d !== 0) for (let p = l + 1 + f.length, m = h.length; p < m; p++) h[p] = h[p] + d
            } else if (e.isFull(n)) (this._content = n.text), (this._lineOffsets = void 0)
            else throw new Error('Unknown change event received')
          this._version = r
        }
        getLineOffsets() {
          return this._lineOffsets === void 0 && (this._lineOffsets = JJ(this._content, !0)), this._lineOffsets
        }
        positionAt(t) {
          t = Math.max(Math.min(t, this._content.length), 0)
          let r = this.getLineOffsets(),
            n = 0,
            i = r.length
          if (i === 0) return { line: 0, character: t }
          for (; n < i; ) {
            let o = Math.floor((n + i) / 2)
            r[o] > t ? (i = o) : (n = o + 1)
          }
          let s = n - 1
          return (t = this.ensureBeforeEOL(t, r[s])), { line: s, character: t - r[s] }
        }
        offsetAt(t) {
          let r = this.getLineOffsets()
          if (t.line >= r.length) return this._content.length
          if (t.line < 0) return 0
          let n = r[t.line]
          if (t.character <= 0) return n
          let i = t.line + 1 < r.length ? r[t.line + 1] : this._content.length,
            s = Math.min(n + t.character, i)
          return this.ensureBeforeEOL(s, n)
        }
        ensureBeforeEOL(t, r) {
          for (; t > r && ttt(this._content.charCodeAt(t - 1)); ) t--
          return t
        }
        get lineCount() {
          return this.getLineOffsets().length
        }
        static isIncremental(t) {
          let r = t
          return (
            r != null &&
            typeof r.text == 'string' &&
            r.range !== void 0 &&
            (r.rangeLength === void 0 || typeof r.rangeLength == 'number')
          )
        }
        static isFull(t) {
          let r = t
          return r != null && typeof r.text == 'string' && r.range === void 0 && r.rangeLength === void 0
        }
      }
      ;(function (e) {
        function t(i, s, o, l) {
          return new LS(i, s, o, l)
        }
        a(t, 'create'), (e.create = t)
        function r(i, s, o) {
          if (i instanceof LS) return i.update(s, o), i
          throw new Error('TextDocument.update: document must be created by TextDocument.create')
        }
        a(r, 'update'), (e.update = r)
        function n(i, s) {
          let o = i.getText(),
            l = yR(s.map(FAt), (f, d) => {
              let p = f.range.start.line - d.range.start.line
              return p === 0 ? f.range.start.character - d.range.start.character : p
            }),
            u = 0,
            h = []
          for (let f of l) {
            let d = i.offsetAt(f.range.start)
            if (d < u) throw new Error('Overlapping edit')
            d > u && h.push(o.substring(u, d)), f.newText.length && h.push(f.newText), (u = i.offsetAt(f.range.end))
          }
          return h.push(o.substr(u)), h.join('')
        }
        a(n, 'applyEdits'), (e.applyEdits = n)
      })(im || (im = {}))
      a(yR, 'mergeSort')
      a(JJ, 'computeLineOffsets')
      a(ttt, 'isEOL')
      a(ett, 'getWellformedRange')
      a(FAt, 'getWellformedEdit')
    })
  var ntt,
    Yi,
    sm,
    xR = x(() => {
      'use strict'
      ;(() => {
        'use strict'
        var e = {
            470: (i) => {
              function s(u) {
                if (typeof u != 'string') throw new TypeError('Path must be a string. Received ' + JSON.stringify(u))
              }
              a(s, 'e')
              function o(u, h) {
                for (var f, d = '', p = 0, m = -1, g = 0, y = 0; y <= u.length; ++y) {
                  if (y < u.length) f = u.charCodeAt(y)
                  else {
                    if (f === 47) break
                    f = 47
                  }
                  if (f === 47) {
                    if (!(m === y - 1 || g === 1))
                      if (m !== y - 1 && g === 2) {
                        if (
                          d.length < 2 ||
                          p !== 2 ||
                          d.charCodeAt(d.length - 1) !== 46 ||
                          d.charCodeAt(d.length - 2) !== 46
                        ) {
                          if (d.length > 2) {
                            var b = d.lastIndexOf('/')
                            if (b !== d.length - 1) {
                              b === -1
                                ? ((d = ''), (p = 0))
                                : (p = (d = d.slice(0, b)).length - 1 - d.lastIndexOf('/')),
                                (m = y),
                                (g = 0)
                              continue
                            }
                          } else if (d.length === 2 || d.length === 1) {
                            ;(d = ''), (p = 0), (m = y), (g = 0)
                            continue
                          }
                        }
                        h && (d.length > 0 ? (d += '/..') : (d = '..'), (p = 2))
                      } else d.length > 0 ? (d += '/' + u.slice(m + 1, y)) : (d = u.slice(m + 1, y)), (p = y - m - 1)
                    ;(m = y), (g = 0)
                  } else f === 46 && g !== -1 ? ++g : (g = -1)
                }
                return d
              }
              a(o, 'r')
              var l = {
                resolve: a(function () {
                  for (var u, h = '', f = !1, d = arguments.length - 1; d >= -1 && !f; d--) {
                    var p
                    d >= 0 ? (p = arguments[d]) : (u === void 0 && (u = process.cwd()), (p = u)),
                      s(p),
                      p.length !== 0 && ((h = p + '/' + h), (f = p.charCodeAt(0) === 47))
                  }
                  return (h = o(h, !f)), f ? (h.length > 0 ? '/' + h : '/') : h.length > 0 ? h : '.'
                }, 'resolve'),
                normalize: a(function (u) {
                  if ((s(u), u.length === 0)) return '.'
                  var h = u.charCodeAt(0) === 47,
                    f = u.charCodeAt(u.length - 1) === 47
                  return (u = o(u, !h)).length !== 0 || h || (u = '.'), u.length > 0 && f && (u += '/'), h ? '/' + u : u
                }, 'normalize'),
                isAbsolute: a(function (u) {
                  return s(u), u.length > 0 && u.charCodeAt(0) === 47
                }, 'isAbsolute'),
                join: a(function () {
                  if (arguments.length === 0) return '.'
                  for (var u, h = 0; h < arguments.length; ++h) {
                    var f = arguments[h]
                    s(f), f.length > 0 && (u === void 0 ? (u = f) : (u += '/' + f))
                  }
                  return u === void 0 ? '.' : l.normalize(u)
                }, 'join'),
                relative: a(function (u, h) {
                  if ((s(u), s(h), u === h || (u = l.resolve(u)) === (h = l.resolve(h)))) return ''
                  for (var f = 1; f < u.length && u.charCodeAt(f) === 47; ++f);
                  for (var d = u.length, p = d - f, m = 1; m < h.length && h.charCodeAt(m) === 47; ++m);
                  for (var g = h.length - m, y = p < g ? p : g, b = -1, k = 0; k <= y; ++k) {
                    if (k === y) {
                      if (g > y) {
                        if (h.charCodeAt(m + k) === 47) return h.slice(m + k + 1)
                        if (k === 0) return h.slice(m + k)
                      } else p > y && (u.charCodeAt(f + k) === 47 ? (b = k) : k === 0 && (b = 0))
                      break
                    }
                    var T = u.charCodeAt(f + k)
                    if (T !== h.charCodeAt(m + k)) break
                    T === 47 && (b = k)
                  }
                  var C = ''
                  for (k = f + b + 1; k <= d; ++k)
                    (k !== d && u.charCodeAt(k) !== 47) || (C.length === 0 ? (C += '..') : (C += '/..'))
                  return C.length > 0 ? C + h.slice(m + b) : ((m += b), h.charCodeAt(m) === 47 && ++m, h.slice(m))
                }, 'relative'),
                _makeLong: a(function (u) {
                  return u
                }, '_makeLong'),
                dirname: a(function (u) {
                  if ((s(u), u.length === 0)) return '.'
                  for (var h = u.charCodeAt(0), f = h === 47, d = -1, p = !0, m = u.length - 1; m >= 1; --m)
                    if ((h = u.charCodeAt(m)) === 47) {
                      if (!p) {
                        d = m
                        break
                      }
                    } else p = !1
                  return d === -1 ? (f ? '/' : '.') : f && d === 1 ? '//' : u.slice(0, d)
                }, 'dirname'),
                basename: a(function (u, h) {
                  if (h !== void 0 && typeof h != 'string') throw new TypeError('"ext" argument must be a string')
                  s(u)
                  var f,
                    d = 0,
                    p = -1,
                    m = !0
                  if (h !== void 0 && h.length > 0 && h.length <= u.length) {
                    if (h.length === u.length && h === u) return ''
                    var g = h.length - 1,
                      y = -1
                    for (f = u.length - 1; f >= 0; --f) {
                      var b = u.charCodeAt(f)
                      if (b === 47) {
                        if (!m) {
                          d = f + 1
                          break
                        }
                      } else
                        y === -1 && ((m = !1), (y = f + 1)),
                          g >= 0 && (b === h.charCodeAt(g) ? --g == -1 && (p = f) : ((g = -1), (p = y)))
                    }
                    return d === p ? (p = y) : p === -1 && (p = u.length), u.slice(d, p)
                  }
                  for (f = u.length - 1; f >= 0; --f)
                    if (u.charCodeAt(f) === 47) {
                      if (!m) {
                        d = f + 1
                        break
                      }
                    } else p === -1 && ((m = !1), (p = f + 1))
                  return p === -1 ? '' : u.slice(d, p)
                }, 'basename'),
                extname: a(function (u) {
                  s(u)
                  for (var h = -1, f = 0, d = -1, p = !0, m = 0, g = u.length - 1; g >= 0; --g) {
                    var y = u.charCodeAt(g)
                    if (y !== 47)
                      d === -1 && ((p = !1), (d = g + 1)),
                        y === 46 ? (h === -1 ? (h = g) : m !== 1 && (m = 1)) : h !== -1 && (m = -1)
                    else if (!p) {
                      f = g + 1
                      break
                    }
                  }
                  return h === -1 || d === -1 || m === 0 || (m === 1 && h === d - 1 && h === f + 1) ? '' : u.slice(h, d)
                }, 'extname'),
                format: a(function (u) {
                  if (u === null || typeof u != 'object')
                    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof u)
                  return (function (h, f) {
                    var d = f.dir || f.root,
                      p = f.base || (f.name || '') + (f.ext || '')
                    return d ? (d === f.root ? d + p : d + '/' + p) : p
                  })(0, u)
                }, 'format'),
                parse: a(function (u) {
                  s(u)
                  var h = { root: '', dir: '', base: '', ext: '', name: '' }
                  if (u.length === 0) return h
                  var f,
                    d = u.charCodeAt(0),
                    p = d === 47
                  p ? ((h.root = '/'), (f = 1)) : (f = 0)
                  for (var m = -1, g = 0, y = -1, b = !0, k = u.length - 1, T = 0; k >= f; --k)
                    if ((d = u.charCodeAt(k)) !== 47)
                      y === -1 && ((b = !1), (y = k + 1)),
                        d === 46 ? (m === -1 ? (m = k) : T !== 1 && (T = 1)) : m !== -1 && (T = -1)
                    else if (!b) {
                      g = k + 1
                      break
                    }
                  return (
                    m === -1 || y === -1 || T === 0 || (T === 1 && m === y - 1 && m === g + 1)
                      ? y !== -1 && (h.base = h.name = g === 0 && p ? u.slice(1, y) : u.slice(g, y))
                      : (g === 0 && p
                          ? ((h.name = u.slice(1, m)), (h.base = u.slice(1, y)))
                          : ((h.name = u.slice(g, m)), (h.base = u.slice(g, y))),
                        (h.ext = u.slice(m, y))),
                    g > 0 ? (h.dir = u.slice(0, g - 1)) : p && (h.dir = '/'),
                    h
                  )
                }, 'parse'),
                sep: '/',
                delimiter: ':',
                win32: null,
                posix: null,
              }
              ;(l.posix = l), (i.exports = l)
            },
          },
          t = {}
        function r(i) {
          var s = t[i]
          if (s !== void 0) return s.exports
          var o = (t[i] = { exports: {} })
          return e[i](o, o.exports, r), o.exports
        }
        a(r, 'r'),
          (r.d = (i, s) => {
            for (var o in s) r.o(s, o) && !r.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: s[o] })
          }),
          (r.o = (i, s) => Object.prototype.hasOwnProperty.call(i, s)),
          (r.r = (i) => {
            typeof Symbol < 'u' &&
              Symbol.toStringTag &&
              Object.defineProperty(i, Symbol.toStringTag, { value: 'Module' }),
              Object.defineProperty(i, '__esModule', { value: !0 })
          })
        var n = {}
        ;(() => {
          let i
          r.r(n),
            r.d(n, { URI: a(() => p, 'URI'), Utils: a(() => F, 'Utils') }),
            typeof process == 'object'
              ? (i = process.platform === 'win32')
              : typeof navigator == 'object' && (i = navigator.userAgent.indexOf('Windows') >= 0)
          let s = /^\w[\w\d+.-]*$/,
            o = /^\//,
            l = /^\/\//
          function u(S, O) {
            if (!S.scheme && O)
              throw new Error(
                `[UriError]: Scheme is missing: {scheme: "", authority: "${S.authority}", path: "${S.path}", query: "${S.query}", fragment: "${S.fragment}"}`,
              )
            if (S.scheme && !s.test(S.scheme)) throw new Error('[UriError]: Scheme contains illegal characters.')
            if (S.path) {
              if (S.authority) {
                if (!o.test(S.path))
                  throw new Error(
                    '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
                  )
              } else if (l.test(S.path))
                throw new Error(
                  '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
                )
            }
          }
          a(u, 's')
          let h = '',
            f = '/',
            d = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/
          class p {
            static {
              a(this, 'f')
            }
            static isUri(O) {
              return (
                O instanceof p ||
                (!!O &&
                  typeof O.authority == 'string' &&
                  typeof O.fragment == 'string' &&
                  typeof O.path == 'string' &&
                  typeof O.query == 'string' &&
                  typeof O.scheme == 'string' &&
                  typeof O.fsPath == 'string' &&
                  typeof O.with == 'function' &&
                  typeof O.toString == 'function')
              )
            }
            scheme
            authority
            path
            query
            fragment
            constructor(O, E, _, L, N, P = !1) {
              typeof O == 'object'
                ? ((this.scheme = O.scheme || h),
                  (this.authority = O.authority || h),
                  (this.path = O.path || h),
                  (this.query = O.query || h),
                  (this.fragment = O.fragment || h))
                : ((this.scheme = (function (I, M) {
                    return I || M ? I : 'file'
                  })(O, P)),
                  (this.authority = E || h),
                  (this.path = (function (I, M) {
                    switch (I) {
                      case 'https':
                      case 'http':
                      case 'file':
                        M ? M[0] !== f && (M = f + M) : (M = f)
                    }
                    return M
                  })(this.scheme, _ || h)),
                  (this.query = L || h),
                  (this.fragment = N || h),
                  u(this, P))
            }
            get fsPath() {
              return T(this, !1)
            }
            with(O) {
              if (!O) return this
              let { scheme: E, authority: _, path: L, query: N, fragment: P } = O
              return (
                E === void 0 ? (E = this.scheme) : E === null && (E = h),
                _ === void 0 ? (_ = this.authority) : _ === null && (_ = h),
                L === void 0 ? (L = this.path) : L === null && (L = h),
                N === void 0 ? (N = this.query) : N === null && (N = h),
                P === void 0 ? (P = this.fragment) : P === null && (P = h),
                E === this.scheme && _ === this.authority && L === this.path && N === this.query && P === this.fragment
                  ? this
                  : new g(E, _, L, N, P)
              )
            }
            static parse(O, E = !1) {
              let _ = d.exec(O)
              return _
                ? new g(_[2] || h, D(_[4] || h), D(_[5] || h), D(_[7] || h), D(_[9] || h), E)
                : new g(h, h, h, h, h)
            }
            static file(O) {
              let E = h
              if ((i && (O = O.replace(/\\/g, f)), O[0] === f && O[1] === f)) {
                let _ = O.indexOf(f, 2)
                _ === -1 ? ((E = O.substring(2)), (O = f)) : ((E = O.substring(2, _)), (O = O.substring(_) || f))
              }
              return new g('file', E, O, h, h)
            }
            static from(O) {
              let E = new g(O.scheme, O.authority, O.path, O.query, O.fragment)
              return u(E, !0), E
            }
            toString(O = !1) {
              return C(this, O)
            }
            toJSON() {
              return this
            }
            static revive(O) {
              if (O) {
                if (O instanceof p) return O
                {
                  let E = new g(O)
                  return (E._formatted = O.external), (E._fsPath = O._sep === m ? O.fsPath : null), E
                }
              }
              return O
            }
          }
          let m = i ? 1 : void 0
          class g extends p {
            static {
              a(this, 'l')
            }
            _formatted = null
            _fsPath = null
            get fsPath() {
              return this._fsPath || (this._fsPath = T(this, !1)), this._fsPath
            }
            toString(O = !1) {
              return O ? C(this, !0) : (this._formatted || (this._formatted = C(this, !1)), this._formatted)
            }
            toJSON() {
              let O = { $mid: 1 }
              return (
                this._fsPath && ((O.fsPath = this._fsPath), (O._sep = m)),
                this._formatted && (O.external = this._formatted),
                this.path && (O.path = this.path),
                this.scheme && (O.scheme = this.scheme),
                this.authority && (O.authority = this.authority),
                this.query && (O.query = this.query),
                this.fragment && (O.fragment = this.fragment),
                O
              )
            }
          }
          let y = {
            58: '%3A',
            47: '%2F',
            63: '%3F',
            35: '%23',
            91: '%5B',
            93: '%5D',
            64: '%40',
            33: '%21',
            36: '%24',
            38: '%26',
            39: '%27',
            40: '%28',
            41: '%29',
            42: '%2A',
            43: '%2B',
            44: '%2C',
            59: '%3B',
            61: '%3D',
            32: '%20',
          }
          function b(S, O, E) {
            let _,
              L = -1
            for (let N = 0; N < S.length; N++) {
              let P = S.charCodeAt(N)
              if (
                (P >= 97 && P <= 122) ||
                (P >= 65 && P <= 90) ||
                (P >= 48 && P <= 57) ||
                P === 45 ||
                P === 46 ||
                P === 95 ||
                P === 126 ||
                (O && P === 47) ||
                (E && P === 91) ||
                (E && P === 93) ||
                (E && P === 58)
              )
                L !== -1 && ((_ += encodeURIComponent(S.substring(L, N))), (L = -1)), _ !== void 0 && (_ += S.charAt(N))
              else {
                _ === void 0 && (_ = S.substr(0, N))
                let I = y[P]
                I !== void 0
                  ? (L !== -1 && ((_ += encodeURIComponent(S.substring(L, N))), (L = -1)), (_ += I))
                  : L === -1 && (L = N)
              }
            }
            return L !== -1 && (_ += encodeURIComponent(S.substring(L))), _ !== void 0 ? _ : S
          }
          a(b, 'd')
          function k(S) {
            let O
            for (let E = 0; E < S.length; E++) {
              let _ = S.charCodeAt(E)
              _ === 35 || _ === 63 ? (O === void 0 && (O = S.substr(0, E)), (O += y[_])) : O !== void 0 && (O += S[E])
            }
            return O !== void 0 ? O : S
          }
          a(k, 'p')
          function T(S, O) {
            let E
            return (
              (E =
                S.authority && S.path.length > 1 && S.scheme === 'file'
                  ? `//${S.authority}${S.path}`
                  : S.path.charCodeAt(0) === 47 &&
                      ((S.path.charCodeAt(1) >= 65 && S.path.charCodeAt(1) <= 90) ||
                        (S.path.charCodeAt(1) >= 97 && S.path.charCodeAt(1) <= 122)) &&
                      S.path.charCodeAt(2) === 58
                    ? O
                      ? S.path.substr(1)
                      : S.path[1].toLowerCase() + S.path.substr(2)
                    : S.path),
              i && (E = E.replace(/\//g, '\\')),
              E
            )
          }
          a(T, 'm')
          function C(S, O) {
            let E = O ? k : b,
              _ = '',
              { scheme: L, authority: N, path: P, query: I, fragment: M } = S
            if ((L && ((_ += L), (_ += ':')), (N || L === 'file') && ((_ += f), (_ += f)), N)) {
              let V = N.indexOf('@')
              if (V !== -1) {
                let $ = N.substr(0, V)
                ;(N = N.substr(V + 1)),
                  (V = $.lastIndexOf(':')),
                  V === -1
                    ? (_ += E($, !1, !1))
                    : ((_ += E($.substr(0, V), !1, !1)), (_ += ':'), (_ += E($.substr(V + 1), !1, !0))),
                  (_ += '@')
              }
              ;(N = N.toLowerCase()),
                (V = N.lastIndexOf(':')),
                V === -1 ? (_ += E(N, !1, !0)) : ((_ += E(N.substr(0, V), !1, !0)), (_ += N.substr(V)))
            }
            if (P) {
              if (P.length >= 3 && P.charCodeAt(0) === 47 && P.charCodeAt(2) === 58) {
                let V = P.charCodeAt(1)
                V >= 65 && V <= 90 && (P = `/${String.fromCharCode(V + 32)}:${P.substr(3)}`)
              } else if (P.length >= 2 && P.charCodeAt(1) === 58) {
                let V = P.charCodeAt(0)
                V >= 65 && V <= 90 && (P = `${String.fromCharCode(V + 32)}:${P.substr(2)}`)
              }
              _ += E(P, !0, !1)
            }
            return I && ((_ += '?'), (_ += E(I, !1, !1))), M && ((_ += '#'), (_ += O ? M : b(M, !1, !1))), _
          }
          a(C, 'y')
          function A(S) {
            try {
              return decodeURIComponent(S)
            } catch {
              return S.length > 3 ? S.substr(0, 3) + A(S.substr(3)) : S
            }
          }
          a(A, 'v')
          let w = /(%[0-9A-Za-z][0-9A-Za-z])+/g
          function D(S) {
            return S.match(w) ? S.replace(w, (O) => A(O)) : S
          }
          a(D, 'C')
          var G = r(470)
          let v = G.posix || G,
            R = '/'
          var F
          ;(function (S) {
            ;(S.joinPath = function (O, ...E) {
              return O.with({ path: v.join(O.path, ...E) })
            }),
              (S.resolvePath = function (O, ...E) {
                let _ = O.path,
                  L = !1
                _[0] !== R && ((_ = R + _), (L = !0))
                let N = v.resolve(_, ...E)
                return L && N[0] === R && !O.authority && (N = N.substring(1)), O.with({ path: N })
              }),
              (S.dirname = function (O) {
                if (O.path.length === 0 || O.path === R) return O
                let E = v.dirname(O.path)
                return E.length === 1 && E.charCodeAt(0) === 46 && (E = ''), O.with({ path: E })
              }),
              (S.basename = function (O) {
                return v.basename(O.path)
              }),
              (S.extname = function (O) {
                return v.extname(O.path)
              })
          })(F || (F = {}))
        })(),
          (ntt = n)
      })()
      ;({ URI: Yi, Utils: sm } = ntt)
    })
  var Xi,
    Wo = x(() => {
      'use strict'
      xR()
      ;(function (e) {
        ;(e.basename = sm.basename),
          (e.dirname = sm.dirname),
          (e.extname = sm.extname),
          (e.joinPath = sm.joinPath),
          (e.resolvePath = sm.resolvePath)
        function t(i, s) {
          return i?.toString() === s?.toString()
        }
        a(t, 'equals'), (e.equals = t)
        function r(i, s) {
          let o = typeof i == 'string' ? i : i.path,
            l = typeof s == 'string' ? s : s.path,
            u = o.split('/').filter((m) => m.length > 0),
            h = l.split('/').filter((m) => m.length > 0),
            f = 0
          for (; f < u.length && u[f] === h[f]; f++);
          let d = '../'.repeat(u.length - f),
            p = h.slice(f).join('/')
          return d + p
        }
        a(r, 'relative'), (e.relative = r)
        function n(i) {
          return Yi.parse(i.toString()).toString()
        }
        a(n, 'normalize'), (e.normalize = n)
      })(Xi || (Xi = {}))
    })
  var Pr,
    X1,
    K1,
    am = x(() => {
      'use strict'
      rtt()
      am()
      ha()
      ms()
      Wo()
      ;(function (e) {
        ;(e[(e.Changed = 0)] = 'Changed'),
          (e[(e.Parsed = 1)] = 'Parsed'),
          (e[(e.IndexedContent = 2)] = 'IndexedContent'),
          (e[(e.ComputedScopes = 3)] = 'ComputedScopes'),
          (e[(e.Linked = 4)] = 'Linked'),
          (e[(e.IndexedReferences = 5)] = 'IndexedReferences'),
          (e[(e.Validated = 6)] = 'Validated')
      })(Pr || (Pr = {}))
      ;(X1 = class {
        static {
          a(this, 'DefaultLangiumDocumentFactory')
        }
        constructor(t) {
          ;(this.serviceRegistry = t.ServiceRegistry),
            (this.textDocuments = t.workspace.TextDocuments),
            (this.fileSystemProvider = t.workspace.FileSystemProvider)
        }
        async fromUri(t, r = Ve.CancellationToken.None) {
          let n = await this.fileSystemProvider.readFile(t)
          return this.createAsync(t, n, r)
        }
        fromTextDocument(t, r, n) {
          return (
            (r = r ?? Yi.parse(t.uri)), Ve.CancellationToken.is(n) ? this.createAsync(r, t, n) : this.create(r, t, n)
          )
        }
        fromString(t, r, n) {
          return Ve.CancellationToken.is(n) ? this.createAsync(r, t, n) : this.create(r, t, n)
        }
        fromModel(t, r) {
          return this.create(r, { $model: t })
        }
        create(t, r, n) {
          if (typeof r == 'string') {
            let i = this.parse(t, r, n)
            return this.createLangiumDocument(i, t, void 0, r)
          } else if ('$model' in r) {
            let i = { value: r.$model, parserErrors: [], lexerErrors: [] }
            return this.createLangiumDocument(i, t)
          } else {
            let i = this.parse(t, r.getText(), n)
            return this.createLangiumDocument(i, t, r)
          }
        }
        async createAsync(t, r, n) {
          if (typeof r == 'string') {
            let i = await this.parseAsync(t, r, n)
            return this.createLangiumDocument(i, t, void 0, r)
          } else {
            let i = await this.parseAsync(t, r.getText(), n)
            return this.createLangiumDocument(i, t, r)
          }
        }
        createLangiumDocument(t, r, n, i) {
          let s
          if (n) s = { parseResult: t, uri: r, state: Pr.Parsed, references: [], textDocument: n }
          else {
            let o = this.createTextDocumentGetter(r, i)
            s = {
              parseResult: t,
              uri: r,
              state: Pr.Parsed,
              references: [],
              get textDocument() {
                return o()
              },
            }
          }
          return (t.value.$document = s), s
        }
        async update(t, r) {
          var n, i
          let s = (n = t.parseResult.value.$cstNode) === null || n === void 0 ? void 0 : n.root.fullText,
            o = (i = this.textDocuments) === null || i === void 0 ? void 0 : i.get(t.uri.toString()),
            l = o ? o.getText() : await this.fileSystemProvider.readFile(t.uri)
          if (o) Object.defineProperty(t, 'textDocument', { value: o })
          else {
            let u = this.createTextDocumentGetter(t.uri, l)
            Object.defineProperty(t, 'textDocument', { get: u })
          }
          return (
            s !== l && ((t.parseResult = await this.parseAsync(t.uri, l, r)), (t.parseResult.value.$document = t)),
            (t.state = Pr.Parsed),
            t
          )
        }
        parse(t, r, n) {
          return this.serviceRegistry.getServices(t).parser.LangiumParser.parse(r, n)
        }
        parseAsync(t, r, n) {
          return this.serviceRegistry.getServices(t).parser.AsyncParser.parse(r, n)
        }
        createTextDocumentGetter(t, r) {
          let n = this.serviceRegistry,
            i
          return () => i ?? (i = im.create(t.toString(), n.getServices(t).LanguageMetaData.languageId, 0, r ?? ''))
        }
      }),
        (K1 = class {
          static {
            a(this, 'DefaultLangiumDocuments')
          }
          constructor(t) {
            ;(this.documentMap = new Map()),
              (this.langiumDocumentFactory = t.workspace.LangiumDocumentFactory),
              (this.serviceRegistry = t.ServiceRegistry)
          }
          get all() {
            return kr(this.documentMap.values())
          }
          addDocument(t) {
            let r = t.uri.toString()
            if (this.documentMap.has(r)) throw new Error(`A document with the URI '${r}' is already present.`)
            this.documentMap.set(r, t)
          }
          getDocument(t) {
            let r = t.toString()
            return this.documentMap.get(r)
          }
          async getOrCreateDocument(t, r) {
            let n = this.getDocument(t)
            return n || ((n = await this.langiumDocumentFactory.fromUri(t, r)), this.addDocument(n), n)
          }
          createDocument(t, r, n) {
            if (n) return this.langiumDocumentFactory.fromString(r, t, n).then((i) => (this.addDocument(i), i))
            {
              let i = this.langiumDocumentFactory.fromString(r, t)
              return this.addDocument(i), i
            }
          }
          hasDocument(t) {
            return this.documentMap.has(t.toString())
          }
          invalidateDocument(t) {
            let r = t.toString(),
              n = this.documentMap.get(r)
            return (
              n &&
                (this.serviceRegistry.getServices(t).references.Linker.unlink(n),
                (n.state = Pr.Changed),
                (n.precomputedScopes = void 0),
                (n.diagnostics = void 0)),
              n
            )
          }
          deleteDocument(t) {
            let r = t.toString(),
              n = this.documentMap.get(r)
            return n && ((n.state = Pr.Changed), this.documentMap.delete(r)), n
          }
        })
    })
  var bR,
    Q1,
    kR = x(() => {
      'use strict'
      ha()
      za()
      zi()
      fa()
      am()
      ;(bR = Symbol('ref_resolving')),
        (Q1 = class {
          static {
            a(this, 'DefaultLinker')
          }
          constructor(t) {
            ;(this.reflection = t.shared.AstReflection),
              (this.langiumDocuments = () => t.shared.workspace.LangiumDocuments),
              (this.scopeProvider = t.references.ScopeProvider),
              (this.astNodeLocator = t.workspace.AstNodeLocator)
          }
          async link(t, r = Ve.CancellationToken.None) {
            for (let n of ua(t.parseResult.value)) await Sn(r), Sp(n).forEach((i) => this.doLink(i, t))
          }
          doLink(t, r) {
            var n
            let i = t.reference
            if (i._ref === void 0) {
              i._ref = bR
              try {
                let s = this.getCandidate(t)
                if (yh(s)) i._ref = s
                else if (((i._nodeDescription = s), this.langiumDocuments().hasDocument(s.documentUri))) {
                  let o = this.loadAstNode(s)
                  i._ref = o ?? this.createLinkingError(t, s)
                } else i._ref = void 0
              } catch (s) {
                console.error(`An error occurred while resolving reference to '${i.$refText}':`, s)
                let o = (n = s.message) !== null && n !== void 0 ? n : String(s)
                i._ref = Object.assign(Object.assign({}, t), {
                  message: `An error occurred while resolving reference to '${i.$refText}': ${o}`,
                })
              }
              r.references.push(i)
            }
          }
          unlink(t) {
            for (let r of t.references) delete r._ref, delete r._nodeDescription
            t.references = []
          }
          getCandidate(t) {
            let n = this.scopeProvider.getScope(t).getElement(t.reference.$refText)
            return n ?? this.createLinkingError(t)
          }
          buildReference(t, r, n, i) {
            let s = this,
              o = {
                $refNode: n,
                $refText: i,
                get ref() {
                  var l
                  if (un(this._ref)) return this._ref
                  if (a6(this._nodeDescription)) {
                    let u = s.loadAstNode(this._nodeDescription)
                    this._ref =
                      u ?? s.createLinkingError({ reference: o, container: t, property: r }, this._nodeDescription)
                  } else if (this._ref === void 0) {
                    this._ref = bR
                    let u = o1(t).$document,
                      h = s.getLinkedNode({ reference: o, container: t, property: r })
                    if (h.error && u && u.state < Pr.ComputedScopes) return (this._ref = void 0)
                    ;(this._ref = (l = h.node) !== null && l !== void 0 ? l : h.error),
                      (this._nodeDescription = h.descr),
                      u?.references.push(this)
                  } else if (this._ref === bR)
                    throw new Error(
                      `Cyclic reference resolution detected: ${s.astNodeLocator.getAstNodePath(t)}/${r} (symbol '${i}')`,
                    )
                  return un(this._ref) ? this._ref : void 0
                },
                get $nodeDescription() {
                  return this._nodeDescription
                },
                get error() {
                  return yh(this._ref) ? this._ref : void 0
                },
              }
            return o
          }
          getLinkedNode(t) {
            var r
            try {
              let n = this.getCandidate(t)
              if (yh(n)) return { error: n }
              let i = this.loadAstNode(n)
              return i ? { node: i, descr: n } : { descr: n, error: this.createLinkingError(t, n) }
            } catch (n) {
              console.error(`An error occurred while resolving reference to '${t.reference.$refText}':`, n)
              let i = (r = n.message) !== null && r !== void 0 ? r : String(n)
              return {
                error: Object.assign(Object.assign({}, t), {
                  message: `An error occurred while resolving reference to '${t.reference.$refText}': ${i}`,
                }),
              }
            }
          }
          loadAstNode(t) {
            if (t.node) return t.node
            let r = this.langiumDocuments().getDocument(t.documentUri)
            if (r) return this.astNodeLocator.getAstNode(r.parseResult.value, t.path)
          }
          createLinkingError(t, r) {
            let n = o1(t.container).$document
            n &&
              n.state < Pr.ComputedScopes &&
              console.warn(`Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`)
            let i = this.reflection.getReferenceType(t)
            return Object.assign(Object.assign({}, t), {
              message: `Could not resolve reference to ${i} named '${t.reference.$refText}'.`,
              targetDescription: r,
            })
          }
        })
    })
  function itt(e) {
    return typeof e.name == 'string'
  }
  var Z1,
    TR = x(() => {
      'use strict'
      qa()
      a(itt, 'isNamed')
      Z1 = class {
        static {
          a(this, 'DefaultNameProvider')
        }
        getName(t) {
          if (itt(t)) return t.name
        }
        getNameNode(t) {
          return p1(t.$cstNode, 'name')
        }
      }
    })
  var J1,
    SR = x(() => {
      'use strict'
      qa()
      za()
      zi()
      Wa()
      ms()
      Wo()
      J1 = class {
        static {
          a(this, 'DefaultReferences')
        }
        constructor(t) {
          ;(this.nameProvider = t.references.NameProvider),
            (this.index = t.shared.workspace.IndexManager),
            (this.nodeLocator = t.workspace.AstNodeLocator)
        }
        findDeclaration(t) {
          if (t) {
            let r = Y6(t),
              n = t.astNode
            if (r && n) {
              let i = n[r.feature]
              if (ci(i)) return i.ref
              if (Array.isArray(i)) {
                for (let s of i)
                  if (ci(s) && s.$refNode && s.$refNode.offset <= t.offset && s.$refNode.end >= t.end) return s.ref
              }
            }
            if (n) {
              let i = this.nameProvider.getNameNode(n)
              if (i && (i === t || l6(t, i))) return n
            }
          }
        }
        findDeclarationNode(t) {
          let r = this.findDeclaration(t)
          if (r?.$cstNode) {
            let n = this.nameProvider.getNameNode(r)
            return n ?? r.$cstNode
          }
        }
        findReferences(t, r) {
          let n = []
          if (r.includeDeclaration) {
            let s = this.getReferenceToSelf(t)
            s && n.push(s)
          }
          let i = this.index.findAllReferences(t, this.nodeLocator.getAstNodePath(t))
          return r.documentUri && (i = i.filter((s) => Xi.equals(s.sourceUri, r.documentUri))), n.push(...i), kr(n)
        }
        getReferenceToSelf(t) {
          let r = this.nameProvider.getNameNode(t)
          if (r) {
            let n = _i(t),
              i = this.nodeLocator.getAstNodePath(t)
            return { sourceUri: n.uri, sourcePath: i, targetUri: n.uri, targetPath: i, segment: bh(r), local: !0 }
          }
        }
      }
    })
  var Ya,
    Gh,
    om = x(() => {
      'use strict'
      ms()
      ;(Ya = class {
        static {
          a(this, 'MultiMap')
        }
        constructor(t) {
          if (((this.map = new Map()), t)) for (let [r, n] of t) this.add(r, n)
        }
        get size() {
          return Od.sum(kr(this.map.values()).map((t) => t.length))
        }
        clear() {
          this.map.clear()
        }
        delete(t, r) {
          if (r === void 0) return this.map.delete(t)
          {
            let n = this.map.get(t)
            if (n) {
              let i = n.indexOf(r)
              if (i >= 0) return n.length === 1 ? this.map.delete(t) : n.splice(i, 1), !0
            }
            return !1
          }
        }
        get(t) {
          var r
          return (r = this.map.get(t)) !== null && r !== void 0 ? r : []
        }
        has(t, r) {
          if (r === void 0) return this.map.has(t)
          {
            let n = this.map.get(t)
            return n ? n.indexOf(r) >= 0 : !1
          }
        }
        add(t, r) {
          return this.map.has(t) ? this.map.get(t).push(r) : this.map.set(t, [r]), this
        }
        addAll(t, r) {
          return this.map.has(t) ? this.map.get(t).push(...r) : this.map.set(t, Array.from(r)), this
        }
        forEach(t) {
          this.map.forEach((r, n) => r.forEach((i) => t(i, n, this)))
        }
        [Symbol.iterator]() {
          return this.entries().iterator()
        }
        entries() {
          return kr(this.map.entries()).flatMap(([t, r]) => r.map((n) => [t, n]))
        }
        keys() {
          return kr(this.map.keys())
        }
        values() {
          return kr(this.map.values()).flat()
        }
        entriesGroupedByKey() {
          return kr(this.map.entries())
        }
      }),
        (Gh = class {
          static {
            a(this, 'BiMap')
          }
          get size() {
            return this.map.size
          }
          constructor(t) {
            if (((this.map = new Map()), (this.inverse = new Map()), t)) for (let [r, n] of t) this.set(r, n)
          }
          clear() {
            this.map.clear(), this.inverse.clear()
          }
          set(t, r) {
            return this.map.set(t, r), this.inverse.set(r, t), this
          }
          get(t) {
            return this.map.get(t)
          }
          getKey(t) {
            return this.inverse.get(t)
          }
          delete(t) {
            let r = this.map.get(t)
            return r !== void 0 ? (this.map.delete(t), this.inverse.delete(r), !0) : !1
          }
        })
    })
  var ty,
    _R = x(() => {
      'use strict'
      ha()
      zi()
      om()
      fa()
      ty = class {
        static {
          a(this, 'DefaultScopeComputation')
        }
        constructor(t) {
          ;(this.nameProvider = t.references.NameProvider), (this.descriptions = t.workspace.AstNodeDescriptionProvider)
        }
        async computeExports(t, r = Ve.CancellationToken.None) {
          return this.computeExportsForNode(t.parseResult.value, t, void 0, r)
        }
        async computeExportsForNode(t, r, n = l1, i = Ve.CancellationToken.None) {
          let s = []
          this.exportNode(t, s, r)
          for (let o of n(t)) await Sn(i), this.exportNode(o, s, r)
          return s
        }
        exportNode(t, r, n) {
          let i = this.nameProvider.getName(t)
          i && r.push(this.descriptions.createDescription(t, i, n))
        }
        async computeLocalScopes(t, r = Ve.CancellationToken.None) {
          let n = t.parseResult.value,
            i = new Ya()
          for (let s of Bo(n)) await Sn(r), this.processNode(s, t, i)
          return i
        }
        processNode(t, r, n) {
          let i = t.$container
          if (i) {
            let s = this.nameProvider.getName(t)
            s && n.add(i, this.descriptions.createDescription(t, s, r))
          }
        }
      }
    })
  var lm,
    ey,
    $At,
    CR = x(() => {
      'use strict'
      ms()
      ;(lm = class {
        static {
          a(this, 'StreamScope')
        }
        constructor(t, r, n) {
          var i
          ;(this.elements = t),
            (this.outerScope = r),
            (this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1)
        }
        getAllElements() {
          return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements
        }
        getElement(t) {
          let r = this.caseInsensitive
            ? this.elements.find((n) => n.name.toLowerCase() === t.toLowerCase())
            : this.elements.find((n) => n.name === t)
          if (r) return r
          if (this.outerScope) return this.outerScope.getElement(t)
        }
      }),
        (ey = class {
          static {
            a(this, 'MapScope')
          }
          constructor(t, r, n) {
            var i
            ;(this.elements = new Map()),
              (this.caseInsensitive = (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1)
            for (let s of t) {
              let o = this.caseInsensitive ? s.name.toLowerCase() : s.name
              this.elements.set(o, s)
            }
            this.outerScope = r
          }
          getElement(t) {
            let r = this.caseInsensitive ? t.toLowerCase() : t,
              n = this.elements.get(r)
            if (n) return n
            if (this.outerScope) return this.outerScope.getElement(t)
          }
          getAllElements() {
            let t = kr(this.elements.values())
            return this.outerScope && (t = t.concat(this.outerScope.getAllElements())), t
          }
        }),
        ($At = {
          getElement() {},
          getAllElements() {
            return Q0
          },
        })
    })
  var cm,
    ry,
    Vh,
    RS,
    um,
    DS = x(() => {
      'use strict'
      ;(cm = class {
        static {
          a(this, 'DisposableCache')
        }
        constructor() {
          ;(this.toDispose = []), (this.isDisposed = !1)
        }
        onDispose(t) {
          this.toDispose.push(t)
        }
        dispose() {
          this.throwIfDisposed(), this.clear(), (this.isDisposed = !0), this.toDispose.forEach((t) => t.dispose())
        }
        throwIfDisposed() {
          if (this.isDisposed) throw new Error('This cache has already been disposed')
        }
      }),
        (ry = class extends cm {
          static {
            a(this, 'SimpleCache')
          }
          constructor() {
            super(...arguments), (this.cache = new Map())
          }
          has(t) {
            return this.throwIfDisposed(), this.cache.has(t)
          }
          set(t, r) {
            this.throwIfDisposed(), this.cache.set(t, r)
          }
          get(t, r) {
            if ((this.throwIfDisposed(), this.cache.has(t))) return this.cache.get(t)
            if (r) {
              let n = r()
              return this.cache.set(t, n), n
            } else return
          }
          delete(t) {
            return this.throwIfDisposed(), this.cache.delete(t)
          }
          clear() {
            this.throwIfDisposed(), this.cache.clear()
          }
        }),
        (Vh = class extends cm {
          static {
            a(this, 'ContextCache')
          }
          constructor(t) {
            super(), (this.cache = new Map()), (this.converter = t ?? ((r) => r))
          }
          has(t, r) {
            return this.throwIfDisposed(), this.cacheForContext(t).has(r)
          }
          set(t, r, n) {
            this.throwIfDisposed(), this.cacheForContext(t).set(r, n)
          }
          get(t, r, n) {
            this.throwIfDisposed()
            let i = this.cacheForContext(t)
            if (i.has(r)) return i.get(r)
            if (n) {
              let s = n()
              return i.set(r, s), s
            } else return
          }
          delete(t, r) {
            return this.throwIfDisposed(), this.cacheForContext(t).delete(r)
          }
          clear(t) {
            if ((this.throwIfDisposed(), t)) {
              let r = this.converter(t)
              this.cache.delete(r)
            } else this.cache.clear()
          }
          cacheForContext(t) {
            let r = this.converter(t),
              n = this.cache.get(r)
            return n || ((n = new Map()), this.cache.set(r, n)), n
          }
        }),
        (RS = class extends Vh {
          static {
            a(this, 'DocumentCache')
          }
          constructor(t, r) {
            super((n) => n.toString()),
              r
                ? (this.toDispose.push(
                    t.workspace.DocumentBuilder.onDocumentPhase(r, (n) => {
                      this.clear(n.uri.toString())
                    }),
                  ),
                  this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      for (let s of i) this.clear(s)
                    }),
                  ))
                : this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      let s = n.concat(i)
                      for (let o of s) this.clear(o)
                    }),
                  )
          }
        }),
        (um = class extends ry {
          static {
            a(this, 'WorkspaceCache')
          }
          constructor(t, r) {
            super(),
              r
                ? (this.toDispose.push(
                    t.workspace.DocumentBuilder.onBuildPhase(r, () => {
                      this.clear()
                    }),
                  ),
                  this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      i.length > 0 && this.clear()
                    }),
                  ))
                : this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate(() => {
                      this.clear()
                    }),
                  )
          }
        })
    })
  var ny,
    wR = x(() => {
      'use strict'
      CR()
      zi()
      ms()
      DS()
      ny = class {
        static {
          a(this, 'DefaultScopeProvider')
        }
        constructor(t) {
          ;(this.reflection = t.shared.AstReflection),
            (this.nameProvider = t.references.NameProvider),
            (this.descriptions = t.workspace.AstNodeDescriptionProvider),
            (this.indexManager = t.shared.workspace.IndexManager),
            (this.globalScopeCache = new um(t.shared))
        }
        getScope(t) {
          let r = [],
            n = this.reflection.getReferenceType(t),
            i = _i(t.container).precomputedScopes
          if (i) {
            let o = t.container
            do {
              let l = i.get(o)
              l.length > 0 && r.push(kr(l).filter((u) => this.reflection.isSubtype(u.type, n))), (o = o.$container)
            } while (o)
          }
          let s = this.getGlobalScope(n, t)
          for (let o = r.length - 1; o >= 0; o--) s = this.createScope(r[o], s)
          return s
        }
        createScope(t, r, n) {
          return new lm(kr(t), r, n)
        }
        createScopeForNodes(t, r, n) {
          let i = kr(t)
            .map((s) => {
              let o = this.nameProvider.getName(s)
              if (o) return this.descriptions.createDescription(s, o)
            })
            .nonNullable()
          return new lm(i, r, n)
        }
        getGlobalScope(t, r) {
          return this.globalScopeCache.get(t, () => new ey(this.indexManager.allElements(t)))
        }
      }
    })
  function ER(e) {
    return typeof e.$comment == 'string'
  }
  function stt(e) {
    return typeof e == 'object' && !!e && ('$ref' in e || '$error' in e)
  }
  var iy,
    NS = x(() => {
      'use strict'
      xR()
      za()
      zi()
      qa()
      a(ER, 'isAstNodeWithComment')
      a(stt, 'isIntermediateReference')
      iy = class {
        static {
          a(this, 'DefaultJsonSerializer')
        }
        constructor(t) {
          ;(this.ignoreProperties = new Set([
            '$container',
            '$containerProperty',
            '$containerIndex',
            '$document',
            '$cstNode',
          ])),
            (this.langiumDocuments = t.shared.workspace.LangiumDocuments),
            (this.astNodeLocator = t.workspace.AstNodeLocator),
            (this.nameProvider = t.references.NameProvider),
            (this.commentProvider = t.documentation.CommentProvider)
        }
        serialize(t, r) {
          let n = r ?? {},
            i = r?.replacer,
            s = a((l, u) => this.replacer(l, u, n), 'defaultReplacer'),
            o = i ? (l, u) => i(l, u, s) : s
          try {
            return (this.currentDocument = _i(t)), JSON.stringify(t, o, r?.space)
          } finally {
            this.currentDocument = void 0
          }
        }
        deserialize(t, r) {
          let n = r ?? {},
            i = JSON.parse(t)
          return this.linkNode(i, i, n), i
        }
        replacer(t, r, { refText: n, sourceText: i, textRegions: s, comments: o, uriConverter: l }) {
          var u, h, f, d
          if (!this.ignoreProperties.has(t))
            if (ci(r)) {
              let p = r.ref,
                m = n ? r.$refText : void 0
              if (p) {
                let g = _i(p),
                  y = ''
                this.currentDocument && this.currentDocument !== g && (l ? (y = l(g.uri, r)) : (y = g.uri.toString()))
                let b = this.astNodeLocator.getAstNodePath(p)
                return { $ref: `${y}#${b}`, $refText: m }
              } else
                return {
                  $error:
                    (h = (u = r.error) === null || u === void 0 ? void 0 : u.message) !== null && h !== void 0
                      ? h
                      : 'Could not resolve reference',
                  $refText: m,
                }
            } else if (un(r)) {
              let p
              if (
                (s &&
                  ((p = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, r))),
                  (!t || r.$document) &&
                    p?.$textRegion &&
                    (p.$textRegion.documentURI =
                      (f = this.currentDocument) === null || f === void 0 ? void 0 : f.uri.toString())),
                i &&
                  !t &&
                  (p ?? (p = Object.assign({}, r)),
                  (p.$sourceText = (d = r.$cstNode) === null || d === void 0 ? void 0 : d.text)),
                o)
              ) {
                p ?? (p = Object.assign({}, r))
                let m = this.commentProvider.getComment(r)
                m && (p.$comment = m.replace(/\r/g, ''))
              }
              return p ?? r
            } else return r
        }
        addAstNodeRegionWithAssignmentsTo(t) {
          let r = a(
            (n) => ({ offset: n.offset, end: n.end, length: n.length, range: n.range }),
            'createDocumentSegment',
          )
          if (t.$cstNode) {
            let n = (t.$textRegion = r(t.$cstNode)),
              i = (n.assignments = {})
            return (
              Object.keys(t)
                .filter((s) => !s.startsWith('$'))
                .forEach((s) => {
                  let o = U6(t.$cstNode, s).map(r)
                  o.length !== 0 && (i[s] = o)
                }),
              t
            )
          }
        }
        linkNode(t, r, n, i, s, o) {
          for (let [u, h] of Object.entries(t))
            if (Array.isArray(h))
              for (let f = 0; f < h.length; f++) {
                let d = h[f]
                stt(d) ? (h[f] = this.reviveReference(t, u, r, d, n)) : un(d) && this.linkNode(d, r, n, t, u, f)
              }
            else stt(h) ? (t[u] = this.reviveReference(t, u, r, h, n)) : un(h) && this.linkNode(h, r, n, t, u)
          let l = t
          ;(l.$container = i), (l.$containerProperty = s), (l.$containerIndex = o)
        }
        reviveReference(t, r, n, i, s) {
          let o = i.$refText,
            l = i.$error
          if (i.$ref) {
            let u = this.getRefNode(n, i.$ref, s.uriConverter)
            if (un(u)) return o || (o = this.nameProvider.getName(u)), { $refText: o ?? '', ref: u }
            l = u
          }
          if (l) {
            let u = { $refText: o ?? '' }
            return (u.error = { container: t, property: r, message: l, reference: u }), u
          } else return
        }
        getRefNode(t, r, n) {
          try {
            let i = r.indexOf('#')
            if (i === 0) {
              let u = this.astNodeLocator.getAstNode(t, r.substring(1))
              return u || 'Could not resolve path: ' + r
            }
            if (i < 0) {
              let u = n ? n(r) : Yi.parse(r),
                h = this.langiumDocuments.getDocument(u)
              return h ? h.parseResult.value : 'Could not find document for URI: ' + r
            }
            let s = n ? n(r.substring(0, i)) : Yi.parse(r.substring(0, i)),
              o = this.langiumDocuments.getDocument(s)
            if (!o) return 'Could not find document for URI: ' + r
            if (i === r.length - 1) return o.parseResult.value
            let l = this.astNodeLocator.getAstNode(o.parseResult.value, r.substring(i + 1))
            return l || 'Could not resolve URI: ' + r
          } catch (i) {
            return String(i)
          }
        }
      }
    })
  var sy,
    vR = x(() => {
      'use strict'
      Wo()
      sy = class {
        static {
          a(this, 'DefaultServiceRegistry')
        }
        get map() {
          return this.fileExtensionMap
        }
        constructor(t) {
          ;(this.languageIdMap = new Map()),
            (this.fileExtensionMap = new Map()),
            (this.textDocuments = t?.workspace.TextDocuments)
        }
        register(t) {
          let r = t.LanguageMetaData
          for (let n of r.fileExtensions)
            this.fileExtensionMap.has(n) &&
              console.warn(
                `The file extension ${n} is used by multiple languages. It is now assigned to '${r.languageId}'.`,
              ),
              this.fileExtensionMap.set(n, t)
          this.languageIdMap.set(r.languageId, t),
            this.languageIdMap.size === 1 ? (this.singleton = t) : (this.singleton = void 0)
        }
        getServices(t) {
          var r, n
          if (this.singleton !== void 0) return this.singleton
          if (this.languageIdMap.size === 0)
            throw new Error('The service registry is empty. Use `register` to register the services of a language.')
          let i =
            (n = (r = this.textDocuments) === null || r === void 0 ? void 0 : r.get(t)) === null || n === void 0
              ? void 0
              : n.languageId
          if (i !== void 0) {
            let l = this.languageIdMap.get(i)
            if (l) return l
          }
          let s = Xi.extname(t),
            o = this.fileExtensionMap.get(s)
          if (!o)
            throw i
              ? new Error(`The service registry contains no services for the extension '${s}' for language '${i}'.`)
              : new Error(`The service registry contains no services for the extension '${s}'.`)
          return o
        }
        hasServices(t) {
          try {
            return this.getServices(t), !0
          } catch {
            return !1
          }
        }
        get all() {
          return Array.from(this.languageIdMap.values())
        }
      }
    })
  function zh(e) {
    return { code: e }
  }
  var hm,
    ay,
    oy = x(() => {
      'use strict'
      Bs()
      om()
      fa()
      ms()
      a(zh, 'diagnosticData')
      ;(function (e) {
        e.all = ['fast', 'slow', 'built-in']
      })(hm || (hm = {}))
      ay = class {
        static {
          a(this, 'ValidationRegistry')
        }
        constructor(t) {
          ;(this.entries = new Ya()),
            (this.entriesBefore = []),
            (this.entriesAfter = []),
            (this.reflection = t.shared.AstReflection)
        }
        register(t, r = this, n = 'fast') {
          if (n === 'built-in')
            throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.")
          for (let [i, s] of Object.entries(t)) {
            let o = s
            if (Array.isArray(o))
              for (let l of o) {
                let u = { check: this.wrapValidationException(l, r), category: n }
                this.addEntry(i, u)
              }
            else if (typeof o == 'function') {
              let l = { check: this.wrapValidationException(o, r), category: n }
              this.addEntry(i, l)
            } else Oo(o)
          }
        }
        wrapValidationException(t, r) {
          return async (n, i, s) => {
            await this.handleException(() => t.call(r, n, i, s), 'An error occurred during validation', i, n)
          }
        }
        async handleException(t, r, n, i) {
          try {
            await t()
          } catch (s) {
            if (zo(s)) throw s
            console.error(`${r}:`, s), s instanceof Error && s.stack && console.error(s.stack)
            let o = s instanceof Error ? s.message : String(s)
            n('error', `${r}: ${o}`, { node: i })
          }
        }
        addEntry(t, r) {
          if (t === 'AstNode') {
            this.entries.add('AstNode', r)
            return
          }
          for (let n of this.reflection.getAllSubTypes(t)) this.entries.add(n, r)
        }
        getChecks(t, r) {
          let n = kr(this.entries.get(t)).concat(this.entries.get('AstNode'))
          return r && (n = n.filter((i) => r.includes(i.category))), n.map((i) => i.check)
        }
        registerBeforeDocument(t, r = this) {
          this.entriesBefore.push(
            this.wrapPreparationException(t, 'An error occurred during set-up of the validation', r),
          )
        }
        registerAfterDocument(t, r = this) {
          this.entriesAfter.push(
            this.wrapPreparationException(t, 'An error occurred during tear-down of the validation', r),
          )
        }
        wrapPreparationException(t, r, n) {
          return async (i, s, o, l) => {
            await this.handleException(() => t.call(n, i, s, o, l), r, s, i)
          }
        }
        get checksBefore() {
          return this.entriesBefore
        }
        get checksAfter() {
          return this.entriesAfter
        }
      }
    })
  function att(e) {
    if (e.range) return e.range
    let t
    return (
      typeof e.property == 'string'
        ? (t = p1(e.node.$cstNode, e.property, e.index))
        : typeof e.keyword == 'string' && (t = q6(e.node.$cstNode, e.keyword, e.index)),
      t ?? (t = e.node.$cstNode),
      t ? t.range : { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } }
    )
  }
  function IS(e) {
    switch (e) {
      case 'error':
        return 1
      case 'warning':
        return 2
      case 'info':
        return 3
      case 'hint':
        return 4
      default:
        throw new Error('Invalid diagnostic severity: ' + e)
    }
  }
  function ott(e) {
    switch (e) {
      case 'error':
        return zh(da.LexingError)
      case 'warning':
        return zh(da.LexingWarning)
      case 'info':
        return zh(da.LexingInfo)
      case 'hint':
        return zh(da.LexingHint)
      default:
        throw new Error('Invalid diagnostic severity: ' + e)
    }
  }
  var ly,
    da,
    AR = x(() => {
      'use strict'
      ha()
      qa()
      zi()
      Wa()
      fa()
      oy()
      ly = class {
        static {
          a(this, 'DefaultDocumentValidator')
        }
        constructor(t) {
          ;(this.validationRegistry = t.validation.ValidationRegistry), (this.metadata = t.LanguageMetaData)
        }
        async validateDocument(t, r = {}, n = Ve.CancellationToken.None) {
          let i = t.parseResult,
            s = []
          if (
            (await Sn(n),
            (!r.categories || r.categories.includes('built-in')) &&
              (this.processLexingErrors(i, s, r),
              (r.stopAfterLexingErrors &&
                s.some((o) => {
                  var l
                  return ((l = o.data) === null || l === void 0 ? void 0 : l.code) === da.LexingError
                })) ||
                (this.processParsingErrors(i, s, r),
                r.stopAfterParsingErrors &&
                  s.some((o) => {
                    var l
                    return ((l = o.data) === null || l === void 0 ? void 0 : l.code) === da.ParsingError
                  })) ||
                (this.processLinkingErrors(t, s, r),
                r.stopAfterLinkingErrors &&
                  s.some((o) => {
                    var l
                    return ((l = o.data) === null || l === void 0 ? void 0 : l.code) === da.LinkingError
                  }))))
          )
            return s
          try {
            s.push(...(await this.validateAst(i.value, r, n)))
          } catch (o) {
            if (zo(o)) throw o
            console.error('An error occurred during validation:', o)
          }
          return await Sn(n), s
        }
        processLexingErrors(t, r, n) {
          var i, s, o
          let l = [
            ...t.lexerErrors,
            ...((s = (i = t.lexerReport) === null || i === void 0 ? void 0 : i.diagnostics) !== null && s !== void 0
              ? s
              : []),
          ]
          for (let u of l) {
            let h = (o = u.severity) !== null && o !== void 0 ? o : 'error',
              f = {
                severity: IS(h),
                range: {
                  start: { line: u.line - 1, character: u.column - 1 },
                  end: { line: u.line - 1, character: u.column + u.length - 1 },
                },
                message: u.message,
                data: ott(h),
                source: this.getSource(),
              }
            r.push(f)
          }
        }
        processParsingErrors(t, r, n) {
          for (let i of t.parserErrors) {
            let s
            if (isNaN(i.token.startOffset)) {
              if ('previousToken' in i) {
                let o = i.previousToken
                if (isNaN(o.startOffset)) {
                  let l = { line: 0, character: 0 }
                  s = { start: l, end: l }
                } else {
                  let l = { line: o.endLine - 1, character: o.endColumn }
                  s = { start: l, end: l }
                }
              }
            } else s = Pd(i.token)
            if (s) {
              let o = {
                severity: IS('error'),
                range: s,
                message: i.message,
                data: zh(da.ParsingError),
                source: this.getSource(),
              }
              r.push(o)
            }
          }
        }
        processLinkingErrors(t, r, n) {
          for (let i of t.references) {
            let s = i.error
            if (s) {
              let o = {
                node: s.container,
                property: s.property,
                index: s.index,
                data: {
                  code: da.LinkingError,
                  containerType: s.container.$type,
                  property: s.property,
                  refText: s.reference.$refText,
                },
              }
              r.push(this.toDiagnostic('error', s.message, o))
            }
          }
        }
        async validateAst(t, r, n = Ve.CancellationToken.None) {
          let i = [],
            s = a((o, l, u) => {
              i.push(this.toDiagnostic(o, l, u))
            }, 'acceptor')
          return (
            await this.validateAstBefore(t, r, s, n),
            await this.validateAstNodes(t, r, s, n),
            await this.validateAstAfter(t, r, s, n),
            i
          )
        }
        async validateAstBefore(t, r, n, i = Ve.CancellationToken.None) {
          var s
          let o = this.validationRegistry.checksBefore
          for (let l of o) await Sn(i), await l(t, n, (s = r.categories) !== null && s !== void 0 ? s : [], i)
        }
        async validateAstNodes(t, r, n, i = Ve.CancellationToken.None) {
          await Promise.all(
            ua(t).map(async (s) => {
              await Sn(i)
              let o = this.validationRegistry.getChecks(s.$type, r.categories)
              for (let l of o) await l(s, n, i)
            }),
          )
        }
        async validateAstAfter(t, r, n, i = Ve.CancellationToken.None) {
          var s
          let o = this.validationRegistry.checksAfter
          for (let l of o) await Sn(i), await l(t, n, (s = r.categories) !== null && s !== void 0 ? s : [], i)
        }
        toDiagnostic(t, r, n) {
          return {
            message: r,
            range: att(n),
            severity: IS(t),
            code: n.code,
            codeDescription: n.codeDescription,
            tags: n.tags,
            relatedInformation: n.relatedInformation,
            data: n.data,
            source: this.getSource(),
          }
        }
        getSource() {
          return this.metadata.languageId
        }
      }
      a(att, 'getDiagnosticRange')
      a(IS, 'toDiagnosticSeverity')
      a(ott, 'toDiagnosticData')
      ;(function (e) {
        ;(e.LexingError = 'lexing-error'),
          (e.LexingWarning = 'lexing-warning'),
          (e.LexingInfo = 'lexing-info'),
          (e.LexingHint = 'lexing-hint'),
          (e.ParsingError = 'parsing-error'),
          (e.LinkingError = 'linking-error')
      })(da || (da = {}))
    })
  var cy,
    uy,
    LR = x(() => {
      'use strict'
      ha()
      za()
      zi()
      Wa()
      fa()
      Wo()
      ;(cy = class {
        static {
          a(this, 'DefaultAstNodeDescriptionProvider')
        }
        constructor(t) {
          ;(this.astNodeLocator = t.workspace.AstNodeLocator), (this.nameProvider = t.references.NameProvider)
        }
        createDescription(t, r, n) {
          let i = n ?? _i(t)
          r ?? (r = this.nameProvider.getName(t))
          let s = this.astNodeLocator.getAstNodePath(t)
          if (!r) throw new Error(`Node at path ${s} has no name.`)
          let o,
            l = a(() => {
              var u
              return o ?? (o = bh((u = this.nameProvider.getNameNode(t)) !== null && u !== void 0 ? u : t.$cstNode))
            }, 'nameSegmentGetter')
          return {
            node: t,
            name: r,
            get nameSegment() {
              return l()
            },
            selectionSegment: bh(t.$cstNode),
            type: t.$type,
            documentUri: i.uri,
            path: s,
          }
        }
      }),
        (uy = class {
          static {
            a(this, 'DefaultReferenceDescriptionProvider')
          }
          constructor(t) {
            this.nodeLocator = t.workspace.AstNodeLocator
          }
          async createDescriptions(t, r = Ve.CancellationToken.None) {
            let n = [],
              i = t.parseResult.value
            for (let s of ua(i))
              await Sn(r),
                Sp(s)
                  .filter((o) => !yh(o))
                  .forEach((o) => {
                    let l = this.createDescription(o)
                    l && n.push(l)
                  })
            return n
          }
          createDescription(t) {
            let r = t.reference.$nodeDescription,
              n = t.reference.$refNode
            if (!r || !n) return
            let i = _i(t.container).uri
            return {
              sourceUri: i,
              sourcePath: this.nodeLocator.getAstNodePath(t.container),
              targetUri: r.documentUri,
              targetPath: r.path,
              segment: bh(n),
              local: Xi.equals(r.documentUri, i),
            }
          }
        })
    })
  var hy,
    RR = x(() => {
      'use strict'
      hy = class {
        static {
          a(this, 'DefaultAstNodeLocator')
        }
        constructor() {
          ;(this.segmentSeparator = '/'), (this.indexSeparator = '@')
        }
        getAstNodePath(t) {
          if (t.$container) {
            let r = this.getAstNodePath(t.$container),
              n = this.getPathSegment(t)
            return r + this.segmentSeparator + n
          }
          return ''
        }
        getPathSegment({ $containerProperty: t, $containerIndex: r }) {
          if (!t) throw new Error("Missing '$containerProperty' in AST node.")
          return r !== void 0 ? t + this.indexSeparator + r : t
        }
        getAstNode(t, r) {
          return r.split(this.segmentSeparator).reduce((i, s) => {
            if (!i || s.length === 0) return i
            let o = s.indexOf(this.indexSeparator)
            if (o > 0) {
              let l = s.substring(0, o),
                u = parseInt(s.substring(o + 1)),
                h = i[l]
              return h?.[u]
            }
            return i[s]
          }, t)
        }
      }
    })
  var nn = {}
  var MS = x(() => {
    'use strict'
    qe(nn, Ss(dR(), 1))
  })
  var fy,
    DR = x(() => {
      'use strict'
      MS()
      fa()
      fy = class {
        static {
          a(this, 'DefaultConfigurationProvider')
        }
        constructor(t) {
          ;(this._ready = new Hi()),
            (this.settings = {}),
            (this.workspaceConfig = !1),
            (this.onConfigurationSectionUpdateEmitter = new nn.Emitter()),
            (this.serviceRegistry = t.ServiceRegistry)
        }
        get ready() {
          return this._ready.promise
        }
        initialize(t) {
          var r, n
          this.workspaceConfig =
            (n = (r = t.capabilities.workspace) === null || r === void 0 ? void 0 : r.configuration) !== null &&
            n !== void 0
              ? n
              : !1
        }
        async initialized(t) {
          if (this.workspaceConfig) {
            if (t.register) {
              let r = this.serviceRegistry.all
              t.register({ section: r.map((n) => this.toSectionName(n.LanguageMetaData.languageId)) })
            }
            if (t.fetchConfiguration) {
              let r = this.serviceRegistry.all.map((i) => ({
                  section: this.toSectionName(i.LanguageMetaData.languageId),
                })),
                n = await t.fetchConfiguration(r)
              r.forEach((i, s) => {
                this.updateSectionConfiguration(i.section, n[s])
              })
            }
          }
          this._ready.resolve()
        }
        updateConfiguration(t) {
          t.settings &&
            Object.keys(t.settings).forEach((r) => {
              let n = t.settings[r]
              this.updateSectionConfiguration(r, n),
                this.onConfigurationSectionUpdateEmitter.fire({ section: r, configuration: n })
            })
        }
        updateSectionConfiguration(t, r) {
          this.settings[t] = r
        }
        async getConfiguration(t, r) {
          await this.ready
          let n = this.toSectionName(t)
          if (this.settings[n]) return this.settings[n][r]
        }
        toSectionName(t) {
          return `${t}`
        }
        get onConfigurationSectionUpdate() {
          return this.onConfigurationSectionUpdateEmitter.event
        }
      }
    })
  var Yc,
    NR = x(() => {
      'use strict'
      ;(function (e) {
        function t(r) {
          return { dispose: a(async () => await r(), 'dispose') }
        }
        a(t, 'create'), (e.create = t)
      })(Yc || (Yc = {}))
    })
  var dy,
    IR = x(() => {
      'use strict'
      ha()
      NR()
      om()
      fa()
      ms()
      oy()
      am()
      dy = class {
        static {
          a(this, 'DefaultDocumentBuilder')
        }
        constructor(t) {
          ;(this.updateBuildOptions = { validation: { categories: ['built-in', 'fast'] } }),
            (this.updateListeners = []),
            (this.buildPhaseListeners = new Ya()),
            (this.documentPhaseListeners = new Ya()),
            (this.buildState = new Map()),
            (this.documentBuildWaiters = new Map()),
            (this.currentState = Pr.Changed),
            (this.langiumDocuments = t.workspace.LangiumDocuments),
            (this.langiumDocumentFactory = t.workspace.LangiumDocumentFactory),
            (this.textDocuments = t.workspace.TextDocuments),
            (this.indexManager = t.workspace.IndexManager),
            (this.serviceRegistry = t.ServiceRegistry)
        }
        async build(t, r = {}, n = Ve.CancellationToken.None) {
          var i, s
          for (let o of t) {
            let l = o.uri.toString()
            if (o.state === Pr.Validated) {
              if (typeof r.validation == 'boolean' && r.validation)
                (o.state = Pr.IndexedReferences), (o.diagnostics = void 0), this.buildState.delete(l)
              else if (typeof r.validation == 'object') {
                let u = this.buildState.get(l),
                  h = (i = u?.result) === null || i === void 0 ? void 0 : i.validationChecks
                if (h) {
                  let d = ((s = r.validation.categories) !== null && s !== void 0 ? s : hm.all).filter(
                    (p) => !h.includes(p),
                  )
                  d.length > 0 &&
                    (this.buildState.set(l, {
                      completed: !1,
                      options: { validation: Object.assign(Object.assign({}, r.validation), { categories: d }) },
                      result: u.result,
                    }),
                    (o.state = Pr.IndexedReferences))
                }
              }
            } else this.buildState.delete(l)
          }
          ;(this.currentState = Pr.Changed),
            await this.emitUpdate(
              t.map((o) => o.uri),
              [],
            ),
            await this.buildDocuments(t, r, n)
        }
        async update(t, r, n = Ve.CancellationToken.None) {
          this.currentState = Pr.Changed
          for (let o of r)
            this.langiumDocuments.deleteDocument(o), this.buildState.delete(o.toString()), this.indexManager.remove(o)
          for (let o of t) {
            if (!this.langiumDocuments.invalidateDocument(o)) {
              let u = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, o)
              ;(u.state = Pr.Changed), this.langiumDocuments.addDocument(u)
            }
            this.buildState.delete(o.toString())
          }
          let i = kr(t)
            .concat(r)
            .map((o) => o.toString())
            .toSet()
          this.langiumDocuments.all
            .filter((o) => !i.has(o.uri.toString()) && this.shouldRelink(o, i))
            .forEach((o) => {
              this.serviceRegistry.getServices(o.uri).references.Linker.unlink(o),
                (o.state = Math.min(o.state, Pr.ComputedScopes)),
                (o.diagnostics = void 0)
            }),
            await this.emitUpdate(t, r),
            await Sn(n)
          let s = this.sortDocuments(
            this.langiumDocuments.all
              .filter((o) => {
                var l
                return (
                  o.state < Pr.Linked ||
                  !(!((l = this.buildState.get(o.uri.toString())) === null || l === void 0) && l.completed)
                )
              })
              .toArray(),
          )
          await this.buildDocuments(s, this.updateBuildOptions, n)
        }
        async emitUpdate(t, r) {
          await Promise.all(this.updateListeners.map((n) => n(t, r)))
        }
        sortDocuments(t) {
          let r = 0,
            n = t.length - 1
          for (; r < n; ) {
            for (; r < t.length && this.hasTextDocument(t[r]); ) r++
            for (; n >= 0 && !this.hasTextDocument(t[n]); ) n--
            r < n && ([t[r], t[n]] = [t[n], t[r]])
          }
          return t
        }
        hasTextDocument(t) {
          var r
          return !!(!((r = this.textDocuments) === null || r === void 0) && r.get(t.uri))
        }
        shouldRelink(t, r) {
          return t.references.some((n) => n.error !== void 0) ? !0 : this.indexManager.isAffected(t, r)
        }
        onUpdate(t) {
          return (
            this.updateListeners.push(t),
            Yc.create(() => {
              let r = this.updateListeners.indexOf(t)
              r >= 0 && this.updateListeners.splice(r, 1)
            })
          )
        }
        async buildDocuments(t, r, n) {
          this.prepareBuild(t, r),
            await this.runCancelable(t, Pr.Parsed, n, (s) => this.langiumDocumentFactory.update(s, n)),
            await this.runCancelable(t, Pr.IndexedContent, n, (s) => this.indexManager.updateContent(s, n)),
            await this.runCancelable(t, Pr.ComputedScopes, n, async (s) => {
              let o = this.serviceRegistry.getServices(s.uri).references.ScopeComputation
              s.precomputedScopes = await o.computeLocalScopes(s, n)
            }),
            await this.runCancelable(t, Pr.Linked, n, (s) =>
              this.serviceRegistry.getServices(s.uri).references.Linker.link(s, n),
            ),
            await this.runCancelable(t, Pr.IndexedReferences, n, (s) => this.indexManager.updateReferences(s, n))
          let i = t.filter((s) => this.shouldValidate(s))
          await this.runCancelable(i, Pr.Validated, n, (s) => this.validate(s, n))
          for (let s of t) {
            let o = this.buildState.get(s.uri.toString())
            o && (o.completed = !0)
          }
        }
        prepareBuild(t, r) {
          for (let n of t) {
            let i = n.uri.toString(),
              s = this.buildState.get(i)
            ;(!s || s.completed) && this.buildState.set(i, { completed: !1, options: r, result: s?.result })
          }
        }
        async runCancelable(t, r, n, i) {
          let s = t.filter((l) => l.state < r)
          for (let l of s) await Sn(n), await i(l), (l.state = r), await this.notifyDocumentPhase(l, r, n)
          let o = t.filter((l) => l.state === r)
          await this.notifyBuildPhase(o, r, n), (this.currentState = r)
        }
        onBuildPhase(t, r) {
          return (
            this.buildPhaseListeners.add(t, r),
            Yc.create(() => {
              this.buildPhaseListeners.delete(t, r)
            })
          )
        }
        onDocumentPhase(t, r) {
          return (
            this.documentPhaseListeners.add(t, r),
            Yc.create(() => {
              this.documentPhaseListeners.delete(t, r)
            })
          )
        }
        waitUntil(t, r, n) {
          let i
          if ((r && 'path' in r ? (i = r) : (n = r), n ?? (n = Ve.CancellationToken.None), i)) {
            let s = this.langiumDocuments.getDocument(i)
            if (s && s.state > t) return Promise.resolve(i)
          }
          return this.currentState >= t
            ? Promise.resolve(void 0)
            : n.isCancellationRequested
              ? Promise.reject(Vo)
              : new Promise((s, o) => {
                  let l = this.onBuildPhase(t, () => {
                      if ((l.dispose(), u.dispose(), i)) {
                        let h = this.langiumDocuments.getDocument(i)
                        s(h?.uri)
                      } else s(void 0)
                    }),
                    u = n.onCancellationRequested(() => {
                      l.dispose(), u.dispose(), o(Vo)
                    })
                })
        }
        async notifyDocumentPhase(t, r, n) {
          let s = this.documentPhaseListeners.get(r).slice()
          for (let o of s)
            try {
              await o(t, n)
            } catch (l) {
              if (!zo(l)) throw l
            }
        }
        async notifyBuildPhase(t, r, n) {
          if (t.length === 0) return
          let s = this.buildPhaseListeners.get(r).slice()
          for (let o of s) await Sn(n), await o(t, n)
        }
        shouldValidate(t) {
          return !!this.getBuildOptions(t).validation
        }
        async validate(t, r) {
          var n, i
          let s = this.serviceRegistry.getServices(t.uri).validation.DocumentValidator,
            o = this.getBuildOptions(t).validation,
            l = typeof o == 'object' ? o : void 0,
            u = await s.validateDocument(t, l, r)
          t.diagnostics ? t.diagnostics.push(...u) : (t.diagnostics = u)
          let h = this.buildState.get(t.uri.toString())
          if (h) {
            ;((n = h.result) !== null && n !== void 0) || (h.result = {})
            let f = (i = l?.categories) !== null && i !== void 0 ? i : hm.all
            h.result.validationChecks ? h.result.validationChecks.push(...f) : (h.result.validationChecks = [...f])
          }
        }
        getBuildOptions(t) {
          var r, n
          return (n = (r = this.buildState.get(t.uri.toString())) === null || r === void 0 ? void 0 : r.options) !==
            null && n !== void 0
            ? n
            : {}
        }
      }
    })
  var py,
    MR = x(() => {
      'use strict'
      zi()
      DS()
      ha()
      ms()
      Wo()
      py = class {
        static {
          a(this, 'DefaultIndexManager')
        }
        constructor(t) {
          ;(this.symbolIndex = new Map()),
            (this.symbolByTypeIndex = new Vh()),
            (this.referenceIndex = new Map()),
            (this.documents = t.workspace.LangiumDocuments),
            (this.serviceRegistry = t.ServiceRegistry),
            (this.astReflection = t.AstReflection)
        }
        findAllReferences(t, r) {
          let n = _i(t).uri,
            i = []
          return (
            this.referenceIndex.forEach((s) => {
              s.forEach((o) => {
                Xi.equals(o.targetUri, n) && o.targetPath === r && i.push(o)
              })
            }),
            kr(i)
          )
        }
        allElements(t, r) {
          let n = kr(this.symbolIndex.keys())
          return r && (n = n.filter((i) => !r || r.has(i))), n.map((i) => this.getFileDescriptions(i, t)).flat()
        }
        getFileDescriptions(t, r) {
          var n
          return r
            ? this.symbolByTypeIndex.get(t, r, () => {
                var s
                return ((s = this.symbolIndex.get(t)) !== null && s !== void 0 ? s : []).filter((l) =>
                  this.astReflection.isSubtype(l.type, r),
                )
              })
            : (n = this.symbolIndex.get(t)) !== null && n !== void 0
              ? n
              : []
        }
        remove(t) {
          let r = t.toString()
          this.symbolIndex.delete(r), this.symbolByTypeIndex.clear(r), this.referenceIndex.delete(r)
        }
        async updateContent(t, r = Ve.CancellationToken.None) {
          let i = await this.serviceRegistry.getServices(t.uri).references.ScopeComputation.computeExports(t, r),
            s = t.uri.toString()
          this.symbolIndex.set(s, i), this.symbolByTypeIndex.clear(s)
        }
        async updateReferences(t, r = Ve.CancellationToken.None) {
          let i = await this.serviceRegistry
            .getServices(t.uri)
            .workspace.ReferenceDescriptionProvider.createDescriptions(t, r)
          this.referenceIndex.set(t.uri.toString(), i)
        }
        isAffected(t, r) {
          let n = this.referenceIndex.get(t.uri.toString())
          return n ? n.some((i) => !i.local && r.has(i.targetUri.toString())) : !1
        }
      }
    })
  var my,
    OR = x(() => {
      'use strict'
      ha()
      fa()
      Wo()
      my = class {
        static {
          a(this, 'DefaultWorkspaceManager')
        }
        constructor(t) {
          ;(this.initialBuildOptions = {}),
            (this._ready = new Hi()),
            (this.serviceRegistry = t.ServiceRegistry),
            (this.langiumDocuments = t.workspace.LangiumDocuments),
            (this.documentBuilder = t.workspace.DocumentBuilder),
            (this.fileSystemProvider = t.workspace.FileSystemProvider),
            (this.mutex = t.workspace.WorkspaceLock)
        }
        get ready() {
          return this._ready.promise
        }
        get workspaceFolders() {
          return this.folders
        }
        initialize(t) {
          var r
          this.folders = (r = t.workspaceFolders) !== null && r !== void 0 ? r : void 0
        }
        initialized(t) {
          return this.mutex.write((r) => {
            var n
            return this.initializeWorkspace((n = this.folders) !== null && n !== void 0 ? n : [], r)
          })
        }
        async initializeWorkspace(t, r = Ve.CancellationToken.None) {
          let n = await this.performStartup(t)
          await Sn(r), await this.documentBuilder.build(n, this.initialBuildOptions, r)
        }
        async performStartup(t) {
          let r = this.serviceRegistry.all.flatMap((s) => s.LanguageMetaData.fileExtensions),
            n = [],
            i = a((s) => {
              n.push(s), this.langiumDocuments.hasDocument(s.uri) || this.langiumDocuments.addDocument(s)
            }, 'collector')
          return (
            await this.loadAdditionalDocuments(t, i),
            await Promise.all(
              t.map((s) => [s, this.getRootFolder(s)]).map(async (s) => this.traverseFolder(...s, r, i)),
            ),
            this._ready.resolve(),
            n
          )
        }
        loadAdditionalDocuments(t, r) {
          return Promise.resolve()
        }
        getRootFolder(t) {
          return Yi.parse(t.uri)
        }
        async traverseFolder(t, r, n, i) {
          let s = await this.fileSystemProvider.readDirectory(r)
          await Promise.all(
            s.map(async (o) => {
              if (this.includeEntry(t, o, n)) {
                if (o.isDirectory) await this.traverseFolder(t, o.uri, n, i)
                else if (o.isFile) {
                  let l = await this.langiumDocuments.getOrCreateDocument(o.uri)
                  i(l)
                }
              }
            }),
          )
        }
        includeEntry(t, r, n) {
          let i = Xi.basename(r.uri)
          if (i.startsWith('.')) return !1
          if (r.isDirectory) return i !== 'node_modules' && i !== 'out'
          if (r.isFile) {
            let s = Xi.extname(r.uri)
            return n.includes(s)
          }
          return !1
        }
      }
    })
  function PS(e) {
    return Array.isArray(e) && (e.length === 0 || 'name' in e[0])
  }
  function BR(e) {
    return e && 'modes' in e && 'defaultMode' in e
  }
  function PR(e) {
    return !PS(e) && !BR(e)
  }
  var gy,
    OS,
    Wh,
    BS = x(() => {
      'use strict'
      jc()
      ;(gy = class {
        static {
          a(this, 'DefaultLexerErrorMessageProvider')
        }
        buildUnexpectedCharactersMessage(t, r, n, i, s) {
          return Pp.buildUnexpectedCharactersMessage(t, r, n, i, s)
        }
        buildUnableToPopLexerModeMessage(t) {
          return Pp.buildUnableToPopLexerModeMessage(t)
        }
      }),
        (OS = { mode: 'full' }),
        (Wh = class {
          static {
            a(this, 'DefaultLexer')
          }
          constructor(t) {
            ;(this.errorMessageProvider = t.parser.LexerErrorMessageProvider),
              (this.tokenBuilder = t.parser.TokenBuilder)
            let r = this.tokenBuilder.buildTokens(t.Grammar, { caseInsensitive: t.LanguageMetaData.caseInsensitive })
            this.tokenTypes = this.toTokenTypeDictionary(r)
            let n = PR(r) ? Object.values(r) : r,
              i = t.LanguageMetaData.mode === 'production'
            this.chevrotainLexer = new en(n, {
              positionTracking: 'full',
              skipValidations: i,
              errorMessageProvider: this.errorMessageProvider,
            })
          }
          get definition() {
            return this.tokenTypes
          }
          tokenize(t, r = OS) {
            var n, i, s
            let o = this.chevrotainLexer.tokenize(t)
            return {
              tokens: o.tokens,
              errors: o.errors,
              hidden: (n = o.groups.hidden) !== null && n !== void 0 ? n : [],
              report: (s = (i = this.tokenBuilder).flushLexingReport) === null || s === void 0 ? void 0 : s.call(i, t),
            }
          }
          toTokenTypeDictionary(t) {
            if (PR(t)) return t
            let r = BR(t) ? Object.values(t.modes).flat() : t,
              n = {}
            return r.forEach((i) => (n[i.name] = i)), n
          }
        })
      a(PS, 'isTokenTypeArray')
      a(BR, 'isIMultiModeLexerDefinition')
      a(PR, 'isTokenTypeDictionary')
    })
  function GR(e, t, r) {
    let n, i
    typeof e == 'string' ? ((i = t), (n = r)) : ((i = e.range.start), (n = t)), i || (i = gr.create(0, 0))
    let s = utt(e),
      o = zR(n),
      l = VAt({ lines: s, position: i, options: o })
    return qAt({ index: 0, tokens: l, position: i })
  }
  function VR(e, t) {
    let r = zR(t),
      n = utt(e)
    if (n.length === 0) return !1
    let i = n[0],
      s = n[n.length - 1],
      o = r.start,
      l = r.end
    return !!o?.exec(i) && !!l?.exec(s)
  }
  function utt(e) {
    let t = ''
    return typeof e == 'string' ? (t = e) : (t = e.text), t.split(P6)
  }
  function VAt(e) {
    var t, r, n
    let i = [],
      s = e.position.line,
      o = e.position.character
    for (let l = 0; l < e.lines.length; l++) {
      let u = l === 0,
        h = l === e.lines.length - 1,
        f = e.lines[l],
        d = 0
      if (u && e.options.start) {
        let m = (t = e.options.start) === null || t === void 0 ? void 0 : t.exec(f)
        m && (d = m.index + m[0].length)
      } else {
        let m = (r = e.options.line) === null || r === void 0 ? void 0 : r.exec(f)
        m && (d = m.index + m[0].length)
      }
      if (h) {
        let m = (n = e.options.end) === null || n === void 0 ? void 0 : n.exec(f)
        m && (f = f.substring(0, m.index))
      }
      if (((f = f.substring(0, jAt(f))), $R(f, d) >= f.length)) {
        if (i.length > 0) {
          let m = gr.create(s, o)
          i.push({ type: 'break', content: '', range: sr.create(m, m) })
        }
      } else {
        ltt.lastIndex = d
        let m = ltt.exec(f)
        if (m) {
          let g = m[0],
            y = m[1],
            b = gr.create(s, o + d),
            k = gr.create(s, o + d + g.length)
          i.push({ type: 'tag', content: y, range: sr.create(b, k) }), (d += g.length), (d = $R(f, d))
        }
        if (d < f.length) {
          let g = f.substring(d),
            y = Array.from(g.matchAll(GAt))
          i.push(...zAt(y, g, s, o + d))
        }
      }
      s++, (o = 0)
    }
    return i.length > 0 && i[i.length - 1].type === 'break' ? i.slice(0, -1) : i
  }
  function zAt(e, t, r, n) {
    let i = []
    if (e.length === 0) {
      let s = gr.create(r, n),
        o = gr.create(r, n + t.length)
      i.push({ type: 'text', content: t, range: sr.create(s, o) })
    } else {
      let s = 0
      for (let l of e) {
        let u = l.index,
          h = t.substring(s, u)
        h.length > 0 &&
          i.push({
            type: 'text',
            content: t.substring(s, u),
            range: sr.create(gr.create(r, s + n), gr.create(r, u + n)),
          })
        let f = h.length + 1,
          d = l[1]
        if (
          (i.push({
            type: 'inline-tag',
            content: d,
            range: sr.create(gr.create(r, s + f + n), gr.create(r, s + f + d.length + n)),
          }),
          (f += d.length),
          l.length === 4)
        ) {
          f += l[2].length
          let p = l[3]
          i.push({
            type: 'text',
            content: p,
            range: sr.create(gr.create(r, s + f + n), gr.create(r, s + f + p.length + n)),
          })
        } else i.push({ type: 'text', content: '', range: sr.create(gr.create(r, s + f + n), gr.create(r, s + f + n)) })
        s = u + l[0].length
      }
      let o = t.substring(s)
      o.length > 0 &&
        i.push({ type: 'text', content: o, range: sr.create(gr.create(r, s + n), gr.create(r, s + n + o.length)) })
    }
    return i
  }
  function $R(e, t) {
    let r = e.substring(t).match(WAt)
    return r ? t + r.index : e.length
  }
  function jAt(e) {
    let t = e.match(UAt)
    if (t && typeof t.index == 'number') return t.index
  }
  function qAt(e) {
    var t, r, n, i
    let s = gr.create(e.position.line, e.position.character)
    if (e.tokens.length === 0) return new FS([], sr.create(s, s))
    let o = []
    for (; e.index < e.tokens.length; ) {
      let h = HAt(e, o[o.length - 1])
      h && o.push(h)
    }
    let l = (r = (t = o[0]) === null || t === void 0 ? void 0 : t.range.start) !== null && r !== void 0 ? r : s,
      u = (i = (n = o[o.length - 1]) === null || n === void 0 ? void 0 : n.range.end) !== null && i !== void 0 ? i : s
    return new FS(o, sr.create(l, u))
  }
  function HAt(e, t) {
    let r = e.tokens[e.index]
    if (r.type === 'tag') return ftt(e, !1)
    if (r.type === 'text' || r.type === 'inline-tag') return htt(e)
    YAt(r, t), e.index++
  }
  function YAt(e, t) {
    if (t) {
      let r = new $S('', e.range)
      'inlines' in t ? t.inlines.push(r) : t.content.inlines.push(r)
    }
  }
  function htt(e) {
    let t = e.tokens[e.index],
      r = t,
      n = t,
      i = []
    for (; t && t.type !== 'break' && t.type !== 'tag'; ) i.push(XAt(e)), (n = t), (t = e.tokens[e.index])
    return new xy(i, sr.create(r.range.start, n.range.end))
  }
  function XAt(e) {
    return e.tokens[e.index].type === 'inline-tag' ? ftt(e, !0) : dtt(e)
  }
  function ftt(e, t) {
    let r = e.tokens[e.index++],
      n = r.content.substring(1),
      i = e.tokens[e.index]
    if (i?.type === 'text')
      if (t) {
        let s = dtt(e)
        return new yy(n, new xy([s], s.range), t, sr.create(r.range.start, s.range.end))
      } else {
        let s = htt(e)
        return new yy(n, s, t, sr.create(r.range.start, s.range.end))
      }
    else {
      let s = r.range
      return new yy(n, new xy([], s), t, s)
    }
  }
  function dtt(e) {
    let t = e.tokens[e.index++]
    return new $S(t.content, t.range)
  }
  function zR(e) {
    if (!e) return zR({ start: '/**', end: '*/', line: '*' })
    let { start: t, end: r, line: n } = e
    return { start: FR(t, !0), end: FR(r, !1), line: FR(n, !0) }
  }
  function FR(e, t) {
    if (typeof e == 'string' || typeof e == 'object') {
      let r = typeof e == 'string' ? vh(e) : e.source
      return t ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`)
    } else return e
  }
  function KAt(e, t, r) {
    var n, i
    if (e === 'linkplain' || e === 'linkcode' || e === 'link') {
      let s = t.indexOf(' '),
        o = t
      if (s > 0) {
        let u = $R(t, s)
        ;(o = t.substring(u)), (t = t.substring(0, s))
      }
      return (
        (e === 'linkcode' || (e === 'link' && r.link === 'code')) && (o = `\`${o}\``),
        (i = (n = r.renderLink) === null || n === void 0 ? void 0 : n.call(r, t, o)) !== null && i !== void 0
          ? i
          : QAt(t, o)
      )
    }
  }
  function QAt(e, t) {
    try {
      return Yi.parse(e, !0), `[${t}](${e})`
    } catch {
      return e
    }
  }
  function ctt(e) {
    return e.endsWith(`
`)
      ? `
`
      : `

`
  }
  var ltt,
    GAt,
    WAt,
    UAt,
    FS,
    yy,
    xy,
    $S,
    WR = x(() => {
      'use strict'
      ZL()
      wp()
      Wo()
      a(GR, 'parseJSDoc')
      a(VR, 'isJSDoc')
      a(utt, 'getLines')
      ;(ltt = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy), (GAt = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu)
      a(VAt, 'tokenize')
      a(zAt, 'buildInlineTokens')
      ;(WAt = /\S/), (UAt = /\s*$/)
      a($R, 'skipWhitespace')
      a(jAt, 'lastCharacter')
      a(qAt, 'parseJSDocComment')
      a(HAt, 'parseJSDocElement')
      a(YAt, 'appendEmptyLine')
      a(htt, 'parseJSDocText')
      a(XAt, 'parseJSDocInline')
      a(ftt, 'parseJSDocTag')
      a(dtt, 'parseJSDocLine')
      a(zR, 'normalizeOptions')
      a(FR, 'normalizeOption')
      ;(FS = class {
        static {
          a(this, 'JSDocCommentImpl')
        }
        constructor(t, r) {
          ;(this.elements = t), (this.range = r)
        }
        getTag(t) {
          return this.getAllTags().find((r) => r.name === t)
        }
        getTags(t) {
          return this.getAllTags().filter((r) => r.name === t)
        }
        getAllTags() {
          return this.elements.filter((t) => 'name' in t)
        }
        toString() {
          let t = ''
          for (let r of this.elements)
            if (t.length === 0) t = r.toString()
            else {
              let n = r.toString()
              t += ctt(t) + n
            }
          return t.trim()
        }
        toMarkdown(t) {
          let r = ''
          for (let n of this.elements)
            if (r.length === 0) r = n.toMarkdown(t)
            else {
              let i = n.toMarkdown(t)
              r += ctt(r) + i
            }
          return r.trim()
        }
      }),
        (yy = class {
          static {
            a(this, 'JSDocTagImpl')
          }
          constructor(t, r, n, i) {
            ;(this.name = t), (this.content = r), (this.inline = n), (this.range = i)
          }
          toString() {
            let t = `@${this.name}`,
              r = this.content.toString()
            return (
              this.content.inlines.length === 1
                ? (t = `${t} ${r}`)
                : this.content.inlines.length > 1 &&
                  (t = `${t}
${r}`),
              this.inline ? `{${t}}` : t
            )
          }
          toMarkdown(t) {
            var r, n
            return (n = (r = t?.renderTag) === null || r === void 0 ? void 0 : r.call(t, this)) !== null && n !== void 0
              ? n
              : this.toMarkdownDefault(t)
          }
          toMarkdownDefault(t) {
            let r = this.content.toMarkdown(t)
            if (this.inline) {
              let s = KAt(this.name, r, t ?? {})
              if (typeof s == 'string') return s
            }
            let n = ''
            t?.tag === 'italic' || t?.tag === void 0
              ? (n = '*')
              : t?.tag === 'bold'
                ? (n = '**')
                : t?.tag === 'bold-italic' && (n = '***')
            let i = `${n}@${this.name}${n}`
            return (
              this.content.inlines.length === 1
                ? (i = `${i} \u2014 ${r}`)
                : this.content.inlines.length > 1 &&
                  (i = `${i}
${r}`),
              this.inline ? `{${i}}` : i
            )
          }
        })
      a(KAt, 'renderInlineTag')
      a(QAt, 'renderLinkDefault')
      ;(xy = class {
        static {
          a(this, 'JSDocTextImpl')
        }
        constructor(t, r) {
          ;(this.inlines = t), (this.range = r)
        }
        toString() {
          let t = ''
          for (let r = 0; r < this.inlines.length; r++) {
            let n = this.inlines[r],
              i = this.inlines[r + 1]
            ;(t += n.toString()),
              i &&
                i.range.start.line > n.range.start.line &&
                (t += `
`)
          }
          return t
        }
        toMarkdown(t) {
          let r = ''
          for (let n = 0; n < this.inlines.length; n++) {
            let i = this.inlines[n],
              s = this.inlines[n + 1]
            ;(r += i.toMarkdown(t)),
              s &&
                s.range.start.line > i.range.start.line &&
                (r += `
`)
          }
          return r
        }
      }),
        ($S = class {
          static {
            a(this, 'JSDocLineImpl')
          }
          constructor(t, r) {
            ;(this.text = t), (this.range = r)
          }
          toString() {
            return this.text
          }
          toMarkdown() {
            return this.text
          }
        })
      a(ctt, 'fillNewlines')
    })
  var by,
    UR = x(() => {
      'use strict'
      zi()
      WR()
      by = class {
        static {
          a(this, 'JSDocDocumentationProvider')
        }
        constructor(t) {
          ;(this.indexManager = t.shared.workspace.IndexManager),
            (this.commentProvider = t.documentation.CommentProvider)
        }
        getDocumentation(t) {
          let r = this.commentProvider.getComment(t)
          if (r && VR(r))
            return GR(r).toMarkdown({
              renderLink: a((i, s) => this.documentationLinkRenderer(t, i, s), 'renderLink'),
              renderTag: a((i) => this.documentationTagRenderer(t, i), 'renderTag'),
            })
        }
        documentationLinkRenderer(t, r, n) {
          var i
          let s =
            (i = this.findNameInPrecomputedScopes(t, r)) !== null && i !== void 0 ? i : this.findNameInGlobalScope(t, r)
          if (s && s.nameSegment) {
            let o = s.nameSegment.range.start.line + 1,
              l = s.nameSegment.range.start.character + 1,
              u = s.documentUri.with({ fragment: `L${o},${l}` })
            return `[${n}](${u.toString()})`
          } else return
        }
        documentationTagRenderer(t, r) {}
        findNameInPrecomputedScopes(t, r) {
          let i = _i(t).precomputedScopes
          if (!i) return
          let s = t
          do {
            let l = i.get(s).find((u) => u.name === r)
            if (l) return l
            s = s.$container
          } while (s)
        }
        findNameInGlobalScope(t, r) {
          return this.indexManager.allElements().find((i) => i.name === r)
        }
      }
    })
  var ky,
    jR = x(() => {
      'use strict'
      NS()
      Wa()
      ky = class {
        static {
          a(this, 'DefaultCommentProvider')
        }
        constructor(t) {
          this.grammarConfig = () => t.parser.GrammarConfig
        }
        getComment(t) {
          var r
          return ER(t)
            ? t.$comment
            : (r = u6(t.$cstNode, this.grammarConfig().multilineCommentRules)) === null || r === void 0
              ? void 0
              : r.text
        }
      }
    })
  var Ty,
    qR,
    HR,
    YR = x(() => {
      'use strict'
      fa()
      MS()
      ;(Ty = class {
        static {
          a(this, 'DefaultAsyncParser')
        }
        constructor(t) {
          this.syncParser = t.parser.LangiumParser
        }
        parse(t, r) {
          return Promise.resolve(this.syncParser.parse(t))
        }
      }),
        (qR = class {
          static {
            a(this, 'AbstractThreadedAsyncParser')
          }
          constructor(t) {
            ;(this.threadCount = 8),
              (this.terminationDelay = 200),
              (this.workerPool = []),
              (this.queue = []),
              (this.hydrator = t.serializer.Hydrator)
          }
          initializeWorkers() {
            for (; this.workerPool.length < this.threadCount; ) {
              let t = this.createWorker()
              t.onReady(() => {
                if (this.queue.length > 0) {
                  let r = this.queue.shift()
                  r && (t.lock(), r.resolve(t))
                }
              }),
                this.workerPool.push(t)
            }
          }
          async parse(t, r) {
            let n = await this.acquireParserWorker(r),
              i = new Hi(),
              s,
              o = r.onCancellationRequested(() => {
                s = setTimeout(() => {
                  this.terminateWorker(n)
                }, this.terminationDelay)
              })
            return (
              n
                .parse(t)
                .then((l) => {
                  let u = this.hydrator.hydrate(l)
                  i.resolve(u)
                })
                .catch((l) => {
                  i.reject(l)
                })
                .finally(() => {
                  o.dispose(), clearTimeout(s)
                }),
              i.promise
            )
          }
          terminateWorker(t) {
            t.terminate()
            let r = this.workerPool.indexOf(t)
            r >= 0 && this.workerPool.splice(r, 1)
          }
          async acquireParserWorker(t) {
            this.initializeWorkers()
            for (let n of this.workerPool) if (n.ready) return n.lock(), n
            let r = new Hi()
            return (
              t.onCancellationRequested(() => {
                let n = this.queue.indexOf(r)
                n >= 0 && this.queue.splice(n, 1), r.reject(Vo)
              }),
              this.queue.push(r),
              r.promise
            )
          }
        }),
        (HR = class {
          static {
            a(this, 'ParserWorker')
          }
          get ready() {
            return this._ready
          }
          get onReady() {
            return this.onReadyEmitter.event
          }
          constructor(t, r, n, i) {
            ;(this.onReadyEmitter = new nn.Emitter()),
              (this.deferred = new Hi()),
              (this._ready = !0),
              (this._parsing = !1),
              (this.sendMessage = t),
              (this._terminate = i),
              r((s) => {
                let o = s
                this.deferred.resolve(o), this.unlock()
              }),
              n((s) => {
                this.deferred.reject(s), this.unlock()
              })
          }
          terminate() {
            this.deferred.reject(Vo), this._terminate()
          }
          lock() {
            this._ready = !1
          }
          unlock() {
            ;(this._parsing = !1), (this._ready = !0), this.onReadyEmitter.fire()
          }
          parse(t) {
            if (this._parsing) throw new Error('Parser worker is busy')
            return (this._parsing = !0), (this.deferred = new Hi()), this.sendMessage(t), this.deferred.promise
          }
        })
    })
  var Sy,
    XR = x(() => {
      'use strict'
      ha()
      fa()
      Sy = class {
        static {
          a(this, 'DefaultWorkspaceLock')
        }
        constructor() {
          ;(this.previousTokenSource = new Ve.CancellationTokenSource()),
            (this.writeQueue = []),
            (this.readQueue = []),
            (this.done = !0)
        }
        write(t) {
          this.cancelWrite()
          let r = AS()
          return (this.previousTokenSource = r), this.enqueue(this.writeQueue, t, r.token)
        }
        read(t) {
          return this.enqueue(this.readQueue, t)
        }
        enqueue(t, r, n = Ve.CancellationToken.None) {
          let i = new Hi(),
            s = { action: r, deferred: i, cancellationToken: n }
          return t.push(s), this.performNextOperation(), i.promise
        }
        async performNextOperation() {
          if (!this.done) return
          let t = []
          if (this.writeQueue.length > 0) t.push(this.writeQueue.shift())
          else if (this.readQueue.length > 0) t.push(...this.readQueue.splice(0, this.readQueue.length))
          else return
          ;(this.done = !1),
            await Promise.all(
              t.map(async ({ action: r, deferred: n, cancellationToken: i }) => {
                try {
                  let s = await Promise.resolve().then(() => r(i))
                  n.resolve(s)
                } catch (s) {
                  zo(s) ? n.resolve(void 0) : n.reject(s)
                }
              }),
            ),
            (this.done = !0),
            this.performNextOperation()
        }
        cancelWrite() {
          this.previousTokenSource.cancel()
        }
      }
    })
  var _y,
    KR = x(() => {
      'use strict'
      xS()
      Po()
      za()
      zi()
      om()
      Wa()
      _y = class {
        static {
          a(this, 'DefaultHydrator')
        }
        constructor(t) {
          ;(this.grammarElementIdMap = new Gh()),
            (this.tokenTypeIdMap = new Gh()),
            (this.grammar = t.Grammar),
            (this.lexer = t.parser.Lexer),
            (this.linker = t.references.Linker)
        }
        dehydrate(t) {
          return {
            lexerErrors: t.lexerErrors,
            lexerReport: t.lexerReport ? this.dehydrateLexerReport(t.lexerReport) : void 0,
            parserErrors: t.parserErrors.map((r) => Object.assign(Object.assign({}, r), { message: r.message })),
            value: this.dehydrateAstNode(t.value, this.createDehyrationContext(t.value)),
          }
        }
        dehydrateLexerReport(t) {
          return t
        }
        createDehyrationContext(t) {
          let r = new Map(),
            n = new Map()
          for (let i of ua(t)) r.set(i, {})
          if (t.$cstNode) for (let i of xh(t.$cstNode)) n.set(i, {})
          return { astNodes: r, cstNodes: n }
        }
        dehydrateAstNode(t, r) {
          let n = r.astNodes.get(t)
          ;(n.$type = t.$type),
            (n.$containerIndex = t.$containerIndex),
            (n.$containerProperty = t.$containerProperty),
            t.$cstNode !== void 0 && (n.$cstNode = this.dehydrateCstNode(t.$cstNode, r))
          for (let [i, s] of Object.entries(t))
            if (!i.startsWith('$'))
              if (Array.isArray(s)) {
                let o = []
                n[i] = o
                for (let l of s)
                  un(l)
                    ? o.push(this.dehydrateAstNode(l, r))
                    : ci(l)
                      ? o.push(this.dehydrateReference(l, r))
                      : o.push(l)
              } else
                un(s)
                  ? (n[i] = this.dehydrateAstNode(s, r))
                  : ci(s)
                    ? (n[i] = this.dehydrateReference(s, r))
                    : s !== void 0 && (n[i] = s)
          return n
        }
        dehydrateReference(t, r) {
          let n = {}
          return (n.$refText = t.$refText), t.$refNode && (n.$refNode = r.cstNodes.get(t.$refNode)), n
        }
        dehydrateCstNode(t, r) {
          let n = r.cstNodes.get(t)
          return (
            K0(t) ? (n.fullText = t.fullText) : (n.grammarSource = this.getGrammarElementId(t.grammarSource)),
            (n.hidden = t.hidden),
            (n.astNode = r.astNodes.get(t.astNode)),
            Va(t)
              ? (n.content = t.content.map((i) => this.dehydrateCstNode(i, r)))
              : Vc(t) &&
                ((n.tokenType = t.tokenType.name),
                (n.offset = t.offset),
                (n.length = t.length),
                (n.startLine = t.range.start.line),
                (n.startColumn = t.range.start.character),
                (n.endLine = t.range.end.line),
                (n.endColumn = t.range.end.character)),
            n
          )
        }
        hydrate(t) {
          let r = t.value,
            n = this.createHydrationContext(r)
          return (
            '$cstNode' in r && this.hydrateCstNode(r.$cstNode, n),
            {
              lexerErrors: t.lexerErrors,
              lexerReport: t.lexerReport,
              parserErrors: t.parserErrors,
              value: this.hydrateAstNode(r, n),
            }
          )
        }
        createHydrationContext(t) {
          let r = new Map(),
            n = new Map()
          for (let s of ua(t)) r.set(s, {})
          let i
          if (t.$cstNode)
            for (let s of xh(t.$cstNode)) {
              let o
              'fullText' in s
                ? ((o = new tm(s.fullText)), (i = o))
                : 'content' in s
                  ? (o = new Bh())
                  : 'tokenType' in s && (o = this.hydrateCstLeafNode(s)),
                o && (n.set(s, o), (o.root = i))
            }
          return { astNodes: r, cstNodes: n }
        }
        hydrateAstNode(t, r) {
          let n = r.astNodes.get(t)
          ;(n.$type = t.$type),
            (n.$containerIndex = t.$containerIndex),
            (n.$containerProperty = t.$containerProperty),
            t.$cstNode && (n.$cstNode = r.cstNodes.get(t.$cstNode))
          for (let [i, s] of Object.entries(t))
            if (!i.startsWith('$'))
              if (Array.isArray(s)) {
                let o = []
                n[i] = o
                for (let l of s)
                  un(l)
                    ? o.push(this.setParent(this.hydrateAstNode(l, r), n))
                    : ci(l)
                      ? o.push(this.hydrateReference(l, n, i, r))
                      : o.push(l)
              } else
                un(s)
                  ? (n[i] = this.setParent(this.hydrateAstNode(s, r), n))
                  : ci(s)
                    ? (n[i] = this.hydrateReference(s, n, i, r))
                    : s !== void 0 && (n[i] = s)
          return n
        }
        setParent(t, r) {
          return (t.$container = r), t
        }
        hydrateReference(t, r, n, i) {
          return this.linker.buildReference(r, n, i.cstNodes.get(t.$refNode), t.$refText)
        }
        hydrateCstNode(t, r, n = 0) {
          let i = r.cstNodes.get(t)
          if (
            (typeof t.grammarSource == 'number' && (i.grammarSource = this.getGrammarElement(t.grammarSource)),
            (i.astNode = r.astNodes.get(t.astNode)),
            Va(i))
          )
            for (let s of t.content) {
              let o = this.hydrateCstNode(s, r, n++)
              i.content.push(o)
            }
          return i
        }
        hydrateCstLeafNode(t) {
          let r = this.getTokenType(t.tokenType),
            n = t.offset,
            i = t.length,
            s = t.startLine,
            o = t.startColumn,
            l = t.endLine,
            u = t.endColumn,
            h = t.hidden
          return new Ph(n, i, { start: { line: s, character: o }, end: { line: l, character: u } }, r, h)
        }
        getTokenType(t) {
          return this.lexer.definition[t]
        }
        getGrammarElementId(t) {
          if (t)
            return (
              this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.get(t)
            )
        }
        getGrammarElement(t) {
          return (
            this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.getKey(t)
          )
        }
        createGrammarElementIdMap() {
          let t = 0
          for (let r of ua(this.grammar)) i1(r) && this.grammarElementIdMap.set(r, t++)
        }
      }
    })
  function ui(e) {
    return {
      documentation: {
        CommentProvider: a((t) => new ky(t), 'CommentProvider'),
        DocumentationProvider: a((t) => new by(t), 'DocumentationProvider'),
      },
      parser: {
        AsyncParser: a((t) => new Ty(t), 'AsyncParser'),
        GrammarConfig: a((t) => Q6(t), 'GrammarConfig'),
        LangiumParser: a((t) => sR(t), 'LangiumParser'),
        CompletionParser: a((t) => nR(t), 'CompletionParser'),
        ValueConverter: a(() => new $h(), 'ValueConverter'),
        TokenBuilder: a(() => new Nl(), 'TokenBuilder'),
        Lexer: a((t) => new Wh(t), 'Lexer'),
        ParserErrorMessageProvider: a(() => new em(), 'ParserErrorMessageProvider'),
        LexerErrorMessageProvider: a(() => new gy(), 'LexerErrorMessageProvider'),
      },
      workspace: {
        AstNodeLocator: a(() => new hy(), 'AstNodeLocator'),
        AstNodeDescriptionProvider: a((t) => new cy(t), 'AstNodeDescriptionProvider'),
        ReferenceDescriptionProvider: a((t) => new uy(t), 'ReferenceDescriptionProvider'),
      },
      references: {
        Linker: a((t) => new Q1(t), 'Linker'),
        NameProvider: a(() => new Z1(), 'NameProvider'),
        ScopeProvider: a((t) => new ny(t), 'ScopeProvider'),
        ScopeComputation: a((t) => new ty(t), 'ScopeComputation'),
        References: a((t) => new J1(t), 'References'),
      },
      serializer: { Hydrator: a((t) => new _y(t), 'Hydrator'), JsonSerializer: a((t) => new iy(t), 'JsonSerializer') },
      validation: {
        DocumentValidator: a((t) => new ly(t), 'DocumentValidator'),
        ValidationRegistry: a((t) => new ay(t), 'ValidationRegistry'),
      },
      shared: a(() => e.shared, 'shared'),
    }
  }
  function hi(e) {
    return {
      ServiceRegistry: a((t) => new sy(t), 'ServiceRegistry'),
      workspace: {
        LangiumDocuments: a((t) => new K1(t), 'LangiumDocuments'),
        LangiumDocumentFactory: a((t) => new X1(t), 'LangiumDocumentFactory'),
        DocumentBuilder: a((t) => new dy(t), 'DocumentBuilder'),
        IndexManager: a((t) => new py(t), 'IndexManager'),
        WorkspaceManager: a((t) => new my(t), 'WorkspaceManager'),
        FileSystemProvider: a((t) => e.fileSystemProvider(t), 'FileSystemProvider'),
        WorkspaceLock: a(() => new Sy(), 'WorkspaceLock'),
        ConfigurationProvider: a((t) => new fy(t), 'ConfigurationProvider'),
      },
    }
  }
  var QR = x(() => {
    'use strict'
    Z6()
    iR()
    aR()
    _S()
    oR()
    kR()
    TR()
    SR()
    _R()
    wR()
    NS()
    vR()
    AR()
    oy()
    LR()
    RR()
    DR()
    IR()
    am()
    MR()
    OR()
    BS()
    UR()
    jR()
    H1()
    YR()
    XR()
    KR()
    a(ui, 'createDefaultCoreModule')
    a(hi, 'createDefaultSharedCoreModule')
  })
  function Xr(e, t, r, n, i, s, o, l, u) {
    let h = [e, t, r, n, i, s, o, l, u].reduce(GS, {})
    return xtt(h)
  }
  function ytt(e) {
    if (e && e[gtt]) for (let t of Object.values(e)) ytt(t)
    return e
  }
  function xtt(e, t) {
    let r = new Proxy(
      {},
      {
        deleteProperty: a(() => !1, 'deleteProperty'),
        set: a(() => {
          throw new Error('Cannot set property on injected service container')
        }, 'set'),
        get: a((n, i) => (i === gtt ? !0 : mtt(n, i, e, t || r)), 'get'),
        getOwnPropertyDescriptor: a(
          (n, i) => (mtt(n, i, e, t || r), Object.getOwnPropertyDescriptor(n, i)),
          'getOwnPropertyDescriptor',
        ),
        has: a((n, i) => i in e, 'has'),
        ownKeys: a(() => [...Object.getOwnPropertyNames(e)], 'ownKeys'),
      },
    )
    return r
  }
  function mtt(e, t, r, n) {
    if (t in e) {
      if (e[t] instanceof Error)
        throw new Error('Construction failure. Please make sure that your dependencies are constructable.', {
          cause: e[t],
        })
      if (e[t] === ptt)
        throw new Error(
          'Cycle detected. Please make "' +
            String(t) +
            '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies',
        )
      return e[t]
    } else if (t in r) {
      let i = r[t]
      e[t] = ptt
      try {
        e[t] = typeof i == 'function' ? i(n) : xtt(i, n)
      } catch (s) {
        throw ((e[t] = s instanceof Error ? s : void 0), s)
      }
      return e[t]
    } else return
  }
  function GS(e, t) {
    if (t) {
      for (let [r, n] of Object.entries(t))
        if (n !== void 0) {
          let i = e[r]
          i !== null && n !== null && typeof i == 'object' && typeof n == 'object' ? (e[r] = GS(i, n)) : (e[r] = n)
        }
    }
    return e
  }
  var ZR,
    gtt,
    ptt,
    JR = x(() => {
      'use strict'
      ;(function (e) {
        e.merge = (t, r) => GS(GS({}, t), r)
      })(ZR || (ZR = {}))
      a(Xr, 'inject')
      gtt = Symbol('isProxy')
      a(ytt, 'eagerLoad')
      a(xtt, '_inject')
      ptt = Symbol()
      a(mtt, '_resolve')
      a(GS, '_merge')
    })
  var btt = x(() => {
    'use strict'
  })
  var ktt = x(() => {
    'use strict'
    jR()
    UR()
    WR()
  })
  var Ttt = x(() => {
    'use strict'
  })
  var Stt = x(() => {
    'use strict'
    Z6()
    Ttt()
  })
  var tD,
    Uh,
    VS,
    eD,
    _tt = x(() => {
      'use strict'
      jc()
      _S()
      BS()
      tD = {
        indentTokenName: 'INDENT',
        dedentTokenName: 'DEDENT',
        whitespaceTokenName: 'WS',
        ignoreIndentationDelimiters: [],
      }
      ;(function (e) {
        ;(e.REGULAR = 'indentation-sensitive'), (e.IGNORE_INDENTATION = 'ignore-indentation')
      })(Uh || (Uh = {}))
      ;(VS = class extends Nl {
        static {
          a(this, 'IndentationAwareTokenBuilder')
        }
        constructor(t = tD) {
          super(),
            (this.indentationStack = [0]),
            (this.whitespaceRegExp = /[ \t]+/y),
            (this.options = Object.assign(Object.assign({}, tD), t)),
            (this.indentTokenType = Wc({
              name: this.options.indentTokenName,
              pattern: this.indentMatcher.bind(this),
              line_breaks: !1,
            })),
            (this.dedentTokenType = Wc({
              name: this.options.dedentTokenName,
              pattern: this.dedentMatcher.bind(this),
              line_breaks: !1,
            }))
        }
        buildTokens(t, r) {
          let n = super.buildTokens(t, r)
          if (!PS(n)) throw new Error('Invalid tokens built by default builder')
          let {
              indentTokenName: i,
              dedentTokenName: s,
              whitespaceTokenName: o,
              ignoreIndentationDelimiters: l,
            } = this.options,
            u,
            h,
            f,
            d = []
          for (let p of n) {
            for (let [m, g] of l)
              p.name === m ? (p.PUSH_MODE = Uh.IGNORE_INDENTATION) : p.name === g && (p.POP_MODE = !0)
            p.name === s ? (u = p) : p.name === i ? (h = p) : p.name === o ? (f = p) : d.push(p)
          }
          if (!u || !h || !f) throw new Error('Some indentation/whitespace tokens not found!')
          return l.length > 0
            ? { modes: { [Uh.REGULAR]: [u, h, ...d, f], [Uh.IGNORE_INDENTATION]: [...d, f] }, defaultMode: Uh.REGULAR }
            : [u, h, f, ...d]
        }
        flushLexingReport(t) {
          let r = super.flushLexingReport(t)
          return Object.assign(Object.assign({}, r), { remainingDedents: this.flushRemainingDedents(t) })
        }
        isStartOfLine(t, r) {
          return (
            r === 0 ||
            `\r
`.includes(t[r - 1])
          )
        }
        matchWhitespace(t, r, n, i) {
          var s
          this.whitespaceRegExp.lastIndex = r
          let o = this.whitespaceRegExp.exec(t)
          return {
            currIndentLevel: (s = o?.[0].length) !== null && s !== void 0 ? s : 0,
            prevIndentLevel: this.indentationStack.at(-1),
            match: o,
          }
        }
        createIndentationTokenInstance(t, r, n, i) {
          let s = this.getLineNumber(r, i)
          return Al(t, n, i, i + n.length, s, s, 1, n.length)
        }
        getLineNumber(t, r) {
          return t.substring(0, r).split(/\r\n|\r|\n/).length
        }
        indentMatcher(t, r, n, i) {
          if (!this.isStartOfLine(t, r)) return null
          let { currIndentLevel: s, prevIndentLevel: o, match: l } = this.matchWhitespace(t, r, n, i)
          return s <= o ? null : (this.indentationStack.push(s), l)
        }
        dedentMatcher(t, r, n, i) {
          var s, o, l, u
          if (!this.isStartOfLine(t, r)) return null
          let { currIndentLevel: h, prevIndentLevel: f, match: d } = this.matchWhitespace(t, r, n, i)
          if (h >= f) return null
          let p = this.indentationStack.lastIndexOf(h)
          if (p === -1)
            return (
              this.diagnostics.push({
                severity: 'error',
                message: `Invalid dedent level ${h} at offset: ${r}. Current indentation stack: ${this.indentationStack}`,
                offset: r,
                length:
                  (o = (s = d?.[0]) === null || s === void 0 ? void 0 : s.length) !== null && o !== void 0 ? o : 0,
                line: this.getLineNumber(t, r),
                column: 1,
              }),
              null
            )
          let m = this.indentationStack.length - p - 1,
            g =
              (u = (l = t.substring(0, r).match(/[\r\n]+$/)) === null || l === void 0 ? void 0 : l[0].length) !==
                null && u !== void 0
                ? u
                : 1
          for (let y = 0; y < m; y++) {
            let b = this.createIndentationTokenInstance(this.dedentTokenType, t, '', r - (g - 1))
            n.push(b), this.indentationStack.pop()
          }
          return null
        }
        buildTerminalToken(t) {
          let r = super.buildTerminalToken(t),
            { indentTokenName: n, dedentTokenName: i, whitespaceTokenName: s } = this.options
          return r.name === n
            ? this.indentTokenType
            : r.name === i
              ? this.dedentTokenType
              : r.name === s
                ? Wc({ name: s, pattern: this.whitespaceRegExp, group: en.SKIPPED })
                : r
        }
        flushRemainingDedents(t) {
          let r = []
          for (; this.indentationStack.length > 1; )
            r.push(this.createIndentationTokenInstance(this.dedentTokenType, t, '', t.length)),
              this.indentationStack.pop()
          return (this.indentationStack = [0]), r
        }
      }),
        (eD = class extends Wh {
          static {
            a(this, 'IndentationAwareLexer')
          }
          constructor(t) {
            if ((super(t), t.parser.TokenBuilder instanceof VS)) this.indentationTokenBuilder = t.parser.TokenBuilder
            else throw new Error('IndentationAwareLexer requires an accompanying IndentationAwareTokenBuilder')
          }
          tokenize(t, r = OS) {
            let n = super.tokenize(t),
              i = n.report
            r?.mode === 'full' && n.tokens.push(...i.remainingDedents), (i.remainingDedents = [])
            let { indentTokenType: s, dedentTokenType: o } = this.indentationTokenBuilder,
              l = s.tokenTypeIdx,
              u = o.tokenTypeIdx,
              h = [],
              f = n.tokens.length - 1
            for (let d = 0; d < f; d++) {
              let p = n.tokens[d],
                m = n.tokens[d + 1]
              if (p.tokenTypeIdx === l && m.tokenTypeIdx === u) {
                d++
                continue
              }
              h.push(p)
            }
            return f >= 0 && h.push(n.tokens[f]), (n.tokens = h), n
          }
        })
    })
  var Ctt = x(() => {
    'use strict'
  })
  var wtt = x(() => {
    'use strict'
    YR()
    iR()
    xS()
    _tt()
    aR()
    H1()
    BS()
    SS()
    Ctt()
    _S()
    oR()
  })
  var Ett = x(() => {
    'use strict'
    kR()
    TR()
    SR()
    CR()
    _R()
    wR()
  })
  var vtt = x(() => {
    'use strict'
    KR()
    NS()
  })
  var zS,
    fi,
    rD = x(() => {
      'use strict'
      ;(zS = class {
        static {
          a(this, 'EmptyFileSystemProvider')
        }
        readFile() {
          throw new Error('No file system is available.')
        }
        async readDirectory() {
          return []
        }
      }),
        (fi = { fileSystemProvider: a(() => new zS(), 'fileSystemProvider') })
    })
  function t5t() {
    let e = Xr(hi(fi), JAt),
      t = Xr(ui({ shared: e }), ZAt)
    return e.ServiceRegistry.register(t), t
  }
  function Uo(e) {
    var t
    let r = t5t(),
      n = r.serializer.JsonSerializer.deserialize(e)
    return (
      r.shared.workspace.LangiumDocumentFactory.fromModel(
        n,
        Yi.parse(`memory://${(t = n.name) !== null && t !== void 0 ? t : 'grammar'}.langium`),
      ),
      n
    )
  }
  var ZAt,
    JAt,
    Att = x(() => {
      'use strict'
      QR()
      JR()
      Po()
      rD()
      Wo()
      ;(ZAt = {
        Grammar: a(() => {}, 'Grammar'),
        LanguageMetaData: a(
          () => ({ caseInsensitive: !1, fileExtensions: ['.langium'], languageId: 'langium' }),
          'LanguageMetaData',
        ),
      }),
        (JAt = { AstReflection: a(() => new Tp(), 'AstReflection') })
      a(t5t, 'createMinimalGrammarServices')
      a(Uo, 'loadGrammarFromJson')
    })
  var ur = {}
  Oe(ur, {
    AstUtils: () => TT,
    BiMap: () => Gh,
    Cancellation: () => Ve,
    ContextCache: () => Vh,
    CstUtils: () => hT,
    DONE_RESULT: () => Ti,
    Deferred: () => Hi,
    Disposable: () => Yc,
    DisposableCache: () => cm,
    DocumentCache: () => RS,
    EMPTY_STREAM: () => Q0,
    ErrorWithLocation: () => kh,
    GrammarUtils: () => ET,
    MultiMap: () => Ya,
    OperationCancelled: () => Vo,
    Reduction: () => Od,
    RegExpUtils: () => CT,
    SimpleCache: () => ry,
    StreamImpl: () => Is,
    TreeStreamImpl: () => Io,
    URI: () => Yi,
    UriUtils: () => Xi,
    WorkspaceCache: () => um,
    assertUnreachable: () => Oo,
    delayNextTick: () => gR,
    interruptAndCheck: () => Sn,
    isOperationCancelled: () => zo,
    loadGrammarFromJson: () => Uo,
    setInterruptionPeriod: () => ZJ,
    startCancelableOperation: () => AS,
    stream: () => kr,
  })
  var Ltt = x(() => {
    'use strict'
    DS()
    MS()
    qe(ur, nn)
    om()
    NR()
    fT()
    Att()
    fa()
    ms()
    Wo()
    zi()
    ha()
    Wa()
    qa()
    wp()
  })
  var Rtt = x(() => {
    'use strict'
    AR()
    oy()
  })
  var Dtt = x(() => {
    'use strict'
    LR()
    RR()
    DR()
    IR()
    am()
    rD()
    MR()
    XR()
    OR()
  })
  var di = {}
  Oe(di, {
    AbstractAstReflection: () => gh,
    AbstractCstNode: () => W1,
    AbstractLangiumParser: () => U1,
    AbstractParserErrorMessageProvider: () => kS,
    AbstractThreadedAsyncParser: () => qR,
    AstUtils: () => TT,
    BiMap: () => Gh,
    Cancellation: () => Ve,
    CompositeCstNodeImpl: () => Bh,
    ContextCache: () => Vh,
    CstNodeBuilder: () => z1,
    CstUtils: () => hT,
    DEFAULT_TOKENIZE_OPTIONS: () => OS,
    DONE_RESULT: () => Ti,
    DatatypeSymbol: () => bS,
    DefaultAstNodeDescriptionProvider: () => cy,
    DefaultAstNodeLocator: () => hy,
    DefaultAsyncParser: () => Ty,
    DefaultCommentProvider: () => ky,
    DefaultConfigurationProvider: () => fy,
    DefaultDocumentBuilder: () => dy,
    DefaultDocumentValidator: () => ly,
    DefaultHydrator: () => _y,
    DefaultIndexManager: () => py,
    DefaultJsonSerializer: () => iy,
    DefaultLangiumDocumentFactory: () => X1,
    DefaultLangiumDocuments: () => K1,
    DefaultLexer: () => Wh,
    DefaultLexerErrorMessageProvider: () => gy,
    DefaultLinker: () => Q1,
    DefaultNameProvider: () => Z1,
    DefaultReferenceDescriptionProvider: () => uy,
    DefaultReferences: () => J1,
    DefaultScopeComputation: () => ty,
    DefaultScopeProvider: () => ny,
    DefaultServiceRegistry: () => sy,
    DefaultTokenBuilder: () => Nl,
    DefaultValueConverter: () => $h,
    DefaultWorkspaceLock: () => Sy,
    DefaultWorkspaceManager: () => my,
    Deferred: () => Hi,
    Disposable: () => Yc,
    DisposableCache: () => cm,
    DocumentCache: () => RS,
    DocumentState: () => Pr,
    DocumentValidator: () => da,
    EMPTY_SCOPE: () => $At,
    EMPTY_STREAM: () => Q0,
    EmptyFileSystem: () => fi,
    EmptyFileSystemProvider: () => zS,
    ErrorWithLocation: () => kh,
    GrammarAST: () => a1,
    GrammarUtils: () => ET,
    IndentationAwareLexer: () => eD,
    IndentationAwareTokenBuilder: () => VS,
    JSDocDocumentationProvider: () => by,
    LangiumCompletionParser: () => q1,
    LangiumParser: () => j1,
    LangiumParserErrorMessageProvider: () => em,
    LeafCstNodeImpl: () => Ph,
    LexingMode: () => Uh,
    MapScope: () => ey,
    Module: () => ZR,
    MultiMap: () => Ya,
    OperationCancelled: () => Vo,
    ParserWorker: () => HR,
    Reduction: () => Od,
    RegExpUtils: () => CT,
    RootCstNodeImpl: () => tm,
    SimpleCache: () => ry,
    StreamImpl: () => Is,
    StreamScope: () => lm,
    TextDocument: () => im,
    TreeStreamImpl: () => Io,
    URI: () => Yi,
    UriUtils: () => Xi,
    ValidationCategory: () => hm,
    ValidationRegistry: () => ay,
    ValueConverter: () => Go,
    WorkspaceCache: () => um,
    assertUnreachable: () => Oo,
    createCompletionParser: () => nR,
    createDefaultCoreModule: () => ui,
    createDefaultSharedCoreModule: () => hi,
    createGrammarConfig: () => Q6,
    createLangiumParser: () => sR,
    createParser: () => Y1,
    delayNextTick: () => gR,
    diagnosticData: () => zh,
    eagerLoad: () => ytt,
    getDiagnosticRange: () => att,
    indentationBuilderDefaultOptions: () => tD,
    inject: () => Xr,
    interruptAndCheck: () => Sn,
    isAstNode: () => un,
    isAstNodeDescription: () => a6,
    isAstNodeWithComment: () => ER,
    isCompositeCstNode: () => Va,
    isIMultiModeLexerDefinition: () => BR,
    isJSDoc: () => VR,
    isLeafCstNode: () => Vc,
    isLinkingError: () => yh,
    isNamed: () => itt,
    isOperationCancelled: () => zo,
    isReference: () => ci,
    isRootCstNode: () => K0,
    isTokenTypeArray: () => PS,
    isTokenTypeDictionary: () => PR,
    loadGrammarFromJson: () => Uo,
    parseJSDoc: () => GR,
    prepareLangiumParser: () => jJ,
    setInterruptionPeriod: () => ZJ,
    startCancelableOperation: () => AS,
    stream: () => kr,
    toDiagnosticData: () => ott,
    toDiagnosticSeverity: () => IS,
  })
  var Bs = x(() => {
    'use strict'
    QR()
    JR()
    vR()
    btt()
    za()
    ktt()
    Stt()
    wtt()
    Ett()
    vtt()
    Ltt()
    qe(di, ur)
    Rtt()
    Dtt()
    Po()
  })
  function $tt(e) {
    return Xa.isInstance(e, Cy)
  }
  function Gtt(e) {
    return Xa.isInstance(e, fm)
  }
  function Vtt(e) {
    return Xa.isInstance(e, dm)
  }
  function ztt(e) {
    return Xa.isInstance(e, pm)
  }
  function Wtt(e) {
    return Xa.isInstance(e, wy)
  }
  function Utt(e) {
    return Xa.isInstance(e, mm)
  }
  function jtt(e) {
    return Xa.isInstance(e, Ey)
  }
  function qtt(e) {
    return Xa.isInstance(e, vy)
  }
  function Htt(e) {
    return Xa.isInstance(e, Ay)
  }
  function Ytt(e) {
    return Xa.isInstance(e, Ly)
  }
  function Xtt(e) {
    return Xa.isInstance(e, Ry)
  }
  var e5t,
    zt,
    fD,
    Cy,
    WS,
    fm,
    US,
    jS,
    nD,
    dm,
    iD,
    sD,
    aD,
    pm,
    oD,
    wy,
    qS,
    lD,
    mm,
    cD,
    Ey,
    vy,
    Ay,
    Ly,
    KS,
    uD,
    Ry,
    hD,
    HS,
    YS,
    XS,
    Ktt,
    Xa,
    Ntt,
    r5t,
    Itt,
    n5t,
    Mtt,
    i5t,
    Ott,
    s5t,
    Ptt,
    a5t,
    Btt,
    o5t,
    Ftt,
    l5t,
    c5t,
    u5t,
    h5t,
    f5t,
    d5t,
    p5t,
    m5t,
    Ki,
    dD,
    pD,
    mD,
    gD,
    yD,
    xD,
    bD,
    g5t,
    y5t,
    x5t,
    b5t,
    Xc,
    Il,
    wi,
    k5t,
    Ei = x(() => {
      'use strict'
      Bs()
      Bs()
      Bs()
      Bs()
      ;(e5t = Object.defineProperty),
        (zt = a((e, t) => e5t(e, 'name', { value: t, configurable: !0 }), '__name')),
        (fD = 'Statement'),
        (Cy = 'Architecture')
      a($tt, 'isArchitecture')
      zt($tt, 'isArchitecture')
      ;(WS = 'Axis'), (fm = 'Branch')
      a(Gtt, 'isBranch')
      zt(Gtt, 'isBranch')
      ;(US = 'Checkout'), (jS = 'CherryPicking'), (nD = 'ClassDefStatement'), (dm = 'Commit')
      a(Vtt, 'isCommit')
      zt(Vtt, 'isCommit')
      ;(iD = 'Curve'), (sD = 'Edge'), (aD = 'Entry'), (pm = 'GitGraph')
      a(ztt, 'isGitGraph')
      zt(ztt, 'isGitGraph')
      ;(oD = 'Group'), (wy = 'Info')
      a(Wtt, 'isInfo')
      zt(Wtt, 'isInfo')
      ;(qS = 'Item'), (lD = 'Junction'), (mm = 'Merge')
      a(Utt, 'isMerge')
      zt(Utt, 'isMerge')
      ;(cD = 'Option'), (Ey = 'Packet')
      a(jtt, 'isPacket')
      zt(jtt, 'isPacket')
      vy = 'PacketBlock'
      a(qtt, 'isPacketBlock')
      zt(qtt, 'isPacketBlock')
      Ay = 'Pie'
      a(Htt, 'isPie')
      zt(Htt, 'isPie')
      Ly = 'PieSection'
      a(Ytt, 'isPieSection')
      zt(Ytt, 'isPieSection')
      ;(KS = 'Radar'), (uD = 'Service'), (Ry = 'Treemap')
      a(Xtt, 'isTreemap')
      zt(Xtt, 'isTreemap')
      ;(hD = 'TreemapRow'),
        (HS = 'Direction'),
        (YS = 'Leaf'),
        (XS = 'Section'),
        (Ktt = class extends gh {
          static {
            a(this, 'MermaidAstReflection')
          }
          static {
            zt(this, 'MermaidAstReflection')
          }
          getAllTypes() {
            return [
              Cy,
              WS,
              fm,
              US,
              jS,
              nD,
              dm,
              iD,
              HS,
              sD,
              aD,
              pm,
              oD,
              wy,
              qS,
              lD,
              YS,
              mm,
              cD,
              Ey,
              vy,
              Ay,
              Ly,
              KS,
              XS,
              uD,
              fD,
              Ry,
              hD,
            ]
          }
          computeIsSubtype(e, t) {
            switch (e) {
              case fm:
              case US:
              case jS:
              case dm:
              case mm:
                return this.isSubtype(fD, t)
              case HS:
                return this.isSubtype(pm, t)
              case YS:
              case XS:
                return this.isSubtype(qS, t)
              default:
                return !1
            }
          }
          getReferenceType(e) {
            let t = `${e.container.$type}:${e.property}`
            switch (t) {
              case 'Entry:axis':
                return WS
              default:
                throw new Error(`${t} is not a valid reference id.`)
            }
          }
          getTypeMetaData(e) {
            switch (e) {
              case Cy:
                return {
                  name: Cy,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'edges', defaultValue: [] },
                    { name: 'groups', defaultValue: [] },
                    { name: 'junctions', defaultValue: [] },
                    { name: 'services', defaultValue: [] },
                    { name: 'title' },
                  ],
                }
              case WS:
                return { name: WS, properties: [{ name: 'label' }, { name: 'name' }] }
              case fm:
                return { name: fm, properties: [{ name: 'name' }, { name: 'order' }] }
              case US:
                return { name: US, properties: [{ name: 'branch' }] }
              case jS:
                return {
                  name: jS,
                  properties: [{ name: 'id' }, { name: 'parent' }, { name: 'tags', defaultValue: [] }],
                }
              case nD:
                return { name: nD, properties: [{ name: 'className' }, { name: 'styleText' }] }
              case dm:
                return {
                  name: dm,
                  properties: [
                    { name: 'id' },
                    { name: 'message' },
                    { name: 'tags', defaultValue: [] },
                    { name: 'type' },
                  ],
                }
              case iD:
                return {
                  name: iD,
                  properties: [{ name: 'entries', defaultValue: [] }, { name: 'label' }, { name: 'name' }],
                }
              case sD:
                return {
                  name: sD,
                  properties: [
                    { name: 'lhsDir' },
                    { name: 'lhsGroup', defaultValue: !1 },
                    { name: 'lhsId' },
                    { name: 'lhsInto', defaultValue: !1 },
                    { name: 'rhsDir' },
                    { name: 'rhsGroup', defaultValue: !1 },
                    { name: 'rhsId' },
                    { name: 'rhsInto', defaultValue: !1 },
                    { name: 'title' },
                  ],
                }
              case aD:
                return { name: aD, properties: [{ name: 'axis' }, { name: 'value' }] }
              case pm:
                return {
                  name: pm,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'statements', defaultValue: [] },
                    { name: 'title' },
                  ],
                }
              case oD:
                return { name: oD, properties: [{ name: 'icon' }, { name: 'id' }, { name: 'in' }, { name: 'title' }] }
              case wy:
                return { name: wy, properties: [{ name: 'accDescr' }, { name: 'accTitle' }, { name: 'title' }] }
              case qS:
                return { name: qS, properties: [{ name: 'classSelector' }, { name: 'name' }] }
              case lD:
                return { name: lD, properties: [{ name: 'id' }, { name: 'in' }] }
              case mm:
                return {
                  name: mm,
                  properties: [
                    { name: 'branch' },
                    { name: 'id' },
                    { name: 'tags', defaultValue: [] },
                    { name: 'type' },
                  ],
                }
              case cD:
                return { name: cD, properties: [{ name: 'name' }, { name: 'value', defaultValue: !1 }] }
              case Ey:
                return {
                  name: Ey,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'blocks', defaultValue: [] },
                    { name: 'title' },
                  ],
                }
              case vy:
                return {
                  name: vy,
                  properties: [{ name: 'bits' }, { name: 'end' }, { name: 'label' }, { name: 'start' }],
                }
              case Ay:
                return {
                  name: Ay,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'sections', defaultValue: [] },
                    { name: 'showData', defaultValue: !1 },
                    { name: 'title' },
                  ],
                }
              case Ly:
                return { name: Ly, properties: [{ name: 'label' }, { name: 'value' }] }
              case KS:
                return {
                  name: KS,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'axes', defaultValue: [] },
                    { name: 'curves', defaultValue: [] },
                    { name: 'options', defaultValue: [] },
                    { name: 'title' },
                  ],
                }
              case uD:
                return {
                  name: uD,
                  properties: [
                    { name: 'icon' },
                    { name: 'iconText' },
                    { name: 'id' },
                    { name: 'in' },
                    { name: 'title' },
                  ],
                }
              case Ry:
                return {
                  name: Ry,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'title' },
                    { name: 'TreemapRows', defaultValue: [] },
                  ],
                }
              case hD:
                return { name: hD, properties: [{ name: 'indent' }, { name: 'item' }] }
              case HS:
                return {
                  name: HS,
                  properties: [
                    { name: 'accDescr' },
                    { name: 'accTitle' },
                    { name: 'dir' },
                    { name: 'statements', defaultValue: [] },
                    { name: 'title' },
                  ],
                }
              case YS:
                return { name: YS, properties: [{ name: 'classSelector' }, { name: 'name' }, { name: 'value' }] }
              case XS:
                return { name: XS, properties: [{ name: 'classSelector' }, { name: 'name' }] }
              default:
                return { name: e, properties: [] }
            }
          }
        }),
        (Xa = new Ktt()),
        (r5t = zt(
          () =>
            Ntt ??
            (Ntt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          'InfoGrammar',
        )),
        (n5t = zt(
          () =>
            Itt ??
            (Itt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          'PacketGrammar',
        )),
        (i5t = zt(
          () =>
            Mtt ??
            (Mtt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          'PieGrammar',
        )),
        (s5t = zt(
          () =>
            Ott ??
            (Ott = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          'ArchitectureGrammar',
        )),
        (a5t = zt(
          () =>
            Ptt ??
            (Ptt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          'GitGraphGrammar',
        )),
        (o5t = zt(
          () =>
            Btt ??
            (Btt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`,
            )),
          'RadarGrammar',
        )),
        (l5t = zt(
          () =>
            Ftt ??
            (Ftt = Uo(
              `{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`,
            )),
          'TreemapGrammar',
        )),
        (c5t = { languageId: 'info', fileExtensions: ['.mmd', '.mermaid'], caseInsensitive: !1, mode: 'production' }),
        (u5t = { languageId: 'packet', fileExtensions: ['.mmd', '.mermaid'], caseInsensitive: !1, mode: 'production' }),
        (h5t = { languageId: 'pie', fileExtensions: ['.mmd', '.mermaid'], caseInsensitive: !1, mode: 'production' }),
        (f5t = {
          languageId: 'architecture',
          fileExtensions: ['.mmd', '.mermaid'],
          caseInsensitive: !1,
          mode: 'production',
        }),
        (d5t = {
          languageId: 'gitGraph',
          fileExtensions: ['.mmd', '.mermaid'],
          caseInsensitive: !1,
          mode: 'production',
        }),
        (p5t = { languageId: 'radar', fileExtensions: ['.mmd', '.mermaid'], caseInsensitive: !1, mode: 'production' }),
        (m5t = {
          languageId: 'treemap',
          fileExtensions: ['.mmd', '.mermaid'],
          caseInsensitive: !1,
          mode: 'production',
        }),
        (Ki = { AstReflection: zt(() => new Ktt(), 'AstReflection') }),
        (dD = { Grammar: zt(() => r5t(), 'Grammar'), LanguageMetaData: zt(() => c5t, 'LanguageMetaData'), parser: {} }),
        (pD = { Grammar: zt(() => n5t(), 'Grammar'), LanguageMetaData: zt(() => u5t, 'LanguageMetaData'), parser: {} }),
        (mD = { Grammar: zt(() => i5t(), 'Grammar'), LanguageMetaData: zt(() => h5t, 'LanguageMetaData'), parser: {} }),
        (gD = { Grammar: zt(() => s5t(), 'Grammar'), LanguageMetaData: zt(() => f5t, 'LanguageMetaData'), parser: {} }),
        (yD = { Grammar: zt(() => a5t(), 'Grammar'), LanguageMetaData: zt(() => d5t, 'LanguageMetaData'), parser: {} }),
        (xD = { Grammar: zt(() => o5t(), 'Grammar'), LanguageMetaData: zt(() => p5t, 'LanguageMetaData'), parser: {} }),
        (bD = { Grammar: zt(() => l5t(), 'Grammar'), LanguageMetaData: zt(() => m5t, 'LanguageMetaData'), parser: {} }),
        (g5t = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/),
        (y5t = /accTitle[\t ]*:([^\n\r]*)/),
        (x5t = /title([\t ][^\n\r]*|)/),
        (b5t = { ACC_DESCR: g5t, ACC_TITLE: y5t, TITLE: x5t }),
        (Xc = class extends $h {
          static {
            a(this, 'AbstractMermaidValueConverter')
          }
          static {
            zt(this, 'AbstractMermaidValueConverter')
          }
          runConverter(e, t, r) {
            let n = this.runCommonConverter(e, t, r)
            return (
              n === void 0 && (n = this.runCustomConverter(e, t, r)), n === void 0 ? super.runConverter(e, t, r) : n
            )
          }
          runCommonConverter(e, t, r) {
            let n = b5t[e.name]
            if (n === void 0) return
            let i = n.exec(t)
            if (i !== null) {
              if (i[1] !== void 0) return i[1].trim().replace(/[\t ]{2,}/gm, ' ')
              if (i[2] !== void 0)
                return i[2]
                  .replace(/^\s*/gm, '')
                  .replace(/\s+$/gm, '')
                  .replace(/[\t ]{2,}/gm, ' ')
                  .replace(
                    /[\n\r]{2,}/gm,
                    `
`,
                  )
            }
          }
        }),
        (Il = class extends Xc {
          static {
            a(this, 'CommonValueConverter')
          }
          static {
            zt(this, 'CommonValueConverter')
          }
          runCustomConverter(e, t, r) {}
        }),
        (wi = class extends Nl {
          static {
            a(this, 'AbstractMermaidTokenBuilder')
          }
          static {
            zt(this, 'AbstractMermaidTokenBuilder')
          }
          constructor(e) {
            super(), (this.keywords = new Set(e))
          }
          buildKeywordTokens(e, t, r) {
            let n = super.buildKeywordTokens(e, t, r)
            return (
              n.forEach((i) => {
                this.keywords.has(i.name) &&
                  i.PATTERN !== void 0 &&
                  (i.PATTERN = new RegExp(i.PATTERN.toString() + '(?:(?=%%)|(?!\\S))'))
              }),
              n
            )
          }
        }),
        (k5t = class extends wi {
          static {
            a(this, 'CommonTokenBuilder')
          }
          static {
            zt(this, 'CommonTokenBuilder')
          }
        })
    })
  function ZS(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), yD, QS)
    return t.ServiceRegistry.register(r), { shared: t, GitGraph: r }
  }
  var T5t,
    QS,
    kD = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(T5t = class extends wi {
        static {
          a(this, 'GitGraphTokenBuilder')
        }
        static {
          zt(this, 'GitGraphTokenBuilder')
        }
        constructor() {
          super(['gitGraph'])
        }
      }),
        (QS = {
          parser: {
            TokenBuilder: zt(() => new T5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new Il(), 'ValueConverter'),
          },
        })
      a(ZS, 'createGitGraphServices')
      zt(ZS, 'createGitGraphServices')
    })
  function t_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), dD, JS)
    return t.ServiceRegistry.register(r), { shared: t, Info: r }
  }
  var S5t,
    JS,
    TD = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(S5t = class extends wi {
        static {
          a(this, 'InfoTokenBuilder')
        }
        static {
          zt(this, 'InfoTokenBuilder')
        }
        constructor() {
          super(['info', 'showInfo'])
        }
      }),
        (JS = {
          parser: {
            TokenBuilder: zt(() => new S5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new Il(), 'ValueConverter'),
          },
        })
      a(t_, 'createInfoServices')
      zt(t_, 'createInfoServices')
    })
  function r_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), pD, e_)
    return t.ServiceRegistry.register(r), { shared: t, Packet: r }
  }
  var _5t,
    e_,
    SD = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(_5t = class extends wi {
        static {
          a(this, 'PacketTokenBuilder')
        }
        static {
          zt(this, 'PacketTokenBuilder')
        }
        constructor() {
          super(['packet'])
        }
      }),
        (e_ = {
          parser: {
            TokenBuilder: zt(() => new _5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new Il(), 'ValueConverter'),
          },
        })
      a(r_, 'createPacketServices')
      zt(r_, 'createPacketServices')
    })
  function i_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), mD, n_)
    return t.ServiceRegistry.register(r), { shared: t, Pie: r }
  }
  var C5t,
    w5t,
    n_,
    _D = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(C5t = class extends wi {
        static {
          a(this, 'PieTokenBuilder')
        }
        static {
          zt(this, 'PieTokenBuilder')
        }
        constructor() {
          super(['pie', 'showData'])
        }
      }),
        (w5t = class extends Xc {
          static {
            a(this, 'PieValueConverter')
          }
          static {
            zt(this, 'PieValueConverter')
          }
          runCustomConverter(e, t, r) {
            if (e.name === 'PIE_SECTION_LABEL') return t.replace(/"/g, '').trim()
          }
        }),
        (n_ = {
          parser: {
            TokenBuilder: zt(() => new C5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new w5t(), 'ValueConverter'),
          },
        })
      a(i_, 'createPieServices')
      zt(i_, 'createPieServices')
    })
  function a_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), gD, s_)
    return t.ServiceRegistry.register(r), { shared: t, Architecture: r }
  }
  var E5t,
    v5t,
    s_,
    CD = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(E5t = class extends wi {
        static {
          a(this, 'ArchitectureTokenBuilder')
        }
        static {
          zt(this, 'ArchitectureTokenBuilder')
        }
        constructor() {
          super(['architecture'])
        }
      }),
        (v5t = class extends Xc {
          static {
            a(this, 'ArchitectureValueConverter')
          }
          static {
            zt(this, 'ArchitectureValueConverter')
          }
          runCustomConverter(e, t, r) {
            if (e.name === 'ARCH_ICON') return t.replace(/[()]/g, '').trim()
            if (e.name === 'ARCH_TEXT_ICON') return t.replace(/["()]/g, '')
            if (e.name === 'ARCH_TITLE') return t.replace(/[[\]]/g, '').trim()
          }
        }),
        (s_ = {
          parser: {
            TokenBuilder: zt(() => new E5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new v5t(), 'ValueConverter'),
          },
        })
      a(a_, 'createArchitectureServices')
      zt(a_, 'createArchitectureServices')
    })
  function l_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), xD, o_)
    return t.ServiceRegistry.register(r), { shared: t, Radar: r }
  }
  var A5t,
    o_,
    wD = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(A5t = class extends wi {
        static {
          a(this, 'RadarTokenBuilder')
        }
        static {
          zt(this, 'RadarTokenBuilder')
        }
        constructor() {
          super(['radar-beta'])
        }
      }),
        (o_ = {
          parser: {
            TokenBuilder: zt(() => new A5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new Il(), 'ValueConverter'),
          },
        })
      a(l_, 'createRadarServices')
      zt(l_, 'createRadarServices')
    })
  function Qtt(e) {
    let t = e.validation.TreemapValidator,
      r = e.validation.ValidationRegistry
    if (r) {
      let n = { Treemap: t.checkSingleRoot.bind(t) }
      r.register(n, t)
    }
  }
  function u_(e = fi) {
    let t = Xr(hi(e), Ki),
      r = Xr(ui({ shared: t }), bD, c_)
    return t.ServiceRegistry.register(r), Qtt(r), { shared: t, Treemap: r }
  }
  var L5t,
    R5t,
    D5t,
    N5t,
    c_,
    ED = x(() => {
      'use strict'
      Ei()
      Bs()
      ;(L5t = class extends wi {
        static {
          a(this, 'TreemapTokenBuilder')
        }
        static {
          zt(this, 'TreemapTokenBuilder')
        }
        constructor() {
          super(['treemap'])
        }
      }),
        (R5t = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/),
        (D5t = class extends Xc {
          static {
            a(this, 'TreemapValueConverter')
          }
          static {
            zt(this, 'TreemapValueConverter')
          }
          runCustomConverter(e, t, r) {
            if (e.name === 'NUMBER2') return parseFloat(t.replace(/,/g, ''))
            if (e.name === 'SEPARATOR') return t.substring(1, t.length - 1)
            if (e.name === 'STRING2') return t.substring(1, t.length - 1)
            if (e.name === 'INDENTATION') return t.length
            if (e.name === 'ClassDef') {
              if (typeof t != 'string') return t
              let n = R5t.exec(t)
              if (n) return { $type: 'ClassDefStatement', className: n[1], styleText: n[2] || void 0 }
            }
          }
        })
      a(Qtt, 'registerValidationChecks')
      zt(Qtt, 'registerValidationChecks')
      ;(N5t = class {
        static {
          a(this, 'TreemapValidator')
        }
        static {
          zt(this, 'TreemapValidator')
        }
        checkSingleRoot(e, t) {
          let r
          for (let n of e.TreemapRows)
            n.item &&
              (r === void 0 && n.indent === void 0
                ? (r = 0)
                : n.indent === void 0
                  ? t('error', 'Multiple root nodes are not allowed in a treemap.', { node: n, property: 'item' })
                  : r !== void 0 &&
                    r >= parseInt(n.indent, 10) &&
                    t('error', 'Multiple root nodes are not allowed in a treemap.', { node: n, property: 'item' }))
        }
      }),
        (c_ = {
          parser: {
            TokenBuilder: zt(() => new L5t(), 'TokenBuilder'),
            ValueConverter: zt(() => new D5t(), 'ValueConverter'),
          },
          validation: { TreemapValidator: zt(() => new N5t(), 'TreemapValidator') },
        })
      a(u_, 'createTreemapServices')
      zt(u_, 'createTreemapServices')
    })
  var Ztt = {}
  Oe(Ztt, { InfoModule: () => JS, createInfoServices: () => t_ })
  var Jtt = x(() => {
    'use strict'
    TD()
    Ei()
  })
  var tet = {}
  Oe(tet, { PacketModule: () => e_, createPacketServices: () => r_ })
  var eet = x(() => {
    'use strict'
    SD()
    Ei()
  })
  var ret = {}
  Oe(ret, { PieModule: () => n_, createPieServices: () => i_ })
  var net = x(() => {
    'use strict'
    _D()
    Ei()
  })
  var iet = {}
  Oe(iet, { ArchitectureModule: () => s_, createArchitectureServices: () => a_ })
  var set = x(() => {
    'use strict'
    CD()
    Ei()
  })
  var aet = {}
  Oe(aet, { GitGraphModule: () => QS, createGitGraphServices: () => ZS })
  var oet = x(() => {
    'use strict'
    kD()
    Ei()
  })
  var cet = {}
  Oe(cet, { RadarModule: () => o_, createRadarServices: () => l_ })
  var uet = x(() => {
    'use strict'
    wD()
    Ei()
  })
  var het = {}
  Oe(het, { TreemapModule: () => c_, createTreemapServices: () => u_ })
  var fet = x(() => {
    'use strict'
    ED()
    Ei()
  })
  async function Fs(e, t) {
    let r = I5t[e]
    if (!r) throw new Error(`Unknown diagram type: ${e}`)
    Ml[e] || (await r())
    let i = Ml[e].parse(t)
    if (i.lexerErrors.length > 0 || i.parserErrors.length > 0) throw new M5t(i)
    return i.value
  }
  var Ml,
    I5t,
    M5t,
    jh = x(() => {
      'use strict'
      kD()
      TD()
      SD()
      _D()
      CD()
      wD()
      ED()
      Ei()
      ;(Ml = {}),
        (I5t = {
          info: zt(async () => {
            let { createInfoServices: e } = await Promise.resolve().then(() => (Jtt(), Ztt)),
              t = e().Info.parser.LangiumParser
            Ml.info = t
          }, 'info'),
          packet: zt(async () => {
            let { createPacketServices: e } = await Promise.resolve().then(() => (eet(), tet)),
              t = e().Packet.parser.LangiumParser
            Ml.packet = t
          }, 'packet'),
          pie: zt(async () => {
            let { createPieServices: e } = await Promise.resolve().then(() => (net(), ret)),
              t = e().Pie.parser.LangiumParser
            Ml.pie = t
          }, 'pie'),
          architecture: zt(async () => {
            let { createArchitectureServices: e } = await Promise.resolve().then(() => (set(), iet)),
              t = e().Architecture.parser.LangiumParser
            Ml.architecture = t
          }, 'architecture'),
          gitGraph: zt(async () => {
            let { createGitGraphServices: e } = await Promise.resolve().then(() => (oet(), aet)),
              t = e().GitGraph.parser.LangiumParser
            Ml.gitGraph = t
          }, 'gitGraph'),
          radar: zt(async () => {
            let { createRadarServices: e } = await Promise.resolve().then(() => (uet(), cet)),
              t = e().Radar.parser.LangiumParser
            Ml.radar = t
          }, 'radar'),
          treemap: zt(async () => {
            let { createTreemapServices: e } = await Promise.resolve().then(() => (fet(), het)),
              t = e().Treemap.parser.LangiumParser
            Ml.treemap = t
          }, 'treemap'),
        })
      a(Fs, 'parse')
      zt(Fs, 'parse')
      M5t = class extends Error {
        static {
          a(this, 'MermaidParseError')
        }
        constructor(e) {
          let t = e.lexerErrors.map((n) => n.message).join(`
`),
            r = e.parserErrors.map((n) => n.message).join(`
`)
          super(`Parsing failed: ${t} ${r}`), (this.result = e)
        }
        static {
          zt(this, 'MermaidParseError')
        }
      }
    })
  function jo(e, t) {
    e.accDescr && t.setAccDescription?.(e.accDescr),
      e.accTitle && t.setAccTitle?.(e.accTitle),
      e.title && t.setDiagramTitle?.(e.title)
  }
  var gm = x(() => {
    'use strict'
    a(jo, 'populateCommonDb')
  })
  var yr,
    h_ = x(() => {
      'use strict'
      yr = { NORMAL: 0, REVERSE: 1, HIGHLIGHT: 2, MERGE: 3, CHERRY_PICK: 4 }
    })
  var ym,
    vD = x(() => {
      'use strict'
      ym = class {
        constructor(t) {
          this.init = t
          this.records = this.init()
        }
        static {
          a(this, 'ImperativeState')
        }
        reset() {
          this.records = this.init()
        }
      }
    })
  function AD() {
    return A4({ length: 7 })
  }
  function P5t(e, t) {
    let r = Object.create(null)
    return e.reduce((n, i) => {
      let s = t(i)
      return r[s] || ((r[s] = !0), n.push(i)), n
    }, [])
  }
  function det(e, t, r) {
    let n = e.indexOf(t)
    n === -1 ? e.push(r) : e.splice(n, 1, r)
  }
  function met(e) {
    let t = e.reduce((i, s) => (i.seq > s.seq ? i : s), e[0]),
      r = ''
    e.forEach(function (i) {
      i === t ? (r += '	*') : (r += '	|')
    })
    let n = [r, t.id, t.seq]
    for (let i in qt.records.branches) qt.records.branches.get(i) === t.id && n.push(i)
    if ((B.debug(n.join(' ')), t.parents && t.parents.length == 2 && t.parents[0] && t.parents[1])) {
      let i = qt.records.commits.get(t.parents[0])
      det(e, t, i), t.parents[1] && e.push(qt.records.commits.get(t.parents[1]))
    } else {
      if (t.parents.length == 0) return
      if (t.parents[0]) {
        let i = qt.records.commits.get(t.parents[0])
        det(e, t, i)
      }
    }
    ;(e = P5t(e, (i) => i.id)), met(e)
  }
  var O5t,
    qh,
    qt,
    B5t,
    F5t,
    $5t,
    G5t,
    V5t,
    z5t,
    W5t,
    pet,
    U5t,
    j5t,
    q5t,
    H5t,
    Y5t,
    get,
    X5t,
    K5t,
    Q5t,
    f_,
    LD = x(() => {
      'use strict'
      Vt()
      Ce()
      fn()
      Be()
      bn()
      h_()
      vD()
      _s()
      ;(O5t = ze.gitGraph),
        (qh = a(() => ln({ ...O5t, ...Te().gitGraph }), 'getConfig')),
        (qt = new ym(() => {
          let e = qh(),
            t = e.mainBranchName,
            r = e.mainBranchOrder
          return {
            mainBranchName: t,
            commits: new Map(),
            head: null,
            branchConfig: new Map([[t, { name: t, order: r }]]),
            branches: new Map([[t, null]]),
            currBranch: t,
            direction: 'LR',
            seq: 0,
            options: {},
          }
        }))
      a(AD, 'getID')
      a(P5t, 'uniqBy')
      ;(B5t = a(function (e) {
        qt.records.direction = e
      }, 'setDirection')),
        (F5t = a(function (e) {
          B.debug('options str', e), (e = e?.trim()), (e = e || '{}')
          try {
            qt.records.options = JSON.parse(e)
          } catch (t) {
            B.error('error while parsing gitGraph options', t.message)
          }
        }, 'setOptions')),
        ($5t = a(function () {
          return qt.records.options
        }, 'getOptions')),
        (G5t = a(function (e) {
          let t = e.msg,
            r = e.id,
            n = e.type,
            i = e.tags
          B.info('commit', t, r, n, i), B.debug('Entering commit:', t, r, n, i)
          let s = qh()
          ;(r = Rt.sanitizeText(r, s)), (t = Rt.sanitizeText(t, s)), (i = i?.map((l) => Rt.sanitizeText(l, s)))
          let o = {
            id: r || qt.records.seq + '-' + AD(),
            message: t,
            seq: qt.records.seq++,
            type: n ?? yr.NORMAL,
            tags: i ?? [],
            parents: qt.records.head == null ? [] : [qt.records.head.id],
            branch: qt.records.currBranch,
          }
          ;(qt.records.head = o),
            B.info('main branch', s.mainBranchName),
            qt.records.commits.has(o.id) && B.warn(`Commit ID ${o.id} already exists`),
            qt.records.commits.set(o.id, o),
            qt.records.branches.set(qt.records.currBranch, o.id),
            B.debug('in pushCommit ' + o.id)
        }, 'commit')),
        (V5t = a(function (e) {
          let t = e.name,
            r = e.order
          if (((t = Rt.sanitizeText(t, qh())), qt.records.branches.has(t)))
            throw new Error(
              `Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`,
            )
          qt.records.branches.set(t, qt.records.head != null ? qt.records.head.id : null),
            qt.records.branchConfig.set(t, { name: t, order: r }),
            pet(t),
            B.debug('in createBranch')
        }, 'branch')),
        (z5t = a((e) => {
          let t = e.branch,
            r = e.id,
            n = e.type,
            i = e.tags,
            s = qh()
          ;(t = Rt.sanitizeText(t, s)), r && (r = Rt.sanitizeText(r, s))
          let o = qt.records.branches.get(qt.records.currBranch),
            l = qt.records.branches.get(t),
            u = o ? qt.records.commits.get(o) : void 0,
            h = l ? qt.records.commits.get(l) : void 0
          if (u && h && u.branch === t) throw new Error(`Cannot merge branch '${t}' into itself.`)
          if (qt.records.currBranch === t) {
            let p = new Error('Incorrect usage of "merge". Cannot merge a branch to itself')
            throw ((p.hash = { text: `merge ${t}`, token: `merge ${t}`, expected: ['branch abc'] }), p)
          }
          if (u === void 0 || !u) {
            let p = new Error(`Incorrect usage of "merge". Current branch (${qt.records.currBranch})has no commits`)
            throw ((p.hash = { text: `merge ${t}`, token: `merge ${t}`, expected: ['commit'] }), p)
          }
          if (!qt.records.branches.has(t)) {
            let p = new Error('Incorrect usage of "merge". Branch to be merged (' + t + ') does not exist')
            throw ((p.hash = { text: `merge ${t}`, token: `merge ${t}`, expected: [`branch ${t}`] }), p)
          }
          if (h === void 0 || !h) {
            let p = new Error('Incorrect usage of "merge". Branch to be merged (' + t + ') has no commits')
            throw ((p.hash = { text: `merge ${t}`, token: `merge ${t}`, expected: ['"commit"'] }), p)
          }
          if (u === h) {
            let p = new Error('Incorrect usage of "merge". Both branches have same head')
            throw ((p.hash = { text: `merge ${t}`, token: `merge ${t}`, expected: ['branch abc'] }), p)
          }
          if (r && qt.records.commits.has(r)) {
            let p = new Error(
              'Incorrect usage of "merge". Commit with id:' + r + ' already exists, use different custom id',
            )
            throw (
              ((p.hash = {
                text: `merge ${t} ${r} ${n} ${i?.join(' ')}`,
                token: `merge ${t} ${r} ${n} ${i?.join(' ')}`,
                expected: [`merge ${t} ${r}_UNIQUE ${n} ${i?.join(' ')}`],
              }),
              p)
            )
          }
          let f = l || '',
            d = {
              id: r || `${qt.records.seq}-${AD()}`,
              message: `merged branch ${t} into ${qt.records.currBranch}`,
              seq: qt.records.seq++,
              parents: qt.records.head == null ? [] : [qt.records.head.id, f],
              branch: qt.records.currBranch,
              type: yr.MERGE,
              customType: n,
              customId: !!r,
              tags: i ?? [],
            }
          ;(qt.records.head = d),
            qt.records.commits.set(d.id, d),
            qt.records.branches.set(qt.records.currBranch, d.id),
            B.debug(qt.records.branches),
            B.debug('in mergeBranch')
        }, 'merge')),
        (W5t = a(function (e) {
          let t = e.id,
            r = e.targetId,
            n = e.tags,
            i = e.parent
          B.debug('Entering cherryPick:', t, r, n)
          let s = qh()
          if (
            ((t = Rt.sanitizeText(t, s)),
            (r = Rt.sanitizeText(r, s)),
            (n = n?.map((u) => Rt.sanitizeText(u, s))),
            (i = Rt.sanitizeText(i, s)),
            !t || !qt.records.commits.has(t))
          ) {
            let u = new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided')
            throw (
              ((u.hash = {
                text: `cherryPick ${t} ${r}`,
                token: `cherryPick ${t} ${r}`,
                expected: ['cherry-pick abc'],
              }),
              u)
            )
          }
          let o = qt.records.commits.get(t)
          if (o === void 0 || !o)
            throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided')
          if (i && !(Array.isArray(o.parents) && o.parents.includes(i)))
            throw new Error(
              'Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.',
            )
          let l = o.branch
          if (o.type === yr.MERGE && !i)
            throw new Error(
              'Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.',
            )
          if (!r || !qt.records.commits.has(r)) {
            if (l === qt.records.currBranch) {
              let d = new Error('Incorrect usage of "cherryPick". Source commit is already on current branch')
              throw (
                ((d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ['cherry-pick abc'],
                }),
                d)
              )
            }
            let u = qt.records.branches.get(qt.records.currBranch)
            if (u === void 0 || !u) {
              let d = new Error(
                `Incorrect usage of "cherry-pick". Current branch (${qt.records.currBranch})has no commits`,
              )
              throw (
                ((d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ['cherry-pick abc'],
                }),
                d)
              )
            }
            let h = qt.records.commits.get(u)
            if (h === void 0 || !h) {
              let d = new Error(
                `Incorrect usage of "cherry-pick". Current branch (${qt.records.currBranch})has no commits`,
              )
              throw (
                ((d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ['cherry-pick abc'],
                }),
                d)
              )
            }
            let f = {
              id: qt.records.seq + '-' + AD(),
              message: `cherry-picked ${o?.message} into ${qt.records.currBranch}`,
              seq: qt.records.seq++,
              parents: qt.records.head == null ? [] : [qt.records.head.id, o.id],
              branch: qt.records.currBranch,
              type: yr.CHERRY_PICK,
              tags: n ? n.filter(Boolean) : [`cherry-pick:${o.id}${o.type === yr.MERGE ? `|parent:${i}` : ''}`],
            }
            ;(qt.records.head = f),
              qt.records.commits.set(f.id, f),
              qt.records.branches.set(qt.records.currBranch, f.id),
              B.debug(qt.records.branches),
              B.debug('in cherryPick')
          }
        }, 'cherryPick')),
        (pet = a(function (e) {
          if (((e = Rt.sanitizeText(e, qh())), qt.records.branches.has(e))) {
            qt.records.currBranch = e
            let t = qt.records.branches.get(qt.records.currBranch)
            t === void 0 || !t ? (qt.records.head = null) : (qt.records.head = qt.records.commits.get(t) ?? null)
          } else {
            let t = new Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`)
            throw ((t.hash = { text: `checkout ${e}`, token: `checkout ${e}`, expected: [`branch ${e}`] }), t)
          }
        }, 'checkout'))
      a(det, 'upsert')
      a(met, 'prettyPrintCommitHistory')
      ;(U5t = a(function () {
        B.debug(qt.records.commits)
        let e = get()[0]
        met([e])
      }, 'prettyPrint')),
        (j5t = a(function () {
          qt.reset(), Ye()
        }, 'clear')),
        (q5t = a(function () {
          return [...qt.records.branchConfig.values()]
            .map((t, r) => (t.order !== null && t.order !== void 0 ? t : { ...t, order: parseFloat(`0.${r}`) }))
            .sort((t, r) => (t.order ?? 0) - (r.order ?? 0))
            .map(({ name: t }) => ({ name: t }))
        }, 'getBranchesAsObjArray')),
        (H5t = a(function () {
          return qt.records.branches
        }, 'getBranches')),
        (Y5t = a(function () {
          return qt.records.commits
        }, 'getCommits')),
        (get = a(function () {
          let e = [...qt.records.commits.values()]
          return (
            e.forEach(function (t) {
              B.debug(t.id)
            }),
            e.sort((t, r) => t.seq - r.seq),
            e
          )
        }, 'getCommitsArray')),
        (X5t = a(function () {
          return qt.records.currBranch
        }, 'getCurrentBranch')),
        (K5t = a(function () {
          return qt.records.direction
        }, 'getDirection')),
        (Q5t = a(function () {
          return qt.records.head
        }, 'getHead')),
        (f_ = {
          commitType: yr,
          getConfig: qh,
          setDirection: B5t,
          setOptions: F5t,
          getOptions: $5t,
          commit: G5t,
          branch: V5t,
          merge: z5t,
          cherryPick: W5t,
          checkout: pet,
          prettyPrint: U5t,
          clear: j5t,
          getBranchesAsObjArray: q5t,
          getBranches: H5t,
          getCommits: Y5t,
          getCommitsArray: get,
          getCurrentBranch: X5t,
          getDirection: K5t,
          getHead: Q5t,
          setAccTitle: Xe,
          getAccTitle: tr,
          getAccDescription: rr,
          setAccDescription: er,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
        })
    })
  var Z5t,
    J5t,
    t6t,
    e6t,
    r6t,
    n6t,
    i6t,
    yet,
    xet = x(() => {
      'use strict'
      jh()
      Vt()
      gm()
      LD()
      h_()
      ;(Z5t = a((e, t) => {
        jo(e, t), e.dir && t.setDirection(e.dir)
        for (let r of e.statements) J5t(r, t)
      }, 'populate')),
        (J5t = a((e, t) => {
          let n = {
            Commit: a((i) => t.commit(t6t(i)), 'Commit'),
            Branch: a((i) => t.branch(e6t(i)), 'Branch'),
            Merge: a((i) => t.merge(r6t(i)), 'Merge'),
            Checkout: a((i) => t.checkout(n6t(i)), 'Checkout'),
            CherryPicking: a((i) => t.cherryPick(i6t(i)), 'CherryPicking'),
          }[e.$type]
          n ? n(e) : B.error(`Unknown statement type: ${e.$type}`)
        }, 'parseStatement')),
        (t6t = a(
          (e) => ({
            id: e.id,
            msg: e.message ?? '',
            type: e.type !== void 0 ? yr[e.type] : yr.NORMAL,
            tags: e.tags ?? void 0,
          }),
          'parseCommit',
        )),
        (e6t = a((e) => ({ name: e.name, order: e.order ?? 0 }), 'parseBranch')),
        (r6t = a(
          (e) => ({
            branch: e.branch,
            id: e.id ?? '',
            type: e.type !== void 0 ? yr[e.type] : void 0,
            tags: e.tags ?? void 0,
          }),
          'parseMerge',
        )),
        (n6t = a((e) => e.branch, 'parseCheckout')),
        (i6t = a(
          (e) => ({ id: e.id, targetId: '', tags: e.tags?.length === 0 ? void 0 : e.tags, parent: e.parent }),
          'parseCherryPicking',
        )),
        (yet = {
          parse: a(async (e) => {
            let t = await Fs('gitGraph', e)
            B.debug(t), Z5t(t, f_)
          }, 'parse'),
        })
    })
  var s6t,
    pa,
    Qc,
    Zc,
    qo,
    Ol,
    Hh,
    xs,
    bs,
    d_,
    Dy,
    p_,
    Kc,
    ar,
    a6t,
    ket,
    Tet,
    o6t,
    l6t,
    c6t,
    u6t,
    h6t,
    f6t,
    d6t,
    p6t,
    m6t,
    g6t,
    y6t,
    x6t,
    bet,
    b6t,
    Ny,
    k6t,
    T6t,
    S6t,
    _6t,
    C6t,
    _et,
    Cet = x(() => {
      'use strict'
      Ge()
      pe()
      Vt()
      Ce()
      h_()
      ;(s6t = K()),
        (pa = s6t?.gitGraph),
        (Qc = 10),
        (Zc = 40),
        (qo = 4),
        (Ol = 2),
        (Hh = 8),
        (xs = new Map()),
        (bs = new Map()),
        (d_ = 30),
        (Dy = new Map()),
        (p_ = []),
        (Kc = 0),
        (ar = 'LR'),
        (a6t = a(() => {
          xs.clear(), bs.clear(), Dy.clear(), (Kc = 0), (p_ = []), (ar = 'LR')
        }, 'clear')),
        (ket = a((e) => {
          let t = document.createElementNS('http://www.w3.org/2000/svg', 'text')
          return (
            (typeof e == 'string' ? e.split(/\\n|\n|<br\s*\/?>/gi) : e).forEach((n) => {
              let i = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
              i.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'),
                i.setAttribute('dy', '1em'),
                i.setAttribute('x', '0'),
                i.setAttribute('class', 'row'),
                (i.textContent = n.trim()),
                t.appendChild(i)
            }),
            t
          )
        }, 'drawText')),
        (Tet = a((e) => {
          let t, r, n
          return (
            ar === 'BT'
              ? ((r = a((i, s) => i <= s, 'comparisonFunc')), (n = 1 / 0))
              : ((r = a((i, s) => i >= s, 'comparisonFunc')), (n = 0)),
            e.forEach((i) => {
              let s = ar === 'TB' || ar == 'BT' ? bs.get(i)?.y : bs.get(i)?.x
              s !== void 0 && r(s, n) && ((t = i), (n = s))
            }),
            t
          )
        }, 'findClosestParent')),
        (o6t = a((e) => {
          let t = '',
            r = 1 / 0
          return (
            e.forEach((n) => {
              let i = bs.get(n).y
              i <= r && ((t = n), (r = i))
            }),
            t || void 0
          )
        }, 'findClosestParentBT')),
        (l6t = a((e, t, r) => {
          let n = r,
            i = r,
            s = []
          e.forEach((o) => {
            let l = t.get(o)
            if (!l) throw new Error(`Commit not found for key ${o}`)
            l.parents.length ? ((n = u6t(l)), (i = Math.max(n, i))) : s.push(l), h6t(l, n)
          }),
            (n = i),
            s.forEach((o) => {
              f6t(o, n, r)
            }),
            e.forEach((o) => {
              let l = t.get(o)
              if (l?.parents.length) {
                let u = o6t(l.parents)
                ;(n = bs.get(u).y - Zc), n <= i && (i = n)
                let h = xs.get(l.branch).pos,
                  f = n - Qc
                bs.set(l.id, { x: h, y: f })
              }
            })
        }, 'setParallelBTPos')),
        (c6t = a((e) => {
          let t = Tet(e.parents.filter((n) => n !== null))
          if (!t) throw new Error(`Closest parent not found for commit ${e.id}`)
          let r = bs.get(t)?.y
          if (r === void 0) throw new Error(`Closest parent position not found for commit ${e.id}`)
          return r
        }, 'findClosestParentPos')),
        (u6t = a((e) => c6t(e) + Zc, 'calculateCommitPosition')),
        (h6t = a((e, t) => {
          let r = xs.get(e.branch)
          if (!r) throw new Error(`Branch not found for commit ${e.id}`)
          let n = r.pos,
            i = t + Qc
          return bs.set(e.id, { x: n, y: i }), { x: n, y: i }
        }, 'setCommitPosition')),
        (f6t = a((e, t, r) => {
          let n = xs.get(e.branch)
          if (!n) throw new Error(`Branch not found for commit ${e.id}`)
          let i = t + r,
            s = n.pos
          bs.set(e.id, { x: s, y: i })
        }, 'setRootPosition')),
        (d6t = a((e, t, r, n, i, s) => {
          if (s === yr.HIGHLIGHT)
            e
              .append('rect')
              .attr('x', r.x - 10)
              .attr('y', r.y - 10)
              .attr('width', 20)
              .attr('height', 20)
              .attr('class', `commit ${t.id} commit-highlight${i % Hh} ${n}-outer`),
              e
                .append('rect')
                .attr('x', r.x - 6)
                .attr('y', r.y - 6)
                .attr('width', 12)
                .attr('height', 12)
                .attr('class', `commit ${t.id} commit${i % Hh} ${n}-inner`)
          else if (s === yr.CHERRY_PICK)
            e.append('circle').attr('cx', r.x).attr('cy', r.y).attr('r', 10).attr('class', `commit ${t.id} ${n}`),
              e
                .append('circle')
                .attr('cx', r.x - 3)
                .attr('cy', r.y + 2)
                .attr('r', 2.75)
                .attr('fill', '#fff')
                .attr('class', `commit ${t.id} ${n}`),
              e
                .append('circle')
                .attr('cx', r.x + 3)
                .attr('cy', r.y + 2)
                .attr('r', 2.75)
                .attr('fill', '#fff')
                .attr('class', `commit ${t.id} ${n}`),
              e
                .append('line')
                .attr('x1', r.x + 3)
                .attr('y1', r.y + 1)
                .attr('x2', r.x)
                .attr('y2', r.y - 5)
                .attr('stroke', '#fff')
                .attr('class', `commit ${t.id} ${n}`),
              e
                .append('line')
                .attr('x1', r.x - 3)
                .attr('y1', r.y + 1)
                .attr('x2', r.x)
                .attr('y2', r.y - 5)
                .attr('stroke', '#fff')
                .attr('class', `commit ${t.id} ${n}`)
          else {
            let o = e.append('circle')
            if (
              (o.attr('cx', r.x),
              o.attr('cy', r.y),
              o.attr('r', t.type === yr.MERGE ? 9 : 10),
              o.attr('class', `commit ${t.id} commit${i % Hh}`),
              s === yr.MERGE)
            ) {
              let l = e.append('circle')
              l.attr('cx', r.x),
                l.attr('cy', r.y),
                l.attr('r', 6),
                l.attr('class', `commit ${n} ${t.id} commit${i % Hh}`)
            }
            s === yr.REVERSE &&
              e
                .append('path')
                .attr('d', `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`)
                .attr('class', `commit ${n} ${t.id} commit${i % Hh}`)
          }
        }, 'drawCommitBullet')),
        (p6t = a((e, t, r, n) => {
          if (
            t.type !== yr.CHERRY_PICK &&
            ((t.customId && t.type === yr.MERGE) || t.type !== yr.MERGE) &&
            pa?.showCommitLabel
          ) {
            let i = e.append('g'),
              s = i.insert('rect').attr('class', 'commit-label-bkg'),
              o = i
                .append('text')
                .attr('x', n)
                .attr('y', r.y + 25)
                .attr('class', 'commit-label')
                .text(t.id),
              l = o.node()?.getBBox()
            if (
              l &&
              (s
                .attr('x', r.posWithOffset - l.width / 2 - Ol)
                .attr('y', r.y + 13.5)
                .attr('width', l.width + 2 * Ol)
                .attr('height', l.height + 2 * Ol),
              ar === 'TB' || ar === 'BT'
                ? (s.attr('x', r.x - (l.width + 4 * qo + 5)).attr('y', r.y - 12),
                  o.attr('x', r.x - (l.width + 4 * qo)).attr('y', r.y + l.height - 12))
                : o.attr('x', r.posWithOffset - l.width / 2),
              pa.rotateCommitLabel)
            )
              if (ar === 'TB' || ar === 'BT')
                o.attr('transform', 'rotate(-45, ' + r.x + ', ' + r.y + ')'),
                  s.attr('transform', 'rotate(-45, ' + r.x + ', ' + r.y + ')')
              else {
                let u = -7.5 - ((l.width + 10) / 25) * 9.5,
                  h = 10 + (l.width / 25) * 8.5
                i.attr('transform', 'translate(' + u + ', ' + h + ') rotate(-45, ' + n + ', ' + r.y + ')')
              }
          }
        }, 'drawCommitLabel')),
        (m6t = a((e, t, r, n) => {
          if (t.tags.length > 0) {
            let i = 0,
              s = 0,
              o = 0,
              l = []
            for (let u of t.tags.reverse()) {
              let h = e.insert('polygon'),
                f = e.append('circle'),
                d = e
                  .append('text')
                  .attr('y', r.y - 16 - i)
                  .attr('class', 'tag-label')
                  .text(u),
                p = d.node()?.getBBox()
              if (!p) throw new Error('Tag bbox not found')
              ;(s = Math.max(s, p.width)),
                (o = Math.max(o, p.height)),
                d.attr('x', r.posWithOffset - p.width / 2),
                l.push({ tag: d, hole: f, rect: h, yOffset: i }),
                (i += 20)
            }
            for (let { tag: u, hole: h, rect: f, yOffset: d } of l) {
              let p = o / 2,
                m = r.y - 19.2 - d
              if (
                (f.attr('class', 'tag-label-bkg').attr(
                  'points',
                  `
      ${n - s / 2 - qo / 2},${m + Ol}
      ${n - s / 2 - qo / 2},${m - Ol}
      ${r.posWithOffset - s / 2 - qo},${m - p - Ol}
      ${r.posWithOffset + s / 2 + qo},${m - p - Ol}
      ${r.posWithOffset + s / 2 + qo},${m + p + Ol}
      ${r.posWithOffset - s / 2 - qo},${m + p + Ol}`,
                ),
                h
                  .attr('cy', m)
                  .attr('cx', n - s / 2 + qo / 2)
                  .attr('r', 1.5)
                  .attr('class', 'tag-hole'),
                ar === 'TB' || ar === 'BT')
              ) {
                let g = n + d
                f
                  .attr('class', 'tag-label-bkg')
                  .attr(
                    'points',
                    `
        ${r.x},${g + 2}
        ${r.x},${g - 2}
        ${r.x + Qc},${g - p - 2}
        ${r.x + Qc + s + 4},${g - p - 2}
        ${r.x + Qc + s + 4},${g + p + 2}
        ${r.x + Qc},${g + p + 2}`,
                  )
                  .attr('transform', 'translate(12,12) rotate(45, ' + r.x + ',' + n + ')'),
                  h
                    .attr('cx', r.x + qo / 2)
                    .attr('cy', g)
                    .attr('transform', 'translate(12,12) rotate(45, ' + r.x + ',' + n + ')'),
                  u
                    .attr('x', r.x + 5)
                    .attr('y', g + 3)
                    .attr('transform', 'translate(14,14) rotate(45, ' + r.x + ',' + n + ')')
              }
            }
          }
        }, 'drawCommitTags')),
        (g6t = a((e) => {
          switch (e.customType ?? e.type) {
            case yr.NORMAL:
              return 'commit-normal'
            case yr.REVERSE:
              return 'commit-reverse'
            case yr.HIGHLIGHT:
              return 'commit-highlight'
            case yr.MERGE:
              return 'commit-merge'
            case yr.CHERRY_PICK:
              return 'commit-cherry-pick'
            default:
              return 'commit-normal'
          }
        }, 'getCommitClassType')),
        (y6t = a((e, t, r, n) => {
          let i = { x: 0, y: 0 }
          if (e.parents.length > 0) {
            let s = Tet(e.parents)
            if (s) {
              let o = n.get(s) ?? i
              return t === 'TB' ? o.y + Zc : t === 'BT' ? (n.get(e.id) ?? i).y - Zc : o.x + Zc
            }
          } else return t === 'TB' ? d_ : t === 'BT' ? (n.get(e.id) ?? i).y - Zc : 0
          return 0
        }, 'calculatePosition')),
        (x6t = a((e, t, r) => {
          let n = ar === 'BT' && r ? t : t + Qc,
            i = ar === 'TB' || ar === 'BT' ? n : xs.get(e.branch)?.pos,
            s = ar === 'TB' || ar === 'BT' ? xs.get(e.branch)?.pos : n
          if (s === void 0 || i === void 0) throw new Error(`Position were undefined for commit ${e.id}`)
          return { x: s, y: i, posWithOffset: n }
        }, 'getCommitPosition')),
        (bet = a((e, t, r) => {
          if (!pa) throw new Error('GitGraph config not found')
          let n = e.append('g').attr('class', 'commit-bullets'),
            i = e.append('g').attr('class', 'commit-labels'),
            s = ar === 'TB' || ar === 'BT' ? d_ : 0,
            o = [...t.keys()],
            l = pa?.parallelCommits ?? !1,
            u = a((f, d) => {
              let p = t.get(f)?.seq,
                m = t.get(d)?.seq
              return p !== void 0 && m !== void 0 ? p - m : 0
            }, 'sortKeys'),
            h = o.sort(u)
          ar === 'BT' && (l && l6t(h, t, s), (h = h.reverse())),
            h.forEach((f) => {
              let d = t.get(f)
              if (!d) throw new Error(`Commit not found for key ${f}`)
              l && (s = y6t(d, ar, s, bs))
              let p = x6t(d, s, l)
              if (r) {
                let m = g6t(d),
                  g = d.customType ?? d.type,
                  y = xs.get(d.branch)?.index ?? 0
                d6t(n, d, p, m, y, g), p6t(i, d, p, s), m6t(i, d, p, s)
              }
              ar === 'TB' || ar === 'BT'
                ? bs.set(d.id, { x: p.x, y: p.posWithOffset })
                : bs.set(d.id, { x: p.posWithOffset, y: p.y }),
                (s = ar === 'BT' && l ? s + Zc : s + Zc + Qc),
                s > Kc && (Kc = s)
            })
        }, 'drawCommits')),
        (b6t = a((e, t, r, n, i) => {
          let o = (ar === 'TB' || ar === 'BT' ? r.x < n.x : r.y < n.y) ? t.branch : e.branch,
            l = a((h) => h.branch === o, 'isOnBranchToGetCurve'),
            u = a((h) => h.seq > e.seq && h.seq < t.seq, 'isBetweenCommits')
          return [...i.values()].some((h) => u(h) && l(h))
        }, 'shouldRerouteArrow')),
        (Ny = a((e, t, r = 0) => {
          let n = e + Math.abs(e - t) / 2
          if (r > 5) return n
          if (p_.every((o) => Math.abs(o - n) >= 10)) return p_.push(n), n
          let s = Math.abs(e - t)
          return Ny(e, t - s / 5, r + 1)
        }, 'findLane')),
        (k6t = a((e, t, r, n) => {
          let i = bs.get(t.id),
            s = bs.get(r.id)
          if (i === void 0 || s === void 0)
            throw new Error(`Commit positions not found for commits ${t.id} and ${r.id}`)
          let o = b6t(t, r, i, s, n),
            l = '',
            u = '',
            h = 0,
            f = 0,
            d = xs.get(r.branch)?.index
          r.type === yr.MERGE && t.id !== r.parents[0] && (d = xs.get(t.branch)?.index)
          let p
          if (o) {
            ;(l = 'A 10 10, 0, 0, 0,'), (u = 'A 10 10, 0, 0, 1,'), (h = 10), (f = 10)
            let m = i.y < s.y ? Ny(i.y, s.y) : Ny(s.y, i.y),
              g = i.x < s.x ? Ny(i.x, s.x) : Ny(s.x, i.x)
            ar === 'TB'
              ? i.x < s.x
                ? (p = `M ${i.x} ${i.y} L ${g - h} ${i.y} ${u} ${g} ${i.y + f} L ${g} ${s.y - h} ${l} ${g + f} ${s.y} L ${s.x} ${s.y}`)
                : ((d = xs.get(t.branch)?.index),
                  (p = `M ${i.x} ${i.y} L ${g + h} ${i.y} ${l} ${g} ${i.y + f} L ${g} ${s.y - h} ${u} ${g - f} ${s.y} L ${s.x} ${s.y}`))
              : ar === 'BT'
                ? i.x < s.x
                  ? (p = `M ${i.x} ${i.y} L ${g - h} ${i.y} ${l} ${g} ${i.y - f} L ${g} ${s.y + h} ${u} ${g + f} ${s.y} L ${s.x} ${s.y}`)
                  : ((d = xs.get(t.branch)?.index),
                    (p = `M ${i.x} ${i.y} L ${g + h} ${i.y} ${u} ${g} ${i.y - f} L ${g} ${s.y + h} ${l} ${g - f} ${s.y} L ${s.x} ${s.y}`))
                : i.y < s.y
                  ? (p = `M ${i.x} ${i.y} L ${i.x} ${m - h} ${l} ${i.x + f} ${m} L ${s.x - h} ${m} ${u} ${s.x} ${m + f} L ${s.x} ${s.y}`)
                  : ((d = xs.get(t.branch)?.index),
                    (p = `M ${i.x} ${i.y} L ${i.x} ${m + h} ${u} ${i.x + f} ${m} L ${s.x - h} ${m} ${l} ${s.x} ${m - f} L ${s.x} ${s.y}`))
          } else
            (l = 'A 20 20, 0, 0, 0,'),
              (u = 'A 20 20, 0, 0, 1,'),
              (h = 20),
              (f = 20),
              ar === 'TB'
                ? (i.x < s.x &&
                    (r.type === yr.MERGE && t.id !== r.parents[0]
                      ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${l} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)
                      : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${u} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)),
                  i.x > s.x &&
                    ((l = 'A 20 20, 0, 0, 0,'),
                    (u = 'A 20 20, 0, 0, 1,'),
                    (h = 20),
                    (f = 20),
                    r.type === yr.MERGE && t.id !== r.parents[0]
                      ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${u} ${i.x - f} ${s.y} L ${s.x} ${s.y}`)
                      : (p = `M ${i.x} ${i.y} L ${s.x + h} ${i.y} ${l} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)),
                  i.x === s.x && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`))
                : ar === 'BT'
                  ? (i.x < s.x &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${u} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)),
                    i.x > s.x &&
                      ((l = 'A 20 20, 0, 0, 0,'),
                      (u = 'A 20 20, 0, 0, 1,'),
                      (h = 20),
                      (f = 20),
                      r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${l} ${i.x - f} ${s.y} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)),
                    i.x === s.x && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`))
                  : (i.y < s.y &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${u} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${l} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)),
                    i.y > s.y &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${u} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)),
                    i.y === s.y && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`))
          if (p === void 0) throw new Error('Line definition not found')
          e.append('path')
            .attr('d', p)
            .attr('class', 'arrow arrow' + (d % Hh))
        }, 'drawArrow')),
        (T6t = a((e, t) => {
          let r = e.append('g').attr('class', 'commit-arrows')
          ;[...t.keys()].forEach((n) => {
            let i = t.get(n)
            i.parents &&
              i.parents.length > 0 &&
              i.parents.forEach((s) => {
                k6t(r, t.get(s), i, t)
              })
          })
        }, 'drawArrows')),
        (S6t = a((e, t) => {
          let r = e.append('g')
          t.forEach((n, i) => {
            let s = i % Hh,
              o = xs.get(n.name)?.pos
            if (o === void 0) throw new Error(`Position not found for branch ${n.name}`)
            let l = r.append('line')
            l.attr('x1', 0),
              l.attr('y1', o),
              l.attr('x2', Kc),
              l.attr('y2', o),
              l.attr('class', 'branch branch' + s),
              ar === 'TB'
                ? (l.attr('y1', d_), l.attr('x1', o), l.attr('y2', Kc), l.attr('x2', o))
                : ar === 'BT' && (l.attr('y1', Kc), l.attr('x1', o), l.attr('y2', d_), l.attr('x2', o)),
              p_.push(o)
            let u = n.name,
              h = ket(u),
              f = r.insert('rect'),
              p = r
                .insert('g')
                .attr('class', 'branchLabel')
                .insert('g')
                .attr('class', 'label branch-label' + s)
            p.node().appendChild(h)
            let m = h.getBBox()
            f
              .attr('class', 'branchLabelBkg label' + s)
              .attr('rx', 4)
              .attr('ry', 4)
              .attr('x', -m.width - 4 - (pa?.rotateCommitLabel === !0 ? 30 : 0))
              .attr('y', -m.height / 2 + 8)
              .attr('width', m.width + 18)
              .attr('height', m.height + 4),
              p.attr(
                'transform',
                'translate(' +
                  (-m.width - 14 - (pa?.rotateCommitLabel === !0 ? 30 : 0)) +
                  ', ' +
                  (o - m.height / 2 - 1) +
                  ')',
              ),
              ar === 'TB'
                ? (f.attr('x', o - m.width / 2 - 10).attr('y', 0),
                  p.attr('transform', 'translate(' + (o - m.width / 2 - 5) + ', 0)'))
                : ar === 'BT'
                  ? (f.attr('x', o - m.width / 2 - 10).attr('y', Kc),
                    p.attr('transform', 'translate(' + (o - m.width / 2 - 5) + ', ' + Kc + ')'))
                  : f.attr('transform', 'translate(-19, ' + (o - m.height / 2) + ')')
          })
        }, 'drawBranches')),
        (_6t = a(function (e, t, r, n, i) {
          return (
            xs.set(e, { pos: t, index: r }),
            (t += 50 + (i ? 40 : 0) + (ar === 'TB' || ar === 'BT' ? n.width / 2 : 0)),
            t
          )
        }, 'setBranchPosition')),
        (C6t = a(function (e, t, r, n) {
          if (
            (a6t(),
            B.debug(
              'in gitgraph renderer',
              e +
                `
`,
              'id:',
              t,
              r,
            ),
            !pa)
          )
            throw new Error('GitGraph config not found')
          let i = pa.rotateCommitLabel ?? !1,
            s = n.db
          Dy = s.getCommits()
          let o = s.getBranchesAsObjArray()
          ar = s.getDirection()
          let l = xt(`[id="${t}"]`),
            u = 0
          o.forEach((h, f) => {
            let d = ket(h.name),
              p = l.append('g'),
              m = p.insert('g').attr('class', 'branchLabel'),
              g = m.insert('g').attr('class', 'label branch-label')
            g.node()?.appendChild(d)
            let y = d.getBBox()
            ;(u = _6t(h.name, u, f, y, i)), g.remove(), m.remove(), p.remove()
          }),
            bet(l, Dy, !1),
            pa.showBranches && S6t(l, o),
            T6t(l, Dy),
            bet(l, Dy, !0),
            le.insertTitle(l, 'gitTitleText', pa.titleTopMargin ?? 0, s.getDiagramTitle()),
            Cw(void 0, l, pa.diagramPadding, pa.useMaxWidth)
        }, 'draw')),
        (_et = { draw: C6t })
    })
  var w6t,
    wet,
    Eet = x(() => {
      'use strict'
      ;(w6t = a(
        (e) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
    (t) => `
        .branch-label${t} { fill: ${e['gitBranchLabel' + t]}; }
        .commit${t} { stroke: ${e['git' + t]}; fill: ${e['git' + t]}; }
        .commit-highlight${t} { stroke: ${e['gitInv' + t]}; fill: ${e['gitInv' + t]}; }
        .label${t}  { fill: ${e['git' + t]}; }
        .arrow${t} { stroke: ${e['git' + t]}; }
        `,
  ).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`,
        'getStyles',
      )),
        (wet = w6t)
    })
  var vet = {}
  Oe(vet, { diagram: () => E6t })
  var E6t,
    Aet = x(() => {
      'use strict'
      xet()
      LD()
      Cet()
      Eet()
      E6t = { parser: yet, db: f_, renderer: _et, styles: wet }
    })
  var RD,
    Det,
    Net = x(() => {
      'use strict'
      RD = (function () {
        var e = a(function (E, _, L, N) {
            for (L = L || {}, N = E.length; N--; L[E[N]] = _);
            return L
          }, 'o'),
          t = [
            6, 8, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 36, 38, 40,
          ],
          r = [1, 26],
          n = [1, 27],
          i = [1, 28],
          s = [1, 29],
          o = [1, 30],
          l = [1, 31],
          u = [1, 32],
          h = [1, 33],
          f = [1, 34],
          d = [1, 9],
          p = [1, 10],
          m = [1, 11],
          g = [1, 12],
          y = [1, 13],
          b = [1, 14],
          k = [1, 15],
          T = [1, 16],
          C = [1, 19],
          A = [1, 20],
          w = [1, 21],
          D = [1, 22],
          G = [1, 23],
          v = [1, 25],
          R = [1, 35],
          F = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              gantt: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NL: 10,
              weekday: 11,
              weekday_monday: 12,
              weekday_tuesday: 13,
              weekday_wednesday: 14,
              weekday_thursday: 15,
              weekday_friday: 16,
              weekday_saturday: 17,
              weekday_sunday: 18,
              weekend: 19,
              weekend_friday: 20,
              weekend_saturday: 21,
              dateFormat: 22,
              inclusiveEndDates: 23,
              topAxis: 24,
              axisFormat: 25,
              tickInterval: 26,
              excludes: 27,
              includes: 28,
              todayMarker: 29,
              title: 30,
              acc_title: 31,
              acc_title_value: 32,
              acc_descr: 33,
              acc_descr_value: 34,
              acc_descr_multiline_value: 35,
              section: 36,
              clickStatement: 37,
              taskTxt: 38,
              taskData: 39,
              click: 40,
              callbackname: 41,
              callbackargs: 42,
              href: 43,
              clickStatementDebug: 44,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'gantt',
              6: 'EOF',
              8: 'SPACE',
              10: 'NL',
              12: 'weekday_monday',
              13: 'weekday_tuesday',
              14: 'weekday_wednesday',
              15: 'weekday_thursday',
              16: 'weekday_friday',
              17: 'weekday_saturday',
              18: 'weekday_sunday',
              20: 'weekend_friday',
              21: 'weekend_saturday',
              22: 'dateFormat',
              23: 'inclusiveEndDates',
              24: 'topAxis',
              25: 'axisFormat',
              26: 'tickInterval',
              27: 'excludes',
              28: 'includes',
              29: 'todayMarker',
              30: 'title',
              31: 'acc_title',
              32: 'acc_title_value',
              33: 'acc_descr',
              34: 'acc_descr_value',
              35: 'acc_descr_multiline_value',
              36: 'section',
              38: 'taskTxt',
              39: 'taskData',
              40: 'click',
              41: 'callbackname',
              42: 'callbackargs',
              43: 'href',
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [19, 1],
              [19, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [37, 2],
              [37, 3],
              [37, 3],
              [37, 4],
              [37, 3],
              [37, 4],
              [37, 2],
              [44, 2],
              [44, 3],
              [44, 3],
              [44, 4],
              [44, 3],
              [44, 4],
              [44, 2],
            ],
            performAction: a(function (_, L, N, P, I, M, V) {
              var $ = M.length - 1
              switch (I) {
                case 1:
                  return M[$ - 1]
                case 2:
                  this.$ = []
                  break
                case 3:
                  M[$ - 1].push(M[$]), (this.$ = M[$ - 1])
                  break
                case 4:
                case 5:
                  this.$ = M[$]
                  break
                case 6:
                case 7:
                  this.$ = []
                  break
                case 8:
                  P.setWeekday('monday')
                  break
                case 9:
                  P.setWeekday('tuesday')
                  break
                case 10:
                  P.setWeekday('wednesday')
                  break
                case 11:
                  P.setWeekday('thursday')
                  break
                case 12:
                  P.setWeekday('friday')
                  break
                case 13:
                  P.setWeekday('saturday')
                  break
                case 14:
                  P.setWeekday('sunday')
                  break
                case 15:
                  P.setWeekend('friday')
                  break
                case 16:
                  P.setWeekend('saturday')
                  break
                case 17:
                  P.setDateFormat(M[$].substr(11)), (this.$ = M[$].substr(11))
                  break
                case 18:
                  P.enableInclusiveEndDates(), (this.$ = M[$].substr(18))
                  break
                case 19:
                  P.TopAxis(), (this.$ = M[$].substr(8))
                  break
                case 20:
                  P.setAxisFormat(M[$].substr(11)), (this.$ = M[$].substr(11))
                  break
                case 21:
                  P.setTickInterval(M[$].substr(13)), (this.$ = M[$].substr(13))
                  break
                case 22:
                  P.setExcludes(M[$].substr(9)), (this.$ = M[$].substr(9))
                  break
                case 23:
                  P.setIncludes(M[$].substr(9)), (this.$ = M[$].substr(9))
                  break
                case 24:
                  P.setTodayMarker(M[$].substr(12)), (this.$ = M[$].substr(12))
                  break
                case 27:
                  P.setDiagramTitle(M[$].substr(6)), (this.$ = M[$].substr(6))
                  break
                case 28:
                  ;(this.$ = M[$].trim()), P.setAccTitle(this.$)
                  break
                case 29:
                case 30:
                  ;(this.$ = M[$].trim()), P.setAccDescription(this.$)
                  break
                case 31:
                  P.addSection(M[$].substr(8)), (this.$ = M[$].substr(8))
                  break
                case 33:
                  P.addTask(M[$ - 1], M[$]), (this.$ = 'task')
                  break
                case 34:
                  ;(this.$ = M[$ - 1]), P.setClickEvent(M[$ - 1], M[$], null)
                  break
                case 35:
                  ;(this.$ = M[$ - 2]), P.setClickEvent(M[$ - 2], M[$ - 1], M[$])
                  break
                case 36:
                  ;(this.$ = M[$ - 2]), P.setClickEvent(M[$ - 2], M[$ - 1], null), P.setLink(M[$ - 2], M[$])
                  break
                case 37:
                  ;(this.$ = M[$ - 3]), P.setClickEvent(M[$ - 3], M[$ - 2], M[$ - 1]), P.setLink(M[$ - 3], M[$])
                  break
                case 38:
                  ;(this.$ = M[$ - 2]), P.setClickEvent(M[$ - 2], M[$], null), P.setLink(M[$ - 2], M[$ - 1])
                  break
                case 39:
                  ;(this.$ = M[$ - 3]), P.setClickEvent(M[$ - 3], M[$ - 1], M[$]), P.setLink(M[$ - 3], M[$ - 2])
                  break
                case 40:
                  ;(this.$ = M[$ - 1]), P.setLink(M[$ - 1], M[$])
                  break
                case 41:
                case 47:
                  this.$ = M[$ - 1] + ' ' + M[$]
                  break
                case 42:
                case 43:
                case 45:
                  this.$ = M[$ - 2] + ' ' + M[$ - 1] + ' ' + M[$]
                  break
                case 44:
                case 46:
                  this.$ = M[$ - 3] + ' ' + M[$ - 2] + ' ' + M[$ - 1] + ' ' + M[$]
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: 17,
                12: r,
                13: n,
                14: i,
                15: s,
                16: o,
                17: l,
                18: u,
                19: 18,
                20: h,
                21: f,
                22: d,
                23: p,
                24: m,
                25: g,
                26: y,
                27: b,
                28: k,
                29: T,
                30: C,
                31: A,
                33: w,
                35: D,
                36: G,
                37: 24,
                38: v,
                40: R,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              {
                9: 36,
                11: 17,
                12: r,
                13: n,
                14: i,
                15: s,
                16: o,
                17: l,
                18: u,
                19: 18,
                20: h,
                21: f,
                22: d,
                23: p,
                24: m,
                25: g,
                26: y,
                27: b,
                28: k,
                29: T,
                30: C,
                31: A,
                33: w,
                35: D,
                36: G,
                37: 24,
                38: v,
                40: R,
              },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 17]),
              e(t, [2, 18]),
              e(t, [2, 19]),
              e(t, [2, 20]),
              e(t, [2, 21]),
              e(t, [2, 22]),
              e(t, [2, 23]),
              e(t, [2, 24]),
              e(t, [2, 25]),
              e(t, [2, 26]),
              e(t, [2, 27]),
              { 32: [1, 37] },
              { 34: [1, 38] },
              e(t, [2, 30]),
              e(t, [2, 31]),
              e(t, [2, 32]),
              { 39: [1, 39] },
              e(t, [2, 8]),
              e(t, [2, 9]),
              e(t, [2, 10]),
              e(t, [2, 11]),
              e(t, [2, 12]),
              e(t, [2, 13]),
              e(t, [2, 14]),
              e(t, [2, 15]),
              e(t, [2, 16]),
              { 41: [1, 40], 43: [1, 41] },
              e(t, [2, 4]),
              e(t, [2, 28]),
              e(t, [2, 29]),
              e(t, [2, 33]),
              e(t, [2, 34], { 42: [1, 42], 43: [1, 43] }),
              e(t, [2, 40], { 41: [1, 44] }),
              e(t, [2, 35], { 43: [1, 45] }),
              e(t, [2, 36]),
              e(t, [2, 38], { 42: [1, 46] }),
              e(t, [2, 37]),
              e(t, [2, 39]),
            ],
            defaultActions: {},
            parseError: a(function (_, L) {
              if (L.recoverable) this.trace(_)
              else {
                var N = new Error(_)
                throw ((N.hash = L), N)
              }
            }, 'parseError'),
            parse: a(function (_) {
              var L = this,
                N = [0],
                P = [],
                I = [null],
                M = [],
                V = this.table,
                $ = '',
                q = 0,
                tt = 0,
                ft = 0,
                H = 2,
                kt = 1,
                ht = M.slice.call(arguments, 1),
                yt = Object.create(this.lexer),
                ot = { yy: {} }
              for (var dt in this.yy) Object.prototype.hasOwnProperty.call(this.yy, dt) && (ot.yy[dt] = this.yy[dt])
              yt.setInput(_, ot.yy),
                (ot.yy.lexer = yt),
                (ot.yy.parser = this),
                typeof yt.yylloc > 'u' && (yt.yylloc = {})
              var it = yt.yylloc
              M.push(it)
              var Q = yt.options && yt.options.ranges
              typeof ot.yy.parseError == 'function'
                ? (this.parseError = ot.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function et(ct) {
                ;(N.length = N.length - 2 * ct), (I.length = I.length - ct), (M.length = M.length - ct)
              }
              a(et, 'popStack')
              function X() {
                var ct
                return (
                  (ct = P.pop() || yt.lex() || kt),
                  typeof ct != 'number' &&
                    (ct instanceof Array && ((P = ct), (ct = P.pop())), (ct = L.symbols_[ct] || ct)),
                  ct
                )
              }
              a(X, 'lex')
              for (var st, U, gt, z, ge, lt, jt = {}, Me, se, Nt, At; ; ) {
                if (
                  ((gt = N[N.length - 1]),
                  this.defaultActions[gt]
                    ? (z = this.defaultActions[gt])
                    : ((st === null || typeof st > 'u') && (st = X()), (z = V[gt] && V[gt][st])),
                  typeof z > 'u' || !z.length || !z[0])
                ) {
                  var bt = ''
                  At = []
                  for (Me in V[gt]) this.terminals_[Me] && Me > H && At.push("'" + this.terminals_[Me] + "'")
                  yt.showPosition
                    ? (bt =
                        'Parse error on line ' +
                        (q + 1) +
                        `:
` +
                        yt.showPosition() +
                        `
Expecting ` +
                        At.join(', ') +
                        ", got '" +
                        (this.terminals_[st] || st) +
                        "'")
                    : (bt =
                        'Parse error on line ' +
                        (q + 1) +
                        ': Unexpected ' +
                        (st == kt ? 'end of input' : "'" + (this.terminals_[st] || st) + "'")),
                    this.parseError(bt, {
                      text: yt.match,
                      token: this.terminals_[st] || st,
                      line: yt.yylineno,
                      loc: it,
                      expected: At,
                    })
                }
                if (z[0] instanceof Array && z.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + gt + ', token: ' + st)
                switch (z[0]) {
                  case 1:
                    N.push(st),
                      I.push(yt.yytext),
                      M.push(yt.yylloc),
                      N.push(z[1]),
                      (st = null),
                      U
                        ? ((st = U), (U = null))
                        : ((tt = yt.yyleng), ($ = yt.yytext), (q = yt.yylineno), (it = yt.yylloc), ft > 0 && ft--)
                    break
                  case 2:
                    if (
                      ((se = this.productions_[z[1]][1]),
                      (jt.$ = I[I.length - se]),
                      (jt._$ = {
                        first_line: M[M.length - (se || 1)].first_line,
                        last_line: M[M.length - 1].last_line,
                        first_column: M[M.length - (se || 1)].first_column,
                        last_column: M[M.length - 1].last_column,
                      }),
                      Q && (jt._$.range = [M[M.length - (se || 1)].range[0], M[M.length - 1].range[1]]),
                      (lt = this.performAction.apply(jt, [$, tt, q, ot.yy, z[1], I, M].concat(ht))),
                      typeof lt < 'u')
                    )
                      return lt
                    se && ((N = N.slice(0, -1 * se * 2)), (I = I.slice(0, -1 * se)), (M = M.slice(0, -1 * se))),
                      N.push(this.productions_[z[1]][0]),
                      I.push(jt.$),
                      M.push(jt._$),
                      (Nt = V[N[N.length - 2]][N[N.length - 1]]),
                      N.push(Nt)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          S = (function () {
            var E = {
              EOF: 1,
              parseError: a(function (L, N) {
                if (this.yy.parser) this.yy.parser.parseError(L, N)
                else throw new Error(L)
              }, 'parseError'),
              setInput: a(function (_, L) {
                return (
                  (this.yy = L || this.yy || {}),
                  (this._input = _),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var _ = this._input[0]
                ;(this.yytext += _), this.yyleng++, this.offset++, (this.match += _), (this.matched += _)
                var L = _.match(/(?:\r\n?|\n).*/g)
                return (
                  L ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  _
                )
              }, 'input'),
              unput: a(function (_) {
                var L = _.length,
                  N = _.split(/(?:\r\n?|\n)/g)
                ;(this._input = _ + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - L)),
                  (this.offset -= L)
                var P = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  N.length - 1 && (this.yylineno -= N.length - 1)
                var I = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: N
                      ? (N.length === P.length ? this.yylloc.first_column : 0) +
                        P[P.length - N.length].length -
                        N[0].length
                      : this.yylloc.first_column - L,
                  }),
                  this.options.ranges && (this.yylloc.range = [I[0], I[0] + this.yyleng - L]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (_) {
                this.unput(this.match.slice(_))
              }, 'less'),
              pastInput: a(function () {
                var _ = this.matched.substr(0, this.matched.length - this.match.length)
                return (_.length > 20 ? '...' : '') + _.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var _ = this.match
                return (
                  _.length < 20 && (_ += this._input.substr(0, 20 - _.length)),
                  (_.substr(0, 20) + (_.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var _ = this.pastInput(),
                  L = new Array(_.length + 1).join('-')
                return (
                  _ +
                  this.upcomingInput() +
                  `
` +
                  L +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (_, L) {
                var N, P, I
                if (
                  (this.options.backtrack_lexer &&
                    ((I = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (I.yylloc.range = this.yylloc.range.slice(0))),
                  (P = _[0].match(/(?:\r\n?|\n).*/g)),
                  P && (this.yylineno += P.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: P
                      ? P[P.length - 1].length - P[P.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + _[0].length,
                  }),
                  (this.yytext += _[0]),
                  (this.match += _[0]),
                  (this.matches = _),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(_[0].length)),
                  (this.matched += _[0]),
                  (N = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    L,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  N)
                )
                  return N
                if (this._backtrack) {
                  for (var M in I) this[M] = I[M]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var _, L, N, P
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var I = this._currentRules(), M = 0; M < I.length; M++)
                  if (((N = this._input.match(this.rules[I[M]])), N && (!L || N[0].length > L[0].length))) {
                    if (((L = N), (P = M), this.options.backtrack_lexer)) {
                      if (((_ = this.test_match(N, I[M])), _ !== !1)) return _
                      if (this._backtrack) {
                        L = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return L
                  ? ((_ = this.test_match(L, I[P])), _ !== !1 ? _ : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var L = this.next()
                return L || this.lex()
              }, 'lex'),
              begin: a(function (L) {
                this.conditionStack.push(L)
              }, 'begin'),
              popState: a(function () {
                var L = this.conditionStack.length - 1
                return L > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (L) {
                return (
                  (L = this.conditionStack.length - 1 - Math.abs(L || 0)), L >= 0 ? this.conditionStack[L] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (L) {
                this.begin(L)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (L, N, P, I) {
                var M = I
                switch (P) {
                  case 0:
                    return this.begin('open_directive'), 'open_directive'
                    break
                  case 1:
                    return this.begin('acc_title'), 31
                    break
                  case 2:
                    return this.popState(), 'acc_title_value'
                    break
                  case 3:
                    return this.begin('acc_descr'), 33
                    break
                  case 4:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 5:
                    this.begin('acc_descr_multiline')
                    break
                  case 6:
                    this.popState()
                    break
                  case 7:
                    return 'acc_descr_multiline_value'
                  case 8:
                    break
                  case 9:
                    break
                  case 10:
                    break
                  case 11:
                    return 10
                  case 12:
                    break
                  case 13:
                    break
                  case 14:
                    this.begin('href')
                    break
                  case 15:
                    this.popState()
                    break
                  case 16:
                    return 43
                  case 17:
                    this.begin('callbackname')
                    break
                  case 18:
                    this.popState()
                    break
                  case 19:
                    this.popState(), this.begin('callbackargs')
                    break
                  case 20:
                    return 41
                  case 21:
                    this.popState()
                    break
                  case 22:
                    return 42
                  case 23:
                    this.begin('click')
                    break
                  case 24:
                    this.popState()
                    break
                  case 25:
                    return 40
                  case 26:
                    return 4
                  case 27:
                    return 22
                  case 28:
                    return 23
                  case 29:
                    return 24
                  case 30:
                    return 25
                  case 31:
                    return 26
                  case 32:
                    return 28
                  case 33:
                    return 27
                  case 34:
                    return 29
                  case 35:
                    return 12
                  case 36:
                    return 13
                  case 37:
                    return 14
                  case 38:
                    return 15
                  case 39:
                    return 16
                  case 40:
                    return 17
                  case 41:
                    return 18
                  case 42:
                    return 20
                  case 43:
                    return 21
                  case 44:
                    return 'date'
                  case 45:
                    return 30
                  case 46:
                    return 'accDescription'
                  case 47:
                    return 36
                  case 48:
                    return 38
                  case 49:
                    return 39
                  case 50:
                    return ':'
                  case 51:
                    return 6
                  case 52:
                    return 'INVALID'
                }
              }, 'anonymous'),
              rules: [
                /^(?:%%\{)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:%%(?!\{)*[^\n]*)/i,
                /^(?:[^\}]%%*[^\n]*)/i,
                /^(?:%%*[^\n]*[\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:%[^\n]*)/i,
                /^(?:href[\s]+["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:call[\s]+)/i,
                /^(?:\([\s]*\))/i,
                /^(?:\()/i,
                /^(?:[^(]*)/i,
                /^(?:\))/i,
                /^(?:[^)]*)/i,
                /^(?:click[\s]+)/i,
                /^(?:[\s\n])/i,
                /^(?:[^\s\n]*)/i,
                /^(?:gantt\b)/i,
                /^(?:dateFormat\s[^#\n;]+)/i,
                /^(?:inclusiveEndDates\b)/i,
                /^(?:topAxis\b)/i,
                /^(?:axisFormat\s[^#\n;]+)/i,
                /^(?:tickInterval\s[^#\n;]+)/i,
                /^(?:includes\s[^#\n;]+)/i,
                /^(?:excludes\s[^#\n;]+)/i,
                /^(?:todayMarker\s[^\n;]+)/i,
                /^(?:weekday\s+monday\b)/i,
                /^(?:weekday\s+tuesday\b)/i,
                /^(?:weekday\s+wednesday\b)/i,
                /^(?:weekday\s+thursday\b)/i,
                /^(?:weekday\s+friday\b)/i,
                /^(?:weekday\s+saturday\b)/i,
                /^(?:weekday\s+sunday\b)/i,
                /^(?:weekend\s+friday\b)/i,
                /^(?:weekend\s+saturday\b)/i,
                /^(?:\d\d\d\d-\d\d-\d\d\b)/i,
                /^(?:title\s[^\n]+)/i,
                /^(?:accDescription\s[^#\n;]+)/i,
                /^(?:section\s[^\n]+)/i,
                /^(?:[^:\n]+)/i,
                /^(?::[^#\n;]+)/i,
                /^(?::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [6, 7], inclusive: !1 },
                acc_descr: { rules: [4], inclusive: !1 },
                acc_title: { rules: [2], inclusive: !1 },
                callbackargs: { rules: [21, 22], inclusive: !1 },
                callbackname: { rules: [18, 19, 20], inclusive: !1 },
                href: { rules: [15, 16], inclusive: !1 },
                click: { rules: [24, 25], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 17, 23, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
                    39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                  ],
                  inclusive: !0,
                },
              },
            }
            return E
          })()
        F.lexer = S
        function O() {
          this.yy = {}
        }
        return a(O, 'Parser'), (O.prototype = F), (F.Parser = O), new O()
      })()
      RD.parser = RD
      Det = RD
    })
  var Iet = Ja((DD, ND) => {
    'use strict'
    ;(function (e, t) {
      typeof DD == 'object' && typeof ND < 'u'
        ? (ND.exports = t())
        : typeof define == 'function' && define.amd
          ? define(t)
          : ((e = typeof globalThis < 'u' ? globalThis : e || self).dayjs_plugin_isoWeek = t())
    })(DD, function () {
      'use strict'
      var e = 'day'
      return function (t, r, n) {
        var i = a(function (l) {
            return l.add(4 - l.isoWeekday(), e)
          }, 'a'),
          s = r.prototype
        ;(s.isoWeekYear = function () {
          return i(this).year()
        }),
          (s.isoWeek = function (l) {
            if (!this.$utils().u(l)) return this.add(7 * (l - this.isoWeek()), e)
            var u,
              h,
              f,
              d,
              p = i(this),
              m =
                ((u = this.isoWeekYear()),
                (h = this.$u),
                (f = (h ? n.utc : n)().year(u).startOf('year')),
                (d = 4 - f.isoWeekday()),
                f.isoWeekday() > 4 && (d += 7),
                f.add(d, e))
            return p.diff(m, 'week') + 1
          }),
          (s.isoWeekday = function (l) {
            return this.$utils().u(l) ? this.day() || 7 : this.day(this.day() % 7 ? l : l - 7)
          })
        var o = s.startOf
        s.startOf = function (l, u) {
          var h = this.$utils(),
            f = !!h.u(u) || u
          return h.p(l) === 'isoweek'
            ? f
              ? this.date(this.date() - (this.isoWeekday() - 1)).startOf('day')
              : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf('day')
            : o.bind(this)(l, u)
        }
      }
    })
  })
  var Met = Ja((ID, MD) => {
    'use strict'
    ;(function (e, t) {
      typeof ID == 'object' && typeof MD < 'u'
        ? (MD.exports = t())
        : typeof define == 'function' && define.amd
          ? define(t)
          : ((e = typeof globalThis < 'u' ? globalThis : e || self).dayjs_plugin_customParseFormat = t())
    })(ID, function () {
      'use strict'
      var e = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        r = /\d/,
        n = /\d\d/,
        i = /\d\d?/,
        s = /\d*[^-_:/,()\s\d]+/,
        o = {},
        l = a(function (g) {
          return (g = +g) + (g > 68 ? 1900 : 2e3)
        }, 'a'),
        u = a(function (g) {
          return function (y) {
            this[g] = +y
          }
        }, 'f'),
        h = [
          /[+-]\d\d:?(\d\d)?|Z/,
          function (g) {
            ;(this.zone || (this.zone = {})).offset = (function (y) {
              if (!y || y === 'Z') return 0
              var b = y.match(/([+-]|\d\d)/g),
                k = 60 * b[1] + (+b[2] || 0)
              return k === 0 ? 0 : b[0] === '+' ? -k : k
            })(g)
          },
        ],
        f = a(function (g) {
          var y = o[g]
          return y && (y.indexOf ? y : y.s.concat(y.f))
        }, 'u'),
        d = a(function (g, y) {
          var b,
            k = o.meridiem
          if (k) {
            for (var T = 1; T <= 24; T += 1)
              if (g.indexOf(k(T, 0, y)) > -1) {
                b = T > 12
                break
              }
          } else b = g === (y ? 'pm' : 'PM')
          return b
        }, 'd'),
        p = {
          A: [
            s,
            function (g) {
              this.afternoon = d(g, !1)
            },
          ],
          a: [
            s,
            function (g) {
              this.afternoon = d(g, !0)
            },
          ],
          Q: [
            r,
            function (g) {
              this.month = 3 * (g - 1) + 1
            },
          ],
          S: [
            r,
            function (g) {
              this.milliseconds = 100 * +g
            },
          ],
          SS: [
            n,
            function (g) {
              this.milliseconds = 10 * +g
            },
          ],
          SSS: [
            /\d{3}/,
            function (g) {
              this.milliseconds = +g
            },
          ],
          s: [i, u('seconds')],
          ss: [i, u('seconds')],
          m: [i, u('minutes')],
          mm: [i, u('minutes')],
          H: [i, u('hours')],
          h: [i, u('hours')],
          HH: [i, u('hours')],
          hh: [i, u('hours')],
          D: [i, u('day')],
          DD: [n, u('day')],
          Do: [
            s,
            function (g) {
              var y = o.ordinal,
                b = g.match(/\d+/)
              if (((this.day = b[0]), y))
                for (var k = 1; k <= 31; k += 1) y(k).replace(/\[|\]/g, '') === g && (this.day = k)
            },
          ],
          w: [i, u('week')],
          ww: [n, u('week')],
          M: [i, u('month')],
          MM: [n, u('month')],
          MMM: [
            s,
            function (g) {
              var y = f('months'),
                b =
                  (
                    f('monthsShort') ||
                    y.map(function (k) {
                      return k.slice(0, 3)
                    })
                  ).indexOf(g) + 1
              if (b < 1) throw new Error()
              this.month = b % 12 || b
            },
          ],
          MMMM: [
            s,
            function (g) {
              var y = f('months').indexOf(g) + 1
              if (y < 1) throw new Error()
              this.month = y % 12 || y
            },
          ],
          Y: [/[+-]?\d+/, u('year')],
          YY: [
            n,
            function (g) {
              this.year = l(g)
            },
          ],
          YYYY: [/\d{4}/, u('year')],
          Z: h,
          ZZ: h,
        }
      function m(g) {
        var y, b
        ;(y = g), (b = o && o.formats)
        for (
          var k = (g = y.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (v, R, F) {
              var S = F && F.toUpperCase()
              return (
                R ||
                b[F] ||
                e[F] ||
                b[S].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (O, E, _) {
                  return E || _.slice(1)
                })
              )
            })).match(t),
            T = k.length,
            C = 0;
          C < T;
          C += 1
        ) {
          var A = k[C],
            w = p[A],
            D = w && w[0],
            G = w && w[1]
          k[C] = G ? { regex: D, parser: G } : A.replace(/^\[|\]$/g, '')
        }
        return function (v) {
          for (var R = {}, F = 0, S = 0; F < T; F += 1) {
            var O = k[F]
            if (typeof O == 'string') S += O.length
            else {
              var E = O.regex,
                _ = O.parser,
                L = v.slice(S),
                N = E.exec(L)[0]
              _.call(R, N), (v = v.replace(N, ''))
            }
          }
          return (
            (function (P) {
              var I = P.afternoon
              if (I !== void 0) {
                var M = P.hours
                I ? M < 12 && (P.hours += 12) : M === 12 && (P.hours = 0), delete P.afternoon
              }
            })(R),
            R
          )
        }
      }
      return (
        a(m, 'l'),
        function (g, y, b) {
          ;(b.p.customParseFormat = !0), g && g.parseTwoDigitYear && (l = g.parseTwoDigitYear)
          var k = y.prototype,
            T = k.parse
          k.parse = function (C) {
            var A = C.date,
              w = C.utc,
              D = C.args
            this.$u = w
            var G = D[1]
            if (typeof G == 'string') {
              var v = D[2] === !0,
                R = D[3] === !0,
                F = v || R,
                S = D[2]
              R && (S = D[2]),
                (o = this.$locale()),
                !v && S && (o = b.Ls[S]),
                (this.$d = (function (L, N, P, I) {
                  try {
                    if (['x', 'X'].indexOf(N) > -1) return new Date((N === 'X' ? 1e3 : 1) * L)
                    var M = m(N)(L),
                      V = M.year,
                      $ = M.month,
                      q = M.day,
                      tt = M.hours,
                      ft = M.minutes,
                      H = M.seconds,
                      kt = M.milliseconds,
                      ht = M.zone,
                      yt = M.week,
                      ot = new Date(),
                      dt = q || (V || $ ? 1 : ot.getDate()),
                      it = V || ot.getFullYear(),
                      Q = 0
                    ;(V && !$) || (Q = $ > 0 ? $ - 1 : ot.getMonth())
                    var et,
                      X = tt || 0,
                      st = ft || 0,
                      U = H || 0,
                      gt = kt || 0
                    return ht
                      ? new Date(Date.UTC(it, Q, dt, X, st, U, gt + 60 * ht.offset * 1e3))
                      : P
                        ? new Date(Date.UTC(it, Q, dt, X, st, U, gt))
                        : ((et = new Date(it, Q, dt, X, st, U, gt)), yt && (et = I(et).week(yt).toDate()), et)
                  } catch {
                    return new Date('')
                  }
                })(A, G, w, b)),
                this.init(),
                S && S !== !0 && (this.$L = this.locale(S).$L),
                F && A != this.format(G) && (this.$d = new Date('')),
                (o = {})
            } else if (G instanceof Array)
              for (var O = G.length, E = 1; E <= O; E += 1) {
                D[1] = G[E - 1]
                var _ = b.apply(this, D)
                if (_.isValid()) {
                  ;(this.$d = _.$d), (this.$L = _.$L), this.init()
                  break
                }
                E === O && (this.$d = new Date(''))
              }
            else T.call(this, C)
          }
        }
      )
    })
  })
  var Oet = Ja((OD, PD) => {
    'use strict'
    ;(function (e, t) {
      typeof OD == 'object' && typeof PD < 'u'
        ? (PD.exports = t())
        : typeof define == 'function' && define.amd
          ? define(t)
          : ((e = typeof globalThis < 'u' ? globalThis : e || self).dayjs_plugin_advancedFormat = t())
    })(OD, function () {
      'use strict'
      return function (e, t) {
        var r = t.prototype,
          n = r.format
        r.format = function (i) {
          var s = this,
            o = this.$locale()
          if (!this.isValid()) return n.bind(this)(i)
          var l = this.$utils(),
            u = (i || 'YYYY-MM-DDTHH:mm:ssZ').replace(
              /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
              function (h) {
                switch (h) {
                  case 'Q':
                    return Math.ceil((s.$M + 1) / 3)
                  case 'Do':
                    return o.ordinal(s.$D)
                  case 'gggg':
                    return s.weekYear()
                  case 'GGGG':
                    return s.isoWeekYear()
                  case 'wo':
                    return o.ordinal(s.week(), 'W')
                  case 'w':
                  case 'ww':
                    return l.s(s.week(), h === 'w' ? 1 : 2, '0')
                  case 'W':
                  case 'WW':
                    return l.s(s.isoWeek(), h === 'W' ? 1 : 2, '0')
                  case 'k':
                  case 'kk':
                    return l.s(String(s.$H === 0 ? 24 : s.$H), h === 'k' ? 1 : 2, '0')
                  case 'X':
                    return Math.floor(s.$d.getTime() / 1e3)
                  case 'x':
                    return s.$d.getTime()
                  case 'z':
                    return '[' + s.offsetName() + ']'
                  case 'zzz':
                    return '[' + s.offsetName('long') + ']'
                  default:
                    return h
                }
              },
            )
          return n.bind(this)(u)
        }
      }
    })
  })
  function Qet(e, t, r) {
    let n = !0
    for (; n; )
      (n = !1),
        r.forEach(function (i) {
          let s = '^\\s*' + i + '\\s*$',
            o = new RegExp(s)
          e[0].match(o) && ((t[i] = !0), e.shift(1), (n = !0))
        })
  }
  var Fet,
    $s,
    $et,
    Get,
    Vet,
    Pet,
    Ho,
    GD,
    VD,
    zD,
    Iy,
    My,
    WD,
    UD,
    y_,
    bm,
    jD,
    zet,
    qD,
    Oy,
    HD,
    YD,
    x_,
    BD,
    R6t,
    D6t,
    N6t,
    I6t,
    M6t,
    O6t,
    P6t,
    B6t,
    F6t,
    $6t,
    G6t,
    V6t,
    z6t,
    W6t,
    U6t,
    j6t,
    q6t,
    H6t,
    Y6t,
    X6t,
    K6t,
    Q6t,
    Z6t,
    Wet,
    J6t,
    tLt,
    eLt,
    Uet,
    rLt,
    FD,
    jet,
    qet,
    m_,
    xm,
    nLt,
    iLt,
    $D,
    g_,
    $n,
    Het,
    sLt,
    Yh,
    aLt,
    Bet,
    oLt,
    Yet,
    lLt,
    Xet,
    cLt,
    uLt,
    Ket,
    Zet = x(() => {
      'use strict'
      ;(Fet = Ss(Vf(), 1)), ($s = Ss(ox(), 1)), ($et = Ss(Iet(), 1)), (Get = Ss(Met(), 1)), (Vet = Ss(Oet(), 1))
      Vt()
      pe()
      Ce()
      bn()
      $s.default.extend($et.default)
      $s.default.extend(Get.default)
      $s.default.extend(Vet.default)
      ;(Pet = { friday: 5, saturday: 6 }),
        (Ho = ''),
        (GD = ''),
        (zD = ''),
        (Iy = []),
        (My = []),
        (WD = new Map()),
        (UD = []),
        (y_ = []),
        (bm = ''),
        (jD = ''),
        (zet = ['active', 'done', 'crit', 'milestone', 'vert']),
        (qD = []),
        (Oy = !1),
        (HD = !1),
        (YD = 'sunday'),
        (x_ = 'saturday'),
        (BD = 0),
        (R6t = a(function () {
          ;(UD = []),
            (y_ = []),
            (bm = ''),
            (qD = []),
            (m_ = 0),
            ($D = void 0),
            (g_ = void 0),
            ($n = []),
            (Ho = ''),
            (GD = ''),
            (jD = ''),
            (VD = void 0),
            (zD = ''),
            (Iy = []),
            (My = []),
            (Oy = !1),
            (HD = !1),
            (BD = 0),
            (WD = new Map()),
            Ye(),
            (YD = 'sunday'),
            (x_ = 'saturday')
        }, 'clear')),
        (D6t = a(function (e) {
          GD = e
        }, 'setAxisFormat')),
        (N6t = a(function () {
          return GD
        }, 'getAxisFormat')),
        (I6t = a(function (e) {
          VD = e
        }, 'setTickInterval')),
        (M6t = a(function () {
          return VD
        }, 'getTickInterval')),
        (O6t = a(function (e) {
          zD = e
        }, 'setTodayMarker')),
        (P6t = a(function () {
          return zD
        }, 'getTodayMarker')),
        (B6t = a(function (e) {
          Ho = e
        }, 'setDateFormat')),
        (F6t = a(function () {
          Oy = !0
        }, 'enableInclusiveEndDates')),
        ($6t = a(function () {
          return Oy
        }, 'endDatesAreInclusive')),
        (G6t = a(function () {
          HD = !0
        }, 'enableTopAxis')),
        (V6t = a(function () {
          return HD
        }, 'topAxisEnabled')),
        (z6t = a(function (e) {
          jD = e
        }, 'setDisplayMode')),
        (W6t = a(function () {
          return jD
        }, 'getDisplayMode')),
        (U6t = a(function () {
          return Ho
        }, 'getDateFormat')),
        (j6t = a(function (e) {
          Iy = e.toLowerCase().split(/[\s,]+/)
        }, 'setIncludes')),
        (q6t = a(function () {
          return Iy
        }, 'getIncludes')),
        (H6t = a(function (e) {
          My = e.toLowerCase().split(/[\s,]+/)
        }, 'setExcludes')),
        (Y6t = a(function () {
          return My
        }, 'getExcludes')),
        (X6t = a(function () {
          return WD
        }, 'getLinks')),
        (K6t = a(function (e) {
          ;(bm = e), UD.push(e)
        }, 'addSection')),
        (Q6t = a(function () {
          return UD
        }, 'getSections')),
        (Z6t = a(function () {
          let e = Bet(),
            t = 10,
            r = 0
          for (; !e && r < t; ) (e = Bet()), r++
          return (y_ = $n), y_
        }, 'getTasks')),
        (Wet = a(function (e, t, r, n) {
          let i = e.format(t.trim()),
            s = e.format('YYYY-MM-DD')
          return n.includes(i) || n.includes(s)
            ? !1
            : (r.includes('weekends') && (e.isoWeekday() === Pet[x_] || e.isoWeekday() === Pet[x_] + 1)) ||
                r.includes(e.format('dddd').toLowerCase())
              ? !0
              : r.includes(i) || r.includes(s)
        }, 'isInvalidDate')),
        (J6t = a(function (e) {
          YD = e
        }, 'setWeekday')),
        (tLt = a(function () {
          return YD
        }, 'getWeekday')),
        (eLt = a(function (e) {
          x_ = e
        }, 'setWeekend')),
        (Uet = a(function (e, t, r, n) {
          if (!r.length || e.manualEndTime) return
          let i
          e.startTime instanceof Date ? (i = (0, $s.default)(e.startTime)) : (i = (0, $s.default)(e.startTime, t, !0)),
            (i = i.add(1, 'd'))
          let s
          e.endTime instanceof Date ? (s = (0, $s.default)(e.endTime)) : (s = (0, $s.default)(e.endTime, t, !0))
          let [o, l] = rLt(i, s, t, r, n)
          ;(e.endTime = o.toDate()), (e.renderEndTime = l)
        }, 'checkTaskDates')),
        (rLt = a(function (e, t, r, n, i) {
          let s = !1,
            o = null
          for (; e <= t; ) s || (o = t.toDate()), (s = Wet(e, r, n, i)), s && (t = t.add(1, 'd')), (e = e.add(1, 'd'))
          return [t, o]
        }, 'fixTaskDates')),
        (FD = a(function (e, t, r) {
          if (((r = r.trim()), (t.trim() === 'x' || t.trim() === 'X') && /^\d+$/.test(r))) return new Date(Number(r))
          let i = /^after\s+(?<ids>[\d\w- ]+)/.exec(r)
          if (i !== null) {
            let o = null
            for (let u of i.groups.ids.split(' ')) {
              let h = Yh(u)
              h !== void 0 && (!o || h.endTime > o.endTime) && (o = h)
            }
            if (o) return o.endTime
            let l = new Date()
            return l.setHours(0, 0, 0, 0), l
          }
          let s = (0, $s.default)(r, t.trim(), !0)
          if (s.isValid()) return s.toDate()
          {
            B.debug('Invalid date:' + r), B.debug('With date format:' + t.trim())
            let o = new Date(r)
            if (o === void 0 || isNaN(o.getTime()) || o.getFullYear() < -1e4 || o.getFullYear() > 1e4)
              throw new Error('Invalid date:' + r)
            return o
          }
        }, 'getStartDate')),
        (jet = a(function (e) {
          let t = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(e.trim())
          return t !== null ? [Number.parseFloat(t[1]), t[2]] : [NaN, 'ms']
        }, 'parseDuration')),
        (qet = a(function (e, t, r, n = !1) {
          r = r.trim()
          let s = /^until\s+(?<ids>[\d\w- ]+)/.exec(r)
          if (s !== null) {
            let f = null
            for (let p of s.groups.ids.split(' ')) {
              let m = Yh(p)
              m !== void 0 && (!f || m.startTime < f.startTime) && (f = m)
            }
            if (f) return f.startTime
            let d = new Date()
            return d.setHours(0, 0, 0, 0), d
          }
          let o = (0, $s.default)(r, t.trim(), !0)
          if (o.isValid()) return n && (o = o.add(1, 'd')), o.toDate()
          let l = (0, $s.default)(e),
            [u, h] = jet(r)
          if (!Number.isNaN(u)) {
            let f = l.add(u, h)
            f.isValid() && (l = f)
          }
          return l.toDate()
        }, 'getEndDate')),
        (m_ = 0),
        (xm = a(function (e) {
          return e === void 0 ? ((m_ = m_ + 1), 'task' + m_) : e
        }, 'parseId')),
        (nLt = a(function (e, t) {
          let r
          t.substr(0, 1) === ':' ? (r = t.substr(1, t.length)) : (r = t)
          let n = r.split(','),
            i = {}
          Qet(n, i, zet)
          for (let o = 0; o < n.length; o++) n[o] = n[o].trim()
          let s = ''
          switch (n.length) {
            case 1:
              ;(i.id = xm()), (i.startTime = e.endTime), (s = n[0])
              break
            case 2:
              ;(i.id = xm()), (i.startTime = FD(void 0, Ho, n[0])), (s = n[1])
              break
            case 3:
              ;(i.id = xm(n[0])), (i.startTime = FD(void 0, Ho, n[1])), (s = n[2])
              break
            default:
          }
          return (
            s &&
              ((i.endTime = qet(i.startTime, Ho, s, Oy)),
              (i.manualEndTime = (0, $s.default)(s, 'YYYY-MM-DD', !0).isValid()),
              Uet(i, Ho, My, Iy)),
            i
          )
        }, 'compileData')),
        (iLt = a(function (e, t) {
          let r
          t.substr(0, 1) === ':' ? (r = t.substr(1, t.length)) : (r = t)
          let n = r.split(','),
            i = {}
          Qet(n, i, zet)
          for (let s = 0; s < n.length; s++) n[s] = n[s].trim()
          switch (n.length) {
            case 1:
              ;(i.id = xm()), (i.startTime = { type: 'prevTaskEnd', id: e }), (i.endTime = { data: n[0] })
              break
            case 2:
              ;(i.id = xm()), (i.startTime = { type: 'getStartDate', startData: n[0] }), (i.endTime = { data: n[1] })
              break
            case 3:
              ;(i.id = xm(n[0])),
                (i.startTime = { type: 'getStartDate', startData: n[1] }),
                (i.endTime = { data: n[2] })
              break
            default:
          }
          return i
        }, 'parseData')),
        ($n = []),
        (Het = {}),
        (sLt = a(function (e, t) {
          let r = {
              section: bm,
              type: bm,
              processed: !1,
              manualEndTime: !1,
              renderEndTime: null,
              raw: { data: t },
              task: e,
              classes: [],
            },
            n = iLt(g_, t)
          ;(r.raw.startTime = n.startTime),
            (r.raw.endTime = n.endTime),
            (r.id = n.id),
            (r.prevTaskId = g_),
            (r.active = n.active),
            (r.done = n.done),
            (r.crit = n.crit),
            (r.milestone = n.milestone),
            (r.vert = n.vert),
            (r.order = BD),
            BD++
          let i = $n.push(r)
          ;(g_ = r.id), (Het[r.id] = i - 1)
        }, 'addTask')),
        (Yh = a(function (e) {
          let t = Het[e]
          return $n[t]
        }, 'findTaskById')),
        (aLt = a(function (e, t) {
          let r = { section: bm, type: bm, description: e, task: e, classes: [] },
            n = nLt($D, t)
          ;(r.startTime = n.startTime),
            (r.endTime = n.endTime),
            (r.id = n.id),
            (r.active = n.active),
            (r.done = n.done),
            (r.crit = n.crit),
            (r.milestone = n.milestone),
            (r.vert = n.vert),
            ($D = r),
            y_.push(r)
        }, 'addTaskOrg')),
        (Bet = a(function () {
          let e = a(function (r) {
              let n = $n[r],
                i = ''
              switch ($n[r].raw.startTime.type) {
                case 'prevTaskEnd': {
                  let s = Yh(n.prevTaskId)
                  n.startTime = s.endTime
                  break
                }
                case 'getStartDate':
                  ;(i = FD(void 0, Ho, $n[r].raw.startTime.startData)), i && ($n[r].startTime = i)
                  break
              }
              return (
                $n[r].startTime &&
                  (($n[r].endTime = qet($n[r].startTime, Ho, $n[r].raw.endTime.data, Oy)),
                  $n[r].endTime &&
                    (($n[r].processed = !0),
                    ($n[r].manualEndTime = (0, $s.default)($n[r].raw.endTime.data, 'YYYY-MM-DD', !0).isValid()),
                    Uet($n[r], Ho, My, Iy))),
                $n[r].processed
              )
            }, 'compileTask'),
            t = !0
          for (let [r, n] of $n.entries()) e(r), (t = t && n.processed)
          return t
        }, 'compileTasks')),
        (oLt = a(function (e, t) {
          let r = t
          K().securityLevel !== 'loose' && (r = (0, Fet.sanitizeUrl)(t)),
            e.split(',').forEach(function (n) {
              Yh(n) !== void 0 &&
                (Xet(n, () => {
                  window.open(r, '_self')
                }),
                WD.set(n, r))
            }),
            Yet(e, 'clickable')
        }, 'setLink')),
        (Yet = a(function (e, t) {
          e.split(',').forEach(function (r) {
            let n = Yh(r)
            n !== void 0 && n.classes.push(t)
          })
        }, 'setClass')),
        (lLt = a(function (e, t, r) {
          if (K().securityLevel !== 'loose' || t === void 0) return
          let n = []
          if (typeof r == 'string') {
            n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
            for (let s = 0; s < n.length; s++) {
              let o = n[s].trim()
              o.startsWith('"') && o.endsWith('"') && (o = o.substr(1, o.length - 2)), (n[s] = o)
            }
          }
          n.length === 0 && n.push(e),
            Yh(e) !== void 0 &&
              Xet(e, () => {
                le.runFunc(t, ...n)
              })
        }, 'setClickFun')),
        (Xet = a(function (e, t) {
          qD.push(
            function () {
              let r = document.querySelector(`[id="${e}"]`)
              r !== null &&
                r.addEventListener('click', function () {
                  t()
                })
            },
            function () {
              let r = document.querySelector(`[id="${e}-text"]`)
              r !== null &&
                r.addEventListener('click', function () {
                  t()
                })
            },
          )
        }, 'pushFun')),
        (cLt = a(function (e, t, r) {
          e.split(',').forEach(function (n) {
            lLt(n, t, r)
          }),
            Yet(e, 'clickable')
        }, 'setClickEvent')),
        (uLt = a(function (e) {
          qD.forEach(function (t) {
            t(e)
          })
        }, 'bindFunctions')),
        (Ket = {
          getConfig: a(() => K().gantt, 'getConfig'),
          clear: R6t,
          setDateFormat: B6t,
          getDateFormat: U6t,
          enableInclusiveEndDates: F6t,
          endDatesAreInclusive: $6t,
          enableTopAxis: G6t,
          topAxisEnabled: V6t,
          setAxisFormat: D6t,
          getAxisFormat: N6t,
          setTickInterval: I6t,
          getTickInterval: M6t,
          setTodayMarker: O6t,
          getTodayMarker: P6t,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setDisplayMode: z6t,
          getDisplayMode: W6t,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: K6t,
          getSections: Q6t,
          getTasks: Z6t,
          addTask: sLt,
          findTaskById: Yh,
          addTaskOrg: aLt,
          setIncludes: j6t,
          getIncludes: q6t,
          setExcludes: H6t,
          getExcludes: Y6t,
          setClickEvent: cLt,
          setLink: oLt,
          getLinks: X6t,
          bindFunctions: uLt,
          parseDuration: jet,
          isInvalidDate: Wet,
          setWeekday: J6t,
          getWeekday: tLt,
          setWeekend: eLt,
        })
      a(Qet, 'getTaskTags')
    })
  var b_,
    hLt,
    Jet,
    fLt,
    Pl,
    dLt,
    trt,
    ert = x(() => {
      'use strict'
      b_ = Ss(ox(), 1)
      Vt()
      Ge()
      Be()
      pe()
      On()
      ;(hLt = a(function () {
        B.debug('Something is calling, setConf, remove the call')
      }, 'setConf')),
        (Jet = { monday: oc, tuesday: k2, wednesday: T2, thursday: uo, friday: S2, saturday: _2, sunday: Ra }),
        (fLt = a((e, t) => {
          let r = [...e].map(() => -1 / 0),
            n = [...e].sort((s, o) => s.startTime - o.startTime || s.order - o.order),
            i = 0
          for (let s of n)
            for (let o = 0; o < r.length; o++)
              if (s.startTime >= r[o]) {
                ;(r[o] = s.endTime), (s.order = o + t), o > i && (i = o)
                break
              }
          return i
        }, 'getMaxIntersections')),
        (dLt = a(function (e, t, r, n) {
          let i = K().gantt,
            s = K().securityLevel,
            o
          s === 'sandbox' && (o = xt('#i' + t))
          let l = s === 'sandbox' ? xt(o.nodes()[0].contentDocument.body) : xt('body'),
            u = s === 'sandbox' ? o.nodes()[0].contentDocument : document,
            h = u.getElementById(t)
          ;(Pl = h.parentElement.offsetWidth), Pl === void 0 && (Pl = 1200), i.useWidth !== void 0 && (Pl = i.useWidth)
          let f = n.db.getTasks(),
            d = []
          for (let v of f) d.push(v.type)
          d = G(d)
          let p = {},
            m = 2 * i.topPadding
          if (n.db.getDisplayMode() === 'compact' || i.displayMode === 'compact') {
            let v = {}
            for (let F of f) v[F.section] === void 0 ? (v[F.section] = [F]) : v[F.section].push(F)
            let R = 0
            for (let F of Object.keys(v)) {
              let S = fLt(v[F], R) + 1
              ;(R += S), (m += S * (i.barHeight + i.barGap)), (p[F] = S)
            }
          } else {
            m += f.length * (i.barHeight + i.barGap)
            for (let v of d) p[v] = f.filter((R) => R.type === v).length
          }
          h.setAttribute('viewBox', '0 0 ' + Pl + ' ' + m)
          let g = l.select(`[id="${t}"]`),
            y = E2()
              .domain([
                Dx(f, function (v) {
                  return v.startTime
                }),
                Rx(f, function (v) {
                  return v.endTime
                }),
              ])
              .rangeRound([0, Pl - i.leftPadding - i.rightPadding])
          function b(v, R) {
            let F = v.startTime,
              S = R.startTime,
              O = 0
            return F > S ? (O = 1) : F < S && (O = -1), O
          }
          a(b, 'taskCompare'),
            f.sort(b),
            k(f, Pl, m),
            Ar(g, m, Pl, i.useMaxWidth),
            g
              .append('text')
              .text(n.db.getDiagramTitle())
              .attr('x', Pl / 2)
              .attr('y', i.titleTopMargin)
              .attr('class', 'titleText')
          function k(v, R, F) {
            let S = i.barHeight,
              O = S + i.barGap,
              E = i.topPadding,
              _ = i.leftPadding,
              L = La().domain([0, d.length]).range(['#00B9FA', '#F95002']).interpolate(rv)
            C(O, E, _, R, F, v, n.db.getExcludes(), n.db.getIncludes()),
              A(_, E, R, F),
              T(v, O, E, _, S, L, R, F),
              w(O, E, _, S, L),
              D(_, E, R, F)
          }
          a(k, 'makeGantt')
          function T(v, R, F, S, O, E, _) {
            v.sort((V, $) => (V.vert === $.vert ? 0 : V.vert ? 1 : -1))
            let N = [...new Set(v.map((V) => V.order))].map((V) => v.find(($) => $.order === V))
            g.append('g')
              .selectAll('rect')
              .data(N)
              .enter()
              .append('rect')
              .attr('x', 0)
              .attr('y', function (V, $) {
                return ($ = V.order), $ * R + F - 2
              })
              .attr('width', function () {
                return _ - i.rightPadding / 2
              })
              .attr('height', R)
              .attr('class', function (V) {
                for (let [$, q] of d.entries()) if (V.type === q) return 'section section' + ($ % i.numberSectionStyles)
                return 'section section0'
              })
              .enter()
            let P = g.append('g').selectAll('rect').data(v).enter(),
              I = n.db.getLinks()
            if (
              (P.append('rect')
                .attr('id', function (V) {
                  return V.id
                })
                .attr('rx', 3)
                .attr('ry', 3)
                .attr('x', function (V) {
                  return V.milestone
                    ? y(V.startTime) + S + 0.5 * (y(V.endTime) - y(V.startTime)) - 0.5 * O
                    : y(V.startTime) + S
                })
                .attr('y', function (V, $) {
                  return ($ = V.order), V.vert ? i.gridLineStartPadding : $ * R + F
                })
                .attr('width', function (V) {
                  return V.milestone ? O : V.vert ? 0.08 * O : y(V.renderEndTime || V.endTime) - y(V.startTime)
                })
                .attr('height', function (V) {
                  return V.vert ? f.length * (i.barHeight + i.barGap) + i.barHeight * 2 : O
                })
                .attr('transform-origin', function (V, $) {
                  return (
                    ($ = V.order),
                    (y(V.startTime) + S + 0.5 * (y(V.endTime) - y(V.startTime))).toString() +
                      'px ' +
                      ($ * R + F + 0.5 * O).toString() +
                      'px'
                  )
                })
                .attr('class', function (V) {
                  let $ = 'task',
                    q = ''
                  V.classes.length > 0 && (q = V.classes.join(' '))
                  let tt = 0
                  for (let [H, kt] of d.entries()) V.type === kt && (tt = H % i.numberSectionStyles)
                  let ft = ''
                  return (
                    V.active
                      ? V.crit
                        ? (ft += ' activeCrit')
                        : (ft = ' active')
                      : V.done
                        ? V.crit
                          ? (ft = ' doneCrit')
                          : (ft = ' done')
                        : V.crit && (ft += ' crit'),
                    ft.length === 0 && (ft = ' task'),
                    V.milestone && (ft = ' milestone ' + ft),
                    V.vert && (ft = ' vert ' + ft),
                    (ft += tt),
                    (ft += ' ' + q),
                    $ + ft
                  )
                }),
              P.append('text')
                .attr('id', function (V) {
                  return V.id + '-text'
                })
                .text(function (V) {
                  return V.task
                })
                .attr('font-size', i.fontSize)
                .attr('x', function (V) {
                  let $ = y(V.startTime),
                    q = y(V.renderEndTime || V.endTime)
                  if ((V.milestone && (($ += 0.5 * (y(V.endTime) - y(V.startTime)) - 0.5 * O), (q = $ + O)), V.vert))
                    return y(V.startTime) + S
                  let tt = this.getBBox().width
                  return tt > q - $ ? (q + tt + 1.5 * i.leftPadding > _ ? $ + S - 5 : q + S + 5) : (q - $) / 2 + $ + S
                })
                .attr('y', function (V, $) {
                  return V.vert
                    ? i.gridLineStartPadding + f.length * (i.barHeight + i.barGap) + 60
                    : (($ = V.order), $ * R + i.barHeight / 2 + (i.fontSize / 2 - 2) + F)
                })
                .attr('text-height', O)
                .attr('class', function (V) {
                  let $ = y(V.startTime),
                    q = y(V.endTime)
                  V.milestone && (q = $ + O)
                  let tt = this.getBBox().width,
                    ft = ''
                  V.classes.length > 0 && (ft = V.classes.join(' '))
                  let H = 0
                  for (let [ht, yt] of d.entries()) V.type === yt && (H = ht % i.numberSectionStyles)
                  let kt = ''
                  return (
                    V.active && (V.crit ? (kt = 'activeCritText' + H) : (kt = 'activeText' + H)),
                    V.done
                      ? V.crit
                        ? (kt = kt + ' doneCritText' + H)
                        : (kt = kt + ' doneText' + H)
                      : V.crit && (kt = kt + ' critText' + H),
                    V.milestone && (kt += ' milestoneText'),
                    V.vert && (kt += ' vertText'),
                    tt > q - $
                      ? q + tt + 1.5 * i.leftPadding > _
                        ? ft + ' taskTextOutsideLeft taskTextOutside' + H + ' ' + kt
                        : ft + ' taskTextOutsideRight taskTextOutside' + H + ' ' + kt + ' width-' + tt
                      : ft + ' taskText taskText' + H + ' ' + kt + ' width-' + tt
                  )
                }),
              K().securityLevel === 'sandbox')
            ) {
              let V
              V = xt('#i' + t)
              let $ = V.nodes()[0].contentDocument
              P.filter(function (q) {
                return I.has(q.id)
              }).each(function (q) {
                var tt = $.querySelector('#' + q.id),
                  ft = $.querySelector('#' + q.id + '-text')
                let H = tt.parentNode
                var kt = $.createElement('a')
                kt.setAttribute('xlink:href', I.get(q.id)),
                  kt.setAttribute('target', '_top'),
                  H.appendChild(kt),
                  kt.appendChild(tt),
                  kt.appendChild(ft)
              })
            }
          }
          a(T, 'drawRects')
          function C(v, R, F, S, O, E, _, L) {
            if (_.length === 0 && L.length === 0) return
            let N, P
            for (let { startTime: tt, endTime: ft } of E)
              (N === void 0 || tt < N) && (N = tt), (P === void 0 || ft > P) && (P = ft)
            if (!N || !P) return
            if ((0, b_.default)(P).diff((0, b_.default)(N), 'year') > 5) {
              B.warn(
                'The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days.',
              )
              return
            }
            let I = n.db.getDateFormat(),
              M = [],
              V = null,
              $ = (0, b_.default)(N)
            for (; $.valueOf() <= P; )
              n.db.isInvalidDate($, I, _, L)
                ? V
                  ? (V.end = $)
                  : (V = { start: $, end: $ })
                : V && (M.push(V), (V = null)),
                ($ = $.add(1, 'd'))
            g.append('g')
              .selectAll('rect')
              .data(M)
              .enter()
              .append('rect')
              .attr('id', (tt) => 'exclude-' + tt.start.format('YYYY-MM-DD'))
              .attr('x', (tt) => y(tt.start.startOf('day')) + F)
              .attr('y', i.gridLineStartPadding)
              .attr('width', (tt) => y(tt.end.endOf('day')) - y(tt.start.startOf('day')))
              .attr('height', O - R - i.gridLineStartPadding)
              .attr('transform-origin', function (tt, ft) {
                return (
                  (y(tt.start) + F + 0.5 * (y(tt.end) - y(tt.start))).toString() +
                  'px ' +
                  (ft * v + 0.5 * O).toString() +
                  'px'
                )
              })
              .attr('class', 'exclude-range')
          }
          a(C, 'drawExcludeDays')
          function A(v, R, F, S) {
            let O = n.db.getDateFormat(),
              E = n.db.getAxisFormat(),
              _
            E ? (_ = E) : O === 'D' ? (_ = '%d') : (_ = i.axisFormat ?? '%Y-%m-%d')
            let L = Bw(y)
                .tickSize(-S + R + i.gridLineStartPadding)
                .tickFormat($u(_)),
              P = /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(
                n.db.getTickInterval() || i.tickInterval,
              )
            if (P !== null) {
              let I = P[1],
                M = P[2],
                V = n.db.getWeekday() || i.weekday
              switch (M) {
                case 'millisecond':
                  L.ticks(lo.every(I))
                  break
                case 'second':
                  L.ticks(ws.every(I))
                  break
                case 'minute':
                  L.ticks(ol.every(I))
                  break
                case 'hour':
                  L.ticks(ll.every(I))
                  break
                case 'day':
                  L.ticks(Ys.every(I))
                  break
                case 'week':
                  L.ticks(Jet[V].every(I))
                  break
                case 'month':
                  L.ticks(cl.every(I))
                  break
              }
            }
            if (
              (g
                .append('g')
                .attr('class', 'grid')
                .attr('transform', 'translate(' + v + ', ' + (S - 50) + ')')
                .call(L)
                .selectAll('text')
                .style('text-anchor', 'middle')
                .attr('fill', '#000')
                .attr('stroke', 'none')
                .attr('font-size', 10)
                .attr('dy', '1em'),
              n.db.topAxisEnabled() || i.topAxis)
            ) {
              let I = Pw(y)
                .tickSize(-S + R + i.gridLineStartPadding)
                .tickFormat($u(_))
              if (P !== null) {
                let M = P[1],
                  V = P[2],
                  $ = n.db.getWeekday() || i.weekday
                switch (V) {
                  case 'millisecond':
                    I.ticks(lo.every(M))
                    break
                  case 'second':
                    I.ticks(ws.every(M))
                    break
                  case 'minute':
                    I.ticks(ol.every(M))
                    break
                  case 'hour':
                    I.ticks(ll.every(M))
                    break
                  case 'day':
                    I.ticks(Ys.every(M))
                    break
                  case 'week':
                    I.ticks(Jet[$].every(M))
                    break
                  case 'month':
                    I.ticks(cl.every(M))
                    break
                }
              }
              g.append('g')
                .attr('class', 'grid')
                .attr('transform', 'translate(' + v + ', ' + R + ')')
                .call(I)
                .selectAll('text')
                .style('text-anchor', 'middle')
                .attr('fill', '#000')
                .attr('stroke', 'none')
                .attr('font-size', 10)
            }
          }
          a(A, 'makeGrid')
          function w(v, R) {
            let F = 0,
              S = Object.keys(p).map((O) => [O, p[O]])
            g.append('g')
              .selectAll('text')
              .data(S)
              .enter()
              .append(function (O) {
                let E = O[0].split(Rt.lineBreakRegex),
                  _ = -(E.length - 1) / 2,
                  L = u.createElementNS('http://www.w3.org/2000/svg', 'text')
                L.setAttribute('dy', _ + 'em')
                for (let [N, P] of E.entries()) {
                  let I = u.createElementNS('http://www.w3.org/2000/svg', 'tspan')
                  I.setAttribute('alignment-baseline', 'central'),
                    I.setAttribute('x', '10'),
                    N > 0 && I.setAttribute('dy', '1em'),
                    (I.textContent = P),
                    L.appendChild(I)
                }
                return L
              })
              .attr('x', 10)
              .attr('y', function (O, E) {
                if (E > 0) for (let _ = 0; _ < E; _++) return (F += S[E - 1][1]), (O[1] * v) / 2 + F * v + R
                else return (O[1] * v) / 2 + R
              })
              .attr('font-size', i.sectionFontSize)
              .attr('class', function (O) {
                for (let [E, _] of d.entries())
                  if (O[0] === _) return 'sectionTitle sectionTitle' + (E % i.numberSectionStyles)
                return 'sectionTitle'
              })
          }
          a(w, 'vertLabels')
          function D(v, R, F, S) {
            let O = n.db.getTodayMarker()
            if (O === 'off') return
            let E = g.append('g').attr('class', 'today'),
              _ = new Date(),
              L = E.append('line')
            L.attr('x1', y(_) + v)
              .attr('x2', y(_) + v)
              .attr('y1', i.titleTopMargin)
              .attr('y2', S - i.titleTopMargin)
              .attr('class', 'today'),
              O !== '' && L.attr('style', O.replace(/,/g, ';'))
          }
          a(D, 'drawToday')
          function G(v) {
            let R = {},
              F = []
            for (let S = 0, O = v.length; S < O; ++S)
              Object.prototype.hasOwnProperty.call(R, v[S]) || ((R[v[S]] = !0), F.push(v[S]))
            return F
          }
          a(G, 'checkUnique')
        }, 'draw')),
        (trt = { setConf: hLt, draw: dLt })
    })
  var pLt,
    rrt,
    nrt = x(() => {
      'use strict'
      ;(pLt = a(
        (e) => `
  .mermaid-main-font {
        font-family: ${e.fontFamily};
  }

  .exclude-range {
    fill: ${e.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${e.sectionBkgColor};
  }

  .section2 {
    fill: ${e.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${e.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${e.titleColor};
  }

  .sectionTitle1 {
    fill: ${e.titleColor};
  }

  .sectionTitle2 {
    fill: ${e.titleColor};
  }

  .sectionTitle3 {
    fill: ${e.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${e.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${e.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${e.fontFamily};
    fill: ${e.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${e.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${e.taskTextDarkColor};
    text-anchor: start;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${e.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${e.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${e.taskBkgColor};
    stroke: ${e.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${e.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${e.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${e.activeTaskBkgColor};
    stroke: ${e.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${e.doneTaskBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${e.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${e.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.titleColor || e.textColor};
    font-family: ${e.fontFamily};
  }
`,
        'getStyles',
      )),
        (rrt = pLt)
    })
  var irt = {}
  Oe(irt, { diagram: () => mLt })
  var mLt,
    srt = x(() => {
      'use strict'
      Net()
      Zet()
      ert()
      nrt()
      mLt = { parser: Det, db: Ket, renderer: trt, styles: rrt }
    })
  var lrt,
    crt = x(() => {
      'use strict'
      jh()
      Vt()
      lrt = {
        parse: a(async (e) => {
          let t = await Fs('info', e)
          B.debug(t)
        }, 'parse'),
      }
    })
  var Py,
    XD = x(() => {
      Py = {
        name: 'mermaid',
        version: '11.12.0',
        description:
          'Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.',
        type: 'module',
        module: './dist/mermaid.core.mjs',
        types: './dist/mermaid.d.ts',
        exports: {
          '.': { types: './dist/mermaid.d.ts', import: './dist/mermaid.core.mjs', default: './dist/mermaid.core.mjs' },
          './*': './*',
        },
        keywords: [
          'diagram',
          'markdown',
          'flowchart',
          'sequence diagram',
          'gantt',
          'class diagram',
          'git graph',
          'mindmap',
          'packet diagram',
          'c4 diagram',
          'er diagram',
          'pie chart',
          'pie diagram',
          'quadrant chart',
          'requirement diagram',
          'graph',
        ],
        scripts: {
          clean: 'rimraf dist',
          dev: 'pnpm -w dev',
          'docs:code':
            'typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup',
          'docs:build': 'rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts',
          'docs:verify': 'pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify',
          'docs:pre:vitepress':
            'pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts',
          'docs:build:vitepress':
            'pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing',
          'docs:dev':
            'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
          'docs:dev:docker':
            'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
          'docs:serve': 'pnpm docs:build:vitepress && vitepress serve src/vitepress',
          'docs:spellcheck': 'cspell "src/docs/**/*.md"',
          'docs:release-version': 'tsx scripts/update-release-version.mts',
          'docs:verify-version': 'tsx scripts/update-release-version.mts --verify',
          'types:build-config': 'tsx scripts/create-types-from-json-schema.mts',
          'types:verify-config': 'tsx scripts/create-types-from-json-schema.mts --verify',
          checkCircle: 'npx madge --circular ./src',
          prepublishOnly: 'pnpm docs:verify-version',
        },
        repository: { type: 'git', url: 'https://github.com/mermaid-js/mermaid' },
        author: 'Knut Sveidqvist',
        license: 'MIT',
        standard: { ignore: ['**/parser/*.js', 'dist/**/*.js', 'cypress/**/*.js'], globals: ['page'] },
        dependencies: {
          '@braintree/sanitize-url': '^7.1.1',
          '@iconify/utils': '^3.0.1',
          '@mermaid-js/parser': 'workspace:^',
          '@types/d3': '^7.4.3',
          cytoscape: '^3.29.3',
          'cytoscape-cose-bilkent': '^4.1.0',
          'cytoscape-fcose': '^2.2.0',
          d3: '^7.9.0',
          'd3-sankey': '^0.12.3',
          'dagre-d3-es': '7.0.11',
          dayjs: '^1.11.18',
          dompurify: '^3.2.5',
          katex: '^0.16.22',
          khroma: '^2.1.0',
          'lodash-es': '^4.17.21',
          marked: '^16.2.1',
          roughjs: '^4.6.6',
          stylis: '^4.3.6',
          'ts-dedent': '^2.2.0',
          uuid: '^11.1.0',
        },
        devDependencies: {
          '@adobe/jsonschema2md': '^8.0.5',
          '@iconify/types': '^2.0.0',
          '@types/cytoscape': '^3.21.9',
          '@types/cytoscape-fcose': '^2.2.4',
          '@types/d3-sankey': '^0.12.4',
          '@types/d3-scale': '^4.0.9',
          '@types/d3-scale-chromatic': '^3.1.0',
          '@types/d3-selection': '^3.0.11',
          '@types/d3-shape': '^3.1.7',
          '@types/jsdom': '^21.1.7',
          '@types/katex': '^0.16.7',
          '@types/lodash-es': '^4.17.12',
          '@types/micromatch': '^4.0.9',
          '@types/stylis': '^4.2.7',
          '@types/uuid': '^10.0.0',
          ajv: '^8.17.1',
          canvas: '^3.1.2',
          chokidar: '3.6.0',
          concurrently: '^9.1.2',
          'csstree-validator': '^4.0.1',
          globby: '^14.1.0',
          jison: '^0.4.18',
          'js-base64': '^3.7.8',
          jsdom: '^26.1.0',
          'json-schema-to-typescript': '^15.0.4',
          micromatch: '^4.0.8',
          'path-browserify': '^1.0.1',
          prettier: '^3.5.3',
          remark: '^15.0.1',
          'remark-frontmatter': '^5.0.0',
          'remark-gfm': '^4.0.1',
          rimraf: '^6.0.1',
          'start-server-and-test': '^2.0.13',
          'type-fest': '^4.35.0',
          typedoc: '^0.28.12',
          'typedoc-plugin-markdown': '^4.8.1',
          typescript: '~5.7.3',
          'unist-util-flatmap': '^1.0.0',
          'unist-util-visit': '^5.0.0',
          vitepress: '^1.6.4',
          'vitepress-plugin-search': '1.0.4-alpha.22',
        },
        files: ['dist/', 'README.md'],
        publishConfig: { access: 'public' },
      }
    })
  var kLt,
    TLt,
    urt,
    hrt = x(() => {
      'use strict'
      XD()
      ;(kLt = { version: Py.version + '-tiny' }),
        (TLt = a(() => kLt.version, 'getVersion')),
        (urt = { getVersion: TLt })
    })
  var Ai,
    Bl = x(() => {
      'use strict'
      Ge()
      pe()
      Ai = a((e) => {
        let { securityLevel: t } = K(),
          r = xt('body')
        if (t === 'sandbox') {
          let s = xt(`#i${e}`).node()?.contentDocument ?? document
          r = xt(s.body)
        }
        return r.select(`#${e}`)
      }, 'selectSvgElement')
    })
  var SLt,
    frt,
    drt = x(() => {
      'use strict'
      Vt()
      Bl()
      On()
      ;(SLt = a((e, t, r) => {
        B.debug(
          `rendering info diagram
` + e,
        )
        let n = Ai(t)
        Ar(n, 100, 400, !0),
          n
            .append('g')
            .append('text')
            .attr('x', 100)
            .attr('y', 40)
            .attr('class', 'version')
            .attr('font-size', 32)
            .style('text-anchor', 'middle')
            .text(`v${r}`)
      }, 'draw')),
        (frt = { draw: SLt })
    })
  var prt = {}
  Oe(prt, { diagram: () => _Lt })
  var _Lt,
    mrt = x(() => {
      'use strict'
      crt()
      hrt()
      drt()
      _Lt = { parser: lrt, db: urt, renderer: frt }
    })
  var xrt,
    KD,
    k_,
    QD,
    ELt,
    vLt,
    ALt,
    LLt,
    RLt,
    DLt,
    NLt,
    T_,
    ZD = x(() => {
      'use strict'
      Vt()
      bn()
      _s()
      ;(xrt = ze.pie),
        (KD = { sections: new Map(), showData: !1, config: xrt }),
        (k_ = KD.sections),
        (QD = KD.showData),
        (ELt = structuredClone(xrt)),
        (vLt = a(() => structuredClone(ELt), 'getConfig')),
        (ALt = a(() => {
          ;(k_ = new Map()), (QD = KD.showData), Ye()
        }, 'clear')),
        (LLt = a(({ label: e, value: t }) => {
          if (t < 0)
            throw new Error(
              `"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`,
            )
          k_.has(e) || (k_.set(e, t), B.debug(`added new section: ${e}, with value: ${t}`))
        }, 'addSection')),
        (RLt = a(() => k_, 'getSections')),
        (DLt = a((e) => {
          QD = e
        }, 'setShowData')),
        (NLt = a(() => QD, 'getShowData')),
        (T_ = {
          getConfig: vLt,
          clear: ALt,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setAccTitle: Xe,
          getAccTitle: tr,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: LLt,
          getSections: RLt,
          setShowData: DLt,
          getShowData: NLt,
        })
    })
  var ILt,
    brt,
    krt = x(() => {
      'use strict'
      jh()
      Vt()
      gm()
      ZD()
      ;(ILt = a((e, t) => {
        jo(e, t), t.setShowData(e.showData), e.sections.map(t.addSection)
      }, 'populateDb')),
        (brt = {
          parse: a(async (e) => {
            let t = await Fs('pie', e)
            B.debug(t), ILt(t, T_)
          }, 'parse'),
        })
    })
  var MLt,
    Trt,
    Srt = x(() => {
      'use strict'
      ;(MLt = a(
        (e) => `
  .pieCircle{
    stroke: ${e.pieStrokeColor};
    stroke-width : ${e.pieStrokeWidth};
    opacity : ${e.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${e.pieOuterStrokeColor};
    stroke-width: ${e.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${e.pieTitleTextSize};
    fill: ${e.pieTitleTextColor};
    font-family: ${e.fontFamily};
  }
  .slice {
    font-family: ${e.fontFamily};
    fill: ${e.pieSectionTextColor};
    font-size:${e.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${e.pieLegendTextColor};
    font-family: ${e.fontFamily};
    font-size: ${e.pieLegendTextSize};
  }
`,
        'getStyles',
      )),
        (Trt = MLt)
    })
  var OLt,
    PLt,
    _rt,
    Crt = x(() => {
      'use strict'
      Ge()
      pe()
      Vt()
      Bl()
      On()
      Ce()
      ;(OLt = a((e) => {
        let t = [...e.values()].reduce((i, s) => i + s, 0),
          r = [...e.entries()]
            .map(([i, s]) => ({ label: i, value: s }))
            .filter((i) => (i.value / t) * 100 >= 1)
            .sort((i, s) => s.value - i.value)
        return N2().value((i) => i.value)(r)
      }, 'createPieArcs')),
        (PLt = a((e, t, r, n) => {
          B.debug(
            `rendering pie chart
` + e,
          )
          let i = n.db,
            s = K(),
            o = ln(i.getConfig(), s.pie),
            l = 40,
            u = 18,
            h = 4,
            f = 450,
            d = f,
            p = Ai(t),
            m = p.append('g')
          m.attr('transform', 'translate(' + d / 2 + ',' + f / 2 + ')')
          let { themeVariables: g } = s,
            [y] = yo(g.pieOuterStrokeWidth)
          y ??= 2
          let b = o.textPosition,
            k = Math.min(d, f) / 2 - l,
            T = Ia().innerRadius(0).outerRadius(k),
            C = Ia()
              .innerRadius(k * b)
              .outerRadius(k * b)
          m.append('circle')
            .attr('cx', 0)
            .attr('cy', 0)
            .attr('r', k + y / 2)
            .attr('class', 'pieOuterCircle')
          let A = i.getSections(),
            w = OLt(A),
            D = [g.pie1, g.pie2, g.pie3, g.pie4, g.pie5, g.pie6, g.pie7, g.pie8, g.pie9, g.pie10, g.pie11, g.pie12],
            G = 0
          A.forEach((_) => {
            G += _
          })
          let v = w.filter((_) => ((_.data.value / G) * 100).toFixed(0) !== '0'),
            R = Cs(D)
          m
            .selectAll('mySlices')
            .data(v)
            .enter()
            .append('path')
            .attr('d', T)
            .attr('fill', (_) => R(_.data.label))
            .attr('class', 'pieCircle'),
            m
              .selectAll('mySlices')
              .data(v)
              .enter()
              .append('text')
              .text((_) => ((_.data.value / G) * 100).toFixed(0) + '%')
              .attr('transform', (_) => 'translate(' + C.centroid(_) + ')')
              .style('text-anchor', 'middle')
              .attr('class', 'slice'),
            m
              .append('text')
              .text(i.getDiagramTitle())
              .attr('x', 0)
              .attr('y', -(f - 50) / 2)
              .attr('class', 'pieTitleText')
          let F = [...A.entries()].map(([_, L]) => ({ label: _, value: L })),
            S = m
              .selectAll('.legend')
              .data(F)
              .enter()
              .append('g')
              .attr('class', 'legend')
              .attr('transform', (_, L) => {
                let N = u + h,
                  P = (N * F.length) / 2,
                  I = 12 * u,
                  M = L * N - P
                return 'translate(' + I + ',' + M + ')'
              })
          S.append('rect')
            .attr('width', u)
            .attr('height', u)
            .style('fill', (_) => R(_.label))
            .style('stroke', (_) => R(_.label)),
            S.append('text')
              .attr('x', u + h)
              .attr('y', u - h)
              .text((_) => (i.getShowData() ? `${_.label} [${_.value}]` : _.label))
          let O = Math.max(
              ...S.selectAll('text')
                .nodes()
                .map((_) => _?.getBoundingClientRect().width ?? 0),
            ),
            E = d + l + u + h + O
          p.attr('viewBox', `0 0 ${E} ${f}`), Ar(p, f, E, o.useMaxWidth)
        }, 'draw')),
        (_rt = { draw: PLt })
    })
  var wrt = {}
  Oe(wrt, { diagram: () => BLt })
  var BLt,
    Ert = x(() => {
      'use strict'
      krt()
      ZD()
      Srt()
      Crt()
      BLt = { parser: brt, db: T_, renderer: _rt, styles: Trt }
    })
  var JD,
    Art,
    Lrt = x(() => {
      'use strict'
      JD = (function () {
        var e = a(function (Gt, j, vt, mt) {
            for (vt = vt || {}, mt = Gt.length; mt--; vt[Gt[mt]] = j);
            return vt
          }, 'o'),
          t = [1, 3],
          r = [1, 4],
          n = [1, 5],
          i = [1, 6],
          s = [1, 7],
          o = [
            1, 4, 5, 10, 12, 13, 14, 18, 25, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65,
            66, 67,
          ],
          l = [
            1, 4, 5, 10, 12, 13, 14, 18, 25, 28, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64,
            65, 66, 67,
          ],
          u = [55, 56, 57],
          h = [2, 36],
          f = [1, 37],
          d = [1, 36],
          p = [1, 38],
          m = [1, 35],
          g = [1, 43],
          y = [1, 41],
          b = [1, 14],
          k = [1, 23],
          T = [1, 18],
          C = [1, 19],
          A = [1, 20],
          w = [1, 21],
          D = [1, 22],
          G = [1, 24],
          v = [1, 25],
          R = [1, 26],
          F = [1, 27],
          S = [1, 28],
          O = [1, 29],
          E = [1, 32],
          _ = [1, 33],
          L = [1, 34],
          N = [1, 39],
          P = [1, 40],
          I = [1, 42],
          M = [1, 44],
          V = [1, 62],
          $ = [1, 61],
          q = [4, 5, 8, 10, 12, 13, 14, 18, 44, 47, 49, 55, 56, 57, 63, 64, 65, 66, 67],
          tt = [1, 65],
          ft = [1, 66],
          H = [1, 67],
          kt = [1, 68],
          ht = [1, 69],
          yt = [1, 70],
          ot = [1, 71],
          dt = [1, 72],
          it = [1, 73],
          Q = [1, 74],
          et = [1, 75],
          X = [1, 76],
          st = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18],
          U = [1, 90],
          gt = [1, 91],
          z = [1, 92],
          ge = [1, 99],
          lt = [1, 93],
          jt = [1, 96],
          Me = [1, 94],
          se = [1, 95],
          Nt = [1, 97],
          At = [1, 98],
          bt = [1, 102],
          ct = [10, 55, 56, 57],
          Lt = [4, 5, 6, 8, 10, 11, 13, 17, 18, 19, 20, 55, 56, 57],
          Z = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              idStringToken: 3,
              ALPHA: 4,
              NUM: 5,
              NODE_STRING: 6,
              DOWN: 7,
              MINUS: 8,
              DEFAULT: 9,
              COMMA: 10,
              COLON: 11,
              AMP: 12,
              BRKT: 13,
              MULT: 14,
              UNICODE_TEXT: 15,
              styleComponent: 16,
              UNIT: 17,
              SPACE: 18,
              STYLE: 19,
              PCT: 20,
              idString: 21,
              style: 22,
              stylesOpt: 23,
              classDefStatement: 24,
              CLASSDEF: 25,
              start: 26,
              eol: 27,
              QUADRANT: 28,
              document: 29,
              line: 30,
              statement: 31,
              axisDetails: 32,
              quadrantDetails: 33,
              points: 34,
              title: 35,
              title_value: 36,
              acc_title: 37,
              acc_title_value: 38,
              acc_descr: 39,
              acc_descr_value: 40,
              acc_descr_multiline_value: 41,
              section: 42,
              text: 43,
              point_start: 44,
              point_x: 45,
              point_y: 46,
              class_name: 47,
              'X-AXIS': 48,
              'AXIS-TEXT-DELIMITER': 49,
              'Y-AXIS': 50,
              QUADRANT_1: 51,
              QUADRANT_2: 52,
              QUADRANT_3: 53,
              QUADRANT_4: 54,
              NEWLINE: 55,
              SEMI: 56,
              EOF: 57,
              alphaNumToken: 58,
              textNoTagsToken: 59,
              STR: 60,
              MD_STR: 61,
              alphaNum: 62,
              PUNCTUATION: 63,
              PLUS: 64,
              EQUALS: 65,
              DOT: 66,
              UNDERSCORE: 67,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'ALPHA',
              5: 'NUM',
              6: 'NODE_STRING',
              7: 'DOWN',
              8: 'MINUS',
              9: 'DEFAULT',
              10: 'COMMA',
              11: 'COLON',
              12: 'AMP',
              13: 'BRKT',
              14: 'MULT',
              15: 'UNICODE_TEXT',
              17: 'UNIT',
              18: 'SPACE',
              19: 'STYLE',
              20: 'PCT',
              25: 'CLASSDEF',
              28: 'QUADRANT',
              35: 'title',
              36: 'title_value',
              37: 'acc_title',
              38: 'acc_title_value',
              39: 'acc_descr',
              40: 'acc_descr_value',
              41: 'acc_descr_multiline_value',
              42: 'section',
              44: 'point_start',
              45: 'point_x',
              46: 'point_y',
              47: 'class_name',
              48: 'X-AXIS',
              49: 'AXIS-TEXT-DELIMITER',
              50: 'Y-AXIS',
              51: 'QUADRANT_1',
              52: 'QUADRANT_2',
              53: 'QUADRANT_3',
              54: 'QUADRANT_4',
              55: 'NEWLINE',
              56: 'SEMI',
              57: 'EOF',
              60: 'STR',
              61: 'MD_STR',
              63: 'PUNCTUATION',
              64: 'PLUS',
              65: 'EQUALS',
              66: 'DOT',
              67: 'UNDERSCORE',
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [21, 1],
              [21, 2],
              [22, 1],
              [22, 2],
              [23, 1],
              [23, 3],
              [24, 5],
              [26, 2],
              [26, 2],
              [26, 2],
              [29, 0],
              [29, 2],
              [30, 2],
              [31, 0],
              [31, 1],
              [31, 2],
              [31, 1],
              [31, 1],
              [31, 1],
              [31, 2],
              [31, 2],
              [31, 2],
              [31, 1],
              [31, 1],
              [34, 4],
              [34, 5],
              [34, 5],
              [34, 6],
              [32, 4],
              [32, 3],
              [32, 2],
              [32, 4],
              [32, 3],
              [32, 2],
              [33, 2],
              [33, 2],
              [33, 2],
              [33, 2],
              [27, 1],
              [27, 1],
              [27, 1],
              [43, 1],
              [43, 2],
              [43, 1],
              [43, 1],
              [62, 1],
              [62, 2],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [59, 1],
              [59, 1],
              [59, 1],
            ],
            performAction: a(function (j, vt, mt, Xt, Ft, _t, Qe) {
              var It = _t.length - 1
              switch (Ft) {
                case 23:
                  this.$ = _t[It]
                  break
                case 24:
                  this.$ = _t[It - 1] + '' + _t[It]
                  break
                case 26:
                  this.$ = _t[It - 1] + _t[It]
                  break
                case 27:
                  this.$ = [_t[It].trim()]
                  break
                case 28:
                  _t[It - 2].push(_t[It].trim()), (this.$ = _t[It - 2])
                  break
                case 29:
                  ;(this.$ = _t[It - 4]), Xt.addClass(_t[It - 2], _t[It])
                  break
                case 37:
                  this.$ = []
                  break
                case 42:
                  ;(this.$ = _t[It].trim()), Xt.setDiagramTitle(this.$)
                  break
                case 43:
                  ;(this.$ = _t[It].trim()), Xt.setAccTitle(this.$)
                  break
                case 44:
                case 45:
                  ;(this.$ = _t[It].trim()), Xt.setAccDescription(this.$)
                  break
                case 46:
                  Xt.addSection(_t[It].substr(8)), (this.$ = _t[It].substr(8))
                  break
                case 47:
                  Xt.addPoint(_t[It - 3], '', _t[It - 1], _t[It], [])
                  break
                case 48:
                  Xt.addPoint(_t[It - 4], _t[It - 3], _t[It - 1], _t[It], [])
                  break
                case 49:
                  Xt.addPoint(_t[It - 4], '', _t[It - 2], _t[It - 1], _t[It])
                  break
                case 50:
                  Xt.addPoint(_t[It - 5], _t[It - 4], _t[It - 2], _t[It - 1], _t[It])
                  break
                case 51:
                  Xt.setXAxisLeftText(_t[It - 2]), Xt.setXAxisRightText(_t[It])
                  break
                case 52:
                  ;(_t[It - 1].text += ' \u27F6 '), Xt.setXAxisLeftText(_t[It - 1])
                  break
                case 53:
                  Xt.setXAxisLeftText(_t[It])
                  break
                case 54:
                  Xt.setYAxisBottomText(_t[It - 2]), Xt.setYAxisTopText(_t[It])
                  break
                case 55:
                  ;(_t[It - 1].text += ' \u27F6 '), Xt.setYAxisBottomText(_t[It - 1])
                  break
                case 56:
                  Xt.setYAxisBottomText(_t[It])
                  break
                case 57:
                  Xt.setQuadrant1Text(_t[It])
                  break
                case 58:
                  Xt.setQuadrant2Text(_t[It])
                  break
                case 59:
                  Xt.setQuadrant3Text(_t[It])
                  break
                case 60:
                  Xt.setQuadrant4Text(_t[It])
                  break
                case 64:
                  this.$ = { text: _t[It], type: 'text' }
                  break
                case 65:
                  this.$ = { text: _t[It - 1].text + '' + _t[It], type: _t[It - 1].type }
                  break
                case 66:
                  this.$ = { text: _t[It], type: 'text' }
                  break
                case 67:
                  this.$ = { text: _t[It], type: 'markdown' }
                  break
                case 68:
                  this.$ = _t[It]
                  break
                case 69:
                  this.$ = _t[It - 1] + '' + _t[It]
                  break
              }
            }, 'anonymous'),
            table: [
              { 18: t, 26: 1, 27: 2, 28: r, 55: n, 56: i, 57: s },
              { 1: [3] },
              { 18: t, 26: 8, 27: 2, 28: r, 55: n, 56: i, 57: s },
              { 18: t, 26: 9, 27: 2, 28: r, 55: n, 56: i, 57: s },
              e(o, [2, 33], { 29: 10 }),
              e(l, [2, 61]),
              e(l, [2, 62]),
              e(l, [2, 63]),
              { 1: [2, 30] },
              { 1: [2, 31] },
              e(u, h, {
                30: 11,
                31: 12,
                24: 13,
                32: 15,
                33: 16,
                34: 17,
                43: 30,
                58: 31,
                1: [2, 32],
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                18: b,
                25: k,
                35: T,
                37: C,
                39: A,
                41: w,
                42: D,
                48: G,
                50: v,
                51: R,
                52: F,
                53: S,
                54: O,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(o, [2, 34]),
              { 27: 45, 55: n, 56: i, 57: s },
              e(u, [2, 37]),
              e(u, h, {
                24: 13,
                32: 15,
                33: 16,
                34: 17,
                43: 30,
                58: 31,
                31: 46,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                18: b,
                25: k,
                35: T,
                37: C,
                39: A,
                41: w,
                42: D,
                48: G,
                50: v,
                51: R,
                52: F,
                53: S,
                54: O,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 39]),
              e(u, [2, 40]),
              e(u, [2, 41]),
              { 36: [1, 47] },
              { 38: [1, 48] },
              { 40: [1, 49] },
              e(u, [2, 45]),
              e(u, [2, 46]),
              { 18: [1, 50] },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 51,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 52,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 53,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 54,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 55,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 56,
                58: 31,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              {
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                44: [1, 57],
                47: [1, 58],
                58: 60,
                59: 59,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              },
              e(q, [2, 64]),
              e(q, [2, 66]),
              e(q, [2, 67]),
              e(q, [2, 70]),
              e(q, [2, 71]),
              e(q, [2, 72]),
              e(q, [2, 73]),
              e(q, [2, 74]),
              e(q, [2, 75]),
              e(q, [2, 76]),
              e(q, [2, 77]),
              e(q, [2, 78]),
              e(q, [2, 79]),
              e(q, [2, 80]),
              e(o, [2, 35]),
              e(u, [2, 38]),
              e(u, [2, 42]),
              e(u, [2, 43]),
              e(u, [2, 44]),
              { 3: 64, 4: tt, 5: ft, 6: H, 7: kt, 8: ht, 9: yt, 10: ot, 11: dt, 12: it, 13: Q, 14: et, 15: X, 21: 63 },
              e(u, [2, 53], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                49: [1, 77],
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 56], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                49: [1, 78],
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 57], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 58], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 59], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 60], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              { 45: [1, 79] },
              { 44: [1, 80] },
              e(q, [2, 65]),
              e(q, [2, 81]),
              e(q, [2, 82]),
              e(q, [2, 83]),
              {
                3: 82,
                4: tt,
                5: ft,
                6: H,
                7: kt,
                8: ht,
                9: yt,
                10: ot,
                11: dt,
                12: it,
                13: Q,
                14: et,
                15: X,
                18: [1, 81],
              },
              e(st, [2, 23]),
              e(st, [2, 1]),
              e(st, [2, 2]),
              e(st, [2, 3]),
              e(st, [2, 4]),
              e(st, [2, 5]),
              e(st, [2, 6]),
              e(st, [2, 7]),
              e(st, [2, 8]),
              e(st, [2, 9]),
              e(st, [2, 10]),
              e(st, [2, 11]),
              e(st, [2, 12]),
              e(u, [2, 52], {
                58: 31,
                43: 83,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 55], {
                58: 31,
                43: 84,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                60: E,
                61: _,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              { 46: [1, 85] },
              { 45: [1, 86] },
              { 4: U, 5: gt, 6: z, 8: ge, 11: lt, 13: jt, 16: 89, 17: Me, 18: se, 19: Nt, 20: At, 22: 88, 23: 87 },
              e(st, [2, 24]),
              e(u, [2, 51], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 54], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: L,
                64: N,
                65: P,
                66: I,
                67: M,
              }),
              e(u, [2, 47], {
                22: 88,
                16: 89,
                23: 100,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
              { 46: [1, 101] },
              e(u, [2, 29], { 10: bt }),
              e(ct, [2, 27], { 16: 103, 4: U, 5: gt, 6: z, 8: ge, 11: lt, 13: jt, 17: Me, 18: se, 19: Nt, 20: At }),
              e(Lt, [2, 25]),
              e(Lt, [2, 13]),
              e(Lt, [2, 14]),
              e(Lt, [2, 15]),
              e(Lt, [2, 16]),
              e(Lt, [2, 17]),
              e(Lt, [2, 18]),
              e(Lt, [2, 19]),
              e(Lt, [2, 20]),
              e(Lt, [2, 21]),
              e(Lt, [2, 22]),
              e(u, [2, 49], { 10: bt }),
              e(u, [2, 48], {
                22: 88,
                16: 89,
                23: 104,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
              { 4: U, 5: gt, 6: z, 8: ge, 11: lt, 13: jt, 16: 89, 17: Me, 18: se, 19: Nt, 20: At, 22: 105 },
              e(Lt, [2, 26]),
              e(u, [2, 50], { 10: bt }),
              e(ct, [2, 28], { 16: 103, 4: U, 5: gt, 6: z, 8: ge, 11: lt, 13: jt, 17: Me, 18: se, 19: Nt, 20: At }),
            ],
            defaultActions: { 8: [2, 30], 9: [2, 31] },
            parseError: a(function (j, vt) {
              if (vt.recoverable) this.trace(j)
              else {
                var mt = new Error(j)
                throw ((mt.hash = vt), mt)
              }
            }, 'parseError'),
            parse: a(function (j) {
              var vt = this,
                mt = [0],
                Xt = [],
                Ft = [null],
                _t = [],
                Qe = this.table,
                It = '',
                xr = 0,
                Ze = 0,
                yn = 0,
                Ae = 2,
                Se = 1,
                Je = _t.slice.call(arguments, 1),
                _e = Object.create(this.lexer),
                hr = { yy: {} }
              for (var Cn in this.yy) Object.prototype.hasOwnProperty.call(this.yy, Cn) && (hr.yy[Cn] = this.yy[Cn])
              _e.setInput(j, hr.yy),
                (hr.yy.lexer = _e),
                (hr.yy.parser = this),
                typeof _e.yylloc > 'u' && (_e.yylloc = {})
              var ve = _e.yylloc
              _t.push(ve)
              var $e = _e.options && _e.options.ranges
              typeof hr.yy.parseError == 'function'
                ? (this.parseError = hr.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function Le(nt) {
                ;(mt.length = mt.length - 2 * nt), (Ft.length = Ft.length - nt), (_t.length = _t.length - nt)
              }
              a(Le, 'popStack')
              function xe() {
                var nt
                return (
                  (nt = Xt.pop() || _e.lex() || Se),
                  typeof nt != 'number' &&
                    (nt instanceof Array && ((Xt = nt), (nt = Xt.pop())), (nt = vt.symbols_[nt] || nt)),
                  nt
                )
              }
              a(xe, 'lex')
              for (var ce, ye, be, Ht, Nn, ne, Ri = {}, xn, Br, vr, mi; ; ) {
                if (
                  ((be = mt[mt.length - 1]),
                  this.defaultActions[be]
                    ? (Ht = this.defaultActions[be])
                    : ((ce === null || typeof ce > 'u') && (ce = xe()), (Ht = Qe[be] && Qe[be][ce])),
                  typeof Ht > 'u' || !Ht.length || !Ht[0])
                ) {
                  var Zt = ''
                  mi = []
                  for (xn in Qe[be]) this.terminals_[xn] && xn > Ae && mi.push("'" + this.terminals_[xn] + "'")
                  _e.showPosition
                    ? (Zt =
                        'Parse error on line ' +
                        (xr + 1) +
                        `:
` +
                        _e.showPosition() +
                        `
Expecting ` +
                        mi.join(', ') +
                        ", got '" +
                        (this.terminals_[ce] || ce) +
                        "'")
                    : (Zt =
                        'Parse error on line ' +
                        (xr + 1) +
                        ': Unexpected ' +
                        (ce == Se ? 'end of input' : "'" + (this.terminals_[ce] || ce) + "'")),
                    this.parseError(Zt, {
                      text: _e.match,
                      token: this.terminals_[ce] || ce,
                      line: _e.yylineno,
                      loc: ve,
                      expected: mi,
                    })
                }
                if (Ht[0] instanceof Array && Ht.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + be + ', token: ' + ce)
                switch (Ht[0]) {
                  case 1:
                    mt.push(ce),
                      Ft.push(_e.yytext),
                      _t.push(_e.yylloc),
                      mt.push(Ht[1]),
                      (ce = null),
                      ye
                        ? ((ce = ye), (ye = null))
                        : ((Ze = _e.yyleng), (It = _e.yytext), (xr = _e.yylineno), (ve = _e.yylloc), yn > 0 && yn--)
                    break
                  case 2:
                    if (
                      ((Br = this.productions_[Ht[1]][1]),
                      (Ri.$ = Ft[Ft.length - Br]),
                      (Ri._$ = {
                        first_line: _t[_t.length - (Br || 1)].first_line,
                        last_line: _t[_t.length - 1].last_line,
                        first_column: _t[_t.length - (Br || 1)].first_column,
                        last_column: _t[_t.length - 1].last_column,
                      }),
                      $e && (Ri._$.range = [_t[_t.length - (Br || 1)].range[0], _t[_t.length - 1].range[1]]),
                      (ne = this.performAction.apply(Ri, [It, Ze, xr, hr.yy, Ht[1], Ft, _t].concat(Je))),
                      typeof ne < 'u')
                    )
                      return ne
                    Br && ((mt = mt.slice(0, -1 * Br * 2)), (Ft = Ft.slice(0, -1 * Br)), (_t = _t.slice(0, -1 * Br))),
                      mt.push(this.productions_[Ht[1]][0]),
                      Ft.push(Ri.$),
                      _t.push(Ri._$),
                      (vr = Qe[mt[mt.length - 2]][mt[mt.length - 1]]),
                      mt.push(vr)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          Mt = (function () {
            var Gt = {
              EOF: 1,
              parseError: a(function (vt, mt) {
                if (this.yy.parser) this.yy.parser.parseError(vt, mt)
                else throw new Error(vt)
              }, 'parseError'),
              setInput: a(function (j, vt) {
                return (
                  (this.yy = vt || this.yy || {}),
                  (this._input = j),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var j = this._input[0]
                ;(this.yytext += j), this.yyleng++, this.offset++, (this.match += j), (this.matched += j)
                var vt = j.match(/(?:\r\n?|\n).*/g)
                return (
                  vt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  j
                )
              }, 'input'),
              unput: a(function (j) {
                var vt = j.length,
                  mt = j.split(/(?:\r\n?|\n)/g)
                ;(this._input = j + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - vt)),
                  (this.offset -= vt)
                var Xt = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  mt.length - 1 && (this.yylineno -= mt.length - 1)
                var Ft = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: mt
                      ? (mt.length === Xt.length ? this.yylloc.first_column : 0) +
                        Xt[Xt.length - mt.length].length -
                        mt[0].length
                      : this.yylloc.first_column - vt,
                  }),
                  this.options.ranges && (this.yylloc.range = [Ft[0], Ft[0] + this.yyleng - vt]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (j) {
                this.unput(this.match.slice(j))
              }, 'less'),
              pastInput: a(function () {
                var j = this.matched.substr(0, this.matched.length - this.match.length)
                return (j.length > 20 ? '...' : '') + j.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var j = this.match
                return (
                  j.length < 20 && (j += this._input.substr(0, 20 - j.length)),
                  (j.substr(0, 20) + (j.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var j = this.pastInput(),
                  vt = new Array(j.length + 1).join('-')
                return (
                  j +
                  this.upcomingInput() +
                  `
` +
                  vt +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (j, vt) {
                var mt, Xt, Ft
                if (
                  (this.options.backtrack_lexer &&
                    ((Ft = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (Ft.yylloc.range = this.yylloc.range.slice(0))),
                  (Xt = j[0].match(/(?:\r\n?|\n).*/g)),
                  Xt && (this.yylineno += Xt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Xt
                      ? Xt[Xt.length - 1].length - Xt[Xt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + j[0].length,
                  }),
                  (this.yytext += j[0]),
                  (this.match += j[0]),
                  (this.matches = j),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(j[0].length)),
                  (this.matched += j[0]),
                  (mt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    vt,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  mt)
                )
                  return mt
                if (this._backtrack) {
                  for (var _t in Ft) this[_t] = Ft[_t]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var j, vt, mt, Xt
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var Ft = this._currentRules(), _t = 0; _t < Ft.length; _t++)
                  if (((mt = this._input.match(this.rules[Ft[_t]])), mt && (!vt || mt[0].length > vt[0].length))) {
                    if (((vt = mt), (Xt = _t), this.options.backtrack_lexer)) {
                      if (((j = this.test_match(mt, Ft[_t])), j !== !1)) return j
                      if (this._backtrack) {
                        vt = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return vt
                  ? ((j = this.test_match(vt, Ft[Xt])), j !== !1 ? j : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var vt = this.next()
                return vt || this.lex()
              }, 'lex'),
              begin: a(function (vt) {
                this.conditionStack.push(vt)
              }, 'begin'),
              popState: a(function () {
                var vt = this.conditionStack.length - 1
                return vt > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (vt) {
                return (
                  (vt = this.conditionStack.length - 1 - Math.abs(vt || 0)),
                  vt >= 0 ? this.conditionStack[vt] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (vt) {
                this.begin(vt)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (vt, mt, Xt, Ft) {
                var _t = Ft
                switch (Xt) {
                  case 0:
                    break
                  case 1:
                    break
                  case 2:
                    return 55
                  case 3:
                    break
                  case 4:
                    return this.begin('title'), 35
                    break
                  case 5:
                    return this.popState(), 'title_value'
                    break
                  case 6:
                    return this.begin('acc_title'), 37
                    break
                  case 7:
                    return this.popState(), 'acc_title_value'
                    break
                  case 8:
                    return this.begin('acc_descr'), 39
                    break
                  case 9:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 10:
                    this.begin('acc_descr_multiline')
                    break
                  case 11:
                    this.popState()
                    break
                  case 12:
                    return 'acc_descr_multiline_value'
                  case 13:
                    return 48
                  case 14:
                    return 50
                  case 15:
                    return 49
                  case 16:
                    return 51
                  case 17:
                    return 52
                  case 18:
                    return 53
                  case 19:
                    return 54
                  case 20:
                    return 25
                  case 21:
                    this.begin('md_string')
                    break
                  case 22:
                    return 'MD_STR'
                  case 23:
                    this.popState()
                    break
                  case 24:
                    this.begin('string')
                    break
                  case 25:
                    this.popState()
                    break
                  case 26:
                    return 'STR'
                  case 27:
                    this.begin('class_name')
                    break
                  case 28:
                    return this.popState(), 47
                    break
                  case 29:
                    return this.begin('point_start'), 44
                    break
                  case 30:
                    return this.begin('point_x'), 45
                    break
                  case 31:
                    this.popState()
                    break
                  case 32:
                    this.popState(), this.begin('point_y')
                    break
                  case 33:
                    return this.popState(), 46
                    break
                  case 34:
                    return 28
                  case 35:
                    return 4
                  case 36:
                    return 11
                  case 37:
                    return 64
                  case 38:
                    return 10
                  case 39:
                    return 65
                  case 40:
                    return 65
                  case 41:
                    return 14
                  case 42:
                    return 13
                  case 43:
                    return 67
                  case 44:
                    return 66
                  case 45:
                    return 12
                  case 46:
                    return 8
                  case 47:
                    return 5
                  case 48:
                    return 18
                  case 49:
                    return 56
                  case 50:
                    return 63
                  case 51:
                    return 57
                }
              }, 'anonymous'),
              rules: [
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n\r]+)/i,
                /^(?:%%[^\n]*)/i,
                /^(?:title\b)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?: *x-axis *)/i,
                /^(?: *y-axis *)/i,
                /^(?: *--+> *)/i,
                /^(?: *quadrant-1 *)/i,
                /^(?: *quadrant-2 *)/i,
                /^(?: *quadrant-3 *)/i,
                /^(?: *quadrant-4 *)/i,
                /^(?:classDef\b)/i,
                /^(?:["][`])/i,
                /^(?:[^`"]+)/i,
                /^(?:[`]["])/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?::::)/i,
                /^(?:^\w+)/i,
                /^(?:\s*:\s*\[\s*)/i,
                /^(?:(1)|(0(.\d+)?))/i,
                /^(?:\s*\] *)/i,
                /^(?:\s*,\s*)/i,
                /^(?:(1)|(0(.\d+)?))/i,
                /^(?: *quadrantChart *)/i,
                /^(?:[A-Za-z]+)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:,)/i,
                /^(?:=)/i,
                /^(?:=)/i,
                /^(?:\*)/i,
                /^(?:#)/i,
                /^(?:[\_])/i,
                /^(?:\.)/i,
                /^(?:&)/i,
                /^(?:-)/i,
                /^(?:[0-9]+)/i,
                /^(?:\s)/i,
                /^(?:;)/i,
                /^(?:[!"#$%&'*+,-.`?\\_/])/i,
                /^(?:$)/i,
              ],
              conditions: {
                class_name: { rules: [28], inclusive: !1 },
                point_y: { rules: [33], inclusive: !1 },
                point_x: { rules: [32], inclusive: !1 },
                point_start: { rules: [30, 31], inclusive: !1 },
                acc_descr_multiline: { rules: [11, 12], inclusive: !1 },
                acc_descr: { rules: [9], inclusive: !1 },
                acc_title: { rules: [7], inclusive: !1 },
                title: { rules: [5], inclusive: !1 },
                md_string: { rules: [22, 23], inclusive: !1 },
                string: { rules: [25, 26], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 29, 34, 35, 36, 37, 38, 39, 40,
                    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
                  ],
                  inclusive: !0,
                },
              },
            }
            return Gt
          })()
        Z.lexer = Mt
        function W() {
          this.yy = {}
        }
        return a(W, 'Parser'), (W.prototype = Z), (Z.Parser = W), new W()
      })()
      JD.parser = JD
      Art = JD
    })
  var Qi,
    S_,
    Rrt = x(() => {
      'use strict'
      Ge()
      _s()
      Vt()
      Qm()
      ;(Qi = ql()),
        (S_ = class {
          constructor() {
            this.classes = new Map()
            ;(this.config = this.getDefaultConfig()),
              (this.themeConfig = this.getDefaultThemeConfig()),
              (this.data = this.getDefaultData())
          }
          static {
            a(this, 'QuadrantBuilder')
          }
          getDefaultData() {
            return {
              titleText: '',
              quadrant1Text: '',
              quadrant2Text: '',
              quadrant3Text: '',
              quadrant4Text: '',
              xAxisLeftText: '',
              xAxisRightText: '',
              yAxisBottomText: '',
              yAxisTopText: '',
              points: [],
            }
          }
          getDefaultConfig() {
            return {
              showXAxis: !0,
              showYAxis: !0,
              showTitle: !0,
              chartHeight: ze.quadrantChart?.chartWidth || 500,
              chartWidth: ze.quadrantChart?.chartHeight || 500,
              titlePadding: ze.quadrantChart?.titlePadding || 10,
              titleFontSize: ze.quadrantChart?.titleFontSize || 20,
              quadrantPadding: ze.quadrantChart?.quadrantPadding || 5,
              xAxisLabelPadding: ze.quadrantChart?.xAxisLabelPadding || 5,
              yAxisLabelPadding: ze.quadrantChart?.yAxisLabelPadding || 5,
              xAxisLabelFontSize: ze.quadrantChart?.xAxisLabelFontSize || 16,
              yAxisLabelFontSize: ze.quadrantChart?.yAxisLabelFontSize || 16,
              quadrantLabelFontSize: ze.quadrantChart?.quadrantLabelFontSize || 16,
              quadrantTextTopPadding: ze.quadrantChart?.quadrantTextTopPadding || 5,
              pointTextPadding: ze.quadrantChart?.pointTextPadding || 5,
              pointLabelFontSize: ze.quadrantChart?.pointLabelFontSize || 12,
              pointRadius: ze.quadrantChart?.pointRadius || 5,
              xAxisPosition: ze.quadrantChart?.xAxisPosition || 'top',
              yAxisPosition: ze.quadrantChart?.yAxisPosition || 'left',
              quadrantInternalBorderStrokeWidth: ze.quadrantChart?.quadrantInternalBorderStrokeWidth || 1,
              quadrantExternalBorderStrokeWidth: ze.quadrantChart?.quadrantExternalBorderStrokeWidth || 2,
            }
          }
          getDefaultThemeConfig() {
            return {
              quadrant1Fill: Qi.quadrant1Fill,
              quadrant2Fill: Qi.quadrant2Fill,
              quadrant3Fill: Qi.quadrant3Fill,
              quadrant4Fill: Qi.quadrant4Fill,
              quadrant1TextFill: Qi.quadrant1TextFill,
              quadrant2TextFill: Qi.quadrant2TextFill,
              quadrant3TextFill: Qi.quadrant3TextFill,
              quadrant4TextFill: Qi.quadrant4TextFill,
              quadrantPointFill: Qi.quadrantPointFill,
              quadrantPointTextFill: Qi.quadrantPointTextFill,
              quadrantXAxisTextFill: Qi.quadrantXAxisTextFill,
              quadrantYAxisTextFill: Qi.quadrantYAxisTextFill,
              quadrantTitleFill: Qi.quadrantTitleFill,
              quadrantInternalBorderStrokeFill: Qi.quadrantInternalBorderStrokeFill,
              quadrantExternalBorderStrokeFill: Qi.quadrantExternalBorderStrokeFill,
            }
          }
          clear() {
            ;(this.config = this.getDefaultConfig()),
              (this.themeConfig = this.getDefaultThemeConfig()),
              (this.data = this.getDefaultData()),
              (this.classes = new Map()),
              B.info('clear called')
          }
          setData(t) {
            this.data = { ...this.data, ...t }
          }
          addPoints(t) {
            this.data.points = [...t, ...this.data.points]
          }
          addClass(t, r) {
            this.classes.set(t, r)
          }
          setConfig(t) {
            B.trace('setConfig called with: ', t), (this.config = { ...this.config, ...t })
          }
          setThemeConfig(t) {
            B.trace('setThemeConfig called with: ', t), (this.themeConfig = { ...this.themeConfig, ...t })
          }
          calculateSpace(t, r, n, i) {
            let s = this.config.xAxisLabelPadding * 2 + this.config.xAxisLabelFontSize,
              o = { top: t === 'top' && r ? s : 0, bottom: t === 'bottom' && r ? s : 0 },
              l = this.config.yAxisLabelPadding * 2 + this.config.yAxisLabelFontSize,
              u = {
                left: this.config.yAxisPosition === 'left' && n ? l : 0,
                right: this.config.yAxisPosition === 'right' && n ? l : 0,
              },
              h = this.config.titleFontSize + this.config.titlePadding * 2,
              f = { top: i ? h : 0 },
              d = this.config.quadrantPadding + u.left,
              p = this.config.quadrantPadding + o.top + f.top,
              m = this.config.chartWidth - this.config.quadrantPadding * 2 - u.left - u.right,
              g = this.config.chartHeight - this.config.quadrantPadding * 2 - o.top - o.bottom - f.top,
              y = m / 2,
              b = g / 2
            return {
              xAxisSpace: o,
              yAxisSpace: u,
              titleSpace: f,
              quadrantSpace: {
                quadrantLeft: d,
                quadrantTop: p,
                quadrantWidth: m,
                quadrantHalfWidth: y,
                quadrantHeight: g,
                quadrantHalfHeight: b,
              },
            }
          }
          getAxisLabels(t, r, n, i) {
            let { quadrantSpace: s, titleSpace: o } = i,
              {
                quadrantHalfHeight: l,
                quadrantHeight: u,
                quadrantLeft: h,
                quadrantHalfWidth: f,
                quadrantTop: d,
                quadrantWidth: p,
              } = s,
              m = !!this.data.xAxisRightText,
              g = !!this.data.yAxisTopText,
              y = []
            return (
              this.data.xAxisLeftText &&
                r &&
                y.push({
                  text: this.data.xAxisLeftText,
                  fill: this.themeConfig.quadrantXAxisTextFill,
                  x: h + (m ? f / 2 : 0),
                  y:
                    t === 'top'
                      ? this.config.xAxisLabelPadding + o.top
                      : this.config.xAxisLabelPadding + d + u + this.config.quadrantPadding,
                  fontSize: this.config.xAxisLabelFontSize,
                  verticalPos: m ? 'center' : 'left',
                  horizontalPos: 'top',
                  rotation: 0,
                }),
              this.data.xAxisRightText &&
                r &&
                y.push({
                  text: this.data.xAxisRightText,
                  fill: this.themeConfig.quadrantXAxisTextFill,
                  x: h + f + (m ? f / 2 : 0),
                  y:
                    t === 'top'
                      ? this.config.xAxisLabelPadding + o.top
                      : this.config.xAxisLabelPadding + d + u + this.config.quadrantPadding,
                  fontSize: this.config.xAxisLabelFontSize,
                  verticalPos: m ? 'center' : 'left',
                  horizontalPos: 'top',
                  rotation: 0,
                }),
              this.data.yAxisBottomText &&
                n &&
                y.push({
                  text: this.data.yAxisBottomText,
                  fill: this.themeConfig.quadrantYAxisTextFill,
                  x:
                    this.config.yAxisPosition === 'left'
                      ? this.config.yAxisLabelPadding
                      : this.config.yAxisLabelPadding + h + p + this.config.quadrantPadding,
                  y: d + u - (g ? l / 2 : 0),
                  fontSize: this.config.yAxisLabelFontSize,
                  verticalPos: g ? 'center' : 'left',
                  horizontalPos: 'top',
                  rotation: -90,
                }),
              this.data.yAxisTopText &&
                n &&
                y.push({
                  text: this.data.yAxisTopText,
                  fill: this.themeConfig.quadrantYAxisTextFill,
                  x:
                    this.config.yAxisPosition === 'left'
                      ? this.config.yAxisLabelPadding
                      : this.config.yAxisLabelPadding + h + p + this.config.quadrantPadding,
                  y: d + l - (g ? l / 2 : 0),
                  fontSize: this.config.yAxisLabelFontSize,
                  verticalPos: g ? 'center' : 'left',
                  horizontalPos: 'top',
                  rotation: -90,
                }),
              y
            )
          }
          getQuadrants(t) {
            let { quadrantSpace: r } = t,
              { quadrantHalfHeight: n, quadrantLeft: i, quadrantHalfWidth: s, quadrantTop: o } = r,
              l = [
                {
                  text: {
                    text: this.data.quadrant1Text,
                    fill: this.themeConfig.quadrant1TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: 'center',
                    horizontalPos: 'middle',
                    rotation: 0,
                  },
                  x: i + s,
                  y: o,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant1Fill,
                },
                {
                  text: {
                    text: this.data.quadrant2Text,
                    fill: this.themeConfig.quadrant2TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: 'center',
                    horizontalPos: 'middle',
                    rotation: 0,
                  },
                  x: i,
                  y: o,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant2Fill,
                },
                {
                  text: {
                    text: this.data.quadrant3Text,
                    fill: this.themeConfig.quadrant3TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: 'center',
                    horizontalPos: 'middle',
                    rotation: 0,
                  },
                  x: i,
                  y: o + n,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant3Fill,
                },
                {
                  text: {
                    text: this.data.quadrant4Text,
                    fill: this.themeConfig.quadrant4TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: 'center',
                    horizontalPos: 'middle',
                    rotation: 0,
                  },
                  x: i + s,
                  y: o + n,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant4Fill,
                },
              ]
            for (let u of l)
              (u.text.x = u.x + u.width / 2),
                this.data.points.length === 0
                  ? ((u.text.y = u.y + u.height / 2), (u.text.horizontalPos = 'middle'))
                  : ((u.text.y = u.y + this.config.quadrantTextTopPadding), (u.text.horizontalPos = 'top'))
            return l
          }
          getQuadrantPoints(t) {
            let { quadrantSpace: r } = t,
              { quadrantHeight: n, quadrantLeft: i, quadrantTop: s, quadrantWidth: o } = r,
              l = La()
                .domain([0, 1])
                .range([i, o + i]),
              u = La()
                .domain([0, 1])
                .range([n + s, s])
            return this.data.points.map((f) => {
              let d = this.classes.get(f.className)
              return (
                d && (f = { ...d, ...f }),
                {
                  x: l(f.x),
                  y: u(f.y),
                  fill: f.color ?? this.themeConfig.quadrantPointFill,
                  radius: f.radius ?? this.config.pointRadius,
                  text: {
                    text: f.text,
                    fill: this.themeConfig.quadrantPointTextFill,
                    x: l(f.x),
                    y: u(f.y) + this.config.pointTextPadding,
                    verticalPos: 'center',
                    horizontalPos: 'top',
                    fontSize: this.config.pointLabelFontSize,
                    rotation: 0,
                  },
                  strokeColor: f.strokeColor ?? this.themeConfig.quadrantPointFill,
                  strokeWidth: f.strokeWidth ?? '0px',
                }
              )
            })
          }
          getBorders(t) {
            let r = this.config.quadrantExternalBorderStrokeWidth / 2,
              { quadrantSpace: n } = t,
              {
                quadrantHalfHeight: i,
                quadrantHeight: s,
                quadrantLeft: o,
                quadrantHalfWidth: l,
                quadrantTop: u,
                quadrantWidth: h,
              } = n
            return [
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o - r,
                y1: u,
                x2: o + h + r,
                y2: u,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o + h,
                y1: u + r,
                x2: o + h,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o - r,
                y1: u + s,
                x2: o + h + r,
                y2: u + s,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o,
                y1: u + r,
                x2: o,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
                strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
                x1: o + l,
                y1: u + r,
                x2: o + l,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
                strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
                x1: o + r,
                y1: u + i,
                x2: o + h - r,
                y2: u + i,
              },
            ]
          }
          getTitle(t) {
            if (t)
              return {
                text: this.data.titleText,
                fill: this.themeConfig.quadrantTitleFill,
                fontSize: this.config.titleFontSize,
                horizontalPos: 'top',
                verticalPos: 'center',
                rotation: 0,
                y: this.config.titlePadding,
                x: this.config.chartWidth / 2,
              }
          }
          build() {
            let t = this.config.showXAxis && !!(this.data.xAxisLeftText || this.data.xAxisRightText),
              r = this.config.showYAxis && !!(this.data.yAxisTopText || this.data.yAxisBottomText),
              n = this.config.showTitle && !!this.data.titleText,
              i = this.data.points.length > 0 ? 'bottom' : this.config.xAxisPosition,
              s = this.calculateSpace(i, t, r, n)
            return {
              points: this.getQuadrantPoints(s),
              quadrants: this.getQuadrants(s),
              axisLabels: this.getAxisLabels(i, t, r, s),
              borderLines: this.getBorders(s),
              title: this.getTitle(n),
            }
          }
        })
    })
  function tN(e) {
    return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(e)
  }
  function Drt(e) {
    return !/^\d+$/.test(e)
  }
  function Nrt(e) {
    return !/^\d+px$/.test(e)
  }
  var Xh,
    Irt = x(() => {
      'use strict'
      Xh = class extends Error {
        static {
          a(this, 'InvalidStyleError')
        }
        constructor(t, r, n) {
          super(`value for ${t} ${r} is invalid, please use a valid ${n}`), (this.name = 'InvalidStyleError')
        }
      }
      a(tN, 'validateHexCode')
      a(Drt, 'validateNumber')
      a(Nrt, 'validateSizeInPixels')
    })
  function Fl(e) {
    return Ie(e.trim(), GLt)
  }
  function VLt(e) {
    pi.setData({ quadrant1Text: Fl(e.text) })
  }
  function zLt(e) {
    pi.setData({ quadrant2Text: Fl(e.text) })
  }
  function WLt(e) {
    pi.setData({ quadrant3Text: Fl(e.text) })
  }
  function ULt(e) {
    pi.setData({ quadrant4Text: Fl(e.text) })
  }
  function jLt(e) {
    pi.setData({ xAxisLeftText: Fl(e.text) })
  }
  function qLt(e) {
    pi.setData({ xAxisRightText: Fl(e.text) })
  }
  function HLt(e) {
    pi.setData({ yAxisTopText: Fl(e.text) })
  }
  function YLt(e) {
    pi.setData({ yAxisBottomText: Fl(e.text) })
  }
  function eN(e) {
    let t = {}
    for (let r of e) {
      let [n, i] = r.trim().split(/\s*:\s*/)
      if (n === 'radius') {
        if (Drt(i)) throw new Xh(n, i, 'number')
        t.radius = parseInt(i)
      } else if (n === 'color') {
        if (tN(i)) throw new Xh(n, i, 'hex code')
        t.color = i
      } else if (n === 'stroke-color') {
        if (tN(i)) throw new Xh(n, i, 'hex code')
        t.strokeColor = i
      } else if (n === 'stroke-width') {
        if (Nrt(i)) throw new Xh(n, i, 'number of pixels (eg. 10px)')
        t.strokeWidth = i
      } else throw new Error(`style named ${n} is not supported.`)
    }
    return t
  }
  function XLt(e, t, r, n, i) {
    let s = eN(i)
    pi.addPoints([{ x: r, y: n, text: Fl(e.text), className: t, ...s }])
  }
  function KLt(e, t) {
    pi.addClass(e, eN(t))
  }
  function QLt(e) {
    pi.setConfig({ chartWidth: e })
  }
  function ZLt(e) {
    pi.setConfig({ chartHeight: e })
  }
  function JLt() {
    let e = K(),
      { themeVariables: t, quadrantChart: r } = e
    return (
      r && pi.setConfig(r),
      pi.setThemeConfig({
        quadrant1Fill: t.quadrant1Fill,
        quadrant2Fill: t.quadrant2Fill,
        quadrant3Fill: t.quadrant3Fill,
        quadrant4Fill: t.quadrant4Fill,
        quadrant1TextFill: t.quadrant1TextFill,
        quadrant2TextFill: t.quadrant2TextFill,
        quadrant3TextFill: t.quadrant3TextFill,
        quadrant4TextFill: t.quadrant4TextFill,
        quadrantPointFill: t.quadrantPointFill,
        quadrantPointTextFill: t.quadrantPointTextFill,
        quadrantXAxisTextFill: t.quadrantXAxisTextFill,
        quadrantYAxisTextFill: t.quadrantYAxisTextFill,
        quadrantExternalBorderStrokeFill: t.quadrantExternalBorderStrokeFill,
        quadrantInternalBorderStrokeFill: t.quadrantInternalBorderStrokeFill,
        quadrantTitleFill: t.quadrantTitleFill,
      }),
      pi.setData({ titleText: nr() }),
      pi.build()
    )
  }
  var GLt,
    pi,
    tRt,
    Mrt,
    Ort = x(() => {
      'use strict'
      pe()
      Be()
      bn()
      Rrt()
      Irt()
      GLt = K()
      a(Fl, 'textSanitizer')
      pi = new S_()
      a(VLt, 'setQuadrant1Text')
      a(zLt, 'setQuadrant2Text')
      a(WLt, 'setQuadrant3Text')
      a(ULt, 'setQuadrant4Text')
      a(jLt, 'setXAxisLeftText')
      a(qLt, 'setXAxisRightText')
      a(HLt, 'setYAxisTopText')
      a(YLt, 'setYAxisBottomText')
      a(eN, 'parseStyles')
      a(XLt, 'addPoint')
      a(KLt, 'addClass')
      a(QLt, 'setWidth')
      a(ZLt, 'setHeight')
      a(JLt, 'getQuadrantData')
      ;(tRt = a(function () {
        pi.clear(), Ye()
      }, 'clear')),
        (Mrt = {
          setWidth: QLt,
          setHeight: ZLt,
          setQuadrant1Text: VLt,
          setQuadrant2Text: zLt,
          setQuadrant3Text: WLt,
          setQuadrant4Text: ULt,
          setXAxisLeftText: jLt,
          setXAxisRightText: qLt,
          setYAxisTopText: HLt,
          setYAxisBottomText: YLt,
          parseStyles: eN,
          addPoint: XLt,
          addClass: KLt,
          getQuadrantData: JLt,
          clear: tRt,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
        })
    })
  var eRt,
    Prt,
    Brt = x(() => {
      'use strict'
      Ge()
      pe()
      Vt()
      On()
      ;(eRt = a((e, t, r, n) => {
        function i(v) {
          return v === 'top' ? 'hanging' : 'middle'
        }
        a(i, 'getDominantBaseLine')
        function s(v) {
          return v === 'left' ? 'start' : 'middle'
        }
        a(s, 'getTextAnchor')
        function o(v) {
          return `translate(${v.x}, ${v.y}) rotate(${v.rotation || 0})`
        }
        a(o, 'getTransformation')
        let l = K()
        B.debug(
          `Rendering quadrant chart
` + e,
        )
        let u = l.securityLevel,
          h
        u === 'sandbox' && (h = xt('#i' + t))
        let d = (u === 'sandbox' ? xt(h.nodes()[0].contentDocument.body) : xt('body')).select(`[id="${t}"]`),
          p = d.append('g').attr('class', 'main'),
          m = l.quadrantChart?.chartWidth ?? 500,
          g = l.quadrantChart?.chartHeight ?? 500
        Ar(d, g, m, l.quadrantChart?.useMaxWidth ?? !0),
          d.attr('viewBox', '0 0 ' + m + ' ' + g),
          n.db.setHeight(g),
          n.db.setWidth(m)
        let y = n.db.getQuadrantData(),
          b = p.append('g').attr('class', 'quadrants'),
          k = p.append('g').attr('class', 'border'),
          T = p.append('g').attr('class', 'data-points'),
          C = p.append('g').attr('class', 'labels'),
          A = p.append('g').attr('class', 'title')
        y.title &&
          A.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('fill', y.title.fill)
            .attr('font-size', y.title.fontSize)
            .attr('dominant-baseline', i(y.title.horizontalPos))
            .attr('text-anchor', s(y.title.verticalPos))
            .attr('transform', o(y.title))
            .text(y.title.text),
          y.borderLines &&
            k
              .selectAll('line')
              .data(y.borderLines)
              .enter()
              .append('line')
              .attr('x1', (v) => v.x1)
              .attr('y1', (v) => v.y1)
              .attr('x2', (v) => v.x2)
              .attr('y2', (v) => v.y2)
              .style('stroke', (v) => v.strokeFill)
              .style('stroke-width', (v) => v.strokeWidth)
        let w = b.selectAll('g.quadrant').data(y.quadrants).enter().append('g').attr('class', 'quadrant')
        w
          .append('rect')
          .attr('x', (v) => v.x)
          .attr('y', (v) => v.y)
          .attr('width', (v) => v.width)
          .attr('height', (v) => v.height)
          .attr('fill', (v) => v.fill),
          w
            .append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('fill', (v) => v.text.fill)
            .attr('font-size', (v) => v.text.fontSize)
            .attr('dominant-baseline', (v) => i(v.text.horizontalPos))
            .attr('text-anchor', (v) => s(v.text.verticalPos))
            .attr('transform', (v) => o(v.text))
            .text((v) => v.text.text),
          C.selectAll('g.label')
            .data(y.axisLabels)
            .enter()
            .append('g')
            .attr('class', 'label')
            .append('text')
            .attr('x', 0)
            .attr('y', 0)
            .text((v) => v.text)
            .attr('fill', (v) => v.fill)
            .attr('font-size', (v) => v.fontSize)
            .attr('dominant-baseline', (v) => i(v.horizontalPos))
            .attr('text-anchor', (v) => s(v.verticalPos))
            .attr('transform', (v) => o(v))
        let G = T.selectAll('g.data-point').data(y.points).enter().append('g').attr('class', 'data-point')
        G.append('circle')
          .attr('cx', (v) => v.x)
          .attr('cy', (v) => v.y)
          .attr('r', (v) => v.radius)
          .attr('fill', (v) => v.fill)
          .attr('stroke', (v) => v.strokeColor)
          .attr('stroke-width', (v) => v.strokeWidth),
          G.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .text((v) => v.text.text)
            .attr('fill', (v) => v.text.fill)
            .attr('font-size', (v) => v.text.fontSize)
            .attr('dominant-baseline', (v) => i(v.text.horizontalPos))
            .attr('text-anchor', (v) => s(v.text.verticalPos))
            .attr('transform', (v) => o(v.text))
      }, 'draw')),
        (Prt = { draw: eRt })
    })
  var Frt = {}
  Oe(Frt, { diagram: () => rRt })
  var rRt,
    $rt = x(() => {
      'use strict'
      Lrt()
      Ort()
      Brt()
      rRt = { parser: Art, db: Mrt, renderer: Prt, styles: a(() => '', 'styles') }
    })
  var rN,
    zrt,
    Wrt = x(() => {
      'use strict'
      rN = (function () {
        var e = a(function (L, N, P, I) {
            for (P = P || {}, I = L.length; I--; P[L[I]] = N);
            return P
          }, 'o'),
          t = [1, 10, 12, 14, 16, 18, 19, 21, 23],
          r = [2, 6],
          n = [1, 3],
          i = [1, 5],
          s = [1, 6],
          o = [1, 7],
          l = [1, 5, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36],
          u = [1, 25],
          h = [1, 26],
          f = [1, 28],
          d = [1, 29],
          p = [1, 30],
          m = [1, 31],
          g = [1, 32],
          y = [1, 33],
          b = [1, 34],
          k = [1, 35],
          T = [1, 36],
          C = [1, 37],
          A = [1, 43],
          w = [1, 42],
          D = [1, 47],
          G = [1, 50],
          v = [1, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36],
          R = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36],
          F = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50],
          S = [1, 64],
          O = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              eol: 4,
              XYCHART: 5,
              chartConfig: 6,
              document: 7,
              CHART_ORIENTATION: 8,
              statement: 9,
              title: 10,
              text: 11,
              X_AXIS: 12,
              parseXAxis: 13,
              Y_AXIS: 14,
              parseYAxis: 15,
              LINE: 16,
              plotData: 17,
              BAR: 18,
              acc_title: 19,
              acc_title_value: 20,
              acc_descr: 21,
              acc_descr_value: 22,
              acc_descr_multiline_value: 23,
              SQUARE_BRACES_START: 24,
              commaSeparatedNumbers: 25,
              SQUARE_BRACES_END: 26,
              NUMBER_WITH_DECIMAL: 27,
              COMMA: 28,
              xAxisData: 29,
              bandData: 30,
              ARROW_DELIMITER: 31,
              commaSeparatedTexts: 32,
              yAxisData: 33,
              NEWLINE: 34,
              SEMI: 35,
              EOF: 36,
              alphaNum: 37,
              STR: 38,
              MD_STR: 39,
              alphaNumToken: 40,
              AMP: 41,
              NUM: 42,
              ALPHA: 43,
              PLUS: 44,
              EQUALS: 45,
              MULT: 46,
              DOT: 47,
              BRKT: 48,
              MINUS: 49,
              UNDERSCORE: 50,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              5: 'XYCHART',
              8: 'CHART_ORIENTATION',
              10: 'title',
              12: 'X_AXIS',
              14: 'Y_AXIS',
              16: 'LINE',
              18: 'BAR',
              19: 'acc_title',
              20: 'acc_title_value',
              21: 'acc_descr',
              22: 'acc_descr_value',
              23: 'acc_descr_multiline_value',
              24: 'SQUARE_BRACES_START',
              26: 'SQUARE_BRACES_END',
              27: 'NUMBER_WITH_DECIMAL',
              28: 'COMMA',
              31: 'ARROW_DELIMITER',
              34: 'NEWLINE',
              35: 'SEMI',
              36: 'EOF',
              38: 'STR',
              39: 'MD_STR',
              41: 'AMP',
              42: 'NUM',
              43: 'ALPHA',
              44: 'PLUS',
              45: 'EQUALS',
              46: 'MULT',
              47: 'DOT',
              48: 'BRKT',
              49: 'MINUS',
              50: 'UNDERSCORE',
            },
            productions_: [
              0,
              [3, 2],
              [3, 3],
              [3, 2],
              [3, 1],
              [6, 1],
              [7, 0],
              [7, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 3],
              [9, 2],
              [9, 3],
              [9, 2],
              [9, 2],
              [9, 1],
              [17, 3],
              [25, 3],
              [25, 1],
              [13, 1],
              [13, 2],
              [13, 1],
              [29, 1],
              [29, 3],
              [30, 3],
              [32, 3],
              [32, 1],
              [15, 1],
              [15, 2],
              [15, 1],
              [33, 3],
              [4, 1],
              [4, 1],
              [4, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [37, 1],
              [37, 2],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
            ],
            performAction: a(function (N, P, I, M, V, $, q) {
              var tt = $.length - 1
              switch (V) {
                case 5:
                  M.setOrientation($[tt])
                  break
                case 9:
                  M.setDiagramTitle($[tt].text.trim())
                  break
                case 12:
                  M.setLineData({ text: '', type: 'text' }, $[tt])
                  break
                case 13:
                  M.setLineData($[tt - 1], $[tt])
                  break
                case 14:
                  M.setBarData({ text: '', type: 'text' }, $[tt])
                  break
                case 15:
                  M.setBarData($[tt - 1], $[tt])
                  break
                case 16:
                  ;(this.$ = $[tt].trim()), M.setAccTitle(this.$)
                  break
                case 17:
                case 18:
                  ;(this.$ = $[tt].trim()), M.setAccDescription(this.$)
                  break
                case 19:
                  this.$ = $[tt - 1]
                  break
                case 20:
                  this.$ = [Number($[tt - 2]), ...$[tt]]
                  break
                case 21:
                  this.$ = [Number($[tt])]
                  break
                case 22:
                  M.setXAxisTitle($[tt])
                  break
                case 23:
                  M.setXAxisTitle($[tt - 1])
                  break
                case 24:
                  M.setXAxisTitle({ type: 'text', text: '' })
                  break
                case 25:
                  M.setXAxisBand($[tt])
                  break
                case 26:
                  M.setXAxisRangeData(Number($[tt - 2]), Number($[tt]))
                  break
                case 27:
                  this.$ = $[tt - 1]
                  break
                case 28:
                  this.$ = [$[tt - 2], ...$[tt]]
                  break
                case 29:
                  this.$ = [$[tt]]
                  break
                case 30:
                  M.setYAxisTitle($[tt])
                  break
                case 31:
                  M.setYAxisTitle($[tt - 1])
                  break
                case 32:
                  M.setYAxisTitle({ type: 'text', text: '' })
                  break
                case 33:
                  M.setYAxisRangeData(Number($[tt - 2]), Number($[tt]))
                  break
                case 37:
                  this.$ = { text: $[tt], type: 'text' }
                  break
                case 38:
                  this.$ = { text: $[tt], type: 'text' }
                  break
                case 39:
                  this.$ = { text: $[tt], type: 'markdown' }
                  break
                case 40:
                  this.$ = $[tt]
                  break
                case 41:
                  this.$ = $[tt - 1] + '' + $[tt]
                  break
              }
            }, 'anonymous'),
            table: [
              e(t, r, { 3: 1, 4: 2, 7: 4, 5: n, 34: i, 35: s, 36: o }),
              { 1: [3] },
              e(t, r, { 4: 2, 7: 4, 3: 8, 5: n, 34: i, 35: s, 36: o }),
              e(t, r, { 4: 2, 7: 4, 6: 9, 3: 10, 5: n, 8: [1, 11], 34: i, 35: s, 36: o }),
              {
                1: [2, 4],
                9: 12,
                10: [1, 13],
                12: [1, 14],
                14: [1, 15],
                16: [1, 16],
                18: [1, 17],
                19: [1, 18],
                21: [1, 19],
                23: [1, 20],
              },
              e(l, [2, 34]),
              e(l, [2, 35]),
              e(l, [2, 36]),
              { 1: [2, 1] },
              e(t, r, { 4: 2, 7: 4, 3: 21, 5: n, 34: i, 35: s, 36: o }),
              { 1: [2, 3] },
              e(l, [2, 5]),
              e(t, [2, 7], { 4: 22, 34: i, 35: s, 36: o }),
              {
                11: 23,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 39,
                13: 38,
                24: A,
                27: w,
                29: 40,
                30: 41,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 45,
                15: 44,
                27: D,
                33: 46,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 49,
                17: 48,
                24: G,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 52,
                17: 51,
                24: G,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              { 20: [1, 53] },
              { 22: [1, 54] },
              e(v, [2, 18]),
              { 1: [2, 2] },
              e(v, [2, 8]),
              e(v, [2, 9]),
              e(R, [2, 37], { 40: 55, 41: f, 42: d, 43: p, 44: m, 45: g, 46: y, 47: b, 48: k, 49: T, 50: C }),
              e(R, [2, 38]),
              e(R, [2, 39]),
              e(F, [2, 40]),
              e(F, [2, 42]),
              e(F, [2, 43]),
              e(F, [2, 44]),
              e(F, [2, 45]),
              e(F, [2, 46]),
              e(F, [2, 47]),
              e(F, [2, 48]),
              e(F, [2, 49]),
              e(F, [2, 50]),
              e(F, [2, 51]),
              e(v, [2, 10]),
              e(v, [2, 22], { 30: 41, 29: 56, 24: A, 27: w }),
              e(v, [2, 24]),
              e(v, [2, 25]),
              { 31: [1, 57] },
              {
                11: 59,
                32: 58,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              e(v, [2, 11]),
              e(v, [2, 30], { 33: 60, 27: D }),
              e(v, [2, 32]),
              { 31: [1, 61] },
              e(v, [2, 12]),
              { 17: 62, 24: G },
              { 25: 63, 27: S },
              e(v, [2, 14]),
              { 17: 65, 24: G },
              e(v, [2, 16]),
              e(v, [2, 17]),
              e(F, [2, 41]),
              e(v, [2, 23]),
              { 27: [1, 66] },
              { 26: [1, 67] },
              { 26: [2, 29], 28: [1, 68] },
              e(v, [2, 31]),
              { 27: [1, 69] },
              e(v, [2, 13]),
              { 26: [1, 70] },
              { 26: [2, 21], 28: [1, 71] },
              e(v, [2, 15]),
              e(v, [2, 26]),
              e(v, [2, 27]),
              {
                11: 59,
                32: 72,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              e(v, [2, 33]),
              e(v, [2, 19]),
              { 25: 73, 27: S },
              { 26: [2, 28] },
              { 26: [2, 20] },
            ],
            defaultActions: { 8: [2, 1], 10: [2, 3], 21: [2, 2], 72: [2, 28], 73: [2, 20] },
            parseError: a(function (N, P) {
              if (P.recoverable) this.trace(N)
              else {
                var I = new Error(N)
                throw ((I.hash = P), I)
              }
            }, 'parseError'),
            parse: a(function (N) {
              var P = this,
                I = [0],
                M = [],
                V = [null],
                $ = [],
                q = this.table,
                tt = '',
                ft = 0,
                H = 0,
                kt = 0,
                ht = 2,
                yt = 1,
                ot = $.slice.call(arguments, 1),
                dt = Object.create(this.lexer),
                it = { yy: {} }
              for (var Q in this.yy) Object.prototype.hasOwnProperty.call(this.yy, Q) && (it.yy[Q] = this.yy[Q])
              dt.setInput(N, it.yy),
                (it.yy.lexer = dt),
                (it.yy.parser = this),
                typeof dt.yylloc > 'u' && (dt.yylloc = {})
              var et = dt.yylloc
              $.push(et)
              var X = dt.options && dt.options.ranges
              typeof it.yy.parseError == 'function'
                ? (this.parseError = it.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function st(Z) {
                ;(I.length = I.length - 2 * Z), (V.length = V.length - Z), ($.length = $.length - Z)
              }
              a(st, 'popStack')
              function U() {
                var Z
                return (
                  (Z = M.pop() || dt.lex() || yt),
                  typeof Z != 'number' && (Z instanceof Array && ((M = Z), (Z = M.pop())), (Z = P.symbols_[Z] || Z)),
                  Z
                )
              }
              a(U, 'lex')
              for (var gt, z, ge, lt, jt, Me, se = {}, Nt, At, bt, ct; ; ) {
                if (
                  ((ge = I[I.length - 1]),
                  this.defaultActions[ge]
                    ? (lt = this.defaultActions[ge])
                    : ((gt === null || typeof gt > 'u') && (gt = U()), (lt = q[ge] && q[ge][gt])),
                  typeof lt > 'u' || !lt.length || !lt[0])
                ) {
                  var Lt = ''
                  ct = []
                  for (Nt in q[ge]) this.terminals_[Nt] && Nt > ht && ct.push("'" + this.terminals_[Nt] + "'")
                  dt.showPosition
                    ? (Lt =
                        'Parse error on line ' +
                        (ft + 1) +
                        `:
` +
                        dt.showPosition() +
                        `
Expecting ` +
                        ct.join(', ') +
                        ", got '" +
                        (this.terminals_[gt] || gt) +
                        "'")
                    : (Lt =
                        'Parse error on line ' +
                        (ft + 1) +
                        ': Unexpected ' +
                        (gt == yt ? 'end of input' : "'" + (this.terminals_[gt] || gt) + "'")),
                    this.parseError(Lt, {
                      text: dt.match,
                      token: this.terminals_[gt] || gt,
                      line: dt.yylineno,
                      loc: et,
                      expected: ct,
                    })
                }
                if (lt[0] instanceof Array && lt.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + ge + ', token: ' + gt)
                switch (lt[0]) {
                  case 1:
                    I.push(gt),
                      V.push(dt.yytext),
                      $.push(dt.yylloc),
                      I.push(lt[1]),
                      (gt = null),
                      z
                        ? ((gt = z), (z = null))
                        : ((H = dt.yyleng), (tt = dt.yytext), (ft = dt.yylineno), (et = dt.yylloc), kt > 0 && kt--)
                    break
                  case 2:
                    if (
                      ((At = this.productions_[lt[1]][1]),
                      (se.$ = V[V.length - At]),
                      (se._$ = {
                        first_line: $[$.length - (At || 1)].first_line,
                        last_line: $[$.length - 1].last_line,
                        first_column: $[$.length - (At || 1)].first_column,
                        last_column: $[$.length - 1].last_column,
                      }),
                      X && (se._$.range = [$[$.length - (At || 1)].range[0], $[$.length - 1].range[1]]),
                      (Me = this.performAction.apply(se, [tt, H, ft, it.yy, lt[1], V, $].concat(ot))),
                      typeof Me < 'u')
                    )
                      return Me
                    At && ((I = I.slice(0, -1 * At * 2)), (V = V.slice(0, -1 * At)), ($ = $.slice(0, -1 * At))),
                      I.push(this.productions_[lt[1]][0]),
                      V.push(se.$),
                      $.push(se._$),
                      (bt = q[I[I.length - 2]][I[I.length - 1]]),
                      I.push(bt)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          E = (function () {
            var L = {
              EOF: 1,
              parseError: a(function (P, I) {
                if (this.yy.parser) this.yy.parser.parseError(P, I)
                else throw new Error(P)
              }, 'parseError'),
              setInput: a(function (N, P) {
                return (
                  (this.yy = P || this.yy || {}),
                  (this._input = N),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var N = this._input[0]
                ;(this.yytext += N), this.yyleng++, this.offset++, (this.match += N), (this.matched += N)
                var P = N.match(/(?:\r\n?|\n).*/g)
                return (
                  P ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  N
                )
              }, 'input'),
              unput: a(function (N) {
                var P = N.length,
                  I = N.split(/(?:\r\n?|\n)/g)
                ;(this._input = N + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - P)),
                  (this.offset -= P)
                var M = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  I.length - 1 && (this.yylineno -= I.length - 1)
                var V = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: I
                      ? (I.length === M.length ? this.yylloc.first_column : 0) +
                        M[M.length - I.length].length -
                        I[0].length
                      : this.yylloc.first_column - P,
                  }),
                  this.options.ranges && (this.yylloc.range = [V[0], V[0] + this.yyleng - P]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (N) {
                this.unput(this.match.slice(N))
              }, 'less'),
              pastInput: a(function () {
                var N = this.matched.substr(0, this.matched.length - this.match.length)
                return (N.length > 20 ? '...' : '') + N.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var N = this.match
                return (
                  N.length < 20 && (N += this._input.substr(0, 20 - N.length)),
                  (N.substr(0, 20) + (N.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var N = this.pastInput(),
                  P = new Array(N.length + 1).join('-')
                return (
                  N +
                  this.upcomingInput() +
                  `
` +
                  P +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (N, P) {
                var I, M, V
                if (
                  (this.options.backtrack_lexer &&
                    ((V = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (V.yylloc.range = this.yylloc.range.slice(0))),
                  (M = N[0].match(/(?:\r\n?|\n).*/g)),
                  M && (this.yylineno += M.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: M
                      ? M[M.length - 1].length - M[M.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + N[0].length,
                  }),
                  (this.yytext += N[0]),
                  (this.match += N[0]),
                  (this.matches = N),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(N[0].length)),
                  (this.matched += N[0]),
                  (I = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    P,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  I)
                )
                  return I
                if (this._backtrack) {
                  for (var $ in V) this[$] = V[$]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var N, P, I, M
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var V = this._currentRules(), $ = 0; $ < V.length; $++)
                  if (((I = this._input.match(this.rules[V[$]])), I && (!P || I[0].length > P[0].length))) {
                    if (((P = I), (M = $), this.options.backtrack_lexer)) {
                      if (((N = this.test_match(I, V[$])), N !== !1)) return N
                      if (this._backtrack) {
                        P = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return P
                  ? ((N = this.test_match(P, V[M])), N !== !1 ? N : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var P = this.next()
                return P || this.lex()
              }, 'lex'),
              begin: a(function (P) {
                this.conditionStack.push(P)
              }, 'begin'),
              popState: a(function () {
                var P = this.conditionStack.length - 1
                return P > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (P) {
                return (
                  (P = this.conditionStack.length - 1 - Math.abs(P || 0)), P >= 0 ? this.conditionStack[P] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (P) {
                this.begin(P)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (P, I, M, V) {
                var $ = V
                switch (M) {
                  case 0:
                    break
                  case 1:
                    break
                  case 2:
                    return this.popState(), 34
                    break
                  case 3:
                    return this.popState(), 34
                    break
                  case 4:
                    return 34
                  case 5:
                    break
                  case 6:
                    return 10
                  case 7:
                    return this.pushState('acc_title'), 19
                    break
                  case 8:
                    return this.popState(), 'acc_title_value'
                    break
                  case 9:
                    return this.pushState('acc_descr'), 21
                    break
                  case 10:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 11:
                    this.pushState('acc_descr_multiline')
                    break
                  case 12:
                    this.popState()
                    break
                  case 13:
                    return 'acc_descr_multiline_value'
                  case 14:
                    return 5
                  case 15:
                    return 5
                  case 16:
                    return 8
                  case 17:
                    return this.pushState('axis_data'), 'X_AXIS'
                    break
                  case 18:
                    return this.pushState('axis_data'), 'Y_AXIS'
                    break
                  case 19:
                    return this.pushState('axis_band_data'), 24
                    break
                  case 20:
                    return 31
                  case 21:
                    return this.pushState('data'), 16
                    break
                  case 22:
                    return this.pushState('data'), 18
                    break
                  case 23:
                    return this.pushState('data_inner'), 24
                    break
                  case 24:
                    return 27
                  case 25:
                    return this.popState(), 26
                    break
                  case 26:
                    this.popState()
                    break
                  case 27:
                    this.pushState('string')
                    break
                  case 28:
                    this.popState()
                    break
                  case 29:
                    return 'STR'
                  case 30:
                    return 24
                  case 31:
                    return 26
                  case 32:
                    return 43
                  case 33:
                    return 'COLON'
                  case 34:
                    return 44
                  case 35:
                    return 28
                  case 36:
                    return 45
                  case 37:
                    return 46
                  case 38:
                    return 48
                  case 39:
                    return 50
                  case 40:
                    return 47
                  case 41:
                    return 41
                  case 42:
                    return 49
                  case 43:
                    return 42
                  case 44:
                    break
                  case 45:
                    return 35
                  case 46:
                    return 36
                }
              }, 'anonymous'),
              rules: [
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:(\r?\n))/i,
                /^(?:(\r?\n))/i,
                /^(?:[\n\r]+)/i,
                /^(?:%%[^\n]*)/i,
                /^(?:title\b)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:\{)/i,
                /^(?:[^\}]*)/i,
                /^(?:xychart-beta\b)/i,
                /^(?:xychart\b)/i,
                /^(?:(?:vertical|horizontal))/i,
                /^(?:x-axis\b)/i,
                /^(?:y-axis\b)/i,
                /^(?:\[)/i,
                /^(?:-->)/i,
                /^(?:line\b)/i,
                /^(?:bar\b)/i,
                /^(?:\[)/i,
                /^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i,
                /^(?:\])/i,
                /^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:\[)/i,
                /^(?:\])/i,
                /^(?:[A-Za-z]+)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:,)/i,
                /^(?:=)/i,
                /^(?:\*)/i,
                /^(?:#)/i,
                /^(?:[\_])/i,
                /^(?:\.)/i,
                /^(?:&)/i,
                /^(?:-)/i,
                /^(?:[0-9]+)/i,
                /^(?:\s+)/i,
                /^(?:;)/i,
                /^(?:$)/i,
              ],
              conditions: {
                data_inner: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37,
                    38, 39, 40, 41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                data: {
                  rules: [
                    0, 1, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37,
                    38, 39, 40, 41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                axis_band_data: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38,
                    39, 40, 41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                axis_data: {
                  rules: [
                    0, 1, 2, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 26, 27, 30, 31, 32, 33, 34, 35,
                    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                title: { rules: [], inclusive: !1 },
                md_string: { rules: [], inclusive: !1 },
                string: { rules: [28, 29], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
                    40, 41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
              },
            }
            return L
          })()
        O.lexer = E
        function _() {
          this.yy = {}
        }
        return a(_, 'Parser'), (_.prototype = O), (O.Parser = _), new _()
      })()
      rN.parser = rN
      zrt = rN
    })
  function nN(e) {
    return e.type === 'bar'
  }
  function __(e) {
    return e.type === 'band'
  }
  function km(e) {
    return e.type === 'linear'
  }
  var C_ = x(() => {
    'use strict'
    a(nN, 'isBarPlot')
    a(__, 'isBandAxisData')
    a(km, 'isLinearAxisData')
  })
  var Tm,
    iN = x(() => {
      'use strict'
      $a()
      Tm = class {
        constructor(t) {
          this.parentGroup = t
        }
        static {
          a(this, 'TextDimensionCalculatorWithFont')
        }
        getMaxDimension(t, r) {
          if (!this.parentGroup) return { width: t.reduce((s, o) => Math.max(o.length, s), 0) * r, height: r }
          let n = { width: 0, height: 0 },
            i = this.parentGroup.append('g').attr('visibility', 'hidden').attr('font-size', r)
          for (let s of t) {
            let o = dV(i, 1, s),
              l = o ? o.width : s.length * r,
              u = o ? o.height : r
            ;(n.width = Math.max(n.width, l)), (n.height = Math.max(n.height, u))
          }
          return i.remove(), n
        }
      }
    })
  var Sm,
    sN = x(() => {
      'use strict'
      Sm = class {
        constructor(t, r, n, i) {
          this.axisConfig = t
          this.title = r
          this.textDimensionCalculator = n
          this.axisThemeConfig = i
          this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }
          this.axisPosition = 'left'
          this.showTitle = !1
          this.showLabel = !1
          this.showTick = !1
          this.showAxisLine = !1
          this.outerPadding = 0
          this.titleTextHeight = 0
          this.labelTextHeight = 0
          ;(this.range = [0, 10]),
            (this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }),
            (this.axisPosition = 'left')
        }
        static {
          a(this, 'BaseAxis')
        }
        setRange(t) {
          ;(this.range = t),
            this.axisPosition === 'left' || this.axisPosition === 'right'
              ? (this.boundingRect.height = t[1] - t[0])
              : (this.boundingRect.width = t[1] - t[0]),
            this.recalculateScale()
        }
        getRange() {
          return [this.range[0] + this.outerPadding, this.range[1] - this.outerPadding]
        }
        setAxisPosition(t) {
          ;(this.axisPosition = t), this.setRange(this.range)
        }
        getTickDistance() {
          let t = this.getRange()
          return Math.abs(t[0] - t[1]) / this.getTickValues().length
        }
        getAxisOuterPadding() {
          return this.outerPadding
        }
        getLabelDimension() {
          return this.textDimensionCalculator.getMaxDimension(
            this.getTickValues().map((t) => t.toString()),
            this.axisConfig.labelFontSize,
          )
        }
        recalculateOuterPaddingToDrawBar() {
          0.7 * this.getTickDistance() > this.outerPadding * 2 &&
            (this.outerPadding = Math.floor((0.7 * this.getTickDistance()) / 2)),
            this.recalculateScale()
        }
        calculateSpaceIfDrawnHorizontally(t) {
          let r = t.height
          if (
            (this.axisConfig.showAxisLine &&
              r > this.axisConfig.axisLineWidth &&
              ((r -= this.axisConfig.axisLineWidth), (this.showAxisLine = !0)),
            this.axisConfig.showLabel)
          ) {
            let n = this.getLabelDimension(),
              i = 0.2 * t.width
            this.outerPadding = Math.min(n.width / 2, i)
            let s = n.height + this.axisConfig.labelPadding * 2
            ;(this.labelTextHeight = n.height), s <= r && ((r -= s), (this.showLabel = !0))
          }
          if (
            (this.axisConfig.showTick &&
              r >= this.axisConfig.tickLength &&
              ((this.showTick = !0), (r -= this.axisConfig.tickLength)),
            this.axisConfig.showTitle && this.title)
          ) {
            let n = this.textDimensionCalculator.getMaxDimension([this.title], this.axisConfig.titleFontSize),
              i = n.height + this.axisConfig.titlePadding * 2
            ;(this.titleTextHeight = n.height), i <= r && ((r -= i), (this.showTitle = !0))
          }
          ;(this.boundingRect.width = t.width), (this.boundingRect.height = t.height - r)
        }
        calculateSpaceIfDrawnVertical(t) {
          let r = t.width
          if (
            (this.axisConfig.showAxisLine &&
              r > this.axisConfig.axisLineWidth &&
              ((r -= this.axisConfig.axisLineWidth), (this.showAxisLine = !0)),
            this.axisConfig.showLabel)
          ) {
            let n = this.getLabelDimension(),
              i = 0.2 * t.height
            this.outerPadding = Math.min(n.height / 2, i)
            let s = n.width + this.axisConfig.labelPadding * 2
            s <= r && ((r -= s), (this.showLabel = !0))
          }
          if (
            (this.axisConfig.showTick &&
              r >= this.axisConfig.tickLength &&
              ((this.showTick = !0), (r -= this.axisConfig.tickLength)),
            this.axisConfig.showTitle && this.title)
          ) {
            let n = this.textDimensionCalculator.getMaxDimension([this.title], this.axisConfig.titleFontSize),
              i = n.height + this.axisConfig.titlePadding * 2
            ;(this.titleTextHeight = n.height), i <= r && ((r -= i), (this.showTitle = !0))
          }
          ;(this.boundingRect.width = t.width - r), (this.boundingRect.height = t.height)
        }
        calculateSpace(t) {
          return (
            this.axisPosition === 'left' || this.axisPosition === 'right'
              ? this.calculateSpaceIfDrawnVertical(t)
              : this.calculateSpaceIfDrawnHorizontally(t),
            this.recalculateScale(),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          )
        }
        setBoundingBoxXY(t) {
          ;(this.boundingRect.x = t.x), (this.boundingRect.y = t.y)
        }
        getDrawableElementsForLeftAxis() {
          let t = []
          if (this.showAxisLine) {
            let r = this.boundingRect.x + this.boundingRect.width - this.axisConfig.axisLineWidth / 2
            t.push({
              type: 'path',
              groupTexts: ['left-axis', 'axisl-line'],
              data: [
                {
                  path: `M ${r},${this.boundingRect.y} L ${r},${this.boundingRect.y + this.boundingRect.height} `,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            })
          }
          if (
            (this.showLabel &&
              t.push({
                type: 'text',
                groupTexts: ['left-axis', 'label'],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x:
                    this.boundingRect.x +
                    this.boundingRect.width -
                    (this.showLabel ? this.axisConfig.labelPadding : 0) -
                    (this.showTick ? this.axisConfig.tickLength : 0) -
                    (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
                  y: this.getScaleValue(r),
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: 'middle',
                  horizontalPos: 'right',
                })),
              }),
            this.showTick)
          ) {
            let r =
              this.boundingRect.x + this.boundingRect.width - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)
            t.push({
              type: 'path',
              groupTexts: ['left-axis', 'ticks'],
              data: this.getTickValues().map((n) => ({
                path: `M ${r},${this.getScaleValue(n)} L ${r - this.axisConfig.tickLength},${this.getScaleValue(n)}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            })
          }
          return (
            this.showTitle &&
              t.push({
                type: 'text',
                groupTexts: ['left-axis', 'title'],
                data: [
                  {
                    text: this.title,
                    x: this.boundingRect.x + this.axisConfig.titlePadding,
                    y: this.boundingRect.y + this.boundingRect.height / 2,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 270,
                    verticalPos: 'top',
                    horizontalPos: 'center',
                  },
                ],
              }),
            t
          )
        }
        getDrawableElementsForBottomAxis() {
          let t = []
          if (this.showAxisLine) {
            let r = this.boundingRect.y + this.axisConfig.axisLineWidth / 2
            t.push({
              type: 'path',
              groupTexts: ['bottom-axis', 'axis-line'],
              data: [
                {
                  path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            })
          }
          if (
            (this.showLabel &&
              t.push({
                type: 'text',
                groupTexts: ['bottom-axis', 'label'],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x: this.getScaleValue(r),
                  y:
                    this.boundingRect.y +
                    this.axisConfig.labelPadding +
                    (this.showTick ? this.axisConfig.tickLength : 0) +
                    (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: 'top',
                  horizontalPos: 'center',
                })),
              }),
            this.showTick)
          ) {
            let r = this.boundingRect.y + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)
            t.push({
              type: 'path',
              groupTexts: ['bottom-axis', 'ticks'],
              data: this.getTickValues().map((n) => ({
                path: `M ${this.getScaleValue(n)},${r} L ${this.getScaleValue(n)},${r + this.axisConfig.tickLength}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            })
          }
          return (
            this.showTitle &&
              t.push({
                type: 'text',
                groupTexts: ['bottom-axis', 'title'],
                data: [
                  {
                    text: this.title,
                    x: this.range[0] + (this.range[1] - this.range[0]) / 2,
                    y:
                      this.boundingRect.y +
                      this.boundingRect.height -
                      this.axisConfig.titlePadding -
                      this.titleTextHeight,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 0,
                    verticalPos: 'top',
                    horizontalPos: 'center',
                  },
                ],
              }),
            t
          )
        }
        getDrawableElementsForTopAxis() {
          let t = []
          if (this.showAxisLine) {
            let r = this.boundingRect.y + this.boundingRect.height - this.axisConfig.axisLineWidth / 2
            t.push({
              type: 'path',
              groupTexts: ['top-axis', 'axis-line'],
              data: [
                {
                  path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            })
          }
          if (
            (this.showLabel &&
              t.push({
                type: 'text',
                groupTexts: ['top-axis', 'label'],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x: this.getScaleValue(r),
                  y:
                    this.boundingRect.y +
                    (this.showTitle ? this.titleTextHeight + this.axisConfig.titlePadding * 2 : 0) +
                    this.axisConfig.labelPadding,
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: 'top',
                  horizontalPos: 'center',
                })),
              }),
            this.showTick)
          ) {
            let r = this.boundingRect.y
            t.push({
              type: 'path',
              groupTexts: ['top-axis', 'ticks'],
              data: this.getTickValues().map((n) => ({
                path: `M ${this.getScaleValue(n)},${r + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(n)},${r + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            })
          }
          return (
            this.showTitle &&
              t.push({
                type: 'text',
                groupTexts: ['top-axis', 'title'],
                data: [
                  {
                    text: this.title,
                    x: this.boundingRect.x + this.boundingRect.width / 2,
                    y: this.boundingRect.y + this.axisConfig.titlePadding,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 0,
                    verticalPos: 'top',
                    horizontalPos: 'center',
                  },
                ],
              }),
            t
          )
        }
        getDrawableElements() {
          if (this.axisPosition === 'left') return this.getDrawableElementsForLeftAxis()
          if (this.axisPosition === 'right') throw Error('Drawing of right axis is not implemented')
          return this.axisPosition === 'bottom'
            ? this.getDrawableElementsForBottomAxis()
            : this.axisPosition === 'top'
              ? this.getDrawableElementsForTopAxis()
              : []
        }
      }
    })
  var w_,
    Urt = x(() => {
      'use strict'
      Ge()
      Vt()
      sN()
      w_ = class extends Sm {
        static {
          a(this, 'BandAxis')
        }
        constructor(t, r, n, i, s) {
          super(t, i, s, r), (this.categories = n), (this.scale = Df().domain(this.categories).range(this.getRange()))
        }
        setRange(t) {
          super.setRange(t)
        }
        recalculateScale() {
          ;(this.scale = Df()
            .domain(this.categories)
            .range(this.getRange())
            .paddingInner(1)
            .paddingOuter(0)
            .align(0.5)),
            B.trace('BandAxis axis final categories, range: ', this.categories, this.getRange())
        }
        getTickValues() {
          return this.categories
        }
        getScaleValue(t) {
          return this.scale(t) ?? this.getRange()[0]
        }
      }
    })
  var E_,
    jrt = x(() => {
      'use strict'
      Ge()
      sN()
      E_ = class extends Sm {
        static {
          a(this, 'LinearAxis')
        }
        constructor(t, r, n, i, s) {
          super(t, i, s, r), (this.domain = n), (this.scale = La().domain(this.domain).range(this.getRange()))
        }
        getTickValues() {
          return this.scale.ticks()
        }
        recalculateScale() {
          let t = [...this.domain]
          this.axisPosition === 'left' && t.reverse(), (this.scale = La().domain(t).range(this.getRange()))
        }
        getScaleValue(t) {
          return this.scale(t)
        }
      }
    })
  function aN(e, t, r, n) {
    let i = new Tm(n)
    return __(e) ? new w_(t, r, e.categories, e.title, i) : new E_(t, r, [e.min, e.max], e.title, i)
  }
  var qrt = x(() => {
    'use strict'
    C_()
    iN()
    Urt()
    jrt()
    a(aN, 'getAxis')
  })
  function Hrt(e, t, r, n) {
    let i = new Tm(n)
    return new oN(i, e, t, r)
  }
  var oN,
    Yrt = x(() => {
      'use strict'
      iN()
      oN = class {
        constructor(t, r, n, i) {
          this.textDimensionCalculator = t
          this.chartConfig = r
          this.chartData = n
          this.chartThemeConfig = i
          ;(this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }), (this.showChartTitle = !1)
        }
        static {
          a(this, 'ChartTitle')
        }
        setBoundingBoxXY(t) {
          ;(this.boundingRect.x = t.x), (this.boundingRect.y = t.y)
        }
        calculateSpace(t) {
          let r = this.textDimensionCalculator.getMaxDimension([this.chartData.title], this.chartConfig.titleFontSize),
            n = Math.max(r.width, t.width),
            i = r.height + 2 * this.chartConfig.titlePadding
          return (
            r.width <= n &&
              r.height <= i &&
              this.chartConfig.showTitle &&
              this.chartData.title &&
              ((this.boundingRect.width = n), (this.boundingRect.height = i), (this.showChartTitle = !0)),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          )
        }
        getDrawableElements() {
          let t = []
          return (
            this.showChartTitle &&
              t.push({
                groupTexts: ['chart-title'],
                type: 'text',
                data: [
                  {
                    fontSize: this.chartConfig.titleFontSize,
                    text: this.chartData.title,
                    verticalPos: 'middle',
                    horizontalPos: 'center',
                    x: this.boundingRect.x + this.boundingRect.width / 2,
                    y: this.boundingRect.y + this.boundingRect.height / 2,
                    fill: this.chartThemeConfig.titleColor,
                    rotation: 0,
                  },
                ],
              }),
            t
          )
        }
      }
      a(Hrt, 'getChartTitleComponent')
    })
  var v_,
    Xrt = x(() => {
      'use strict'
      Ge()
      v_ = class {
        constructor(t, r, n, i, s) {
          this.plotData = t
          this.xAxis = r
          this.yAxis = n
          this.orientation = i
          this.plotIndex = s
        }
        static {
          a(this, 'LinePlot')
        }
        getDrawableElement() {
          let t = this.plotData.data.map((n) => [this.xAxis.getScaleValue(n[0]), this.yAxis.getScaleValue(n[1])]),
            r
          return (
            this.orientation === 'horizontal'
              ? (r = Ma()
                  .y((n) => n[0])
                  .x((n) => n[1])(t))
              : (r = Ma()
                  .x((n) => n[0])
                  .y((n) => n[1])(t)),
            r
              ? [
                  {
                    groupTexts: ['plot', `line-plot-${this.plotIndex}`],
                    type: 'path',
                    data: [{ path: r, strokeFill: this.plotData.strokeFill, strokeWidth: this.plotData.strokeWidth }],
                  },
                ]
              : []
          )
        }
      }
    })
  var A_,
    Krt = x(() => {
      'use strict'
      A_ = class {
        constructor(t, r, n, i, s, o) {
          this.barData = t
          this.boundingRect = r
          this.xAxis = n
          this.yAxis = i
          this.orientation = s
          this.plotIndex = o
        }
        static {
          a(this, 'BarPlot')
        }
        getDrawableElement() {
          let t = this.barData.data.map((s) => [this.xAxis.getScaleValue(s[0]), this.yAxis.getScaleValue(s[1])]),
            n = Math.min(this.xAxis.getAxisOuterPadding() * 2, this.xAxis.getTickDistance()) * (1 - 0.05),
            i = n / 2
          return this.orientation === 'horizontal'
            ? [
                {
                  groupTexts: ['plot', `bar-plot-${this.plotIndex}`],
                  type: 'rect',
                  data: t.map((s) => ({
                    x: this.boundingRect.x,
                    y: s[0] - i,
                    height: n,
                    width: s[1] - this.boundingRect.x,
                    fill: this.barData.fill,
                    strokeWidth: 0,
                    strokeFill: this.barData.fill,
                  })),
                },
              ]
            : [
                {
                  groupTexts: ['plot', `bar-plot-${this.plotIndex}`],
                  type: 'rect',
                  data: t.map((s) => ({
                    x: s[0] - i,
                    y: s[1],
                    width: n,
                    height: this.boundingRect.y + this.boundingRect.height - s[1],
                    fill: this.barData.fill,
                    strokeWidth: 0,
                    strokeFill: this.barData.fill,
                  })),
                },
              ]
        }
      }
    })
  function Qrt(e, t, r) {
    return new lN(e, t, r)
  }
  var lN,
    Zrt = x(() => {
      'use strict'
      Xrt()
      Krt()
      lN = class {
        constructor(t, r, n) {
          this.chartConfig = t
          this.chartData = r
          this.chartThemeConfig = n
          this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }
        }
        static {
          a(this, 'BasePlot')
        }
        setAxes(t, r) {
          ;(this.xAxis = t), (this.yAxis = r)
        }
        setBoundingBoxXY(t) {
          ;(this.boundingRect.x = t.x), (this.boundingRect.y = t.y)
        }
        calculateSpace(t) {
          return (
            (this.boundingRect.width = t.width),
            (this.boundingRect.height = t.height),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          )
        }
        getDrawableElements() {
          if (!(this.xAxis && this.yAxis)) throw Error('Axes must be passed to render Plots')
          let t = []
          for (let [r, n] of this.chartData.plots.entries())
            switch (n.type) {
              case 'line':
                {
                  let i = new v_(n, this.xAxis, this.yAxis, this.chartConfig.chartOrientation, r)
                  t.push(...i.getDrawableElement())
                }
                break
              case 'bar':
                {
                  let i = new A_(n, this.boundingRect, this.xAxis, this.yAxis, this.chartConfig.chartOrientation, r)
                  t.push(...i.getDrawableElement())
                }
                break
            }
          return t
        }
      }
      a(Qrt, 'getPlotComponent')
    })
  var L_,
    Jrt = x(() => {
      'use strict'
      qrt()
      Yrt()
      Zrt()
      C_()
      L_ = class {
        constructor(t, r, n, i) {
          this.chartConfig = t
          this.chartData = r
          this.componentStore = {
            title: Hrt(t, r, n, i),
            plot: Qrt(t, r, n),
            xAxis: aN(
              r.xAxis,
              t.xAxis,
              {
                titleColor: n.xAxisTitleColor,
                labelColor: n.xAxisLabelColor,
                tickColor: n.xAxisTickColor,
                axisLineColor: n.xAxisLineColor,
              },
              i,
            ),
            yAxis: aN(
              r.yAxis,
              t.yAxis,
              {
                titleColor: n.yAxisTitleColor,
                labelColor: n.yAxisLabelColor,
                tickColor: n.yAxisTickColor,
                axisLineColor: n.yAxisLineColor,
              },
              i,
            ),
          }
        }
        static {
          a(this, 'Orchestrator')
        }
        calculateVerticalSpace() {
          let t = this.chartConfig.width,
            r = this.chartConfig.height,
            n = 0,
            i = 0,
            s = Math.floor((t * this.chartConfig.plotReservedSpacePercent) / 100),
            o = Math.floor((r * this.chartConfig.plotReservedSpacePercent) / 100),
            l = this.componentStore.plot.calculateSpace({ width: s, height: o })
          ;(t -= l.width),
            (r -= l.height),
            (l = this.componentStore.title.calculateSpace({ width: this.chartConfig.width, height: r })),
            (i = l.height),
            (r -= l.height),
            this.componentStore.xAxis.setAxisPosition('bottom'),
            (l = this.componentStore.xAxis.calculateSpace({ width: t, height: r })),
            (r -= l.height),
            this.componentStore.yAxis.setAxisPosition('left'),
            (l = this.componentStore.yAxis.calculateSpace({ width: t, height: r })),
            (n = l.width),
            (t -= l.width),
            t > 0 && ((s += t), (t = 0)),
            r > 0 && ((o += r), (r = 0)),
            this.componentStore.plot.calculateSpace({ width: s, height: o }),
            this.componentStore.plot.setBoundingBoxXY({ x: n, y: i }),
            this.componentStore.xAxis.setRange([n, n + s]),
            this.componentStore.xAxis.setBoundingBoxXY({ x: n, y: i + o }),
            this.componentStore.yAxis.setRange([i, i + o]),
            this.componentStore.yAxis.setBoundingBoxXY({ x: 0, y: i }),
            this.chartData.plots.some((u) => nN(u)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar()
        }
        calculateHorizontalSpace() {
          let t = this.chartConfig.width,
            r = this.chartConfig.height,
            n = 0,
            i = 0,
            s = 0,
            o = Math.floor((t * this.chartConfig.plotReservedSpacePercent) / 100),
            l = Math.floor((r * this.chartConfig.plotReservedSpacePercent) / 100),
            u = this.componentStore.plot.calculateSpace({ width: o, height: l })
          ;(t -= u.width),
            (r -= u.height),
            (u = this.componentStore.title.calculateSpace({ width: this.chartConfig.width, height: r })),
            (n = u.height),
            (r -= u.height),
            this.componentStore.xAxis.setAxisPosition('left'),
            (u = this.componentStore.xAxis.calculateSpace({ width: t, height: r })),
            (t -= u.width),
            (i = u.width),
            this.componentStore.yAxis.setAxisPosition('top'),
            (u = this.componentStore.yAxis.calculateSpace({ width: t, height: r })),
            (r -= u.height),
            (s = n + u.height),
            t > 0 && ((o += t), (t = 0)),
            r > 0 && ((l += r), (r = 0)),
            this.componentStore.plot.calculateSpace({ width: o, height: l }),
            this.componentStore.plot.setBoundingBoxXY({ x: i, y: s }),
            this.componentStore.yAxis.setRange([i, i + o]),
            this.componentStore.yAxis.setBoundingBoxXY({ x: i, y: n }),
            this.componentStore.xAxis.setRange([s, s + l]),
            this.componentStore.xAxis.setBoundingBoxXY({ x: 0, y: s }),
            this.chartData.plots.some((h) => nN(h)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar()
        }
        calculateSpace() {
          this.chartConfig.chartOrientation === 'horizontal'
            ? this.calculateHorizontalSpace()
            : this.calculateVerticalSpace()
        }
        getDrawableElement() {
          this.calculateSpace()
          let t = []
          this.componentStore.plot.setAxes(this.componentStore.xAxis, this.componentStore.yAxis)
          for (let r of Object.values(this.componentStore)) t.push(...r.getDrawableElements())
          return t
        }
      }
    })
  var R_,
    tnt = x(() => {
      'use strict'
      Jrt()
      R_ = class {
        static {
          a(this, 'XYChartBuilder')
        }
        static build(t, r, n, i) {
          return new L_(t, r, n, i).getDrawableElement()
        }
      }
    })
  function rnt() {
    let e = ql(),
      t = Te()
    return ln(e.xyChart, t.themeVariables.xyChart)
  }
  function nnt() {
    let e = Te()
    return ln(ze.xyChart, e.xyChart)
  }
  function int() {
    return {
      yAxis: { type: 'linear', title: '', min: 1 / 0, max: -1 / 0 },
      xAxis: { type: 'band', title: '', categories: [] },
      title: '',
      plots: [],
    }
  }
  function hN(e) {
    let t = Te()
    return Ie(e.trim(), t)
  }
  function aRt(e) {
    ent = e
  }
  function oRt(e) {
    e === 'horizontal' ? (Fy.chartOrientation = 'horizontal') : (Fy.chartOrientation = 'vertical')
  }
  function lRt(e) {
    Er.xAxis.title = hN(e.text)
  }
  function snt(e, t) {
    ;(Er.xAxis = { type: 'linear', title: Er.xAxis.title, min: e, max: t }), (D_ = !0)
  }
  function cRt(e) {
    ;(Er.xAxis = { type: 'band', title: Er.xAxis.title, categories: e.map((t) => hN(t.text)) }), (D_ = !0)
  }
  function uRt(e) {
    Er.yAxis.title = hN(e.text)
  }
  function hRt(e, t) {
    ;(Er.yAxis = { type: 'linear', title: Er.yAxis.title, min: e, max: t }), (uN = !0)
  }
  function fRt(e) {
    let t = Math.min(...e),
      r = Math.max(...e),
      n = km(Er.yAxis) ? Er.yAxis.min : 1 / 0,
      i = km(Er.yAxis) ? Er.yAxis.max : -1 / 0
    Er.yAxis = { type: 'linear', title: Er.yAxis.title, min: Math.min(n, t), max: Math.max(i, r) }
  }
  function ant(e) {
    let t = []
    if (e.length === 0) return t
    if (!D_) {
      let r = km(Er.xAxis) ? Er.xAxis.min : 1 / 0,
        n = km(Er.xAxis) ? Er.xAxis.max : -1 / 0
      snt(Math.min(r, 1), Math.max(n, e.length))
    }
    if ((uN || fRt(e), __(Er.xAxis) && (t = Er.xAxis.categories.map((r, n) => [r, e[n]])), km(Er.xAxis))) {
      let r = Er.xAxis.min,
        n = Er.xAxis.max,
        i = (n - r) / (e.length - 1),
        s = []
      for (let o = r; o <= n; o += i) s.push(`${o}`)
      t = s.map((o, l) => [o, e[l]])
    }
    return t
  }
  function ont(e) {
    return cN[e === 0 ? 0 : e % cN.length]
  }
  function dRt(e, t) {
    let r = ant(t)
    Er.plots.push({ type: 'line', strokeFill: ont(By), strokeWidth: 2, data: r }), By++
  }
  function pRt(e, t) {
    let r = ant(t)
    Er.plots.push({ type: 'bar', fill: ont(By), data: r }), By++
  }
  function mRt() {
    if (Er.plots.length === 0) throw Error('No Plot to render, please provide a plot with some data')
    return (Er.title = nr()), R_.build(Fy, Er, $y, ent)
  }
  function gRt() {
    return $y
  }
  function yRt() {
    return Fy
  }
  function xRt() {
    return Er
  }
  var By,
    ent,
    Fy,
    $y,
    Er,
    cN,
    D_,
    uN,
    bRt,
    lnt,
    cnt = x(() => {
      'use strict'
      fn()
      _s()
      Qm()
      Ce()
      Be()
      bn()
      tnt()
      C_()
      ;(By = 0),
        (Fy = nnt()),
        ($y = rnt()),
        (Er = int()),
        (cN = $y.plotColorPalette.split(',').map((e) => e.trim())),
        (D_ = !1),
        (uN = !1)
      a(rnt, 'getChartDefaultThemeConfig')
      a(nnt, 'getChartDefaultConfig')
      a(int, 'getChartDefaultData')
      a(hN, 'textSanitizer')
      a(aRt, 'setTmpSVGG')
      a(oRt, 'setOrientation')
      a(lRt, 'setXAxisTitle')
      a(snt, 'setXAxisRangeData')
      a(cRt, 'setXAxisBand')
      a(uRt, 'setYAxisTitle')
      a(hRt, 'setYAxisRangeData')
      a(fRt, 'setYAxisRangeFromPlotData')
      a(ant, 'transformDataWithoutCategory')
      a(ont, 'getPlotColorFromPalette')
      a(dRt, 'setLineData')
      a(pRt, 'setBarData')
      a(mRt, 'getDrawableElem')
      a(gRt, 'getChartThemeConfig')
      a(yRt, 'getChartConfig')
      a(xRt, 'getXYChartData')
      ;(bRt = a(function () {
        Ye(),
          (By = 0),
          (Fy = nnt()),
          (Er = int()),
          ($y = rnt()),
          (cN = $y.plotColorPalette.split(',').map((e) => e.trim())),
          (D_ = !1),
          (uN = !1)
      }, 'clear')),
        (lnt = {
          getDrawableElem: mRt,
          clear: bRt,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
          setOrientation: oRt,
          setXAxisTitle: lRt,
          setXAxisRangeData: snt,
          setXAxisBand: cRt,
          setYAxisTitle: uRt,
          setYAxisRangeData: hRt,
          setLineData: dRt,
          setBarData: pRt,
          setTmpSVGG: aRt,
          getChartThemeConfig: gRt,
          getChartConfig: yRt,
          getXYChartData: xRt,
        })
    })
  var kRt,
    unt,
    hnt = x(() => {
      'use strict'
      Vt()
      Bl()
      On()
      ;(kRt = a((e, t, r, n) => {
        let i = n.db,
          s = i.getChartThemeConfig(),
          o = i.getChartConfig(),
          l = i.getXYChartData().plots[0].data.map((C) => C[1])
        function u(C) {
          return C === 'top' ? 'text-before-edge' : 'middle'
        }
        a(u, 'getDominantBaseLine')
        function h(C) {
          return C === 'left' ? 'start' : C === 'right' ? 'end' : 'middle'
        }
        a(h, 'getTextAnchor')
        function f(C) {
          return `translate(${C.x}, ${C.y}) rotate(${C.rotation || 0})`
        }
        a(f, 'getTextTransformation'),
          B.debug(
            `Rendering xychart chart
` + e,
          )
        let d = Ai(t),
          p = d.append('g').attr('class', 'main'),
          m = p.append('rect').attr('width', o.width).attr('height', o.height).attr('class', 'background')
        Ar(d, o.height, o.width, !0),
          d.attr('viewBox', `0 0 ${o.width} ${o.height}`),
          m.attr('fill', s.backgroundColor),
          i.setTmpSVGG(d.append('g').attr('class', 'mermaid-tmp-group'))
        let g = i.getDrawableElem(),
          y = {}
        function b(C) {
          let A = p,
            w = ''
          for (let [D] of C.entries()) {
            let G = p
            D > 0 && y[w] && (G = y[w]), (w += C[D]), (A = y[w]), A || (A = y[w] = G.append('g').attr('class', C[D]))
          }
          return A
        }
        a(b, 'getGroup')
        for (let C of g) {
          if (C.data.length === 0) continue
          let A = b(C.groupTexts)
          switch (C.type) {
            case 'rect':
              if (
                (A.selectAll('rect')
                  .data(C.data)
                  .enter()
                  .append('rect')
                  .attr('x', (w) => w.x)
                  .attr('y', (w) => w.y)
                  .attr('width', (w) => w.width)
                  .attr('height', (w) => w.height)
                  .attr('fill', (w) => w.fill)
                  .attr('stroke', (w) => w.strokeFill)
                  .attr('stroke-width', (w) => w.strokeWidth),
                o.showDataLabel)
              )
                if (o.chartOrientation === 'horizontal') {
                  let G = function (F, S) {
                    let { data: O, label: E } = F
                    return S * E.length * 0.7 <= O.width - 10
                  }
                  var k = G
                  a(G, 'fitsHorizontally')
                  let w = 0.7,
                    D = C.data
                      .map((F, S) => ({ data: F, label: l[S].toString() }))
                      .filter((F) => F.data.width > 0 && F.data.height > 0),
                    v = D.map((F) => {
                      let { data: S } = F,
                        O = S.height * 0.7
                      for (; !G(F, O) && O > 0; ) O -= 1
                      return O
                    }),
                    R = Math.floor(Math.min(...v))
                  A.selectAll('text')
                    .data(D)
                    .enter()
                    .append('text')
                    .attr('x', (F) => F.data.x + F.data.width - 10)
                    .attr('y', (F) => F.data.y + F.data.height / 2)
                    .attr('text-anchor', 'end')
                    .attr('dominant-baseline', 'middle')
                    .attr('fill', 'black')
                    .attr('font-size', `${R}px`)
                    .text((F) => F.label)
                } else {
                  let G = function (F, S, O) {
                    let { data: E, label: _ } = F,
                      N = S * _.length * 0.7,
                      P = E.x + E.width / 2,
                      I = P - N / 2,
                      M = P + N / 2,
                      V = I >= E.x && M <= E.x + E.width,
                      $ = E.y + O + S <= E.y + E.height
                    return V && $
                  }
                  var T = G
                  a(G, 'fitsInBar')
                  let w = 10,
                    D = C.data
                      .map((F, S) => ({ data: F, label: l[S].toString() }))
                      .filter((F) => F.data.width > 0 && F.data.height > 0),
                    v = D.map((F) => {
                      let { data: S, label: O } = F,
                        E = S.width / (O.length * 0.7)
                      for (; !G(F, E, 10) && E > 0; ) E -= 1
                      return E
                    }),
                    R = Math.floor(Math.min(...v))
                  A.selectAll('text')
                    .data(D)
                    .enter()
                    .append('text')
                    .attr('x', (F) => F.data.x + F.data.width / 2)
                    .attr('y', (F) => F.data.y + 10)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'hanging')
                    .attr('fill', 'black')
                    .attr('font-size', `${R}px`)
                    .text((F) => F.label)
                }
              break
            case 'text':
              A.selectAll('text')
                .data(C.data)
                .enter()
                .append('text')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', (w) => w.fill)
                .attr('font-size', (w) => w.fontSize)
                .attr('dominant-baseline', (w) => u(w.verticalPos))
                .attr('text-anchor', (w) => h(w.horizontalPos))
                .attr('transform', (w) => f(w))
                .text((w) => w.text)
              break
            case 'path':
              A.selectAll('path')
                .data(C.data)
                .enter()
                .append('path')
                .attr('d', (w) => w.path)
                .attr('fill', (w) => (w.fill ? w.fill : 'none'))
                .attr('stroke', (w) => w.strokeFill)
                .attr('stroke-width', (w) => w.strokeWidth)
              break
          }
        }
      }, 'draw')),
        (unt = { draw: kRt })
    })
  var fnt = {}
  Oe(fnt, { diagram: () => TRt })
  var TRt,
    dnt = x(() => {
      'use strict'
      Wrt()
      cnt()
      hnt()
      TRt = { parser: zrt, db: lnt, renderer: unt }
    })
  var fN,
    gnt,
    ynt = x(() => {
      'use strict'
      fN = (function () {
        var e = a(function (Z, Mt, W, Gt) {
            for (W = W || {}, Gt = Z.length; Gt--; W[Z[Gt]] = Mt);
            return W
          }, 'o'),
          t = [1, 3],
          r = [1, 4],
          n = [1, 5],
          i = [1, 6],
          s = [5, 6, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90],
          o = [1, 22],
          l = [2, 7],
          u = [1, 26],
          h = [1, 27],
          f = [1, 28],
          d = [1, 29],
          p = [1, 33],
          m = [1, 34],
          g = [1, 35],
          y = [1, 36],
          b = [1, 37],
          k = [1, 38],
          T = [1, 24],
          C = [1, 31],
          A = [1, 32],
          w = [1, 30],
          D = [1, 39],
          G = [1, 40],
          v = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90],
          R = [1, 61],
          F = [89, 90],
          S = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 29, 41, 42, 43, 44, 45, 46, 54, 61, 63, 72, 74, 75, 76, 77, 80, 81, 82,
            83, 84, 85, 86, 87, 88, 89, 90,
          ],
          O = [27, 29],
          E = [1, 70],
          _ = [1, 71],
          L = [1, 72],
          N = [1, 73],
          P = [1, 74],
          I = [1, 75],
          M = [1, 76],
          V = [1, 83],
          $ = [1, 80],
          q = [1, 84],
          tt = [1, 85],
          ft = [1, 86],
          H = [1, 87],
          kt = [1, 88],
          ht = [1, 89],
          yt = [1, 90],
          ot = [1, 91],
          dt = [1, 92],
          it = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85,
            86, 87, 88, 89, 90,
          ],
          Q = [63, 64],
          et = [1, 101],
          X = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 76, 77, 89, 90],
          st = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86,
            87, 88, 89, 90,
          ],
          U = [1, 110],
          gt = [1, 106],
          z = [1, 107],
          ge = [1, 108],
          lt = [1, 109],
          jt = [1, 111],
          Me = [1, 116],
          se = [1, 117],
          Nt = [1, 114],
          At = [1, 115],
          bt = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              directive: 4,
              NEWLINE: 5,
              RD: 6,
              diagram: 7,
              EOF: 8,
              acc_title: 9,
              acc_title_value: 10,
              acc_descr: 11,
              acc_descr_value: 12,
              acc_descr_multiline_value: 13,
              requirementDef: 14,
              elementDef: 15,
              relationshipDef: 16,
              direction: 17,
              styleStatement: 18,
              classDefStatement: 19,
              classStatement: 20,
              direction_tb: 21,
              direction_bt: 22,
              direction_rl: 23,
              direction_lr: 24,
              requirementType: 25,
              requirementName: 26,
              STRUCT_START: 27,
              requirementBody: 28,
              STYLE_SEPARATOR: 29,
              idList: 30,
              ID: 31,
              COLONSEP: 32,
              id: 33,
              TEXT: 34,
              text: 35,
              RISK: 36,
              riskLevel: 37,
              VERIFYMTHD: 38,
              verifyType: 39,
              STRUCT_STOP: 40,
              REQUIREMENT: 41,
              FUNCTIONAL_REQUIREMENT: 42,
              INTERFACE_REQUIREMENT: 43,
              PERFORMANCE_REQUIREMENT: 44,
              PHYSICAL_REQUIREMENT: 45,
              DESIGN_CONSTRAINT: 46,
              LOW_RISK: 47,
              MED_RISK: 48,
              HIGH_RISK: 49,
              VERIFY_ANALYSIS: 50,
              VERIFY_DEMONSTRATION: 51,
              VERIFY_INSPECTION: 52,
              VERIFY_TEST: 53,
              ELEMENT: 54,
              elementName: 55,
              elementBody: 56,
              TYPE: 57,
              type: 58,
              DOCREF: 59,
              ref: 60,
              END_ARROW_L: 61,
              relationship: 62,
              LINE: 63,
              END_ARROW_R: 64,
              CONTAINS: 65,
              COPIES: 66,
              DERIVES: 67,
              SATISFIES: 68,
              VERIFIES: 69,
              REFINES: 70,
              TRACES: 71,
              CLASSDEF: 72,
              stylesOpt: 73,
              CLASS: 74,
              ALPHA: 75,
              COMMA: 76,
              STYLE: 77,
              style: 78,
              styleComponent: 79,
              NUM: 80,
              COLON: 81,
              UNIT: 82,
              SPACE: 83,
              BRKT: 84,
              PCT: 85,
              MINUS: 86,
              LABEL: 87,
              SEMICOLON: 88,
              unqString: 89,
              qString: 90,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              5: 'NEWLINE',
              6: 'RD',
              8: 'EOF',
              9: 'acc_title',
              10: 'acc_title_value',
              11: 'acc_descr',
              12: 'acc_descr_value',
              13: 'acc_descr_multiline_value',
              21: 'direction_tb',
              22: 'direction_bt',
              23: 'direction_rl',
              24: 'direction_lr',
              27: 'STRUCT_START',
              29: 'STYLE_SEPARATOR',
              31: 'ID',
              32: 'COLONSEP',
              34: 'TEXT',
              36: 'RISK',
              38: 'VERIFYMTHD',
              40: 'STRUCT_STOP',
              41: 'REQUIREMENT',
              42: 'FUNCTIONAL_REQUIREMENT',
              43: 'INTERFACE_REQUIREMENT',
              44: 'PERFORMANCE_REQUIREMENT',
              45: 'PHYSICAL_REQUIREMENT',
              46: 'DESIGN_CONSTRAINT',
              47: 'LOW_RISK',
              48: 'MED_RISK',
              49: 'HIGH_RISK',
              50: 'VERIFY_ANALYSIS',
              51: 'VERIFY_DEMONSTRATION',
              52: 'VERIFY_INSPECTION',
              53: 'VERIFY_TEST',
              54: 'ELEMENT',
              57: 'TYPE',
              59: 'DOCREF',
              61: 'END_ARROW_L',
              63: 'LINE',
              64: 'END_ARROW_R',
              65: 'CONTAINS',
              66: 'COPIES',
              67: 'DERIVES',
              68: 'SATISFIES',
              69: 'VERIFIES',
              70: 'REFINES',
              71: 'TRACES',
              72: 'CLASSDEF',
              74: 'CLASS',
              75: 'ALPHA',
              76: 'COMMA',
              77: 'STYLE',
              80: 'NUM',
              81: 'COLON',
              82: 'UNIT',
              83: 'SPACE',
              84: 'BRKT',
              85: 'PCT',
              86: 'MINUS',
              87: 'LABEL',
              88: 'SEMICOLON',
              89: 'unqString',
              90: 'qString',
            },
            productions_: [
              0,
              [3, 3],
              [3, 2],
              [3, 4],
              [4, 2],
              [4, 2],
              [4, 1],
              [7, 0],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [17, 1],
              [17, 1],
              [17, 1],
              [17, 1],
              [14, 5],
              [14, 7],
              [28, 5],
              [28, 5],
              [28, 5],
              [28, 5],
              [28, 2],
              [28, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [37, 1],
              [37, 1],
              [37, 1],
              [39, 1],
              [39, 1],
              [39, 1],
              [39, 1],
              [15, 5],
              [15, 7],
              [56, 5],
              [56, 5],
              [56, 2],
              [56, 1],
              [16, 5],
              [16, 5],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [19, 3],
              [20, 3],
              [20, 3],
              [30, 1],
              [30, 3],
              [30, 1],
              [30, 3],
              [18, 3],
              [73, 1],
              [73, 3],
              [78, 1],
              [78, 2],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [26, 1],
              [26, 1],
              [33, 1],
              [33, 1],
              [35, 1],
              [35, 1],
              [55, 1],
              [55, 1],
              [58, 1],
              [58, 1],
              [60, 1],
              [60, 1],
            ],
            performAction: a(function (Mt, W, Gt, j, vt, mt, Xt) {
              var Ft = mt.length - 1
              switch (vt) {
                case 4:
                  ;(this.$ = mt[Ft].trim()), j.setAccTitle(this.$)
                  break
                case 5:
                case 6:
                  ;(this.$ = mt[Ft].trim()), j.setAccDescription(this.$)
                  break
                case 7:
                  this.$ = []
                  break
                case 17:
                  j.setDirection('TB')
                  break
                case 18:
                  j.setDirection('BT')
                  break
                case 19:
                  j.setDirection('RL')
                  break
                case 20:
                  j.setDirection('LR')
                  break
                case 21:
                  j.addRequirement(mt[Ft - 3], mt[Ft - 4])
                  break
                case 22:
                  j.addRequirement(mt[Ft - 5], mt[Ft - 6]), j.setClass([mt[Ft - 5]], mt[Ft - 3])
                  break
                case 23:
                  j.setNewReqId(mt[Ft - 2])
                  break
                case 24:
                  j.setNewReqText(mt[Ft - 2])
                  break
                case 25:
                  j.setNewReqRisk(mt[Ft - 2])
                  break
                case 26:
                  j.setNewReqVerifyMethod(mt[Ft - 2])
                  break
                case 29:
                  this.$ = j.RequirementType.REQUIREMENT
                  break
                case 30:
                  this.$ = j.RequirementType.FUNCTIONAL_REQUIREMENT
                  break
                case 31:
                  this.$ = j.RequirementType.INTERFACE_REQUIREMENT
                  break
                case 32:
                  this.$ = j.RequirementType.PERFORMANCE_REQUIREMENT
                  break
                case 33:
                  this.$ = j.RequirementType.PHYSICAL_REQUIREMENT
                  break
                case 34:
                  this.$ = j.RequirementType.DESIGN_CONSTRAINT
                  break
                case 35:
                  this.$ = j.RiskLevel.LOW_RISK
                  break
                case 36:
                  this.$ = j.RiskLevel.MED_RISK
                  break
                case 37:
                  this.$ = j.RiskLevel.HIGH_RISK
                  break
                case 38:
                  this.$ = j.VerifyType.VERIFY_ANALYSIS
                  break
                case 39:
                  this.$ = j.VerifyType.VERIFY_DEMONSTRATION
                  break
                case 40:
                  this.$ = j.VerifyType.VERIFY_INSPECTION
                  break
                case 41:
                  this.$ = j.VerifyType.VERIFY_TEST
                  break
                case 42:
                  j.addElement(mt[Ft - 3])
                  break
                case 43:
                  j.addElement(mt[Ft - 5]), j.setClass([mt[Ft - 5]], mt[Ft - 3])
                  break
                case 44:
                  j.setNewElementType(mt[Ft - 2])
                  break
                case 45:
                  j.setNewElementDocRef(mt[Ft - 2])
                  break
                case 48:
                  j.addRelationship(mt[Ft - 2], mt[Ft], mt[Ft - 4])
                  break
                case 49:
                  j.addRelationship(mt[Ft - 2], mt[Ft - 4], mt[Ft])
                  break
                case 50:
                  this.$ = j.Relationships.CONTAINS
                  break
                case 51:
                  this.$ = j.Relationships.COPIES
                  break
                case 52:
                  this.$ = j.Relationships.DERIVES
                  break
                case 53:
                  this.$ = j.Relationships.SATISFIES
                  break
                case 54:
                  this.$ = j.Relationships.VERIFIES
                  break
                case 55:
                  this.$ = j.Relationships.REFINES
                  break
                case 56:
                  this.$ = j.Relationships.TRACES
                  break
                case 57:
                  ;(this.$ = mt[Ft - 2]), j.defineClass(mt[Ft - 1], mt[Ft])
                  break
                case 58:
                  j.setClass(mt[Ft - 1], mt[Ft])
                  break
                case 59:
                  j.setClass([mt[Ft - 2]], mt[Ft])
                  break
                case 60:
                case 62:
                  this.$ = [mt[Ft]]
                  break
                case 61:
                case 63:
                  this.$ = mt[Ft - 2].concat([mt[Ft]])
                  break
                case 64:
                  ;(this.$ = mt[Ft - 2]), j.setCssStyle(mt[Ft - 1], mt[Ft])
                  break
                case 65:
                  this.$ = [mt[Ft]]
                  break
                case 66:
                  mt[Ft - 2].push(mt[Ft]), (this.$ = mt[Ft - 2])
                  break
                case 68:
                  this.$ = mt[Ft - 1] + mt[Ft]
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: 2, 6: t, 9: r, 11: n, 13: i },
              { 1: [3] },
              { 3: 8, 4: 2, 5: [1, 7], 6: t, 9: r, 11: n, 13: i },
              { 5: [1, 9] },
              { 10: [1, 10] },
              { 12: [1, 11] },
              e(s, [2, 6]),
              { 3: 12, 4: 2, 6: t, 9: r, 11: n, 13: i },
              { 1: [2, 2] },
              {
                4: 17,
                5: o,
                7: 13,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              e(s, [2, 4]),
              e(s, [2, 5]),
              { 1: [2, 1] },
              { 8: [1, 41] },
              {
                4: 17,
                5: o,
                7: 42,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 43,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 44,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 45,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 46,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 47,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 48,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 49,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 50,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: A,
                77: w,
                89: D,
                90: G,
              },
              { 26: 51, 89: [1, 52], 90: [1, 53] },
              { 55: 54, 89: [1, 55], 90: [1, 56] },
              { 29: [1, 59], 61: [1, 57], 63: [1, 58] },
              e(v, [2, 17]),
              e(v, [2, 18]),
              e(v, [2, 19]),
              e(v, [2, 20]),
              { 30: 60, 33: 62, 75: R, 89: D, 90: G },
              { 30: 63, 33: 62, 75: R, 89: D, 90: G },
              { 30: 64, 33: 62, 75: R, 89: D, 90: G },
              e(F, [2, 29]),
              e(F, [2, 30]),
              e(F, [2, 31]),
              e(F, [2, 32]),
              e(F, [2, 33]),
              e(F, [2, 34]),
              e(S, [2, 81]),
              e(S, [2, 82]),
              { 1: [2, 3] },
              { 8: [2, 8] },
              { 8: [2, 9] },
              { 8: [2, 10] },
              { 8: [2, 11] },
              { 8: [2, 12] },
              { 8: [2, 13] },
              { 8: [2, 14] },
              { 8: [2, 15] },
              { 8: [2, 16] },
              { 27: [1, 65], 29: [1, 66] },
              e(O, [2, 79]),
              e(O, [2, 80]),
              { 27: [1, 67], 29: [1, 68] },
              e(O, [2, 85]),
              e(O, [2, 86]),
              { 62: 69, 65: E, 66: _, 67: L, 68: N, 69: P, 70: I, 71: M },
              { 62: 77, 65: E, 66: _, 67: L, 68: N, 69: P, 70: I, 71: M },
              { 30: 78, 33: 62, 75: R, 89: D, 90: G },
              {
                73: 79,
                75: V,
                76: $,
                78: 81,
                79: 82,
                80: q,
                81: tt,
                82: ft,
                83: H,
                84: kt,
                85: ht,
                86: yt,
                87: ot,
                88: dt,
              },
              e(it, [2, 60]),
              e(it, [2, 62]),
              {
                73: 93,
                75: V,
                76: $,
                78: 81,
                79: 82,
                80: q,
                81: tt,
                82: ft,
                83: H,
                84: kt,
                85: ht,
                86: yt,
                87: ot,
                88: dt,
              },
              { 30: 94, 33: 62, 75: R, 76: $, 89: D, 90: G },
              { 5: [1, 95] },
              { 30: 96, 33: 62, 75: R, 89: D, 90: G },
              { 5: [1, 97] },
              { 30: 98, 33: 62, 75: R, 89: D, 90: G },
              { 63: [1, 99] },
              e(Q, [2, 50]),
              e(Q, [2, 51]),
              e(Q, [2, 52]),
              e(Q, [2, 53]),
              e(Q, [2, 54]),
              e(Q, [2, 55]),
              e(Q, [2, 56]),
              { 64: [1, 100] },
              e(v, [2, 59], { 76: $ }),
              e(v, [2, 64], { 76: et }),
              { 33: 103, 75: [1, 102], 89: D, 90: G },
              e(X, [2, 65], { 79: 104, 75: V, 80: q, 81: tt, 82: ft, 83: H, 84: kt, 85: ht, 86: yt, 87: ot, 88: dt }),
              e(st, [2, 67]),
              e(st, [2, 69]),
              e(st, [2, 70]),
              e(st, [2, 71]),
              e(st, [2, 72]),
              e(st, [2, 73]),
              e(st, [2, 74]),
              e(st, [2, 75]),
              e(st, [2, 76]),
              e(st, [2, 77]),
              e(st, [2, 78]),
              e(v, [2, 57], { 76: et }),
              e(v, [2, 58], { 76: $ }),
              { 5: U, 28: 105, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 27: [1, 112], 76: $ },
              { 5: Me, 40: se, 56: 113, 57: Nt, 59: At },
              { 27: [1, 118], 76: $ },
              { 33: 119, 89: D, 90: G },
              { 33: 120, 89: D, 90: G },
              { 75: V, 78: 121, 79: 82, 80: q, 81: tt, 82: ft, 83: H, 84: kt, 85: ht, 86: yt, 87: ot, 88: dt },
              e(it, [2, 61]),
              e(it, [2, 63]),
              e(st, [2, 68]),
              e(v, [2, 21]),
              { 32: [1, 122] },
              { 32: [1, 123] },
              { 32: [1, 124] },
              { 32: [1, 125] },
              { 5: U, 28: 126, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              e(v, [2, 28]),
              { 5: [1, 127] },
              e(v, [2, 42]),
              { 32: [1, 128] },
              { 32: [1, 129] },
              { 5: Me, 40: se, 56: 130, 57: Nt, 59: At },
              e(v, [2, 47]),
              { 5: [1, 131] },
              e(v, [2, 48]),
              e(v, [2, 49]),
              e(X, [2, 66], { 79: 104, 75: V, 80: q, 81: tt, 82: ft, 83: H, 84: kt, 85: ht, 86: yt, 87: ot, 88: dt }),
              { 33: 132, 89: D, 90: G },
              { 35: 133, 89: [1, 134], 90: [1, 135] },
              { 37: 136, 47: [1, 137], 48: [1, 138], 49: [1, 139] },
              { 39: 140, 50: [1, 141], 51: [1, 142], 52: [1, 143], 53: [1, 144] },
              e(v, [2, 27]),
              { 5: U, 28: 145, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 58: 146, 89: [1, 147], 90: [1, 148] },
              { 60: 149, 89: [1, 150], 90: [1, 151] },
              e(v, [2, 46]),
              { 5: Me, 40: se, 56: 152, 57: Nt, 59: At },
              { 5: [1, 153] },
              { 5: [1, 154] },
              { 5: [2, 83] },
              { 5: [2, 84] },
              { 5: [1, 155] },
              { 5: [2, 35] },
              { 5: [2, 36] },
              { 5: [2, 37] },
              { 5: [1, 156] },
              { 5: [2, 38] },
              { 5: [2, 39] },
              { 5: [2, 40] },
              { 5: [2, 41] },
              e(v, [2, 22]),
              { 5: [1, 157] },
              { 5: [2, 87] },
              { 5: [2, 88] },
              { 5: [1, 158] },
              { 5: [2, 89] },
              { 5: [2, 90] },
              e(v, [2, 43]),
              { 5: U, 28: 159, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 160, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 161, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 162, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: Me, 40: se, 56: 163, 57: Nt, 59: At },
              { 5: Me, 40: se, 56: 164, 57: Nt, 59: At },
              e(v, [2, 23]),
              e(v, [2, 24]),
              e(v, [2, 25]),
              e(v, [2, 26]),
              e(v, [2, 44]),
              e(v, [2, 45]),
            ],
            defaultActions: {
              8: [2, 2],
              12: [2, 1],
              41: [2, 3],
              42: [2, 8],
              43: [2, 9],
              44: [2, 10],
              45: [2, 11],
              46: [2, 12],
              47: [2, 13],
              48: [2, 14],
              49: [2, 15],
              50: [2, 16],
              134: [2, 83],
              135: [2, 84],
              137: [2, 35],
              138: [2, 36],
              139: [2, 37],
              141: [2, 38],
              142: [2, 39],
              143: [2, 40],
              144: [2, 41],
              147: [2, 87],
              148: [2, 88],
              150: [2, 89],
              151: [2, 90],
            },
            parseError: a(function (Mt, W) {
              if (W.recoverable) this.trace(Mt)
              else {
                var Gt = new Error(Mt)
                throw ((Gt.hash = W), Gt)
              }
            }, 'parseError'),
            parse: a(function (Mt) {
              var W = this,
                Gt = [0],
                j = [],
                vt = [null],
                mt = [],
                Xt = this.table,
                Ft = '',
                _t = 0,
                Qe = 0,
                It = 0,
                xr = 2,
                Ze = 1,
                yn = mt.slice.call(arguments, 1),
                Ae = Object.create(this.lexer),
                Se = { yy: {} }
              for (var Je in this.yy) Object.prototype.hasOwnProperty.call(this.yy, Je) && (Se.yy[Je] = this.yy[Je])
              Ae.setInput(Mt, Se.yy),
                (Se.yy.lexer = Ae),
                (Se.yy.parser = this),
                typeof Ae.yylloc > 'u' && (Ae.yylloc = {})
              var _e = Ae.yylloc
              mt.push(_e)
              var hr = Ae.options && Ae.options.ranges
              typeof Se.yy.parseError == 'function'
                ? (this.parseError = Se.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function Cn(vr) {
                ;(Gt.length = Gt.length - 2 * vr), (vt.length = vt.length - vr), (mt.length = mt.length - vr)
              }
              a(Cn, 'popStack')
              function ve() {
                var vr
                return (
                  (vr = j.pop() || Ae.lex() || Ze),
                  typeof vr != 'number' &&
                    (vr instanceof Array && ((j = vr), (vr = j.pop())), (vr = W.symbols_[vr] || vr)),
                  vr
                )
              }
              a(ve, 'lex')
              for (var $e, Le, xe, ce, ye, be, Ht = {}, Nn, ne, Ri, xn; ; ) {
                if (
                  ((xe = Gt[Gt.length - 1]),
                  this.defaultActions[xe]
                    ? (ce = this.defaultActions[xe])
                    : (($e === null || typeof $e > 'u') && ($e = ve()), (ce = Xt[xe] && Xt[xe][$e])),
                  typeof ce > 'u' || !ce.length || !ce[0])
                ) {
                  var Br = ''
                  xn = []
                  for (Nn in Xt[xe]) this.terminals_[Nn] && Nn > xr && xn.push("'" + this.terminals_[Nn] + "'")
                  Ae.showPosition
                    ? (Br =
                        'Parse error on line ' +
                        (_t + 1) +
                        `:
` +
                        Ae.showPosition() +
                        `
Expecting ` +
                        xn.join(', ') +
                        ", got '" +
                        (this.terminals_[$e] || $e) +
                        "'")
                    : (Br =
                        'Parse error on line ' +
                        (_t + 1) +
                        ': Unexpected ' +
                        ($e == Ze ? 'end of input' : "'" + (this.terminals_[$e] || $e) + "'")),
                    this.parseError(Br, {
                      text: Ae.match,
                      token: this.terminals_[$e] || $e,
                      line: Ae.yylineno,
                      loc: _e,
                      expected: xn,
                    })
                }
                if (ce[0] instanceof Array && ce.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + xe + ', token: ' + $e)
                switch (ce[0]) {
                  case 1:
                    Gt.push($e),
                      vt.push(Ae.yytext),
                      mt.push(Ae.yylloc),
                      Gt.push(ce[1]),
                      ($e = null),
                      Le
                        ? (($e = Le), (Le = null))
                        : ((Qe = Ae.yyleng), (Ft = Ae.yytext), (_t = Ae.yylineno), (_e = Ae.yylloc), It > 0 && It--)
                    break
                  case 2:
                    if (
                      ((ne = this.productions_[ce[1]][1]),
                      (Ht.$ = vt[vt.length - ne]),
                      (Ht._$ = {
                        first_line: mt[mt.length - (ne || 1)].first_line,
                        last_line: mt[mt.length - 1].last_line,
                        first_column: mt[mt.length - (ne || 1)].first_column,
                        last_column: mt[mt.length - 1].last_column,
                      }),
                      hr && (Ht._$.range = [mt[mt.length - (ne || 1)].range[0], mt[mt.length - 1].range[1]]),
                      (be = this.performAction.apply(Ht, [Ft, Qe, _t, Se.yy, ce[1], vt, mt].concat(yn))),
                      typeof be < 'u')
                    )
                      return be
                    ne && ((Gt = Gt.slice(0, -1 * ne * 2)), (vt = vt.slice(0, -1 * ne)), (mt = mt.slice(0, -1 * ne))),
                      Gt.push(this.productions_[ce[1]][0]),
                      vt.push(Ht.$),
                      mt.push(Ht._$),
                      (Ri = Xt[Gt[Gt.length - 2]][Gt[Gt.length - 1]]),
                      Gt.push(Ri)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          ct = (function () {
            var Z = {
              EOF: 1,
              parseError: a(function (W, Gt) {
                if (this.yy.parser) this.yy.parser.parseError(W, Gt)
                else throw new Error(W)
              }, 'parseError'),
              setInput: a(function (Mt, W) {
                return (
                  (this.yy = W || this.yy || {}),
                  (this._input = Mt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var Mt = this._input[0]
                ;(this.yytext += Mt), this.yyleng++, this.offset++, (this.match += Mt), (this.matched += Mt)
                var W = Mt.match(/(?:\r\n?|\n).*/g)
                return (
                  W ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  Mt
                )
              }, 'input'),
              unput: a(function (Mt) {
                var W = Mt.length,
                  Gt = Mt.split(/(?:\r\n?|\n)/g)
                ;(this._input = Mt + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - W)),
                  (this.offset -= W)
                var j = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  Gt.length - 1 && (this.yylineno -= Gt.length - 1)
                var vt = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Gt
                      ? (Gt.length === j.length ? this.yylloc.first_column : 0) +
                        j[j.length - Gt.length].length -
                        Gt[0].length
                      : this.yylloc.first_column - W,
                  }),
                  this.options.ranges && (this.yylloc.range = [vt[0], vt[0] + this.yyleng - W]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (Mt) {
                this.unput(this.match.slice(Mt))
              }, 'less'),
              pastInput: a(function () {
                var Mt = this.matched.substr(0, this.matched.length - this.match.length)
                return (Mt.length > 20 ? '...' : '') + Mt.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var Mt = this.match
                return (
                  Mt.length < 20 && (Mt += this._input.substr(0, 20 - Mt.length)),
                  (Mt.substr(0, 20) + (Mt.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var Mt = this.pastInput(),
                  W = new Array(Mt.length + 1).join('-')
                return (
                  Mt +
                  this.upcomingInput() +
                  `
` +
                  W +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (Mt, W) {
                var Gt, j, vt
                if (
                  (this.options.backtrack_lexer &&
                    ((vt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (vt.yylloc.range = this.yylloc.range.slice(0))),
                  (j = Mt[0].match(/(?:\r\n?|\n).*/g)),
                  j && (this.yylineno += j.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: j
                      ? j[j.length - 1].length - j[j.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + Mt[0].length,
                  }),
                  (this.yytext += Mt[0]),
                  (this.match += Mt[0]),
                  (this.matches = Mt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(Mt[0].length)),
                  (this.matched += Mt[0]),
                  (Gt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    W,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Gt)
                )
                  return Gt
                if (this._backtrack) {
                  for (var mt in vt) this[mt] = vt[mt]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var Mt, W, Gt, j
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var vt = this._currentRules(), mt = 0; mt < vt.length; mt++)
                  if (((Gt = this._input.match(this.rules[vt[mt]])), Gt && (!W || Gt[0].length > W[0].length))) {
                    if (((W = Gt), (j = mt), this.options.backtrack_lexer)) {
                      if (((Mt = this.test_match(Gt, vt[mt])), Mt !== !1)) return Mt
                      if (this._backtrack) {
                        W = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return W
                  ? ((Mt = this.test_match(W, vt[j])), Mt !== !1 ? Mt : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var W = this.next()
                return W || this.lex()
              }, 'lex'),
              begin: a(function (W) {
                this.conditionStack.push(W)
              }, 'begin'),
              popState: a(function () {
                var W = this.conditionStack.length - 1
                return W > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (W) {
                return (
                  (W = this.conditionStack.length - 1 - Math.abs(W || 0)), W >= 0 ? this.conditionStack[W] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (W) {
                this.begin(W)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (W, Gt, j, vt) {
                var mt = vt
                switch (j) {
                  case 0:
                    return 'title'
                  case 1:
                    return this.begin('acc_title'), 9
                    break
                  case 2:
                    return this.popState(), 'acc_title_value'
                    break
                  case 3:
                    return this.begin('acc_descr'), 11
                    break
                  case 4:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 5:
                    this.begin('acc_descr_multiline')
                    break
                  case 6:
                    this.popState()
                    break
                  case 7:
                    return 'acc_descr_multiline_value'
                  case 8:
                    return 21
                  case 9:
                    return 22
                  case 10:
                    return 23
                  case 11:
                    return 24
                  case 12:
                    return 5
                  case 13:
                    break
                  case 14:
                    break
                  case 15:
                    break
                  case 16:
                    return 8
                  case 17:
                    return 6
                  case 18:
                    return 27
                  case 19:
                    return 40
                  case 20:
                    return 29
                  case 21:
                    return 32
                  case 22:
                    return 31
                  case 23:
                    return 34
                  case 24:
                    return 36
                  case 25:
                    return 38
                  case 26:
                    return 41
                  case 27:
                    return 42
                  case 28:
                    return 43
                  case 29:
                    return 44
                  case 30:
                    return 45
                  case 31:
                    return 46
                  case 32:
                    return 47
                  case 33:
                    return 48
                  case 34:
                    return 49
                  case 35:
                    return 50
                  case 36:
                    return 51
                  case 37:
                    return 52
                  case 38:
                    return 53
                  case 39:
                    return 54
                  case 40:
                    return 65
                  case 41:
                    return 66
                  case 42:
                    return 67
                  case 43:
                    return 68
                  case 44:
                    return 69
                  case 45:
                    return 70
                  case 46:
                    return 71
                  case 47:
                    return 57
                  case 48:
                    return 59
                  case 49:
                    return this.begin('style'), 77
                    break
                  case 50:
                    return 75
                  case 51:
                    return 81
                  case 52:
                    return 88
                  case 53:
                    return 'PERCENT'
                  case 54:
                    return 86
                  case 55:
                    return 84
                  case 56:
                    break
                  case 57:
                    this.begin('string')
                    break
                  case 58:
                    this.popState()
                    break
                  case 59:
                    return this.begin('style'), 72
                    break
                  case 60:
                    return this.begin('style'), 74
                    break
                  case 61:
                    return 61
                  case 62:
                    return 64
                  case 63:
                    return 63
                  case 64:
                    this.begin('string')
                    break
                  case 65:
                    this.popState()
                    break
                  case 66:
                    return 'qString'
                  case 67:
                    return (Gt.yytext = Gt.yytext.trim()), 89
                    break
                  case 68:
                    return 75
                  case 69:
                    return 80
                  case 70:
                    return 76
                }
              }, 'anonymous'),
              rules: [
                /^(?:title\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:(\r?\n)+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%[^\n]*)/i,
                /^(?:$)/i,
                /^(?:requirementDiagram\b)/i,
                /^(?:\{)/i,
                /^(?:\})/i,
                /^(?::{3})/i,
                /^(?::)/i,
                /^(?:id\b)/i,
                /^(?:text\b)/i,
                /^(?:risk\b)/i,
                /^(?:verifyMethod\b)/i,
                /^(?:requirement\b)/i,
                /^(?:functionalRequirement\b)/i,
                /^(?:interfaceRequirement\b)/i,
                /^(?:performanceRequirement\b)/i,
                /^(?:physicalRequirement\b)/i,
                /^(?:designConstraint\b)/i,
                /^(?:low\b)/i,
                /^(?:medium\b)/i,
                /^(?:high\b)/i,
                /^(?:analysis\b)/i,
                /^(?:demonstration\b)/i,
                /^(?:inspection\b)/i,
                /^(?:test\b)/i,
                /^(?:element\b)/i,
                /^(?:contains\b)/i,
                /^(?:copies\b)/i,
                /^(?:derives\b)/i,
                /^(?:satisfies\b)/i,
                /^(?:verifies\b)/i,
                /^(?:refines\b)/i,
                /^(?:traces\b)/i,
                /^(?:type\b)/i,
                /^(?:docref\b)/i,
                /^(?:style\b)/i,
                /^(?:\w+)/i,
                /^(?::)/i,
                /^(?:;)/i,
                /^(?:%)/i,
                /^(?:-)/i,
                /^(?:#)/i,
                /^(?: )/i,
                /^(?:["])/i,
                /^(?:\n)/i,
                /^(?:classDef\b)/i,
                /^(?:class\b)/i,
                /^(?:<-)/i,
                /^(?:->)/i,
                /^(?:-)/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i,
                /^(?:\w+)/i,
                /^(?:[0-9]+)/i,
                /^(?:,)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [6, 7, 68, 69, 70], inclusive: !1 },
                acc_descr: { rules: [4, 68, 69, 70], inclusive: !1 },
                acc_title: { rules: [2, 68, 69, 70], inclusive: !1 },
                style: { rules: [50, 51, 52, 53, 54, 55, 56, 57, 58, 68, 69, 70], inclusive: !1 },
                unqString: { rules: [68, 69, 70], inclusive: !1 },
                token: { rules: [68, 69, 70], inclusive: !1 },
                string: { rules: [65, 66, 68, 69, 70], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
                    30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 59, 60, 61, 62, 63,
                    64, 67, 68, 69, 70,
                  ],
                  inclusive: !0,
                },
              },
            }
            return Z
          })()
        bt.lexer = ct
        function Lt() {
          this.yy = {}
        }
        return a(Lt, 'Parser'), (Lt.prototype = bt), (bt.Parser = Lt), new Lt()
      })()
      fN.parser = fN
      gnt = fN
    })
  var N_,
    xnt = x(() => {
      'use strict'
      pe()
      Vt()
      bn()
      N_ = class {
        constructor() {
          this.relations = []
          this.latestRequirement = this.getInitialRequirement()
          this.requirements = new Map()
          this.latestElement = this.getInitialElement()
          this.elements = new Map()
          this.classes = new Map()
          this.direction = 'TB'
          this.RequirementType = {
            REQUIREMENT: 'Requirement',
            FUNCTIONAL_REQUIREMENT: 'Functional Requirement',
            INTERFACE_REQUIREMENT: 'Interface Requirement',
            PERFORMANCE_REQUIREMENT: 'Performance Requirement',
            PHYSICAL_REQUIREMENT: 'Physical Requirement',
            DESIGN_CONSTRAINT: 'Design Constraint',
          }
          this.RiskLevel = { LOW_RISK: 'Low', MED_RISK: 'Medium', HIGH_RISK: 'High' }
          this.VerifyType = {
            VERIFY_ANALYSIS: 'Analysis',
            VERIFY_DEMONSTRATION: 'Demonstration',
            VERIFY_INSPECTION: 'Inspection',
            VERIFY_TEST: 'Test',
          }
          this.Relationships = {
            CONTAINS: 'contains',
            COPIES: 'copies',
            DERIVES: 'derives',
            SATISFIES: 'satisfies',
            VERIFIES: 'verifies',
            REFINES: 'refines',
            TRACES: 'traces',
          }
          this.setAccTitle = Xe
          this.getAccTitle = tr
          this.setAccDescription = er
          this.getAccDescription = rr
          this.setDiagramTitle = lr
          this.getDiagramTitle = nr
          this.getConfig = a(() => K().requirement, 'getConfig')
          this.clear(),
            (this.setDirection = this.setDirection.bind(this)),
            (this.addRequirement = this.addRequirement.bind(this)),
            (this.setNewReqId = this.setNewReqId.bind(this)),
            (this.setNewReqRisk = this.setNewReqRisk.bind(this)),
            (this.setNewReqText = this.setNewReqText.bind(this)),
            (this.setNewReqVerifyMethod = this.setNewReqVerifyMethod.bind(this)),
            (this.addElement = this.addElement.bind(this)),
            (this.setNewElementType = this.setNewElementType.bind(this)),
            (this.setNewElementDocRef = this.setNewElementDocRef.bind(this)),
            (this.addRelationship = this.addRelationship.bind(this)),
            (this.setCssStyle = this.setCssStyle.bind(this)),
            (this.setClass = this.setClass.bind(this)),
            (this.defineClass = this.defineClass.bind(this)),
            (this.setAccTitle = this.setAccTitle.bind(this)),
            (this.setAccDescription = this.setAccDescription.bind(this))
        }
        static {
          a(this, 'RequirementDB')
        }
        getDirection() {
          return this.direction
        }
        setDirection(t) {
          this.direction = t
        }
        resetLatestRequirement() {
          this.latestRequirement = this.getInitialRequirement()
        }
        resetLatestElement() {
          this.latestElement = this.getInitialElement()
        }
        getInitialRequirement() {
          return {
            requirementId: '',
            text: '',
            risk: '',
            verifyMethod: '',
            name: '',
            type: '',
            cssStyles: [],
            classes: ['default'],
          }
        }
        getInitialElement() {
          return { name: '', type: '', docRef: '', cssStyles: [], classes: ['default'] }
        }
        addRequirement(t, r) {
          return (
            this.requirements.has(t) ||
              this.requirements.set(t, {
                name: t,
                type: r,
                requirementId: this.latestRequirement.requirementId,
                text: this.latestRequirement.text,
                risk: this.latestRequirement.risk,
                verifyMethod: this.latestRequirement.verifyMethod,
                cssStyles: [],
                classes: ['default'],
              }),
            this.resetLatestRequirement(),
            this.requirements.get(t)
          )
        }
        getRequirements() {
          return this.requirements
        }
        setNewReqId(t) {
          this.latestRequirement !== void 0 && (this.latestRequirement.requirementId = t)
        }
        setNewReqText(t) {
          this.latestRequirement !== void 0 && (this.latestRequirement.text = t)
        }
        setNewReqRisk(t) {
          this.latestRequirement !== void 0 && (this.latestRequirement.risk = t)
        }
        setNewReqVerifyMethod(t) {
          this.latestRequirement !== void 0 && (this.latestRequirement.verifyMethod = t)
        }
        addElement(t) {
          return (
            this.elements.has(t) ||
              (this.elements.set(t, {
                name: t,
                type: this.latestElement.type,
                docRef: this.latestElement.docRef,
                cssStyles: [],
                classes: ['default'],
              }),
              B.info('Added new element: ', t)),
            this.resetLatestElement(),
            this.elements.get(t)
          )
        }
        getElements() {
          return this.elements
        }
        setNewElementType(t) {
          this.latestElement !== void 0 && (this.latestElement.type = t)
        }
        setNewElementDocRef(t) {
          this.latestElement !== void 0 && (this.latestElement.docRef = t)
        }
        addRelationship(t, r, n) {
          this.relations.push({ type: t, src: r, dst: n })
        }
        getRelationships() {
          return this.relations
        }
        clear() {
          ;(this.relations = []),
            this.resetLatestRequirement(),
            (this.requirements = new Map()),
            this.resetLatestElement(),
            (this.elements = new Map()),
            (this.classes = new Map()),
            Ye()
        }
        setCssStyle(t, r) {
          for (let n of t) {
            let i = this.requirements.get(n) ?? this.elements.get(n)
            if (!r || !i) return
            for (let s of r) s.includes(',') ? i.cssStyles.push(...s.split(',')) : i.cssStyles.push(s)
          }
        }
        setClass(t, r) {
          for (let n of t) {
            let i = this.requirements.get(n) ?? this.elements.get(n)
            if (i)
              for (let s of r) {
                i.classes.push(s)
                let o = this.classes.get(s)?.styles
                o && i.cssStyles.push(...o)
              }
          }
        }
        defineClass(t, r) {
          for (let n of t) {
            let i = this.classes.get(n)
            i === void 0 && ((i = { id: n, styles: [], textStyles: [] }), this.classes.set(n, i)),
              r &&
                r.forEach(function (s) {
                  if (/color/.exec(s)) {
                    let o = s.replace('fill', 'bgFill')
                    i.textStyles.push(o)
                  }
                  i.styles.push(s)
                }),
              this.requirements.forEach((s) => {
                s.classes.includes(n) && s.cssStyles.push(...r.flatMap((o) => o.split(',')))
              }),
              this.elements.forEach((s) => {
                s.classes.includes(n) && s.cssStyles.push(...r.flatMap((o) => o.split(',')))
              })
          }
        }
        getClasses() {
          return this.classes
        }
        getData() {
          let t = K(),
            r = [],
            n = []
          for (let i of this.requirements.values()) {
            let s = i
            ;(s.id = i.name),
              (s.cssStyles = i.cssStyles),
              (s.cssClasses = i.classes.join(' ')),
              (s.shape = 'requirementBox'),
              (s.look = t.look),
              r.push(s)
          }
          for (let i of this.elements.values()) {
            let s = i
            ;(s.shape = 'requirementBox'),
              (s.look = t.look),
              (s.id = i.name),
              (s.cssStyles = i.cssStyles),
              (s.cssClasses = i.classes.join(' ')),
              r.push(s)
          }
          for (let i of this.relations) {
            let s = 0,
              o = i.type === this.Relationships.CONTAINS,
              l = {
                id: `${i.src}-${i.dst}-${s}`,
                start: this.requirements.get(i.src)?.name ?? this.elements.get(i.src)?.name,
                end: this.requirements.get(i.dst)?.name ?? this.elements.get(i.dst)?.name,
                label: `&lt;&lt;${i.type}&gt;&gt;`,
                classes: 'relationshipLine',
                style: ['fill:none', o ? '' : 'stroke-dasharray: 10,7'],
                labelpos: 'c',
                thickness: 'normal',
                type: 'normal',
                pattern: o ? 'normal' : 'dashed',
                arrowTypeStart: o ? 'requirement_contains' : '',
                arrowTypeEnd: o ? '' : 'requirement_arrow',
                look: t.look,
              }
            n.push(l), s++
          }
          return { nodes: r, edges: n, other: {}, config: t, direction: this.getDirection() }
        }
      }
    })
  var wRt,
    bnt,
    knt = x(() => {
      'use strict'
      ;(wRt = a(
        (e) => `

  marker {
    fill: ${e.relationColor};
    stroke: ${e.relationColor};
  }

  marker.cross {
    stroke: ${e.lineColor};
  }

  svg {
    font-family: ${e.fontFamily};
    font-size: ${e.fontSize};
  }

  .reqBox {
    fill: ${e.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }

  .reqTitle, .reqLabel{
    fill:  ${e.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${e.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${e.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${e.relationLabelColor};
  }
  .divider {
    stroke: ${e.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }
  .labelBkg {
    background-color: ${e.edgeLabelBackground};
  }

`,
        'getStyles',
      )),
        (bnt = wRt)
    })
  var dN = {}
  Oe(dN, { draw: () => ERt })
  var ERt,
    Tnt = x(() => {
      'use strict'
      pe()
      Vt()
      hd()
      ph()
      mh()
      Ce()
      ERt = a(async function (e, t, r, n) {
        B.info('REF0:'), B.info('Drawing requirement diagram (unified)', t)
        let { securityLevel: i, state: s, layout: o } = K(),
          l = n.db.getData(),
          u = So(t, i)
        ;(l.type = n.type),
          (l.layoutAlgorithm = Gc(o)),
          (l.nodeSpacing = s?.nodeSpacing ?? 50),
          (l.rankSpacing = s?.rankSpacing ?? 50),
          (l.markers = ['requirement_contains', 'requirement_arrow']),
          (l.diagramId = t),
          await Do(l, u)
        let h = 8
        le.insertTitle(u, 'requirementDiagramTitleText', s?.titleTopMargin ?? 25, n.db.getDiagramTitle()),
          la(u, h, 'requirementDiagram', s?.useMaxWidth ?? !0)
      }, 'draw')
    })
  var Snt = {}
  Oe(Snt, { diagram: () => vRt })
  var vRt,
    _nt = x(() => {
      'use strict'
      ynt()
      xnt()
      knt()
      Tnt()
      vRt = {
        parser: gnt,
        get db() {
          return new N_()
        },
        renderer: dN,
        styles: bnt,
      }
    })
  var pN,
    Ent,
    vnt = x(() => {
      'use strict'
      pN = (function () {
        var e = a(function (dt, it, Q, et) {
            for (Q = Q || {}, et = dt.length; et--; Q[dt[et]] = it);
            return Q
          }, 'o'),
          t = [1, 2],
          r = [1, 3],
          n = [1, 4],
          i = [2, 4],
          s = [1, 9],
          o = [1, 11],
          l = [1, 13],
          u = [1, 14],
          h = [1, 16],
          f = [1, 17],
          d = [1, 18],
          p = [1, 24],
          m = [1, 25],
          g = [1, 26],
          y = [1, 27],
          b = [1, 28],
          k = [1, 29],
          T = [1, 30],
          C = [1, 31],
          A = [1, 32],
          w = [1, 33],
          D = [1, 34],
          G = [1, 35],
          v = [1, 36],
          R = [1, 37],
          F = [1, 38],
          S = [1, 39],
          O = [1, 41],
          E = [1, 42],
          _ = [1, 43],
          L = [1, 44],
          N = [1, 45],
          P = [1, 46],
          I = [
            1, 4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 48, 49, 50, 52, 53,
            55, 60, 61, 62, 63, 71,
          ],
          M = [2, 71],
          V = [4, 5, 16, 50, 52, 53],
          $ = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61,
            62, 63, 71,
          ],
          q = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 49, 50, 52, 53, 55, 60,
            61, 62, 63, 71,
          ],
          tt = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 48, 50, 52, 53, 55, 60,
            61, 62, 63, 71,
          ],
          ft = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 50, 52, 53, 55, 60,
            61, 62, 63, 71,
          ],
          H = [69, 70, 71],
          kt = [1, 127],
          ht = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SPACE: 4,
              NEWLINE: 5,
              SD: 6,
              document: 7,
              line: 8,
              statement: 9,
              box_section: 10,
              box_line: 11,
              participant_statement: 12,
              create: 13,
              box: 14,
              restOfLine: 15,
              end: 16,
              signal: 17,
              autonumber: 18,
              NUM: 19,
              off: 20,
              activate: 21,
              actor: 22,
              deactivate: 23,
              note_statement: 24,
              links_statement: 25,
              link_statement: 26,
              properties_statement: 27,
              details_statement: 28,
              title: 29,
              legacy_title: 30,
              acc_title: 31,
              acc_title_value: 32,
              acc_descr: 33,
              acc_descr_value: 34,
              acc_descr_multiline_value: 35,
              loop: 36,
              rect: 37,
              opt: 38,
              alt: 39,
              else_sections: 40,
              par: 41,
              par_sections: 42,
              par_over: 43,
              critical: 44,
              option_sections: 45,
              break: 46,
              option: 47,
              and: 48,
              else: 49,
              participant: 50,
              AS: 51,
              participant_actor: 52,
              destroy: 53,
              actor_with_config: 54,
              note: 55,
              placement: 56,
              text2: 57,
              over: 58,
              actor_pair: 59,
              links: 60,
              link: 61,
              properties: 62,
              details: 63,
              spaceList: 64,
              ',': 65,
              left_of: 66,
              right_of: 67,
              signaltype: 68,
              '+': 69,
              '-': 70,
              ACTOR: 71,
              config_object: 72,
              CONFIG_START: 73,
              CONFIG_CONTENT: 74,
              CONFIG_END: 75,
              SOLID_OPEN_ARROW: 76,
              DOTTED_OPEN_ARROW: 77,
              SOLID_ARROW: 78,
              BIDIRECTIONAL_SOLID_ARROW: 79,
              DOTTED_ARROW: 80,
              BIDIRECTIONAL_DOTTED_ARROW: 81,
              SOLID_CROSS: 82,
              DOTTED_CROSS: 83,
              SOLID_POINT: 84,
              DOTTED_POINT: 85,
              TXT: 86,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'SPACE',
              5: 'NEWLINE',
              6: 'SD',
              13: 'create',
              14: 'box',
              15: 'restOfLine',
              16: 'end',
              18: 'autonumber',
              19: 'NUM',
              20: 'off',
              21: 'activate',
              23: 'deactivate',
              29: 'title',
              30: 'legacy_title',
              31: 'acc_title',
              32: 'acc_title_value',
              33: 'acc_descr',
              34: 'acc_descr_value',
              35: 'acc_descr_multiline_value',
              36: 'loop',
              37: 'rect',
              38: 'opt',
              39: 'alt',
              41: 'par',
              43: 'par_over',
              44: 'critical',
              46: 'break',
              47: 'option',
              48: 'and',
              49: 'else',
              50: 'participant',
              51: 'AS',
              52: 'participant_actor',
              53: 'destroy',
              55: 'note',
              58: 'over',
              60: 'links',
              61: 'link',
              62: 'properties',
              63: 'details',
              65: ',',
              66: 'left_of',
              67: 'right_of',
              69: '+',
              70: '-',
              71: 'ACTOR',
              73: 'CONFIG_START',
              74: 'CONFIG_CONTENT',
              75: 'CONFIG_END',
              76: 'SOLID_OPEN_ARROW',
              77: 'DOTTED_OPEN_ARROW',
              78: 'SOLID_ARROW',
              79: 'BIDIRECTIONAL_SOLID_ARROW',
              80: 'DOTTED_ARROW',
              81: 'BIDIRECTIONAL_DOTTED_ARROW',
              82: 'SOLID_CROSS',
              83: 'DOTTED_CROSS',
              84: 'SOLID_POINT',
              85: 'DOTTED_POINT',
              86: 'TXT',
            },
            productions_: [
              0,
              [3, 2],
              [3, 2],
              [3, 2],
              [7, 0],
              [7, 2],
              [8, 2],
              [8, 1],
              [8, 1],
              [10, 0],
              [10, 2],
              [11, 2],
              [11, 1],
              [11, 1],
              [9, 1],
              [9, 2],
              [9, 4],
              [9, 2],
              [9, 4],
              [9, 3],
              [9, 3],
              [9, 2],
              [9, 3],
              [9, 3],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [45, 1],
              [45, 4],
              [42, 1],
              [42, 4],
              [40, 1],
              [40, 4],
              [12, 5],
              [12, 3],
              [12, 5],
              [12, 3],
              [12, 3],
              [12, 3],
              [24, 4],
              [24, 4],
              [25, 3],
              [26, 3],
              [27, 3],
              [28, 3],
              [64, 2],
              [64, 1],
              [59, 3],
              [59, 1],
              [56, 1],
              [56, 1],
              [17, 5],
              [17, 5],
              [17, 4],
              [54, 2],
              [72, 3],
              [22, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [57, 1],
            ],
            performAction: a(function (it, Q, et, X, st, U, gt) {
              var z = U.length - 1
              switch (st) {
                case 3:
                  return X.apply(U[z]), U[z]
                  break
                case 4:
                case 9:
                  this.$ = []
                  break
                case 5:
                case 10:
                  U[z - 1].push(U[z]), (this.$ = U[z - 1])
                  break
                case 6:
                case 7:
                case 11:
                case 12:
                  this.$ = U[z]
                  break
                case 8:
                case 13:
                  this.$ = []
                  break
                case 15:
                  ;(U[z].type = 'createParticipant'), (this.$ = U[z])
                  break
                case 16:
                  U[z - 1].unshift({ type: 'boxStart', boxData: X.parseBoxData(U[z - 2]) }),
                    U[z - 1].push({ type: 'boxEnd', boxText: U[z - 2] }),
                    (this.$ = U[z - 1])
                  break
                case 18:
                  this.$ = {
                    type: 'sequenceIndex',
                    sequenceIndex: Number(U[z - 2]),
                    sequenceIndexStep: Number(U[z - 1]),
                    sequenceVisible: !0,
                    signalType: X.LINETYPE.AUTONUMBER,
                  }
                  break
                case 19:
                  this.$ = {
                    type: 'sequenceIndex',
                    sequenceIndex: Number(U[z - 1]),
                    sequenceIndexStep: 1,
                    sequenceVisible: !0,
                    signalType: X.LINETYPE.AUTONUMBER,
                  }
                  break
                case 20:
                  this.$ = { type: 'sequenceIndex', sequenceVisible: !1, signalType: X.LINETYPE.AUTONUMBER }
                  break
                case 21:
                  this.$ = { type: 'sequenceIndex', sequenceVisible: !0, signalType: X.LINETYPE.AUTONUMBER }
                  break
                case 22:
                  this.$ = { type: 'activeStart', signalType: X.LINETYPE.ACTIVE_START, actor: U[z - 1].actor }
                  break
                case 23:
                  this.$ = { type: 'activeEnd', signalType: X.LINETYPE.ACTIVE_END, actor: U[z - 1].actor }
                  break
                case 29:
                  X.setDiagramTitle(U[z].substring(6)), (this.$ = U[z].substring(6))
                  break
                case 30:
                  X.setDiagramTitle(U[z].substring(7)), (this.$ = U[z].substring(7))
                  break
                case 31:
                  ;(this.$ = U[z].trim()), X.setAccTitle(this.$)
                  break
                case 32:
                case 33:
                  ;(this.$ = U[z].trim()), X.setAccDescription(this.$)
                  break
                case 34:
                  U[z - 1].unshift({
                    type: 'loopStart',
                    loopText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.LOOP_START,
                  }),
                    U[z - 1].push({ type: 'loopEnd', loopText: U[z - 2], signalType: X.LINETYPE.LOOP_END }),
                    (this.$ = U[z - 1])
                  break
                case 35:
                  U[z - 1].unshift({
                    type: 'rectStart',
                    color: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.RECT_START,
                  }),
                    U[z - 1].push({
                      type: 'rectEnd',
                      color: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.RECT_END,
                    }),
                    (this.$ = U[z - 1])
                  break
                case 36:
                  U[z - 1].unshift({
                    type: 'optStart',
                    optText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.OPT_START,
                  }),
                    U[z - 1].push({
                      type: 'optEnd',
                      optText: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.OPT_END,
                    }),
                    (this.$ = U[z - 1])
                  break
                case 37:
                  U[z - 1].unshift({
                    type: 'altStart',
                    altText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.ALT_START,
                  }),
                    U[z - 1].push({ type: 'altEnd', signalType: X.LINETYPE.ALT_END }),
                    (this.$ = U[z - 1])
                  break
                case 38:
                  U[z - 1].unshift({
                    type: 'parStart',
                    parText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.PAR_START,
                  }),
                    U[z - 1].push({ type: 'parEnd', signalType: X.LINETYPE.PAR_END }),
                    (this.$ = U[z - 1])
                  break
                case 39:
                  U[z - 1].unshift({
                    type: 'parStart',
                    parText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.PAR_OVER_START,
                  }),
                    U[z - 1].push({ type: 'parEnd', signalType: X.LINETYPE.PAR_END }),
                    (this.$ = U[z - 1])
                  break
                case 40:
                  U[z - 1].unshift({
                    type: 'criticalStart',
                    criticalText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.CRITICAL_START,
                  }),
                    U[z - 1].push({ type: 'criticalEnd', signalType: X.LINETYPE.CRITICAL_END }),
                    (this.$ = U[z - 1])
                  break
                case 41:
                  U[z - 1].unshift({
                    type: 'breakStart',
                    breakText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.BREAK_START,
                  }),
                    U[z - 1].push({
                      type: 'breakEnd',
                      optText: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.BREAK_END,
                    }),
                    (this.$ = U[z - 1])
                  break
                case 43:
                  this.$ = U[z - 3].concat([
                    { type: 'option', optionText: X.parseMessage(U[z - 1]), signalType: X.LINETYPE.CRITICAL_OPTION },
                    U[z],
                  ])
                  break
                case 45:
                  this.$ = U[z - 3].concat([
                    { type: 'and', parText: X.parseMessage(U[z - 1]), signalType: X.LINETYPE.PAR_AND },
                    U[z],
                  ])
                  break
                case 47:
                  this.$ = U[z - 3].concat([
                    { type: 'else', altText: X.parseMessage(U[z - 1]), signalType: X.LINETYPE.ALT_ELSE },
                    U[z],
                  ])
                  break
                case 48:
                  ;(U[z - 3].draw = 'participant'),
                    (U[z - 3].type = 'addParticipant'),
                    (U[z - 3].description = X.parseMessage(U[z - 1])),
                    (this.$ = U[z - 3])
                  break
                case 49:
                  ;(U[z - 1].draw = 'participant'), (U[z - 1].type = 'addParticipant'), (this.$ = U[z - 1])
                  break
                case 50:
                  ;(U[z - 3].draw = 'actor'),
                    (U[z - 3].type = 'addParticipant'),
                    (U[z - 3].description = X.parseMessage(U[z - 1])),
                    (this.$ = U[z - 3])
                  break
                case 51:
                  ;(U[z - 1].draw = 'actor'), (U[z - 1].type = 'addParticipant'), (this.$ = U[z - 1])
                  break
                case 52:
                  ;(U[z - 1].type = 'destroyParticipant'), (this.$ = U[z - 1])
                  break
                case 53:
                  ;(U[z - 1].draw = 'participant'), (U[z - 1].type = 'addParticipant'), (this.$ = U[z - 1])
                  break
                case 54:
                  this.$ = [U[z - 1], { type: 'addNote', placement: U[z - 2], actor: U[z - 1].actor, text: U[z] }]
                  break
                case 55:
                  ;(U[z - 2] = [].concat(U[z - 1], U[z - 1]).slice(0, 2)),
                    (U[z - 2][0] = U[z - 2][0].actor),
                    (U[z - 2][1] = U[z - 2][1].actor),
                    (this.$ = [
                      U[z - 1],
                      { type: 'addNote', placement: X.PLACEMENT.OVER, actor: U[z - 2].slice(0, 2), text: U[z] },
                    ])
                  break
                case 56:
                  this.$ = [U[z - 1], { type: 'addLinks', actor: U[z - 1].actor, text: U[z] }]
                  break
                case 57:
                  this.$ = [U[z - 1], { type: 'addALink', actor: U[z - 1].actor, text: U[z] }]
                  break
                case 58:
                  this.$ = [U[z - 1], { type: 'addProperties', actor: U[z - 1].actor, text: U[z] }]
                  break
                case 59:
                  this.$ = [U[z - 1], { type: 'addDetails', actor: U[z - 1].actor, text: U[z] }]
                  break
                case 62:
                  this.$ = [U[z - 2], U[z]]
                  break
                case 63:
                  this.$ = U[z]
                  break
                case 64:
                  this.$ = X.PLACEMENT.LEFTOF
                  break
                case 65:
                  this.$ = X.PLACEMENT.RIGHTOF
                  break
                case 66:
                  this.$ = [
                    U[z - 4],
                    U[z - 1],
                    {
                      type: 'addMessage',
                      from: U[z - 4].actor,
                      to: U[z - 1].actor,
                      signalType: U[z - 3],
                      msg: U[z],
                      activate: !0,
                    },
                    { type: 'activeStart', signalType: X.LINETYPE.ACTIVE_START, actor: U[z - 1].actor },
                  ]
                  break
                case 67:
                  this.$ = [
                    U[z - 4],
                    U[z - 1],
                    { type: 'addMessage', from: U[z - 4].actor, to: U[z - 1].actor, signalType: U[z - 3], msg: U[z] },
                    { type: 'activeEnd', signalType: X.LINETYPE.ACTIVE_END, actor: U[z - 4].actor },
                  ]
                  break
                case 68:
                  this.$ = [
                    U[z - 3],
                    U[z - 1],
                    { type: 'addMessage', from: U[z - 3].actor, to: U[z - 1].actor, signalType: U[z - 2], msg: U[z] },
                  ]
                  break
                case 69:
                  this.$ = { type: 'addParticipant', actor: U[z - 1], config: U[z] }
                  break
                case 70:
                  this.$ = U[z - 1].trim()
                  break
                case 71:
                  this.$ = { type: 'addParticipant', actor: U[z] }
                  break
                case 72:
                  this.$ = X.LINETYPE.SOLID_OPEN
                  break
                case 73:
                  this.$ = X.LINETYPE.DOTTED_OPEN
                  break
                case 74:
                  this.$ = X.LINETYPE.SOLID
                  break
                case 75:
                  this.$ = X.LINETYPE.BIDIRECTIONAL_SOLID
                  break
                case 76:
                  this.$ = X.LINETYPE.DOTTED
                  break
                case 77:
                  this.$ = X.LINETYPE.BIDIRECTIONAL_DOTTED
                  break
                case 78:
                  this.$ = X.LINETYPE.SOLID_CROSS
                  break
                case 79:
                  this.$ = X.LINETYPE.DOTTED_CROSS
                  break
                case 80:
                  this.$ = X.LINETYPE.SOLID_POINT
                  break
                case 81:
                  this.$ = X.LINETYPE.DOTTED_POINT
                  break
                case 82:
                  this.$ = X.parseMessage(U[z].trim().substring(1))
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: t, 5: r, 6: n },
              { 1: [3] },
              { 3: 5, 4: t, 5: r, 6: n },
              { 3: 6, 4: t, 5: r, 6: n },
              e(
                [
                  1, 4, 5, 13, 14, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60,
                  61, 62, 63, 71,
                ],
                i,
                { 7: 7 },
              ),
              { 1: [2, 1] },
              { 1: [2, 2] },
              {
                1: [2, 3],
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              e(I, [2, 5]),
              {
                9: 47,
                12: 12,
                13: l,
                14: u,
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              e(I, [2, 7]),
              e(I, [2, 8]),
              e(I, [2, 14]),
              { 12: 48, 50: R, 52: F, 53: S },
              { 15: [1, 49] },
              { 5: [1, 50] },
              { 5: [1, 53], 19: [1, 51], 20: [1, 52] },
              { 22: 54, 71: P },
              { 22: 55, 71: P },
              { 5: [1, 56] },
              { 5: [1, 57] },
              { 5: [1, 58] },
              { 5: [1, 59] },
              { 5: [1, 60] },
              e(I, [2, 29]),
              e(I, [2, 30]),
              { 32: [1, 61] },
              { 34: [1, 62] },
              e(I, [2, 33]),
              { 15: [1, 63] },
              { 15: [1, 64] },
              { 15: [1, 65] },
              { 15: [1, 66] },
              { 15: [1, 67] },
              { 15: [1, 68] },
              { 15: [1, 69] },
              { 15: [1, 70] },
              { 22: 71, 54: 72, 71: [1, 73] },
              { 22: 74, 71: P },
              { 22: 75, 71: P },
              {
                68: 76,
                76: [1, 77],
                77: [1, 78],
                78: [1, 79],
                79: [1, 80],
                80: [1, 81],
                81: [1, 82],
                82: [1, 83],
                83: [1, 84],
                84: [1, 85],
                85: [1, 86],
              },
              { 56: 87, 58: [1, 88], 66: [1, 89], 67: [1, 90] },
              { 22: 91, 71: P },
              { 22: 92, 71: P },
              { 22: 93, 71: P },
              { 22: 94, 71: P },
              e([5, 51, 65, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], M),
              e(I, [2, 6]),
              e(I, [2, 15]),
              e(V, [2, 9], { 10: 95 }),
              e(I, [2, 17]),
              { 5: [1, 97], 19: [1, 96] },
              { 5: [1, 98] },
              e(I, [2, 21]),
              { 5: [1, 99] },
              { 5: [1, 100] },
              e(I, [2, 24]),
              e(I, [2, 25]),
              e(I, [2, 26]),
              e(I, [2, 27]),
              e(I, [2, 28]),
              e(I, [2, 31]),
              e(I, [2, 32]),
              e($, i, { 7: 101 }),
              e($, i, { 7: 102 }),
              e($, i, { 7: 103 }),
              e(q, i, { 40: 104, 7: 105 }),
              e(tt, i, { 42: 106, 7: 107 }),
              e(tt, i, { 7: 107, 42: 108 }),
              e(ft, i, { 45: 109, 7: 110 }),
              e($, i, { 7: 111 }),
              { 5: [1, 113], 51: [1, 112] },
              { 5: [1, 114] },
              e([5, 51], M, { 72: 115, 73: [1, 116] }),
              { 5: [1, 118], 51: [1, 117] },
              { 5: [1, 119] },
              { 22: 122, 69: [1, 120], 70: [1, 121], 71: P },
              e(H, [2, 72]),
              e(H, [2, 73]),
              e(H, [2, 74]),
              e(H, [2, 75]),
              e(H, [2, 76]),
              e(H, [2, 77]),
              e(H, [2, 78]),
              e(H, [2, 79]),
              e(H, [2, 80]),
              e(H, [2, 81]),
              { 22: 123, 71: P },
              { 22: 125, 59: 124, 71: P },
              { 71: [2, 64] },
              { 71: [2, 65] },
              { 57: 126, 86: kt },
              { 57: 128, 86: kt },
              { 57: 129, 86: kt },
              { 57: 130, 86: kt },
              { 4: [1, 133], 5: [1, 135], 11: 132, 12: 134, 16: [1, 131], 50: R, 52: F, 53: S },
              { 5: [1, 136] },
              e(I, [2, 19]),
              e(I, [2, 20]),
              e(I, [2, 22]),
              e(I, [2, 23]),
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 137],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 138],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 139],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              { 16: [1, 140] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 46],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                49: [1, 141],
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              { 16: [1, 142] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 44],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                48: [1, 143],
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              { 16: [1, 144] },
              { 16: [1, 145] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 42],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                47: [1, 146],
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 147],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: A,
                41: w,
                43: D,
                44: G,
                46: v,
                50: R,
                52: F,
                53: S,
                55: O,
                60: E,
                61: _,
                62: L,
                63: N,
                71: P,
              },
              { 15: [1, 148] },
              e(I, [2, 49]),
              e(I, [2, 53]),
              { 5: [2, 69] },
              { 74: [1, 149] },
              { 15: [1, 150] },
              e(I, [2, 51]),
              e(I, [2, 52]),
              { 22: 151, 71: P },
              { 22: 152, 71: P },
              { 57: 153, 86: kt },
              { 57: 154, 86: kt },
              { 57: 155, 86: kt },
              { 65: [1, 156], 86: [2, 63] },
              { 5: [2, 56] },
              { 5: [2, 82] },
              { 5: [2, 57] },
              { 5: [2, 58] },
              { 5: [2, 59] },
              e(I, [2, 16]),
              e(V, [2, 10]),
              { 12: 157, 50: R, 52: F, 53: S },
              e(V, [2, 12]),
              e(V, [2, 13]),
              e(I, [2, 18]),
              e(I, [2, 34]),
              e(I, [2, 35]),
              e(I, [2, 36]),
              e(I, [2, 37]),
              { 15: [1, 158] },
              e(I, [2, 38]),
              { 15: [1, 159] },
              e(I, [2, 39]),
              e(I, [2, 40]),
              { 15: [1, 160] },
              e(I, [2, 41]),
              { 5: [1, 161] },
              { 75: [1, 162] },
              { 5: [1, 163] },
              { 57: 164, 86: kt },
              { 57: 165, 86: kt },
              { 5: [2, 68] },
              { 5: [2, 54] },
              { 5: [2, 55] },
              { 22: 166, 71: P },
              e(V, [2, 11]),
              e(q, i, { 7: 105, 40: 167 }),
              e(tt, i, { 7: 107, 42: 168 }),
              e(ft, i, { 7: 110, 45: 169 }),
              e(I, [2, 48]),
              { 5: [2, 70] },
              e(I, [2, 50]),
              { 5: [2, 66] },
              { 5: [2, 67] },
              { 86: [2, 62] },
              { 16: [2, 47] },
              { 16: [2, 45] },
              { 16: [2, 43] },
            ],
            defaultActions: {
              5: [2, 1],
              6: [2, 2],
              89: [2, 64],
              90: [2, 65],
              115: [2, 69],
              126: [2, 56],
              127: [2, 82],
              128: [2, 57],
              129: [2, 58],
              130: [2, 59],
              153: [2, 68],
              154: [2, 54],
              155: [2, 55],
              162: [2, 70],
              164: [2, 66],
              165: [2, 67],
              166: [2, 62],
              167: [2, 47],
              168: [2, 45],
              169: [2, 43],
            },
            parseError: a(function (it, Q) {
              if (Q.recoverable) this.trace(it)
              else {
                var et = new Error(it)
                throw ((et.hash = Q), et)
              }
            }, 'parseError'),
            parse: a(function (it) {
              var Q = this,
                et = [0],
                X = [],
                st = [null],
                U = [],
                gt = this.table,
                z = '',
                ge = 0,
                lt = 0,
                jt = 0,
                Me = 2,
                se = 1,
                Nt = U.slice.call(arguments, 1),
                At = Object.create(this.lexer),
                bt = { yy: {} }
              for (var ct in this.yy) Object.prototype.hasOwnProperty.call(this.yy, ct) && (bt.yy[ct] = this.yy[ct])
              At.setInput(it, bt.yy),
                (bt.yy.lexer = At),
                (bt.yy.parser = this),
                typeof At.yylloc > 'u' && (At.yylloc = {})
              var Lt = At.yylloc
              U.push(Lt)
              var Z = At.options && At.options.ranges
              typeof bt.yy.parseError == 'function'
                ? (this.parseError = bt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function Mt(Ae) {
                ;(et.length = et.length - 2 * Ae), (st.length = st.length - Ae), (U.length = U.length - Ae)
              }
              a(Mt, 'popStack')
              function W() {
                var Ae
                return (
                  (Ae = X.pop() || At.lex() || se),
                  typeof Ae != 'number' &&
                    (Ae instanceof Array && ((X = Ae), (Ae = X.pop())), (Ae = Q.symbols_[Ae] || Ae)),
                  Ae
                )
              }
              a(W, 'lex')
              for (var Gt, j, vt, mt, Xt, Ft, _t = {}, Qe, It, xr, Ze; ; ) {
                if (
                  ((vt = et[et.length - 1]),
                  this.defaultActions[vt]
                    ? (mt = this.defaultActions[vt])
                    : ((Gt === null || typeof Gt > 'u') && (Gt = W()), (mt = gt[vt] && gt[vt][Gt])),
                  typeof mt > 'u' || !mt.length || !mt[0])
                ) {
                  var yn = ''
                  Ze = []
                  for (Qe in gt[vt]) this.terminals_[Qe] && Qe > Me && Ze.push("'" + this.terminals_[Qe] + "'")
                  At.showPosition
                    ? (yn =
                        'Parse error on line ' +
                        (ge + 1) +
                        `:
` +
                        At.showPosition() +
                        `
Expecting ` +
                        Ze.join(', ') +
                        ", got '" +
                        (this.terminals_[Gt] || Gt) +
                        "'")
                    : (yn =
                        'Parse error on line ' +
                        (ge + 1) +
                        ': Unexpected ' +
                        (Gt == se ? 'end of input' : "'" + (this.terminals_[Gt] || Gt) + "'")),
                    this.parseError(yn, {
                      text: At.match,
                      token: this.terminals_[Gt] || Gt,
                      line: At.yylineno,
                      loc: Lt,
                      expected: Ze,
                    })
                }
                if (mt[0] instanceof Array && mt.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + vt + ', token: ' + Gt)
                switch (mt[0]) {
                  case 1:
                    et.push(Gt),
                      st.push(At.yytext),
                      U.push(At.yylloc),
                      et.push(mt[1]),
                      (Gt = null),
                      j
                        ? ((Gt = j), (j = null))
                        : ((lt = At.yyleng), (z = At.yytext), (ge = At.yylineno), (Lt = At.yylloc), jt > 0 && jt--)
                    break
                  case 2:
                    if (
                      ((It = this.productions_[mt[1]][1]),
                      (_t.$ = st[st.length - It]),
                      (_t._$ = {
                        first_line: U[U.length - (It || 1)].first_line,
                        last_line: U[U.length - 1].last_line,
                        first_column: U[U.length - (It || 1)].first_column,
                        last_column: U[U.length - 1].last_column,
                      }),
                      Z && (_t._$.range = [U[U.length - (It || 1)].range[0], U[U.length - 1].range[1]]),
                      (Ft = this.performAction.apply(_t, [z, lt, ge, bt.yy, mt[1], st, U].concat(Nt))),
                      typeof Ft < 'u')
                    )
                      return Ft
                    It && ((et = et.slice(0, -1 * It * 2)), (st = st.slice(0, -1 * It)), (U = U.slice(0, -1 * It))),
                      et.push(this.productions_[mt[1]][0]),
                      st.push(_t.$),
                      U.push(_t._$),
                      (xr = gt[et[et.length - 2]][et[et.length - 1]]),
                      et.push(xr)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          yt = (function () {
            var dt = {
              EOF: 1,
              parseError: a(function (Q, et) {
                if (this.yy.parser) this.yy.parser.parseError(Q, et)
                else throw new Error(Q)
              }, 'parseError'),
              setInput: a(function (it, Q) {
                return (
                  (this.yy = Q || this.yy || {}),
                  (this._input = it),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var it = this._input[0]
                ;(this.yytext += it), this.yyleng++, this.offset++, (this.match += it), (this.matched += it)
                var Q = it.match(/(?:\r\n?|\n).*/g)
                return (
                  Q ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  it
                )
              }, 'input'),
              unput: a(function (it) {
                var Q = it.length,
                  et = it.split(/(?:\r\n?|\n)/g)
                ;(this._input = it + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - Q)),
                  (this.offset -= Q)
                var X = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  et.length - 1 && (this.yylineno -= et.length - 1)
                var st = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: et
                      ? (et.length === X.length ? this.yylloc.first_column : 0) +
                        X[X.length - et.length].length -
                        et[0].length
                      : this.yylloc.first_column - Q,
                  }),
                  this.options.ranges && (this.yylloc.range = [st[0], st[0] + this.yyleng - Q]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (it) {
                this.unput(this.match.slice(it))
              }, 'less'),
              pastInput: a(function () {
                var it = this.matched.substr(0, this.matched.length - this.match.length)
                return (it.length > 20 ? '...' : '') + it.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var it = this.match
                return (
                  it.length < 20 && (it += this._input.substr(0, 20 - it.length)),
                  (it.substr(0, 20) + (it.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var it = this.pastInput(),
                  Q = new Array(it.length + 1).join('-')
                return (
                  it +
                  this.upcomingInput() +
                  `
` +
                  Q +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (it, Q) {
                var et, X, st
                if (
                  (this.options.backtrack_lexer &&
                    ((st = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (st.yylloc.range = this.yylloc.range.slice(0))),
                  (X = it[0].match(/(?:\r\n?|\n).*/g)),
                  X && (this.yylineno += X.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: X
                      ? X[X.length - 1].length - X[X.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + it[0].length,
                  }),
                  (this.yytext += it[0]),
                  (this.match += it[0]),
                  (this.matches = it),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(it[0].length)),
                  (this.matched += it[0]),
                  (et = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    Q,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  et)
                )
                  return et
                if (this._backtrack) {
                  for (var U in st) this[U] = st[U]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var it, Q, et, X
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var st = this._currentRules(), U = 0; U < st.length; U++)
                  if (((et = this._input.match(this.rules[st[U]])), et && (!Q || et[0].length > Q[0].length))) {
                    if (((Q = et), (X = U), this.options.backtrack_lexer)) {
                      if (((it = this.test_match(et, st[U])), it !== !1)) return it
                      if (this._backtrack) {
                        Q = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return Q
                  ? ((it = this.test_match(Q, st[X])), it !== !1 ? it : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var Q = this.next()
                return Q || this.lex()
              }, 'lex'),
              begin: a(function (Q) {
                this.conditionStack.push(Q)
              }, 'begin'),
              popState: a(function () {
                var Q = this.conditionStack.length - 1
                return Q > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (Q) {
                return (
                  (Q = this.conditionStack.length - 1 - Math.abs(Q || 0)), Q >= 0 ? this.conditionStack[Q] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (Q) {
                this.begin(Q)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (Q, et, X, st) {
                var U = st
                switch (X) {
                  case 0:
                    return 5
                  case 1:
                    break
                  case 2:
                    break
                  case 3:
                    break
                  case 4:
                    break
                  case 5:
                    break
                  case 6:
                    return 19
                  case 7:
                    return this.begin('CONFIG'), 73
                    break
                  case 8:
                    return 74
                  case 9:
                    return this.popState(), this.popState(), 75
                    break
                  case 10:
                    return (et.yytext = et.yytext.trim()), 71
                    break
                  case 11:
                    return (et.yytext = et.yytext.trim()), this.begin('ALIAS'), 71
                    break
                  case 12:
                    return this.begin('LINE'), 14
                    break
                  case 13:
                    return this.begin('ID'), 50
                    break
                  case 14:
                    return this.begin('ID'), 52
                    break
                  case 15:
                    return 13
                  case 16:
                    return this.begin('ID'), 53
                    break
                  case 17:
                    return (et.yytext = et.yytext.trim()), this.begin('ALIAS'), 71
                    break
                  case 18:
                    return this.popState(), this.popState(), this.begin('LINE'), 51
                    break
                  case 19:
                    return this.popState(), this.popState(), 5
                    break
                  case 20:
                    return this.begin('LINE'), 36
                    break
                  case 21:
                    return this.begin('LINE'), 37
                    break
                  case 22:
                    return this.begin('LINE'), 38
                    break
                  case 23:
                    return this.begin('LINE'), 39
                    break
                  case 24:
                    return this.begin('LINE'), 49
                    break
                  case 25:
                    return this.begin('LINE'), 41
                    break
                  case 26:
                    return this.begin('LINE'), 43
                    break
                  case 27:
                    return this.begin('LINE'), 48
                    break
                  case 28:
                    return this.begin('LINE'), 44
                    break
                  case 29:
                    return this.begin('LINE'), 47
                    break
                  case 30:
                    return this.begin('LINE'), 46
                    break
                  case 31:
                    return this.popState(), 15
                    break
                  case 32:
                    return 16
                  case 33:
                    return 66
                  case 34:
                    return 67
                  case 35:
                    return 60
                  case 36:
                    return 61
                  case 37:
                    return 62
                  case 38:
                    return 63
                  case 39:
                    return 58
                  case 40:
                    return 55
                  case 41:
                    return this.begin('ID'), 21
                    break
                  case 42:
                    return this.begin('ID'), 23
                    break
                  case 43:
                    return 29
                  case 44:
                    return 30
                  case 45:
                    return this.begin('acc_title'), 31
                    break
                  case 46:
                    return this.popState(), 'acc_title_value'
                    break
                  case 47:
                    return this.begin('acc_descr'), 33
                    break
                  case 48:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 49:
                    this.begin('acc_descr_multiline')
                    break
                  case 50:
                    this.popState()
                    break
                  case 51:
                    return 'acc_descr_multiline_value'
                  case 52:
                    return 6
                  case 53:
                    return 18
                  case 54:
                    return 20
                  case 55:
                    return 65
                  case 56:
                    return 5
                  case 57:
                    return (et.yytext = et.yytext.trim()), 71
                    break
                  case 58:
                    return 78
                  case 59:
                    return 79
                  case 60:
                    return 80
                  case 61:
                    return 81
                  case 62:
                    return 76
                  case 63:
                    return 77
                  case 64:
                    return 82
                  case 65:
                    return 83
                  case 66:
                    return 84
                  case 67:
                    return 85
                  case 68:
                    return 86
                  case 69:
                    return 86
                  case 70:
                    return 69
                  case 71:
                    return 70
                  case 72:
                    return 5
                  case 73:
                    return 'INVALID'
                }
              }, 'anonymous'),
              rules: [
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:((?!\n)\s)+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[0-9]+(?=[ \n]+))/i,
                /^(?:@\{)/i,
                /^(?:[^\}]+)/i,
                /^(?:\})/i,
                /^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i,
                /^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
                /^(?:box\b)/i,
                /^(?:participant\b)/i,
                /^(?:actor\b)/i,
                /^(?:create\b)/i,
                /^(?:destroy\b)/i,
                /^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
                /^(?:as\b)/i,
                /^(?:(?:))/i,
                /^(?:loop\b)/i,
                /^(?:rect\b)/i,
                /^(?:opt\b)/i,
                /^(?:alt\b)/i,
                /^(?:else\b)/i,
                /^(?:par\b)/i,
                /^(?:par_over\b)/i,
                /^(?:and\b)/i,
                /^(?:critical\b)/i,
                /^(?:option\b)/i,
                /^(?:break\b)/i,
                /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i,
                /^(?:end\b)/i,
                /^(?:left of\b)/i,
                /^(?:right of\b)/i,
                /^(?:links\b)/i,
                /^(?:link\b)/i,
                /^(?:properties\b)/i,
                /^(?:details\b)/i,
                /^(?:over\b)/i,
                /^(?:note\b)/i,
                /^(?:activate\b)/i,
                /^(?:deactivate\b)/i,
                /^(?:title\s[^#\n;]+)/i,
                /^(?:title:\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:sequenceDiagram\b)/i,
                /^(?:autonumber\b)/i,
                /^(?:off\b)/i,
                /^(?:,)/i,
                /^(?:;)/i,
                /^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i,
                /^(?:->>)/i,
                /^(?:<<->>)/i,
                /^(?:-->>)/i,
                /^(?:<<-->>)/i,
                /^(?:->)/i,
                /^(?:-->)/i,
                /^(?:-[x])/i,
                /^(?:--[x])/i,
                /^(?:-[\)])/i,
                /^(?:--[\)])/i,
                /^(?::(?:(?:no)?wrap)?[^#\n;]*)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:-)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [50, 51], inclusive: !1 },
                acc_descr: { rules: [48], inclusive: !1 },
                acc_title: { rules: [46], inclusive: !1 },
                ID: { rules: [2, 3, 7, 10, 11, 17], inclusive: !1 },
                ALIAS: { rules: [2, 3, 18, 19], inclusive: !1 },
                LINE: { rules: [2, 3, 31], inclusive: !1 },
                CONFIG: { rules: [8, 9], inclusive: !1 },
                CONFIG_DATA: { rules: [], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 4, 5, 6, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35,
                    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73,
                  ],
                  inclusive: !0,
                },
              },
            }
            return dt
          })()
        ht.lexer = yt
        function ot() {
          this.yy = {}
        }
        return a(ot, 'Parser'), (ot.prototype = ht), (ht.Parser = ot), new ot()
      })()
      pN.parser = pN
      Ent = pN
    })
  var DRt,
    NRt,
    IRt,
    Gy,
    I_,
    mN = x(() => {
      'use strict'
      pe()
      E0()
      Vt()
      vD()
      Be()
      bn()
      ;(DRt = {
        SOLID: 0,
        DOTTED: 1,
        NOTE: 2,
        SOLID_CROSS: 3,
        DOTTED_CROSS: 4,
        SOLID_OPEN: 5,
        DOTTED_OPEN: 6,
        LOOP_START: 10,
        LOOP_END: 11,
        ALT_START: 12,
        ALT_ELSE: 13,
        ALT_END: 14,
        OPT_START: 15,
        OPT_END: 16,
        ACTIVE_START: 17,
        ACTIVE_END: 18,
        PAR_START: 19,
        PAR_AND: 20,
        PAR_END: 21,
        RECT_START: 22,
        RECT_END: 23,
        SOLID_POINT: 24,
        DOTTED_POINT: 25,
        AUTONUMBER: 26,
        CRITICAL_START: 27,
        CRITICAL_OPTION: 28,
        CRITICAL_END: 29,
        BREAK_START: 30,
        BREAK_END: 31,
        PAR_OVER_START: 32,
        BIDIRECTIONAL_SOLID: 33,
        BIDIRECTIONAL_DOTTED: 34,
      }),
        (NRt = { FILLED: 0, OPEN: 1 }),
        (IRt = { LEFTOF: 0, RIGHTOF: 1, OVER: 2 }),
        (Gy = {
          ACTOR: 'actor',
          BOUNDARY: 'boundary',
          COLLECTIONS: 'collections',
          CONTROL: 'control',
          DATABASE: 'database',
          ENTITY: 'entity',
          PARTICIPANT: 'participant',
          QUEUE: 'queue',
        }),
        (I_ = class {
          constructor() {
            this.state = new ym(() => ({
              prevActor: void 0,
              actors: new Map(),
              createdActors: new Map(),
              destroyedActors: new Map(),
              boxes: [],
              messages: [],
              notes: [],
              sequenceNumbersEnabled: !1,
              wrapEnabled: void 0,
              currentBox: void 0,
              lastCreated: void 0,
              lastDestroyed: void 0,
            }))
            this.setAccTitle = Xe
            this.setAccDescription = er
            this.setDiagramTitle = lr
            this.getAccTitle = tr
            this.getAccDescription = rr
            this.getDiagramTitle = nr
            ;(this.apply = this.apply.bind(this)),
              (this.parseBoxData = this.parseBoxData.bind(this)),
              (this.parseMessage = this.parseMessage.bind(this)),
              this.clear(),
              this.setWrap(K().wrap),
              (this.LINETYPE = DRt),
              (this.ARROWTYPE = NRt),
              (this.PLACEMENT = IRt)
          }
          static {
            a(this, 'SequenceDB')
          }
          addBox(t) {
            this.state.records.boxes.push({
              name: t.text,
              wrap: t.wrap ?? this.autoWrap(),
              fill: t.color,
              actorKeys: [],
            }),
              (this.state.records.currentBox = this.state.records.boxes.slice(-1)[0])
          }
          addActor(t, r, n, i, s) {
            let o = this.state.records.currentBox,
              l
            if (s !== void 0) {
              let h
              s.includes(`
`)
                ? (h =
                    s +
                    `
`)
                : (h =
                    `{
` +
                    s +
                    `
}`),
                (l = Cc(h, { schema: _c }))
            }
            i = l?.type ?? i
            let u = this.state.records.actors.get(t)
            if (u) {
              if (this.state.records.currentBox && u.box && this.state.records.currentBox !== u.box)
                throw new Error(
                  `A same participant should only be defined in one Box: ${u.name} can't be in '${u.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`,
                )
              if (((o = u.box ? u.box : this.state.records.currentBox), (u.box = o), u && r === u.name && n == null))
                return
            }
            if (
              (n?.text == null && (n = { text: r, type: i }),
              (i == null || n.text == null) && (n = { text: r, type: i }),
              this.state.records.actors.set(t, {
                box: o,
                name: r,
                description: n.text,
                wrap: n.wrap ?? this.autoWrap(),
                prevActor: this.state.records.prevActor,
                links: {},
                properties: {},
                actorCnt: null,
                rectData: null,
                type: i ?? 'participant',
              }),
              this.state.records.prevActor)
            ) {
              let h = this.state.records.actors.get(this.state.records.prevActor)
              h && (h.nextActor = t)
            }
            this.state.records.currentBox && this.state.records.currentBox.actorKeys.push(t),
              (this.state.records.prevActor = t)
          }
          activationCount(t) {
            let r,
              n = 0
            if (!t) return 0
            for (r = 0; r < this.state.records.messages.length; r++)
              this.state.records.messages[r].type === this.LINETYPE.ACTIVE_START &&
                this.state.records.messages[r].from === t &&
                n++,
                this.state.records.messages[r].type === this.LINETYPE.ACTIVE_END &&
                  this.state.records.messages[r].from === t &&
                  n--
            return n
          }
          addMessage(t, r, n, i) {
            this.state.records.messages.push({
              id: this.state.records.messages.length.toString(),
              from: t,
              to: r,
              message: n.text,
              wrap: n.wrap ?? this.autoWrap(),
              answer: i,
            })
          }
          addSignal(t, r, n, i, s = !1) {
            if (i === this.LINETYPE.ACTIVE_END && this.activationCount(t ?? '') < 1) {
              let l = new Error('Trying to inactivate an inactive participant (' + t + ')')
              throw (
                ((l.hash = {
                  text: '->>-',
                  token: '->>-',
                  line: '1',
                  loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
                  expected: ["'ACTIVE_PARTICIPANT'"],
                }),
                l)
              )
            }
            return (
              this.state.records.messages.push({
                id: this.state.records.messages.length.toString(),
                from: t,
                to: r,
                message: n?.text ?? '',
                wrap: n?.wrap ?? this.autoWrap(),
                type: i,
                activate: s,
              }),
              !0
            )
          }
          hasAtLeastOneBox() {
            return this.state.records.boxes.length > 0
          }
          hasAtLeastOneBoxWithTitle() {
            return this.state.records.boxes.some((t) => t.name)
          }
          getMessages() {
            return this.state.records.messages
          }
          getBoxes() {
            return this.state.records.boxes
          }
          getActors() {
            return this.state.records.actors
          }
          getCreatedActors() {
            return this.state.records.createdActors
          }
          getDestroyedActors() {
            return this.state.records.destroyedActors
          }
          getActor(t) {
            return this.state.records.actors.get(t)
          }
          getActorKeys() {
            return [...this.state.records.actors.keys()]
          }
          enableSequenceNumbers() {
            this.state.records.sequenceNumbersEnabled = !0
          }
          disableSequenceNumbers() {
            this.state.records.sequenceNumbersEnabled = !1
          }
          showSequenceNumbers() {
            return this.state.records.sequenceNumbersEnabled
          }
          setWrap(t) {
            this.state.records.wrapEnabled = t
          }
          extractWrap(t) {
            if (t === void 0) return {}
            t = t.trim()
            let r = /^:?wrap:/.exec(t) !== null ? !0 : /^:?nowrap:/.exec(t) !== null ? !1 : void 0
            return { cleanedText: (r === void 0 ? t : t.replace(/^:?(?:no)?wrap:/, '')).trim(), wrap: r }
          }
          autoWrap() {
            return this.state.records.wrapEnabled !== void 0
              ? this.state.records.wrapEnabled
              : (K().sequence?.wrap ?? !1)
          }
          clear() {
            this.state.reset(), Ye()
          }
          parseMessage(t) {
            let r = t.trim(),
              { wrap: n, cleanedText: i } = this.extractWrap(r),
              s = { text: i, wrap: n }
            return B.debug(`parseMessage: ${JSON.stringify(s)}`), s
          }
          parseBoxData(t) {
            let r = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(t),
              n = r?.[1] ? r[1].trim() : 'transparent',
              i = r?.[2] ? r[2].trim() : void 0
            if (window?.CSS) window.CSS.supports('color', n) || ((n = 'transparent'), (i = t.trim()))
            else {
              let l = new Option().style
              ;(l.color = n), l.color !== n && ((n = 'transparent'), (i = t.trim()))
            }
            let { wrap: s, cleanedText: o } = this.extractWrap(i)
            return { text: o ? Ie(o, K()) : void 0, color: n, wrap: s }
          }
          addNote(t, r, n) {
            let i = { actor: t, placement: r, message: n.text, wrap: n.wrap ?? this.autoWrap() },
              s = [].concat(t, t)
            this.state.records.notes.push(i),
              this.state.records.messages.push({
                id: this.state.records.messages.length.toString(),
                from: s[0],
                to: s[1],
                message: n.text,
                wrap: n.wrap ?? this.autoWrap(),
                type: this.LINETYPE.NOTE,
                placement: r,
              })
          }
          addLinks(t, r) {
            let n = this.getActor(t)
            try {
              let i = Ie(r.text, K())
              ;(i = i.replace(/&equals;/g, '=')), (i = i.replace(/&amp;/g, '&'))
              let s = JSON.parse(i)
              this.insertLinks(n, s)
            } catch (i) {
              B.error('error while parsing actor link text', i)
            }
          }
          addALink(t, r) {
            let n = this.getActor(t)
            try {
              let i = {},
                s = Ie(r.text, K()),
                o = s.indexOf('@')
              ;(s = s.replace(/&equals;/g, '=')), (s = s.replace(/&amp;/g, '&'))
              let l = s.slice(0, o - 1).trim(),
                u = s.slice(o + 1).trim()
              ;(i[l] = u), this.insertLinks(n, i)
            } catch (i) {
              B.error('error while parsing actor link text', i)
            }
          }
          insertLinks(t, r) {
            if (t.links == null) t.links = r
            else for (let n in r) t.links[n] = r[n]
          }
          addProperties(t, r) {
            let n = this.getActor(t)
            try {
              let i = Ie(r.text, K()),
                s = JSON.parse(i)
              this.insertProperties(n, s)
            } catch (i) {
              B.error('error while parsing actor properties text', i)
            }
          }
          insertProperties(t, r) {
            if (t.properties == null) t.properties = r
            else for (let n in r) t.properties[n] = r[n]
          }
          boxEnd() {
            this.state.records.currentBox = void 0
          }
          addDetails(t, r) {
            let n = this.getActor(t),
              i = document.getElementById(r.text)
            try {
              let s = i.innerHTML,
                o = JSON.parse(s)
              o.properties && this.insertProperties(n, o.properties), o.links && this.insertLinks(n, o.links)
            } catch (s) {
              B.error('error while parsing actor details text', s)
            }
          }
          getActorProperty(t, r) {
            if (t?.properties !== void 0) return t.properties[r]
          }
          apply(t) {
            if (Array.isArray(t))
              t.forEach((r) => {
                this.apply(r)
              })
            else
              switch (t.type) {
                case 'sequenceIndex':
                  this.state.records.messages.push({
                    id: this.state.records.messages.length.toString(),
                    from: void 0,
                    to: void 0,
                    message: { start: t.sequenceIndex, step: t.sequenceIndexStep, visible: t.sequenceVisible },
                    wrap: !1,
                    type: t.signalType,
                  })
                  break
                case 'addParticipant':
                  this.addActor(t.actor, t.actor, t.description, t.draw, t.config)
                  break
                case 'createParticipant':
                  if (this.state.records.actors.has(t.actor))
                    throw new Error(
                      "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior",
                    )
                  ;(this.state.records.lastCreated = t.actor),
                    this.addActor(t.actor, t.actor, t.description, t.draw, t.config),
                    this.state.records.createdActors.set(t.actor, this.state.records.messages.length)
                  break
                case 'destroyParticipant':
                  ;(this.state.records.lastDestroyed = t.actor),
                    this.state.records.destroyedActors.set(t.actor, this.state.records.messages.length)
                  break
                case 'activeStart':
                  this.addSignal(t.actor, void 0, void 0, t.signalType)
                  break
                case 'activeEnd':
                  this.addSignal(t.actor, void 0, void 0, t.signalType)
                  break
                case 'addNote':
                  this.addNote(t.actor, t.placement, t.text)
                  break
                case 'addLinks':
                  this.addLinks(t.actor, t.text)
                  break
                case 'addALink':
                  this.addALink(t.actor, t.text)
                  break
                case 'addProperties':
                  this.addProperties(t.actor, t.text)
                  break
                case 'addDetails':
                  this.addDetails(t.actor, t.text)
                  break
                case 'addMessage':
                  if (this.state.records.lastCreated) {
                    if (t.to !== this.state.records.lastCreated)
                      throw new Error(
                        'The created participant ' +
                          this.state.records.lastCreated.name +
                          ' does not have an associated creating message after its declaration. Please check the sequence diagram.',
                      )
                    this.state.records.lastCreated = void 0
                  } else if (this.state.records.lastDestroyed) {
                    if (t.to !== this.state.records.lastDestroyed && t.from !== this.state.records.lastDestroyed)
                      throw new Error(
                        'The destroyed participant ' +
                          this.state.records.lastDestroyed.name +
                          ' does not have an associated destroying message after its declaration. Please check the sequence diagram.',
                      )
                    this.state.records.lastDestroyed = void 0
                  }
                  this.addSignal(t.from, t.to, t.msg, t.signalType, t.activate)
                  break
                case 'boxStart':
                  this.addBox(t.boxData)
                  break
                case 'boxEnd':
                  this.boxEnd()
                  break
                case 'loopStart':
                  this.addSignal(void 0, void 0, t.loopText, t.signalType)
                  break
                case 'loopEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'rectStart':
                  this.addSignal(void 0, void 0, t.color, t.signalType)
                  break
                case 'rectEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'optStart':
                  this.addSignal(void 0, void 0, t.optText, t.signalType)
                  break
                case 'optEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'altStart':
                  this.addSignal(void 0, void 0, t.altText, t.signalType)
                  break
                case 'else':
                  this.addSignal(void 0, void 0, t.altText, t.signalType)
                  break
                case 'altEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'setAccTitle':
                  Xe(t.text)
                  break
                case 'parStart':
                  this.addSignal(void 0, void 0, t.parText, t.signalType)
                  break
                case 'and':
                  this.addSignal(void 0, void 0, t.parText, t.signalType)
                  break
                case 'parEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'criticalStart':
                  this.addSignal(void 0, void 0, t.criticalText, t.signalType)
                  break
                case 'option':
                  this.addSignal(void 0, void 0, t.optionText, t.signalType)
                  break
                case 'criticalEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
                case 'breakStart':
                  this.addSignal(void 0, void 0, t.breakText, t.signalType)
                  break
                case 'breakEnd':
                  this.addSignal(void 0, void 0, void 0, t.signalType)
                  break
              }
          }
          getConfig() {
            return K().sequence
          }
        })
    })
  var MRt,
    Ant,
    Lnt = x(() => {
      'use strict'
      ;(MRt = a(
        (e) => `.actor {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }

  text.actor > tspan {
    fill: ${e.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${e.actorLineColor};
  }

  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${e.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${e.signalColor};
  }

  #arrowhead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .sequenceNumber {
    fill: ${e.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${e.signalColor};
  }

  #crosshead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .messageText {
    fill: ${e.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${e.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${e.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${e.noteBorderColor};
    fill: ${e.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${e.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation1 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation2 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${e.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
    stroke-width: 2px;
  }

`,
        'getStyles',
      )),
        (Ant = MRt)
    })
  var gN,
    Jc,
    eu,
    ru,
    M_,
    tu,
    Vy,
    ORt,
    O_,
    zy,
    Kh,
    Rnt,
    Ke,
    yN,
    PRt,
    BRt,
    FRt,
    $Rt,
    GRt,
    VRt,
    zRt,
    WRt,
    URt,
    jRt,
    qRt,
    HRt,
    YRt,
    Dnt,
    XRt,
    KRt,
    QRt,
    ZRt,
    JRt,
    tDt,
    eDt,
    Nnt,
    rDt,
    $l,
    nDt,
    gn,
    Int = x(() => {
      'use strict'
      gN = Ss(Vf(), 1)
      fn()
      Ce()
      Be()
      a0()
      ;(Jc = 36),
        (eu = 'actor-top'),
        (ru = 'actor-bottom'),
        (M_ = 'actor-box'),
        (tu = 'actor-man'),
        (Vy = a(function (e, t) {
          return Vu(e, t)
        }, 'drawRect')),
        (ORt = a(function (e, t, r, n, i) {
          if (t.links === void 0 || t.links === null || Object.keys(t.links).length === 0)
            return { height: 0, width: 0 }
          let s = t.links,
            o = t.actorCnt,
            l = t.rectData
          var u = 'none'
          i && (u = 'block !important')
          let h = e.append('g')
          h.attr('id', 'actor' + o + '_popup'), h.attr('class', 'actorPopupMenu'), h.attr('display', u)
          var f = ''
          l.class !== void 0 && (f = ' ' + l.class)
          let d = l.width > r ? l.width : r,
            p = h.append('rect')
          if (
            (p.attr('class', 'actorPopupMenuPanel' + f),
            p.attr('x', l.x),
            p.attr('y', l.height),
            p.attr('fill', l.fill),
            p.attr('stroke', l.stroke),
            p.attr('width', d),
            p.attr('height', l.height),
            p.attr('rx', l.rx),
            p.attr('ry', l.ry),
            s != null)
          ) {
            var m = 20
            for (let b in s) {
              var g = h.append('a'),
                y = (0, gN.sanitizeUrl)(s[b])
              g.attr('xlink:href', y),
                g.attr('target', '_blank'),
                nDt(n)(b, g, l.x + 10, l.height + m, d, 20, { class: 'actor' }, n),
                (m += 30)
            }
          }
          return p.attr('height', m), { height: l.height + m, width: d }
        }, 'drawPopup')),
        (O_ = a(function (e) {
          return (
            "var pu = document.getElementById('" +
            e +
            "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }"
          )
        }, 'popupMenuToggle')),
        (zy = a(async function (e, t, r = null) {
          let n = e.append('foreignObject'),
            i = await Xl(t.text, Te()),
            o = n
              .append('xhtml:div')
              .attr('style', 'width: fit-content;')
              .attr('xmlns', 'http://www.w3.org/1999/xhtml')
              .html(i)
              .node()
              .getBoundingClientRect()
          if ((n.attr('height', Math.round(o.height)).attr('width', Math.round(o.width)), t.class === 'noteText')) {
            let l = e.node().firstChild
            l.setAttribute('height', o.height + 2 * t.textMargin)
            let u = l.getBBox()
            n.attr('x', Math.round(u.x + u.width / 2 - o.width / 2)).attr(
              'y',
              Math.round(u.y + u.height / 2 - o.height / 2),
            )
          } else if (r) {
            let { startx: l, stopx: u, starty: h } = r
            if (l > u) {
              let f = l
              ;(l = u), (u = f)
            }
            n.attr('x', Math.round(l + Math.abs(l - u) / 2 - o.width / 2)),
              t.class === 'loopText' ? n.attr('y', Math.round(h)) : n.attr('y', Math.round(h - o.height))
          }
          return [n]
        }, 'drawKatex')),
        (Kh = a(function (e, t) {
          let r = 0,
            n = 0,
            i = t.text.split(Rt.lineBreakRegex),
            [s, o] = yo(t.fontSize),
            l = [],
            u = 0,
            h = a(() => t.y, 'yfunc')
          if (t.valign !== void 0 && t.textMargin !== void 0 && t.textMargin > 0)
            switch (t.valign) {
              case 'top':
              case 'start':
                h = a(() => Math.round(t.y + t.textMargin), 'yfunc')
                break
              case 'middle':
              case 'center':
                h = a(() => Math.round(t.y + (r + n + t.textMargin) / 2), 'yfunc')
                break
              case 'bottom':
              case 'end':
                h = a(() => Math.round(t.y + (r + n + 2 * t.textMargin) - t.textMargin), 'yfunc')
                break
            }
          if (t.anchor !== void 0 && t.textMargin !== void 0 && t.width !== void 0)
            switch (t.anchor) {
              case 'left':
              case 'start':
                ;(t.x = Math.round(t.x + t.textMargin)),
                  (t.anchor = 'start'),
                  (t.dominantBaseline = 'middle'),
                  (t.alignmentBaseline = 'middle')
                break
              case 'middle':
              case 'center':
                ;(t.x = Math.round(t.x + t.width / 2)),
                  (t.anchor = 'middle'),
                  (t.dominantBaseline = 'middle'),
                  (t.alignmentBaseline = 'middle')
                break
              case 'right':
              case 'end':
                ;(t.x = Math.round(t.x + t.width - t.textMargin)),
                  (t.anchor = 'end'),
                  (t.dominantBaseline = 'middle'),
                  (t.alignmentBaseline = 'middle')
                break
            }
          for (let [f, d] of i.entries()) {
            t.textMargin !== void 0 && t.textMargin === 0 && s !== void 0 && (u = f * s)
            let p = e.append('text')
            p.attr('x', t.x),
              p.attr('y', h()),
              t.anchor !== void 0 &&
                p
                  .attr('text-anchor', t.anchor)
                  .attr('dominant-baseline', t.dominantBaseline)
                  .attr('alignment-baseline', t.alignmentBaseline),
              t.fontFamily !== void 0 && p.style('font-family', t.fontFamily),
              o !== void 0 && p.style('font-size', o),
              t.fontWeight !== void 0 && p.style('font-weight', t.fontWeight),
              t.fill !== void 0 && p.attr('fill', t.fill),
              t.class !== void 0 && p.attr('class', t.class),
              t.dy !== void 0 ? p.attr('dy', t.dy) : u !== 0 && p.attr('dy', u)
            let m = d || _4
            if (t.tspan) {
              let g = p.append('tspan')
              g.attr('x', t.x), t.fill !== void 0 && g.attr('fill', t.fill), g.text(m)
            } else p.text(m)
            t.valign !== void 0 &&
              t.textMargin !== void 0 &&
              t.textMargin > 0 &&
              ((n += (p._groups || p)[0][0].getBBox().height), (r = n)),
              l.push(p)
          }
          return l
        }, 'drawText')),
        (Rnt = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              (s + l - u) +
              ' ' +
              (i + o - u * 1.2) +
              ',' +
              (s + l) +
              ' ' +
              i +
              ',' +
              (s + l)
            )
          }
          a(r, 'genPoints')
          let n = e.append('polygon')
          return (
            n.attr('points', r(t.x, t.y, t.width, t.height, 7)),
            n.attr('class', 'labelBox'),
            (t.y = t.y + t.height / 2),
            Kh(e, t),
            n
          )
        }, 'drawLabel')),
        (Ke = -1),
        (yN = a((e, t, r, n) => {
          e.select &&
            r.forEach((i) => {
              let s = t.get(i),
                o = e.select('#actor' + s.actorCnt)
              !n.mirrorActors && s.stopy
                ? o.attr('y2', s.stopy + s.height / 2)
                : n.mirrorActors && o.attr('y2', s.stopy)
            })
        }, 'fixLifeLineHeights')),
        (PRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append('g').lower()
          var u = l
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u.attr('onclick', O_(`actor${Ke}_popup`)).attr('cursor', 'pointer'),
            u
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (u = l.append('g')),
            (t.actorCnt = Ke),
            t.links != null && u.attr('id', 'root-' + Ke))
          let h = ri()
          var f = 'actor'
          t.properties?.class ? (f = t.properties.class) : (h.fill = '#eaeaea'),
            n ? (f += ` ${ru}`) : (f += ` ${eu}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.rx = 3),
            (h.ry = 3),
            (h.name = t.name)
          let d = Vy(u, h)
          if (((t.rectData = h), t.properties?.icon)) {
            let m = t.properties.icon.trim()
            m.charAt(0) === '@'
              ? q2(u, h.x + h.width - 20, h.y + 10, m.substr(1))
              : j2(u, h.x + h.width - 20, h.y + 10, m)
          }
          $l(r, $r(t.description))(t.description, u, h.x, h.y, h.width, h.height, { class: `actor ${M_}` }, r)
          let p = t.height
          if (d.node) {
            let m = d.node().getBBox()
            ;(t.height = m.height), (p = m.height)
          }
          return p
        }, 'drawActorTypeParticipant')),
        (BRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append('g').lower()
          var u = l
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u.attr('onclick', O_(`actor${Ke}_popup`)).attr('cursor', 'pointer'),
            u
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (u = l.append('g')),
            (t.actorCnt = Ke),
            t.links != null && u.attr('id', 'root-' + Ke))
          let h = ri()
          var f = 'actor'
          t.properties?.class ? (f = t.properties.class) : (h.fill = '#eaeaea'),
            n ? (f += ` ${ru}`) : (f += ` ${eu}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name)
          let d = 6,
            p = { ...h, x: h.x + -d, y: h.y + +d, class: 'actor' },
            m = Vy(u, h)
          if ((Vy(u, p), (t.rectData = h), t.properties?.icon)) {
            let y = t.properties.icon.trim()
            y.charAt(0) === '@'
              ? q2(u, h.x + h.width - 20, h.y + 10, y.substr(1))
              : j2(u, h.x + h.width - 20, h.y + 10, y)
          }
          $l(r, $r(t.description))(t.description, u, h.x - d, h.y + d, h.width, h.height, { class: `actor ${M_}` }, r)
          let g = t.height
          if (m.node) {
            let y = m.node().getBBox()
            ;(t.height = y.height), (g = y.height)
          }
          return g
        }, 'drawActorTypeCollections')),
        (FRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append('g').lower(),
            u = l
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u.attr('onclick', O_(`actor${Ke}_popup`)).attr('cursor', 'pointer'),
            u
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (u = l.append('g')),
            (t.actorCnt = Ke),
            t.links != null && u.attr('id', 'root-' + Ke))
          let h = ri(),
            f = 'actor'
          t.properties?.class ? (f = t.properties.class) : (h.fill = '#eaeaea'),
            n ? (f += ` ${ru}`) : (f += ` ${eu}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name)
          let d = h.height / 2,
            p = d / (2.5 + h.height / 50),
            m = u.append('g'),
            g = u.append('g')
          if (
            (m
              .append('path')
              .attr(
                'd',
                `M ${h.x},${h.y + d}
    a ${p},${d} 0 0 0 0,${h.height}
    h ${h.width - 2 * p}
    a ${p},${d} 0 0 0 0,-${h.height}
    Z
  `,
              )
              .attr('class', f),
            g
              .append('path')
              .attr(
                'd',
                `M ${h.x},${h.y + d}
      a ${p},${d} 0 0 0 0,${h.height}`,
              )
              .attr('stroke', '#666')
              .attr('stroke-width', '1px')
              .attr('class', f),
            m.attr('transform', `translate(${p}, ${-(h.height / 2)})`),
            g.attr('transform', `translate(${h.width - p}, ${-h.height / 2})`),
            (t.rectData = h),
            t.properties?.icon)
          ) {
            let k = t.properties.icon.trim(),
              T = h.x + h.width - 20,
              C = h.y + 10
            k.charAt(0) === '@' ? q2(u, T, C, k.substr(1)) : j2(u, T, C, k)
          }
          $l(r, $r(t.description))(t.description, u, h.x, h.y, h.width, h.height, { class: `actor ${M_}` }, r)
          let y = t.height,
            b = m.select('path:last-child')
          if (b.node()) {
            let k = b.node().getBBox()
            ;(t.height = k.height), (y = k.height)
          }
          return y
        }, 'drawActorTypeQueue')),
        ($Rt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 75,
            l = e.append('g').lower()
          n ||
            (Ke++,
            l
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (t.actorCnt = Ke))
          let u = e.append('g'),
            h = tu
          n ? (h += ` ${ru}`) : (h += ` ${eu}`), u.attr('class', h), u.attr('name', t.name)
          let f = ri()
          ;(f.x = t.x), (f.y = i), (f.fill = '#eaeaea'), (f.width = t.width), (f.height = t.height), (f.class = 'actor')
          let d = t.x + t.width / 2,
            p = i + 30,
            m = 18
          u
            .append('defs')
            .append('marker')
            .attr('id', 'filled-head-control')
            .attr('refX', 11)
            .attr('refY', 5.8)
            .attr('markerWidth', 20)
            .attr('markerHeight', 28)
            .attr('orient', '172.5')
            .append('path')
            .attr('d', 'M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z'),
            u
              .append('circle')
              .attr('cx', d)
              .attr('cy', p)
              .attr('r', m)
              .attr('fill', '#eaeaf7')
              .attr('stroke', '#666')
              .attr('stroke-width', 1.2),
            u
              .append('line')
              .attr('marker-end', 'url(#filled-head-control)')
              .attr('transform', `translate(${d}, ${p - m})`)
          let g = u.node().getBBox()
          return (
            (t.height = g.height + 2 * (r?.sequence?.labelBoxHeight ?? 0)),
            $l(r, $r(t.description))(
              t.description,
              u,
              f.x,
              f.y + m + (n ? 5 : 10),
              f.width,
              f.height,
              { class: `actor ${tu}` },
              r,
            ),
            t.height
          )
        }, 'drawActorTypeControl')),
        (GRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 75,
            l = e.append('g').lower(),
            u = e.append('g'),
            h = tu
          n ? (h += ` ${ru}`) : (h += ` ${eu}`), u.attr('class', h), u.attr('name', t.name)
          let f = ri()
          ;(f.x = t.x), (f.y = i), (f.fill = '#eaeaea'), (f.width = t.width), (f.height = t.height), (f.class = 'actor')
          let d = t.x + t.width / 2,
            p = i + (n ? 10 : 25),
            m = 18
          u.append('circle').attr('cx', d).attr('cy', p).attr('r', m).attr('width', t.width).attr('height', t.height),
            u
              .append('line')
              .attr('x1', d - m)
              .attr('x2', d + m)
              .attr('y1', p + m)
              .attr('y2', p + m)
              .attr('stroke', '#333')
              .attr('stroke-width', 2)
          let g = u.node().getBBox()
          return (
            (t.height = g.height + (r?.sequence?.labelBoxHeight ?? 0)),
            n ||
              (Ke++,
              l
                .append('line')
                .attr('id', 'actor' + Ke)
                .attr('x1', s)
                .attr('y1', o)
                .attr('x2', s)
                .attr('y2', 2e3)
                .attr('class', 'actor-line 200')
                .attr('stroke-width', '0.5px')
                .attr('stroke', '#999')
                .attr('name', t.name),
              (t.actorCnt = Ke)),
            $l(r, $r(t.description))(
              t.description,
              u,
              f.x,
              f.y + (n ? (p - i + m - 5) / 2 : (p + m - i) / 2),
              f.width,
              f.height,
              { class: `actor ${tu}` },
              r,
            ),
            n ? u.attr('transform', `translate(0, ${m / 2})`) : u.attr('transform', `translate(0, ${m / 2})`),
            t.height
          )
        }, 'drawActorTypeEntity')),
        (VRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height + 2 * r.boxTextMargin,
            l = e.append('g').lower(),
            u = l
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u.attr('onclick', O_(`actor${Ke}_popup`)).attr('cursor', 'pointer'),
            u
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (u = l.append('g')),
            (t.actorCnt = Ke),
            t.links != null && u.attr('id', 'root-' + Ke))
          let h = ri(),
            f = 'actor'
          t.properties?.class ? (f = t.properties.class) : (h.fill = '#eaeaea'),
            n ? (f += ` ${ru}`) : (f += ` ${eu}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name),
            (h.x = t.x),
            (h.y = i)
          let d = h.width / 4,
            p = h.width / 4,
            m = d / 2,
            g = m / (2.5 + d / 50),
            y = u.append('g'),
            b = `
  M ${h.x},${h.y + g}
  a ${m},${g} 0 0 0 ${d},0
  a ${m},${g} 0 0 0 -${d},0
  l 0,${p - 2 * g}
  a ${m},${g} 0 0 0 ${d},0
  l 0,-${p - 2 * g}
`
          y
            .append('path')
            .attr('d', b)
            .attr('fill', '#eaeaea')
            .attr('stroke', '#000')
            .attr('stroke-width', 1)
            .attr('class', f),
            n
              ? y.attr('transform', `translate(${d * 1.5}, ${h.height / 4 - 2 * g})`)
              : y.attr('transform', `translate(${d * 1.5}, ${(h.height + g) / 4})`),
            (t.rectData = h),
            $l(r, $r(t.description))(
              t.description,
              u,
              h.x,
              h.y + (n ? (h.height + p) / 4 : (h.height + g) / 2),
              h.width,
              h.height,
              { class: `actor ${M_}` },
              r,
            )
          let k = y.select('path:last-child')
          if (k.node()) {
            let T = k.node().getBBox()
            t.height = T.height + (r.sequence.labelBoxHeight ?? 0)
          }
          return t.height
        }, 'drawActorTypeDatabase')),
        (zRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 80,
            l = 30,
            u = e.append('g').lower()
          n ||
            (Ke++,
            u
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (t.actorCnt = Ke))
          let h = e.append('g'),
            f = tu
          n ? (f += ` ${ru}`) : (f += ` ${eu}`), h.attr('class', f), h.attr('name', t.name)
          let d = ri()
          ;(d.x = t.x),
            (d.y = i),
            (d.fill = '#eaeaea'),
            (d.width = t.width),
            (d.height = t.height),
            (d.class = 'actor'),
            h
              .append('line')
              .attr('id', 'actor-man-torso' + Ke)
              .attr('x1', t.x + t.width / 2 - l * 2.5)
              .attr('y1', i + 10)
              .attr('x2', t.x + t.width / 2 - 15)
              .attr('y2', i + 10),
            h
              .append('line')
              .attr('id', 'actor-man-arms' + Ke)
              .attr('x1', t.x + t.width / 2 - l * 2.5)
              .attr('y1', i + 0)
              .attr('x2', t.x + t.width / 2 - l * 2.5)
              .attr('y2', i + 20),
            h
              .append('circle')
              .attr('cx', t.x + t.width / 2)
              .attr('cy', i + 10)
              .attr('r', l)
          let p = h.node().getBBox()
          return (
            (t.height = p.height + (r.sequence.labelBoxHeight ?? 0)),
            $l(r, $r(t.description))(
              t.description,
              h,
              d.x,
              d.y + (n ? l / 2 - 4 : l / 2 + 3),
              d.width,
              d.height,
              { class: `actor ${tu}` },
              r,
            ),
            n ? h.attr('transform', `translate(0,${l / 2 + 7})`) : h.attr('transform', `translate(0,${l / 2 + 7})`),
            t.height
          )
        }, 'drawActorTypeBoundary')),
        (WRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 80,
            l = e.append('g').lower()
          n ||
            (Ke++,
            l
              .append('line')
              .attr('id', 'actor' + Ke)
              .attr('x1', s)
              .attr('y1', o)
              .attr('x2', s)
              .attr('y2', 2e3)
              .attr('class', 'actor-line 200')
              .attr('stroke-width', '0.5px')
              .attr('stroke', '#999')
              .attr('name', t.name),
            (t.actorCnt = Ke))
          let u = e.append('g'),
            h = tu
          n ? (h += ` ${ru}`) : (h += ` ${eu}`), u.attr('class', h), u.attr('name', t.name)
          let f = ri()
          ;(f.x = t.x),
            (f.y = i),
            (f.fill = '#eaeaea'),
            (f.width = t.width),
            (f.height = t.height),
            (f.class = 'actor'),
            (f.rx = 3),
            (f.ry = 3),
            u
              .append('line')
              .attr('id', 'actor-man-torso' + Ke)
              .attr('x1', s)
              .attr('y1', i + 25)
              .attr('x2', s)
              .attr('y2', i + 45),
            u
              .append('line')
              .attr('id', 'actor-man-arms' + Ke)
              .attr('x1', s - Jc / 2)
              .attr('y1', i + 33)
              .attr('x2', s + Jc / 2)
              .attr('y2', i + 33),
            u
              .append('line')
              .attr('x1', s - Jc / 2)
              .attr('y1', i + 60)
              .attr('x2', s)
              .attr('y2', i + 45),
            u
              .append('line')
              .attr('x1', s)
              .attr('y1', i + 45)
              .attr('x2', s + Jc / 2 - 2)
              .attr('y2', i + 60)
          let d = u.append('circle')
          d.attr('cx', t.x + t.width / 2),
            d.attr('cy', i + 10),
            d.attr('r', 15),
            d.attr('width', t.width),
            d.attr('height', t.height)
          let p = u.node().getBBox()
          return (
            (t.height = p.height),
            $l(r, $r(t.description))(t.description, u, f.x, f.y + 35, f.width, f.height, { class: `actor ${tu}` }, r),
            t.height
          )
        }, 'drawActorTypeActor')),
        (URt = a(async function (e, t, r, n) {
          switch (t.type) {
            case 'actor':
              return await WRt(e, t, r, n)
            case 'participant':
              return await PRt(e, t, r, n)
            case 'boundary':
              return await zRt(e, t, r, n)
            case 'control':
              return await $Rt(e, t, r, n)
            case 'entity':
              return await GRt(e, t, r, n)
            case 'database':
              return await VRt(e, t, r, n)
            case 'collections':
              return await BRt(e, t, r, n)
            case 'queue':
              return await FRt(e, t, r, n)
          }
        }, 'drawActor')),
        (jRt = a(function (e, t, r) {
          let i = e.append('g')
          Dnt(i, t),
            t.name &&
              $l(r)(
                t.name,
                i,
                t.x,
                t.y + r.boxTextMargin + (t.textMaxHeight || 0) / 2,
                t.width,
                0,
                { class: 'text' },
                r,
              ),
            i.lower()
        }, 'drawBox')),
        (qRt = a(function (e) {
          return e.append('g')
        }, 'anchorElement')),
        (HRt = a(function (e, t, r, n, i) {
          let s = ri(),
            o = t.anchored
          ;(s.x = t.startx),
            (s.y = t.starty),
            (s.class = 'activation' + (i % 3)),
            (s.width = t.stopx - t.startx),
            (s.height = r - t.starty),
            Vy(o, s)
        }, 'drawActivation')),
        (YRt = a(async function (e, t, r, n) {
          let {
              boxMargin: i,
              boxTextMargin: s,
              labelBoxHeight: o,
              labelBoxWidth: l,
              messageFontFamily: u,
              messageFontSize: h,
              messageFontWeight: f,
            } = n,
            d = e.append('g'),
            p = a(function (y, b, k, T) {
              return d.append('line').attr('x1', y).attr('y1', b).attr('x2', k).attr('y2', T).attr('class', 'loopLine')
            }, 'drawLoopLine')
          p(t.startx, t.starty, t.stopx, t.starty),
            p(t.stopx, t.starty, t.stopx, t.stopy),
            p(t.startx, t.stopy, t.stopx, t.stopy),
            p(t.startx, t.starty, t.startx, t.stopy),
            t.sections !== void 0 &&
              t.sections.forEach(function (y) {
                p(t.startx, y.y, t.stopx, y.y).style('stroke-dasharray', '3, 3')
              })
          let m = s0()
          ;(m.text = r),
            (m.x = t.startx),
            (m.y = t.starty),
            (m.fontFamily = u),
            (m.fontSize = h),
            (m.fontWeight = f),
            (m.anchor = 'middle'),
            (m.valign = 'middle'),
            (m.tspan = !1),
            (m.width = l || 50),
            (m.height = o || 20),
            (m.textMargin = s),
            (m.class = 'labelText'),
            Rnt(d, m),
            (m = Nnt()),
            (m.text = t.title),
            (m.x = t.startx + l / 2 + (t.stopx - t.startx) / 2),
            (m.y = t.starty + i + s),
            (m.anchor = 'middle'),
            (m.valign = 'middle'),
            (m.textMargin = s),
            (m.class = 'loopText'),
            (m.fontFamily = u),
            (m.fontSize = h),
            (m.fontWeight = f),
            (m.wrap = !0)
          let g = $r(m.text) ? await zy(d, m, t) : Kh(d, m)
          if (t.sectionTitles !== void 0) {
            for (let [y, b] of Object.entries(t.sectionTitles))
              if (b.message) {
                ;(m.text = b.message),
                  (m.x = t.startx + (t.stopx - t.startx) / 2),
                  (m.y = t.sections[y].y + i + s),
                  (m.class = 'loopText'),
                  (m.anchor = 'middle'),
                  (m.valign = 'middle'),
                  (m.tspan = !1),
                  (m.fontFamily = u),
                  (m.fontSize = h),
                  (m.fontWeight = f),
                  (m.wrap = t.wrap),
                  $r(m.text) ? ((t.starty = t.sections[y].y), await zy(d, m, t)) : Kh(d, m)
                let k = Math.round(g.map((T) => (T._groups || T)[0][0].getBBox().height).reduce((T, C) => T + C))
                t.sections[y].height += k - (i + s)
              }
          }
          return (t.height = Math.round(t.stopy - t.starty)), d
        }, 'drawLoop')),
        (Dnt = a(function (e, t) {
          U2(e, t)
        }, 'drawBackgroundRect')),
        (XRt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'database')
            .attr('fill-rule', 'evenodd')
            .attr('clip-rule', 'evenodd')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z',
            )
        }, 'insertDatabaseIcon')),
        (KRt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'computer')
            .attr('width', '24')
            .attr('height', '24')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z',
            )
        }, 'insertComputerIcon')),
        (QRt = a(function (e) {
          e.append('defs')
            .append('symbol')
            .attr('id', 'clock')
            .attr('width', '24')
            .attr('height', '24')
            .append('path')
            .attr('transform', 'scale(.5)')
            .attr(
              'd',
              'M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z',
            )
        }, 'insertClockIcon')),
        (ZRt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'arrowhead')
            .attr('refX', 7.9)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 12)
            .attr('markerHeight', 12)
            .attr('orient', 'auto-start-reverse')
            .append('path')
            .attr('d', 'M -1 0 L 10 5 L 0 10 z')
        }, 'insertArrowHead')),
        (JRt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'filled-head')
            .attr('refX', 15.5)
            .attr('refY', 7)
            .attr('markerWidth', 20)
            .attr('markerHeight', 28)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z')
        }, 'insertArrowFilledHead')),
        (tDt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'sequencenumber')
            .attr('refX', 15)
            .attr('refY', 15)
            .attr('markerWidth', 60)
            .attr('markerHeight', 40)
            .attr('orient', 'auto')
            .append('circle')
            .attr('cx', 15)
            .attr('cy', 15)
            .attr('r', 6)
        }, 'insertSequenceNumber')),
        (eDt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'crosshead')
            .attr('markerWidth', 15)
            .attr('markerHeight', 8)
            .attr('orient', 'auto')
            .attr('refX', 4)
            .attr('refY', 4.5)
            .append('path')
            .attr('fill', 'none')
            .attr('stroke', '#000000')
            .style('stroke-dasharray', '0, 0')
            .attr('stroke-width', '1pt')
            .attr('d', 'M 1,2 L 6,7 M 6,2 L 1,7')
        }, 'insertArrowCrossHead')),
        (Nnt = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            anchor: void 0,
            style: '#666',
            width: void 0,
            height: void 0,
            textMargin: 0,
            rx: 0,
            ry: 0,
            tspan: !0,
            valign: void 0,
          }
        }, 'getTextObj')),
        (rDt = a(function () {
          return { x: 0, y: 0, fill: '#EDF2AE', stroke: '#666', width: 100, anchor: 'start', height: 100, rx: 0, ry: 0 }
        }, 'getNoteRect')),
        ($l = (function () {
          function e(s, o, l, u, h, f, d) {
            let p = o
              .append('text')
              .attr('x', l + h / 2)
              .attr('y', u + f / 2 + 5)
              .style('text-anchor', 'middle')
              .text(s)
            i(p, d)
          }
          a(e, 'byText')
          function t(s, o, l, u, h, f, d, p) {
            let { actorFontSize: m, actorFontFamily: g, actorFontWeight: y } = p,
              [b, k] = yo(m),
              T = s.split(Rt.lineBreakRegex)
            for (let C = 0; C < T.length; C++) {
              let A = C * b - (b * (T.length - 1)) / 2,
                w = o
                  .append('text')
                  .attr('x', l + h / 2)
                  .attr('y', u)
                  .style('text-anchor', 'middle')
                  .style('font-size', k)
                  .style('font-weight', y)
                  .style('font-family', g)
              w
                .append('tspan')
                .attr('x', l + h / 2)
                .attr('dy', A)
                .text(T[C]),
                w
                  .attr('y', u + f / 2)
                  .attr('dominant-baseline', 'central')
                  .attr('alignment-baseline', 'central'),
                i(w, d)
            }
          }
          a(t, 'byTspan')
          function r(s, o, l, u, h, f, d, p) {
            let m = o.append('switch'),
              y = m
                .append('foreignObject')
                .attr('x', l)
                .attr('y', u)
                .attr('width', h)
                .attr('height', f)
                .append('xhtml:div')
                .style('display', 'table')
                .style('height', '100%')
                .style('width', '100%')
            y
              .append('div')
              .style('display', 'table-cell')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .text(s),
              t(s, m, l, u, h, f, d, p),
              i(y, d)
          }
          a(r, 'byFo')
          async function n(s, o, l, u, h, f, d, p) {
            let m = await xu(s, Te()),
              g = o.append('switch'),
              b = g
                .append('foreignObject')
                .attr('x', l + h / 2 - m.width / 2)
                .attr('y', u + f / 2 - m.height / 2)
                .attr('width', m.width)
                .attr('height', m.height)
                .append('xhtml:div')
                .style('height', '100%')
                .style('width', '100%')
            b
              .append('div')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .html(await Xl(s, Te())),
              t(s, g, l, u, h, f, d, p),
              i(b, d)
          }
          a(n, 'byKatex')
          function i(s, o) {
            for (let l in o) o.hasOwnProperty(l) && s.attr(l, o[l])
          }
          return (
            a(i, '_setTextAttrs'),
            function (s, o = !1) {
              return o ? n : s.textPlacement === 'fo' ? r : s.textPlacement === 'old' ? e : t
            }
          )
        })()),
        (nDt = (function () {
          function e(i, s, o, l, u, h, f) {
            let d = s.append('text').attr('x', o).attr('y', l).style('text-anchor', 'start').text(i)
            n(d, f)
          }
          a(e, 'byText')
          function t(i, s, o, l, u, h, f, d) {
            let { actorFontSize: p, actorFontFamily: m, actorFontWeight: g } = d,
              y = i.split(Rt.lineBreakRegex)
            for (let b = 0; b < y.length; b++) {
              let k = b * p - (p * (y.length - 1)) / 2,
                T = s
                  .append('text')
                  .attr('x', o)
                  .attr('y', l)
                  .style('text-anchor', 'start')
                  .style('font-size', p)
                  .style('font-weight', g)
                  .style('font-family', m)
              T.append('tspan').attr('x', o).attr('dy', k).text(y[b]),
                T.attr('y', l + h / 2)
                  .attr('dominant-baseline', 'central')
                  .attr('alignment-baseline', 'central'),
                n(T, f)
            }
          }
          a(t, 'byTspan')
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append('switch'),
              g = p
                .append('foreignObject')
                .attr('x', o)
                .attr('y', l)
                .attr('width', u)
                .attr('height', h)
                .append('xhtml:div')
                .style('display', 'table')
                .style('height', '100%')
                .style('width', '100%')
            g
              .append('div')
              .style('display', 'table-cell')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f)
          }
          a(r, 'byFo')
          function n(i, s) {
            for (let o in s) s.hasOwnProperty(o) && i.attr(o, s[o])
          }
          return (
            a(n, '_setTextAttrs'),
            function (i) {
              return i.textPlacement === 'fo' ? r : i.textPlacement === 'old' ? e : t
            }
          )
        })()),
        (gn = {
          drawRect: Vy,
          drawText: Kh,
          drawLabel: Rnt,
          drawActor: URt,
          drawBox: jRt,
          drawPopup: ORt,
          anchorElement: qRt,
          drawActivation: HRt,
          drawLoop: YRt,
          drawBackgroundRect: Dnt,
          insertArrowHead: ZRt,
          insertArrowFilledHead: JRt,
          insertSequenceNumber: tDt,
          insertArrowCrossHead: eDt,
          insertDatabaseIcon: XRt,
          insertComputerIcon: KRt,
          insertClockIcon: QRt,
          getTextObj: Nnt,
          getNoteRect: rDt,
          fixLifeLineHeights: yN,
          sanitizeUrl: gN.sanitizeUrl,
        })
    })
  async function sDt(e, t) {
    Pt.bumpVerticalPos(10)
    let { startx: r, stopx: n, message: i } = t,
      s = Rt.splitBreaks(i).length,
      o = $r(i),
      l = o ? await xu(i, K()) : le.calculateTextDimensions(i, Qh(at))
    if (!o) {
      let d = l.height / s
      ;(t.height += d), Pt.bumpVerticalPos(d)
    }
    let u,
      h = l.height - 10,
      f = l.width
    if (r === n) {
      ;(u = Pt.getVerticalPos() + h), at.rightAngles || ((h += at.boxMargin), (u = Pt.getVerticalPos() + h)), (h += 30)
      let d = Rt.getMax(f / 2, at.width / 2)
      Pt.insert(r - d, Pt.getVerticalPos() - 10 + h, n + d, Pt.getVerticalPos() + 30 + h)
    } else (h += at.boxMargin), (u = Pt.getVerticalPos() + h), Pt.insert(r, u - 10, n, u)
    return (
      Pt.bumpVerticalPos(h),
      (t.height += h),
      (t.stopy = t.starty + t.height),
      Pt.insert(t.fromBounds, t.starty, t.toBounds, t.stopy),
      u
    )
  }
  function Yo(e, t, r, n, i) {
    Pt.bumpVerticalPos(r)
    let s = n
    if (t.id && t.message && e[t.id]) {
      let o = e[t.id].width,
        l = Qh(at)
      ;(t.message = le.wrapLabel(`[${t.message}]`, o - 2 * at.wrapPadding, l)), (t.width = o), (t.wrap = !0)
      let u = le.calculateTextDimensions(t.message, l),
        h = Rt.getMax(u.height, at.labelBoxHeight)
      ;(s = n + h), B.debug(`${h} - ${t.message}`)
    }
    i(t), Pt.bumpVerticalPos(s)
  }
  function lDt(e, t, r, n, i, s, o) {
    function l(f, d) {
      f.x < i.get(e.from).x
        ? (Pt.insert(t.stopx - d, t.starty, t.startx, t.stopy + f.height / 2 + at.noteMargin), (t.stopx = t.stopx + d))
        : (Pt.insert(t.startx, t.starty, t.stopx + d, t.stopy + f.height / 2 + at.noteMargin), (t.stopx = t.stopx - d))
    }
    a(l, 'receiverAdjustment')
    function u(f, d) {
      f.x < i.get(e.to).x
        ? (Pt.insert(t.startx - d, t.starty, t.stopx, t.stopy + f.height / 2 + at.noteMargin),
          (t.startx = t.startx + d))
        : (Pt.insert(t.stopx, t.starty, t.startx + d, t.stopy + f.height / 2 + at.noteMargin),
          (t.startx = t.startx - d))
    }
    a(u, 'senderAdjustment')
    let h = [Gy.ACTOR, Gy.CONTROL, Gy.ENTITY, Gy.DATABASE]
    if (s.get(e.to) == n) {
      let f = i.get(e.to),
        d = h.includes(f.type) ? Jc / 2 + 3 : f.width / 2 + 3
      l(f, d), (f.starty = r - f.height / 2), Pt.bumpVerticalPos(f.height / 2)
    } else if (o.get(e.from) == n) {
      let f = i.get(e.from)
      if (at.mirrorActors) {
        let d = h.includes(f.type) ? Jc / 2 : f.width / 2
        u(f, d)
      }
      ;(f.stopy = r - f.height / 2), Pt.bumpVerticalPos(f.height / 2)
    } else if (o.get(e.to) == n) {
      let f = i.get(e.to)
      if (at.mirrorActors) {
        let d = h.includes(f.type) ? Jc / 2 + 3 : f.width / 2 + 3
        l(f, d)
      }
      ;(f.stopy = r - f.height / 2), Pt.bumpVerticalPos(f.height / 2)
    }
  }
  async function uDt(e, t, r) {
    let n = {}
    for (let i of t)
      if (e.get(i.to) && e.get(i.from)) {
        let s = e.get(i.to)
        if (
          (i.placement === r.db.PLACEMENT.LEFTOF && !s.prevActor) ||
          (i.placement === r.db.PLACEMENT.RIGHTOF && !s.nextActor)
        )
          continue
        let o = i.placement !== void 0,
          l = !o,
          u = o ? _m(at) : Qh(at),
          h = i.wrap ? le.wrapLabel(i.message, at.width - 2 * at.wrapPadding, u) : i.message,
          d = ($r(h) ? await xu(i.message, K()) : le.calculateTextDimensions(h, u)).width + 2 * at.wrapPadding
        l && i.from === s.nextActor
          ? (n[i.to] = Rt.getMax(n[i.to] || 0, d))
          : l && i.from === s.prevActor
            ? (n[i.from] = Rt.getMax(n[i.from] || 0, d))
            : l && i.from === i.to
              ? ((n[i.from] = Rt.getMax(n[i.from] || 0, d / 2)), (n[i.to] = Rt.getMax(n[i.to] || 0, d / 2)))
              : i.placement === r.db.PLACEMENT.RIGHTOF
                ? (n[i.from] = Rt.getMax(n[i.from] || 0, d))
                : i.placement === r.db.PLACEMENT.LEFTOF
                  ? (n[s.prevActor] = Rt.getMax(n[s.prevActor] || 0, d))
                  : i.placement === r.db.PLACEMENT.OVER &&
                    (s.prevActor && (n[s.prevActor] = Rt.getMax(n[s.prevActor] || 0, d / 2)),
                    s.nextActor && (n[i.from] = Rt.getMax(n[i.from] || 0, d / 2)))
      }
    return B.debug('maxMessageWidthPerActor:', n), n
  }
  async function fDt(e, t, r) {
    let n = 0
    for (let s of e.keys()) {
      let o = e.get(s)
      o.wrap && (o.description = le.wrapLabel(o.description, at.width - 2 * at.wrapPadding, xN(at)))
      let l = $r(o.description) ? await xu(o.description, K()) : le.calculateTextDimensions(o.description, xN(at))
      ;(o.width = o.wrap ? at.width : Rt.getMax(at.width, l.width + 2 * at.wrapPadding)),
        (o.height = o.wrap ? Rt.getMax(l.height, at.height) : at.height),
        (n = Rt.getMax(n, o.height))
    }
    for (let s in t) {
      let o = e.get(s)
      if (!o) continue
      let l = e.get(o.nextActor)
      if (!l) {
        let d = t[s] + at.actorMargin - o.width / 2
        o.margin = Rt.getMax(d, at.actorMargin)
        continue
      }
      let h = t[s] + at.actorMargin - o.width / 2 - l.width / 2
      o.margin = Rt.getMax(h, at.actorMargin)
    }
    let i = 0
    return (
      r.forEach((s) => {
        let o = Qh(at),
          l = s.actorKeys.reduce((d, p) => (d += e.get(p).width + (e.get(p).margin || 0)), 0),
          u = at.boxMargin * 8
        ;(l += u), (l -= 2 * at.boxTextMargin), s.wrap && (s.name = le.wrapLabel(s.name, l - 2 * at.wrapPadding, o))
        let h = le.calculateTextDimensions(s.name, o)
        i = Rt.getMax(h.height, i)
        let f = Rt.getMax(l, h.width + 2 * at.wrapPadding)
        if (((s.margin = at.boxTextMargin), l < f)) {
          let d = (f - l) / 2
          s.margin += d
        }
      }),
      r.forEach((s) => (s.textMaxHeight = i)),
      Rt.getMax(n, at.height)
    )
  }
  var at,
    Pt,
    iDt,
    Qh,
    _m,
    xN,
    aDt,
    oDt,
    bN,
    Ont,
    Pnt,
    P_,
    Mnt,
    cDt,
    hDt,
    dDt,
    pDt,
    mDt,
    Bnt,
    Fnt = x(() => {
      'use strict'
      Ge()
      Int()
      Vt()
      Be()
      Be()
      a0()
      pe()
      of()
      Ce()
      On()
      mN()
      ;(at = {}),
        (Pt = {
          data: { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0 },
          verticalPos: 0,
          sequenceItems: [],
          activations: [],
          models: {
            getHeight: a(function () {
              return (
                Math.max.apply(null, this.actors.length === 0 ? [0] : this.actors.map((e) => e.height || 0)) +
                (this.loops.length === 0 ? 0 : this.loops.map((e) => e.height || 0).reduce((e, t) => e + t)) +
                (this.messages.length === 0 ? 0 : this.messages.map((e) => e.height || 0).reduce((e, t) => e + t)) +
                (this.notes.length === 0 ? 0 : this.notes.map((e) => e.height || 0).reduce((e, t) => e + t))
              )
            }, 'getHeight'),
            clear: a(function () {
              ;(this.actors = []), (this.boxes = []), (this.loops = []), (this.messages = []), (this.notes = [])
            }, 'clear'),
            addBox: a(function (e) {
              this.boxes.push(e)
            }, 'addBox'),
            addActor: a(function (e) {
              this.actors.push(e)
            }, 'addActor'),
            addLoop: a(function (e) {
              this.loops.push(e)
            }, 'addLoop'),
            addMessage: a(function (e) {
              this.messages.push(e)
            }, 'addMessage'),
            addNote: a(function (e) {
              this.notes.push(e)
            }, 'addNote'),
            lastActor: a(function () {
              return this.actors[this.actors.length - 1]
            }, 'lastActor'),
            lastLoop: a(function () {
              return this.loops[this.loops.length - 1]
            }, 'lastLoop'),
            lastMessage: a(function () {
              return this.messages[this.messages.length - 1]
            }, 'lastMessage'),
            lastNote: a(function () {
              return this.notes[this.notes.length - 1]
            }, 'lastNote'),
            actors: [],
            boxes: [],
            loops: [],
            messages: [],
            notes: [],
          },
          init: a(function () {
            ;(this.sequenceItems = []),
              (this.activations = []),
              this.models.clear(),
              (this.data = { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0 }),
              (this.verticalPos = 0),
              Pnt(K())
          }, 'init'),
          updateVal: a(function (e, t, r, n) {
            e[t] === void 0 ? (e[t] = r) : (e[t] = n(r, e[t]))
          }, 'updateVal'),
          updateBounds: a(function (e, t, r, n) {
            let i = this,
              s = 0
            function o(l) {
              return a(function (h) {
                s++
                let f = i.sequenceItems.length - s + 1
                i.updateVal(h, 'starty', t - f * at.boxMargin, Math.min),
                  i.updateVal(h, 'stopy', n + f * at.boxMargin, Math.max),
                  i.updateVal(Pt.data, 'startx', e - f * at.boxMargin, Math.min),
                  i.updateVal(Pt.data, 'stopx', r + f * at.boxMargin, Math.max),
                  l !== 'activation' &&
                    (i.updateVal(h, 'startx', e - f * at.boxMargin, Math.min),
                    i.updateVal(h, 'stopx', r + f * at.boxMargin, Math.max),
                    i.updateVal(Pt.data, 'starty', t - f * at.boxMargin, Math.min),
                    i.updateVal(Pt.data, 'stopy', n + f * at.boxMargin, Math.max))
              }, 'updateItemBounds')
            }
            a(o, 'updateFn'), this.sequenceItems.forEach(o()), this.activations.forEach(o('activation'))
          }, 'updateBounds'),
          insert: a(function (e, t, r, n) {
            let i = Rt.getMin(e, r),
              s = Rt.getMax(e, r),
              o = Rt.getMin(t, n),
              l = Rt.getMax(t, n)
            this.updateVal(Pt.data, 'startx', i, Math.min),
              this.updateVal(Pt.data, 'starty', o, Math.min),
              this.updateVal(Pt.data, 'stopx', s, Math.max),
              this.updateVal(Pt.data, 'stopy', l, Math.max),
              this.updateBounds(i, o, s, l)
          }, 'insert'),
          newActivation: a(function (e, t, r) {
            let n = r.get(e.from),
              i = P_(e.from).length || 0,
              s = n.x + n.width / 2 + ((i - 1) * at.activationWidth) / 2
            this.activations.push({
              startx: s,
              starty: this.verticalPos + 2,
              stopx: s + at.activationWidth,
              stopy: void 0,
              actor: e.from,
              anchored: gn.anchorElement(t),
            })
          }, 'newActivation'),
          endActivation: a(function (e) {
            let t = this.activations
              .map(function (r) {
                return r.actor
              })
              .lastIndexOf(e.from)
            return this.activations.splice(t, 1)[0]
          }, 'endActivation'),
          createLoop: a(function (e = { message: void 0, wrap: !1, width: void 0 }, t) {
            return {
              startx: void 0,
              starty: this.verticalPos,
              stopx: void 0,
              stopy: void 0,
              title: e.message,
              wrap: e.wrap,
              width: e.width,
              height: 0,
              fill: t,
            }
          }, 'createLoop'),
          newLoop: a(function (e = { message: void 0, wrap: !1, width: void 0 }, t) {
            this.sequenceItems.push(this.createLoop(e, t))
          }, 'newLoop'),
          endLoop: a(function () {
            return this.sequenceItems.pop()
          }, 'endLoop'),
          isLoopOverlap: a(function () {
            return this.sequenceItems.length ? this.sequenceItems[this.sequenceItems.length - 1].overlap : !1
          }, 'isLoopOverlap'),
          addSectionToLoop: a(function (e) {
            let t = this.sequenceItems.pop()
            ;(t.sections = t.sections || []),
              (t.sectionTitles = t.sectionTitles || []),
              t.sections.push({ y: Pt.getVerticalPos(), height: 0 }),
              t.sectionTitles.push(e),
              this.sequenceItems.push(t)
          }, 'addSectionToLoop'),
          saveVerticalPos: a(function () {
            this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos)
          }, 'saveVerticalPos'),
          resetVerticalPos: a(function () {
            this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos)
          }, 'resetVerticalPos'),
          bumpVerticalPos: a(function (e) {
            ;(this.verticalPos = this.verticalPos + e), (this.data.stopy = Rt.getMax(this.data.stopy, this.verticalPos))
          }, 'bumpVerticalPos'),
          getVerticalPos: a(function () {
            return this.verticalPos
          }, 'getVerticalPos'),
          getBounds: a(function () {
            return { bounds: this.data, models: this.models }
          }, 'getBounds'),
        }),
        (iDt = a(async function (e, t) {
          Pt.bumpVerticalPos(at.boxMargin), (t.height = at.boxMargin), (t.starty = Pt.getVerticalPos())
          let r = ri()
          ;(r.x = t.startx), (r.y = t.starty), (r.width = t.width || at.width), (r.class = 'note')
          let n = e.append('g'),
            i = gn.drawRect(n, r),
            s = s0()
          ;(s.x = t.startx),
            (s.y = t.starty),
            (s.width = r.width),
            (s.dy = '1em'),
            (s.text = t.message),
            (s.class = 'noteText'),
            (s.fontFamily = at.noteFontFamily),
            (s.fontSize = at.noteFontSize),
            (s.fontWeight = at.noteFontWeight),
            (s.anchor = at.noteAlign),
            (s.textMargin = at.noteMargin),
            (s.valign = 'center')
          let o = $r(s.text) ? await zy(n, s) : Kh(n, s),
            l = Math.round(o.map((u) => (u._groups || u)[0][0].getBBox().height).reduce((u, h) => u + h))
          i.attr('height', l + 2 * at.noteMargin),
            (t.height += l + 2 * at.noteMargin),
            Pt.bumpVerticalPos(l + 2 * at.noteMargin),
            (t.stopy = t.starty + l + 2 * at.noteMargin),
            (t.stopx = t.startx + r.width),
            Pt.insert(t.startx, t.starty, t.stopx, t.stopy),
            Pt.models.addNote(t)
        }, 'drawNote')),
        (Qh = a(
          (e) => ({ fontFamily: e.messageFontFamily, fontSize: e.messageFontSize, fontWeight: e.messageFontWeight }),
          'messageFont',
        )),
        (_m = a(
          (e) => ({ fontFamily: e.noteFontFamily, fontSize: e.noteFontSize, fontWeight: e.noteFontWeight }),
          'noteFont',
        )),
        (xN = a(
          (e) => ({ fontFamily: e.actorFontFamily, fontSize: e.actorFontSize, fontWeight: e.actorFontWeight }),
          'actorFont',
        ))
      a(sDt, 'boundMessage')
      ;(aDt = a(async function (e, t, r, n) {
        let { startx: i, stopx: s, starty: o, message: l, type: u, sequenceIndex: h, sequenceVisible: f } = t,
          d = le.calculateTextDimensions(l, Qh(at)),
          p = s0()
        ;(p.x = i),
          (p.y = o + 10),
          (p.width = s - i),
          (p.class = 'messageText'),
          (p.dy = '1em'),
          (p.text = l),
          (p.fontFamily = at.messageFontFamily),
          (p.fontSize = at.messageFontSize),
          (p.fontWeight = at.messageFontWeight),
          (p.anchor = at.messageAlign),
          (p.valign = 'center'),
          (p.textMargin = at.wrapPadding),
          (p.tspan = !1),
          $r(p.text) ? await zy(e, p, { startx: i, stopx: s, starty: r }) : Kh(e, p)
        let m = d.width,
          g
        i === s
          ? at.rightAngles
            ? (g = e
                .append('path')
                .attr('d', `M  ${i},${r} H ${i + Rt.getMax(at.width / 2, m / 2)} V ${r + 25} H ${i}`))
            : (g = e
                .append('path')
                .attr(
                  'd',
                  'M ' +
                    i +
                    ',' +
                    r +
                    ' C ' +
                    (i + 60) +
                    ',' +
                    (r - 10) +
                    ' ' +
                    (i + 60) +
                    ',' +
                    (r + 30) +
                    ' ' +
                    i +
                    ',' +
                    (r + 20),
                ))
          : ((g = e.append('line')), g.attr('x1', i), g.attr('y1', r), g.attr('x2', s), g.attr('y2', r)),
          u === n.db.LINETYPE.DOTTED ||
          u === n.db.LINETYPE.DOTTED_CROSS ||
          u === n.db.LINETYPE.DOTTED_POINT ||
          u === n.db.LINETYPE.DOTTED_OPEN ||
          u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED
            ? (g.style('stroke-dasharray', '3, 3'), g.attr('class', 'messageLine1'))
            : g.attr('class', 'messageLine0')
        let y = ''
        at.arrowMarkerAbsolute && (y = yu(!0)),
          g.attr('stroke-width', 2),
          g.attr('stroke', 'none'),
          g.style('fill', 'none'),
          (u === n.db.LINETYPE.SOLID || u === n.db.LINETYPE.DOTTED) && g.attr('marker-end', 'url(' + y + '#arrowhead)'),
          (u === n.db.LINETYPE.BIDIRECTIONAL_SOLID || u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) &&
            (g.attr('marker-start', 'url(' + y + '#arrowhead)'), g.attr('marker-end', 'url(' + y + '#arrowhead)')),
          (u === n.db.LINETYPE.SOLID_POINT || u === n.db.LINETYPE.DOTTED_POINT) &&
            g.attr('marker-end', 'url(' + y + '#filled-head)'),
          (u === n.db.LINETYPE.SOLID_CROSS || u === n.db.LINETYPE.DOTTED_CROSS) &&
            g.attr('marker-end', 'url(' + y + '#crosshead)'),
          (f || at.showSequenceNumbers) &&
            ((u === n.db.LINETYPE.BIDIRECTIONAL_SOLID || u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) &&
              (i < s ? g.attr('x1', i + 12) : g.attr('x1', i + 6)),
            e
              .append('line')
              .attr('x1', i)
              .attr('y1', r)
              .attr('x2', i)
              .attr('y2', r)
              .attr('stroke-width', 0)
              .attr('marker-start', 'url(' + y + '#sequencenumber)'),
            e
              .append('text')
              .attr('x', i)
              .attr('y', r + 4)
              .attr('font-family', 'sans-serif')
              .attr('font-size', '12px')
              .attr('text-anchor', 'middle')
              .attr('class', 'sequenceNumber')
              .text(h))
      }, 'drawMessage')),
        (oDt = a(function (e, t, r, n, i, s, o) {
          let l = 0,
            u = 0,
            h,
            f = 0
          for (let d of n) {
            let p = t.get(d),
              m = p.box
            h && h != m && (o || Pt.models.addBox(h), (u += at.boxMargin + h.margin)),
              m && m != h && (o || ((m.x = l + u), (m.y = i)), (u += m.margin)),
              (p.width = p.width || at.width),
              (p.height = Rt.getMax(p.height || at.height, at.height)),
              (p.margin = p.margin || at.actorMargin),
              (f = Rt.getMax(f, p.height)),
              r.get(p.name) && (u += p.width / 2),
              (p.x = l + u),
              (p.starty = Pt.getVerticalPos()),
              Pt.insert(p.x, i, p.x + p.width, p.height),
              (l += p.width + u),
              p.box && (p.box.width = l + m.margin - p.box.x),
              (u = p.margin),
              (h = p.box),
              Pt.models.addActor(p)
          }
          h && !o && Pt.models.addBox(h), Pt.bumpVerticalPos(f)
        }, 'addActorRenderingData')),
        (bN = a(async function (e, t, r, n) {
          if (n) {
            let i = 0
            Pt.bumpVerticalPos(at.boxMargin * 2)
            for (let s of r) {
              let o = t.get(s)
              o.stopy || (o.stopy = Pt.getVerticalPos())
              let l = await gn.drawActor(e, o, at, !0)
              i = Rt.getMax(i, l)
            }
            Pt.bumpVerticalPos(i + at.boxMargin)
          } else
            for (let i of r) {
              let s = t.get(i)
              await gn.drawActor(e, s, at, !1)
            }
        }, 'drawActors')),
        (Ont = a(function (e, t, r, n) {
          let i = 0,
            s = 0
          for (let o of r) {
            let l = t.get(o),
              u = hDt(l),
              h = gn.drawPopup(e, l, u, at, at.forceMenus, n)
            h.height > i && (i = h.height), h.width + l.x > s && (s = h.width + l.x)
          }
          return { maxHeight: i, maxWidth: s }
        }, 'drawActorsPopup')),
        (Pnt = a(function (e) {
          Kr(at, e),
            e.fontFamily && (at.actorFontFamily = at.noteFontFamily = at.messageFontFamily = e.fontFamily),
            e.fontSize && (at.actorFontSize = at.noteFontSize = at.messageFontSize = e.fontSize),
            e.fontWeight && (at.actorFontWeight = at.noteFontWeight = at.messageFontWeight = e.fontWeight)
        }, 'setConf')),
        (P_ = a(function (e) {
          return Pt.activations.filter(function (t) {
            return t.actor === e
          })
        }, 'actorActivations')),
        (Mnt = a(function (e, t) {
          let r = t.get(e),
            n = P_(e),
            i = n.reduce(
              function (o, l) {
                return Rt.getMin(o, l.startx)
              },
              r.x + r.width / 2 - 1,
            ),
            s = n.reduce(
              function (o, l) {
                return Rt.getMax(o, l.stopx)
              },
              r.x + r.width / 2 + 1,
            )
          return [i, s]
        }, 'activationBounds'))
      a(Yo, 'adjustLoopHeightForWrap')
      a(lDt, 'adjustCreatedDestroyedData')
      cDt = a(async function (e, t, r, n) {
        let { securityLevel: i, sequence: s } = K()
        at = s
        let o
        i === 'sandbox' && (o = xt('#i' + t))
        let l = i === 'sandbox' ? xt(o.nodes()[0].contentDocument.body) : xt('body'),
          u = i === 'sandbox' ? o.nodes()[0].contentDocument : document
        Pt.init(), B.debug(n.db)
        let h = i === 'sandbox' ? l.select(`[id="${t}"]`) : xt(`[id="${t}"]`),
          f = n.db.getActors(),
          d = n.db.getCreatedActors(),
          p = n.db.getDestroyedActors(),
          m = n.db.getBoxes(),
          g = n.db.getActorKeys(),
          y = n.db.getMessages(),
          b = n.db.getDiagramTitle(),
          k = n.db.hasAtLeastOneBox(),
          T = n.db.hasAtLeastOneBoxWithTitle(),
          C = await uDt(f, y, n)
        if (
          ((at.height = await fDt(f, C, m)),
          gn.insertComputerIcon(h),
          gn.insertDatabaseIcon(h),
          gn.insertClockIcon(h),
          k && (Pt.bumpVerticalPos(at.boxMargin), T && Pt.bumpVerticalPos(m[0].textMaxHeight)),
          at.hideUnusedParticipants === !0)
        ) {
          let I = new Set()
          y.forEach((M) => {
            I.add(M.from), I.add(M.to)
          }),
            (g = g.filter((M) => I.has(M)))
        }
        oDt(h, f, d, g, 0, y, !1)
        let A = await mDt(y, f, C, n)
        gn.insertArrowHead(h), gn.insertArrowCrossHead(h), gn.insertArrowFilledHead(h), gn.insertSequenceNumber(h)
        function w(I, M) {
          let V = Pt.endActivation(I)
          V.starty + 18 > M && ((V.starty = M - 6), (M += 12)),
            gn.drawActivation(h, V, M, at, P_(I.from).length),
            Pt.insert(V.startx, M - 10, V.stopx, M)
        }
        a(w, 'activeEnd')
        let D = 1,
          G = 1,
          v = [],
          R = [],
          F = 0
        for (let I of y) {
          let M, V, $
          switch (I.type) {
            case n.db.LINETYPE.NOTE:
              Pt.resetVerticalPos(), (V = I.noteModel), await iDt(h, V)
              break
            case n.db.LINETYPE.ACTIVE_START:
              Pt.newActivation(I, h, f)
              break
            case n.db.LINETYPE.ACTIVE_END:
              w(I, Pt.getVerticalPos())
              break
            case n.db.LINETYPE.LOOP_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q))
              break
            case n.db.LINETYPE.LOOP_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'loop', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            case n.db.LINETYPE.RECT_START:
              Yo(A, I, at.boxMargin, at.boxMargin, (q) => Pt.newLoop(void 0, q.message))
              break
            case n.db.LINETYPE.RECT_END:
              ;(M = Pt.endLoop()), R.push(M), Pt.models.addLoop(M), Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos())
              break
            case n.db.LINETYPE.OPT_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q))
              break
            case n.db.LINETYPE.OPT_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'opt', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            case n.db.LINETYPE.ALT_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q))
              break
            case n.db.LINETYPE.ALT_ELSE:
              Yo(A, I, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) => Pt.addSectionToLoop(q))
              break
            case n.db.LINETYPE.ALT_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'alt', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            case n.db.LINETYPE.PAR_START:
            case n.db.LINETYPE.PAR_OVER_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q)), Pt.saveVerticalPos()
              break
            case n.db.LINETYPE.PAR_AND:
              Yo(A, I, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) => Pt.addSectionToLoop(q))
              break
            case n.db.LINETYPE.PAR_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'par', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            case n.db.LINETYPE.AUTONUMBER:
              ;(D = I.message.start || D),
                (G = I.message.step || G),
                I.message.visible ? n.db.enableSequenceNumbers() : n.db.disableSequenceNumbers()
              break
            case n.db.LINETYPE.CRITICAL_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q))
              break
            case n.db.LINETYPE.CRITICAL_OPTION:
              Yo(A, I, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) => Pt.addSectionToLoop(q))
              break
            case n.db.LINETYPE.CRITICAL_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'critical', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            case n.db.LINETYPE.BREAK_START:
              Yo(A, I, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) => Pt.newLoop(q))
              break
            case n.db.LINETYPE.BREAK_END:
              ;(M = Pt.endLoop()),
                await gn.drawLoop(h, M, 'break', at),
                Pt.bumpVerticalPos(M.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(M)
              break
            default:
              try {
                ;($ = I.msgModel),
                  ($.starty = Pt.getVerticalPos()),
                  ($.sequenceIndex = D),
                  ($.sequenceVisible = n.db.showSequenceNumbers())
                let q = await sDt(h, $)
                lDt(I, $, q, F, f, d, p), v.push({ messageModel: $, lineStartY: q }), Pt.models.addMessage($)
              } catch (q) {
                B.error('error while drawing message', q)
              }
          }
          ;[
            n.db.LINETYPE.SOLID_OPEN,
            n.db.LINETYPE.DOTTED_OPEN,
            n.db.LINETYPE.SOLID,
            n.db.LINETYPE.DOTTED,
            n.db.LINETYPE.SOLID_CROSS,
            n.db.LINETYPE.DOTTED_CROSS,
            n.db.LINETYPE.SOLID_POINT,
            n.db.LINETYPE.DOTTED_POINT,
            n.db.LINETYPE.BIDIRECTIONAL_SOLID,
            n.db.LINETYPE.BIDIRECTIONAL_DOTTED,
          ].includes(I.type) && (D = D + G),
            F++
        }
        B.debug('createdActors', d), B.debug('destroyedActors', p), await bN(h, f, g, !1)
        for (let I of v) await aDt(h, I.messageModel, I.lineStartY, n)
        at.mirrorActors && (await bN(h, f, g, !0)), R.forEach((I) => gn.drawBackgroundRect(h, I)), yN(h, f, g, at)
        for (let I of Pt.models.boxes) {
          ;(I.height = Pt.getVerticalPos() - I.y), Pt.insert(I.x, I.y, I.x + I.width, I.height)
          let M = at.boxMargin * 2
          ;(I.startx = I.x - M),
            (I.starty = I.y - M * 0.25),
            (I.stopx = I.startx + I.width + 2 * M),
            (I.stopy = I.starty + I.height + M * 0.75),
            (I.stroke = 'rgb(0,0,0, 0.5)'),
            gn.drawBox(h, I, at)
        }
        k && Pt.bumpVerticalPos(at.boxMargin)
        let S = Ont(h, f, g, u),
          { bounds: O } = Pt.getBounds()
        O.startx === void 0 && (O.startx = 0),
          O.starty === void 0 && (O.starty = 0),
          O.stopx === void 0 && (O.stopx = 0),
          O.stopy === void 0 && (O.stopy = 0)
        let E = O.stopy - O.starty
        E < S.maxHeight && (E = S.maxHeight)
        let _ = E + 2 * at.diagramMarginY
        at.mirrorActors && (_ = _ - at.boxMargin + at.bottomMarginAdj)
        let L = O.stopx - O.startx
        L < S.maxWidth && (L = S.maxWidth)
        let N = L + 2 * at.diagramMarginX
        b &&
          h
            .append('text')
            .text(b)
            .attr('x', (O.stopx - O.startx) / 2 - 2 * at.diagramMarginX)
            .attr('y', -25),
          Ar(h, _, N, at.useMaxWidth)
        let P = b ? 40 : 0
        h.attr('viewBox', O.startx - at.diagramMarginX + ' -' + (at.diagramMarginY + P) + ' ' + N + ' ' + (_ + P)),
          B.debug('models:', Pt.models)
      }, 'draw')
      a(uDt, 'getMaxMessageWidthPerActor')
      hDt = a(function (e) {
        let t = 0,
          r = xN(at)
        for (let n in e.links) {
          let s = le.calculateTextDimensions(n, r).width + 2 * at.wrapPadding + 2 * at.boxMargin
          t < s && (t = s)
        }
        return t
      }, 'getRequiredPopupWidth')
      a(fDt, 'calculateActorMargins')
      ;(dDt = a(async function (e, t, r) {
        let n = t.get(e.from),
          i = t.get(e.to),
          s = n.x,
          o = i.x,
          l = e.wrap && e.message,
          u = $r(e.message)
            ? await xu(e.message, K())
            : le.calculateTextDimensions(l ? le.wrapLabel(e.message, at.width, _m(at)) : e.message, _m(at)),
          h = {
            width: l ? at.width : Rt.getMax(at.width, u.width + 2 * at.noteMargin),
            height: 0,
            startx: n.x,
            stopx: 0,
            starty: 0,
            stopy: 0,
            message: e.message,
          }
        return (
          e.placement === r.db.PLACEMENT.RIGHTOF
            ? ((h.width = l
                ? Rt.getMax(at.width, u.width)
                : Rt.getMax(n.width / 2 + i.width / 2, u.width + 2 * at.noteMargin)),
              (h.startx = s + (n.width + at.actorMargin) / 2))
            : e.placement === r.db.PLACEMENT.LEFTOF
              ? ((h.width = l
                  ? Rt.getMax(at.width, u.width + 2 * at.noteMargin)
                  : Rt.getMax(n.width / 2 + i.width / 2, u.width + 2 * at.noteMargin)),
                (h.startx = s - h.width + (n.width - at.actorMargin) / 2))
              : e.to === e.from
                ? ((u = le.calculateTextDimensions(
                    l ? le.wrapLabel(e.message, Rt.getMax(at.width, n.width), _m(at)) : e.message,
                    _m(at),
                  )),
                  (h.width = l
                    ? Rt.getMax(at.width, n.width)
                    : Rt.getMax(n.width, at.width, u.width + 2 * at.noteMargin)),
                  (h.startx = s + (n.width - h.width) / 2))
                : ((h.width = Math.abs(s + n.width / 2 - (o + i.width / 2)) + at.actorMargin),
                  (h.startx = s < o ? s + n.width / 2 - at.actorMargin / 2 : o + i.width / 2 - at.actorMargin / 2)),
          l && (h.message = le.wrapLabel(e.message, h.width - 2 * at.wrapPadding, _m(at))),
          B.debug(`NM:[${h.startx},${h.stopx},${h.starty},${h.stopy}:${h.width},${h.height}=${e.message}]`),
          h
        )
      }, 'buildNoteModel')),
        (pDt = a(function (e, t, r) {
          if (
            ![
              r.db.LINETYPE.SOLID_OPEN,
              r.db.LINETYPE.DOTTED_OPEN,
              r.db.LINETYPE.SOLID,
              r.db.LINETYPE.DOTTED,
              r.db.LINETYPE.SOLID_CROSS,
              r.db.LINETYPE.DOTTED_CROSS,
              r.db.LINETYPE.SOLID_POINT,
              r.db.LINETYPE.DOTTED_POINT,
              r.db.LINETYPE.BIDIRECTIONAL_SOLID,
              r.db.LINETYPE.BIDIRECTIONAL_DOTTED,
            ].includes(e.type)
          )
            return {}
          let [n, i] = Mnt(e.from, t),
            [s, o] = Mnt(e.to, t),
            l = n <= s,
            u = l ? i : n,
            h = l ? s : o,
            f = Math.abs(s - o) > 2,
            d = a((y) => (l ? -y : y), 'adjustValue')
          e.from === e.to
            ? (h = u)
            : (e.activate && !f && (h += d(at.activationWidth / 2 - 1)),
              [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(e.type) || (h += d(3)),
              [r.db.LINETYPE.BIDIRECTIONAL_SOLID, r.db.LINETYPE.BIDIRECTIONAL_DOTTED].includes(e.type) && (u -= d(3)))
          let p = [n, i, s, o],
            m = Math.abs(u - h)
          e.wrap &&
            e.message &&
            (e.message = le.wrapLabel(e.message, Rt.getMax(m + 2 * at.wrapPadding, at.width), Qh(at)))
          let g = le.calculateTextDimensions(e.message, Qh(at))
          return {
            width: Rt.getMax(e.wrap ? 0 : g.width + 2 * at.wrapPadding, m + 2 * at.wrapPadding, at.width),
            height: 0,
            startx: u,
            stopx: h,
            starty: 0,
            stopy: 0,
            message: e.message,
            type: e.type,
            wrap: e.wrap,
            fromBounds: Math.min.apply(null, p),
            toBounds: Math.max.apply(null, p),
          }
        }, 'buildMessageModel')),
        (mDt = a(async function (e, t, r, n) {
          let i = {},
            s = [],
            o,
            l,
            u
          for (let h of e) {
            switch (h.type) {
              case n.db.LINETYPE.LOOP_START:
              case n.db.LINETYPE.ALT_START:
              case n.db.LINETYPE.OPT_START:
              case n.db.LINETYPE.PAR_START:
              case n.db.LINETYPE.PAR_OVER_START:
              case n.db.LINETYPE.CRITICAL_START:
              case n.db.LINETYPE.BREAK_START:
                s.push({
                  id: h.id,
                  msg: h.message,
                  from: Number.MAX_SAFE_INTEGER,
                  to: Number.MIN_SAFE_INTEGER,
                  width: 0,
                })
                break
              case n.db.LINETYPE.ALT_ELSE:
              case n.db.LINETYPE.PAR_AND:
              case n.db.LINETYPE.CRITICAL_OPTION:
                h.message && ((o = s.pop()), (i[o.id] = o), (i[h.id] = o), s.push(o))
                break
              case n.db.LINETYPE.LOOP_END:
              case n.db.LINETYPE.ALT_END:
              case n.db.LINETYPE.OPT_END:
              case n.db.LINETYPE.PAR_END:
              case n.db.LINETYPE.CRITICAL_END:
              case n.db.LINETYPE.BREAK_END:
                ;(o = s.pop()), (i[o.id] = o)
                break
              case n.db.LINETYPE.ACTIVE_START:
                {
                  let d = t.get(h.from ? h.from : h.to.actor),
                    p = P_(h.from ? h.from : h.to.actor).length,
                    m = d.x + d.width / 2 + ((p - 1) * at.activationWidth) / 2,
                    g = { startx: m, stopx: m + at.activationWidth, actor: h.from, enabled: !0 }
                  Pt.activations.push(g)
                }
                break
              case n.db.LINETYPE.ACTIVE_END:
                {
                  let d = Pt.activations.map((p) => p.actor).lastIndexOf(h.from)
                  Pt.activations.splice(d, 1).splice(0, 1)
                }
                break
            }
            h.placement !== void 0
              ? ((l = await dDt(h, t, n)),
                (h.noteModel = l),
                s.forEach((d) => {
                  ;(o = d),
                    (o.from = Rt.getMin(o.from, l.startx)),
                    (o.to = Rt.getMax(o.to, l.startx + l.width)),
                    (o.width = Rt.getMax(o.width, Math.abs(o.from - o.to)) - at.labelBoxWidth)
                }))
              : ((u = pDt(h, t, n)),
                (h.msgModel = u),
                u.startx &&
                  u.stopx &&
                  s.length > 0 &&
                  s.forEach((d) => {
                    if (((o = d), u.startx === u.stopx)) {
                      let p = t.get(h.from),
                        m = t.get(h.to)
                      ;(o.from = Rt.getMin(p.x - u.width / 2, p.x - p.width / 2, o.from)),
                        (o.to = Rt.getMax(m.x + u.width / 2, m.x + p.width / 2, o.to)),
                        (o.width = Rt.getMax(o.width, Math.abs(o.to - o.from)) - at.labelBoxWidth)
                    } else
                      (o.from = Rt.getMin(u.startx, o.from)),
                        (o.to = Rt.getMax(u.stopx, o.to)),
                        (o.width = Rt.getMax(o.width, u.width) - at.labelBoxWidth)
                  }))
          }
          return (Pt.activations = []), B.debug('Loop type widths:', i), i
        }, 'calculateLoopBounds')),
        (Bnt = { bounds: Pt, drawActors: bN, drawActorsPopup: Ont, setConf: Pnt, draw: cDt })
    })
  var $nt = {}
  Oe($nt, { diagram: () => gDt })
  var gDt,
    Gnt = x(() => {
      'use strict'
      vnt()
      mN()
      Lnt()
      pe()
      Fnt()
      gDt = {
        parser: Ent,
        get db() {
          return new I_()
        },
        renderer: Bnt,
        styles: Ant,
        init: a((e) => {
          e.sequence || (e.sequence = {}), e.wrap && ((e.sequence.wrap = e.wrap), og({ sequence: { wrap: e.wrap } }))
        }, 'init'),
      }
    })
  var kN,
    B_,
    TN = x(() => {
      'use strict'
      kN = (function () {
        var e = a(function (At, bt, ct, Lt) {
            for (ct = ct || {}, Lt = At.length; Lt--; ct[At[Lt]] = bt);
            return ct
          }, 'o'),
          t = [1, 18],
          r = [1, 19],
          n = [1, 20],
          i = [1, 41],
          s = [1, 42],
          o = [1, 26],
          l = [1, 24],
          u = [1, 25],
          h = [1, 32],
          f = [1, 33],
          d = [1, 34],
          p = [1, 45],
          m = [1, 35],
          g = [1, 36],
          y = [1, 37],
          b = [1, 38],
          k = [1, 27],
          T = [1, 28],
          C = [1, 29],
          A = [1, 30],
          w = [1, 31],
          D = [1, 44],
          G = [1, 46],
          v = [1, 43],
          R = [1, 47],
          F = [1, 9],
          S = [1, 8, 9],
          O = [1, 58],
          E = [1, 59],
          _ = [1, 60],
          L = [1, 61],
          N = [1, 62],
          P = [1, 63],
          I = [1, 64],
          M = [1, 8, 9, 41],
          V = [1, 76],
          $ = [1, 8, 9, 12, 13, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81],
          q = [1, 8, 9, 12, 13, 18, 20, 22, 39, 41, 44, 50, 60, 68, 69, 70, 71, 72, 73, 74, 79, 81, 86, 100, 102, 103],
          tt = [13, 60, 86, 100, 102, 103],
          ft = [13, 60, 73, 74, 86, 100, 102, 103],
          H = [13, 60, 68, 69, 70, 71, 72, 86, 100, 102, 103],
          kt = [1, 100],
          ht = [1, 117],
          yt = [1, 113],
          ot = [1, 109],
          dt = [1, 115],
          it = [1, 110],
          Q = [1, 111],
          et = [1, 112],
          X = [1, 114],
          st = [1, 116],
          U = [22, 48, 60, 61, 82, 86, 87, 88, 89, 90],
          gt = [1, 8, 9, 39, 41, 44],
          z = [1, 8, 9, 22],
          ge = [1, 145],
          lt = [1, 8, 9, 61],
          jt = [1, 8, 9, 22, 48, 60, 61, 82, 86, 87, 88, 89, 90],
          Me = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mermaidDoc: 4,
              statements: 5,
              graphConfig: 6,
              CLASS_DIAGRAM: 7,
              NEWLINE: 8,
              EOF: 9,
              statement: 10,
              classLabel: 11,
              SQS: 12,
              STR: 13,
              SQE: 14,
              namespaceName: 15,
              alphaNumToken: 16,
              classLiteralName: 17,
              DOT: 18,
              className: 19,
              GENERICTYPE: 20,
              relationStatement: 21,
              LABEL: 22,
              namespaceStatement: 23,
              classStatement: 24,
              memberStatement: 25,
              annotationStatement: 26,
              clickStatement: 27,
              styleStatement: 28,
              cssClassStatement: 29,
              noteStatement: 30,
              classDefStatement: 31,
              direction: 32,
              acc_title: 33,
              acc_title_value: 34,
              acc_descr: 35,
              acc_descr_value: 36,
              acc_descr_multiline_value: 37,
              namespaceIdentifier: 38,
              STRUCT_START: 39,
              classStatements: 40,
              STRUCT_STOP: 41,
              NAMESPACE: 42,
              classIdentifier: 43,
              STYLE_SEPARATOR: 44,
              members: 45,
              CLASS: 46,
              emptyBody: 47,
              SPACE: 48,
              ANNOTATION_START: 49,
              ANNOTATION_END: 50,
              MEMBER: 51,
              SEPARATOR: 52,
              relation: 53,
              NOTE_FOR: 54,
              noteText: 55,
              NOTE: 56,
              CLASSDEF: 57,
              classList: 58,
              stylesOpt: 59,
              ALPHA: 60,
              COMMA: 61,
              direction_tb: 62,
              direction_bt: 63,
              direction_rl: 64,
              direction_lr: 65,
              relationType: 66,
              lineType: 67,
              AGGREGATION: 68,
              EXTENSION: 69,
              COMPOSITION: 70,
              DEPENDENCY: 71,
              LOLLIPOP: 72,
              LINE: 73,
              DOTTED_LINE: 74,
              CALLBACK: 75,
              LINK: 76,
              LINK_TARGET: 77,
              CLICK: 78,
              CALLBACK_NAME: 79,
              CALLBACK_ARGS: 80,
              HREF: 81,
              STYLE: 82,
              CSSCLASS: 83,
              style: 84,
              styleComponent: 85,
              NUM: 86,
              COLON: 87,
              UNIT: 88,
              BRKT: 89,
              PCT: 90,
              commentToken: 91,
              textToken: 92,
              graphCodeTokens: 93,
              textNoTagsToken: 94,
              TAGSTART: 95,
              TAGEND: 96,
              '==': 97,
              '--': 98,
              DEFAULT: 99,
              MINUS: 100,
              keywords: 101,
              UNICODE_TEXT: 102,
              BQUOTE_STR: 103,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              7: 'CLASS_DIAGRAM',
              8: 'NEWLINE',
              9: 'EOF',
              12: 'SQS',
              13: 'STR',
              14: 'SQE',
              18: 'DOT',
              20: 'GENERICTYPE',
              22: 'LABEL',
              33: 'acc_title',
              34: 'acc_title_value',
              35: 'acc_descr',
              36: 'acc_descr_value',
              37: 'acc_descr_multiline_value',
              39: 'STRUCT_START',
              41: 'STRUCT_STOP',
              42: 'NAMESPACE',
              44: 'STYLE_SEPARATOR',
              46: 'CLASS',
              48: 'SPACE',
              49: 'ANNOTATION_START',
              50: 'ANNOTATION_END',
              51: 'MEMBER',
              52: 'SEPARATOR',
              54: 'NOTE_FOR',
              56: 'NOTE',
              57: 'CLASSDEF',
              60: 'ALPHA',
              61: 'COMMA',
              62: 'direction_tb',
              63: 'direction_bt',
              64: 'direction_rl',
              65: 'direction_lr',
              68: 'AGGREGATION',
              69: 'EXTENSION',
              70: 'COMPOSITION',
              71: 'DEPENDENCY',
              72: 'LOLLIPOP',
              73: 'LINE',
              74: 'DOTTED_LINE',
              75: 'CALLBACK',
              76: 'LINK',
              77: 'LINK_TARGET',
              78: 'CLICK',
              79: 'CALLBACK_NAME',
              80: 'CALLBACK_ARGS',
              81: 'HREF',
              82: 'STYLE',
              83: 'CSSCLASS',
              86: 'NUM',
              87: 'COLON',
              88: 'UNIT',
              89: 'BRKT',
              90: 'PCT',
              93: 'graphCodeTokens',
              95: 'TAGSTART',
              96: 'TAGEND',
              97: '==',
              98: '--',
              99: 'DEFAULT',
              100: 'MINUS',
              101: 'keywords',
              102: 'UNICODE_TEXT',
              103: 'BQUOTE_STR',
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [4, 1],
              [6, 4],
              [5, 1],
              [5, 2],
              [5, 3],
              [11, 3],
              [15, 1],
              [15, 1],
              [15, 3],
              [15, 2],
              [19, 1],
              [19, 3],
              [19, 1],
              [19, 2],
              [19, 2],
              [19, 2],
              [10, 1],
              [10, 2],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 2],
              [10, 2],
              [10, 1],
              [23, 4],
              [23, 5],
              [38, 2],
              [40, 1],
              [40, 2],
              [40, 3],
              [24, 1],
              [24, 3],
              [24, 4],
              [24, 3],
              [24, 6],
              [43, 2],
              [43, 3],
              [47, 0],
              [47, 2],
              [47, 2],
              [26, 4],
              [45, 1],
              [45, 2],
              [25, 1],
              [25, 2],
              [25, 1],
              [25, 1],
              [21, 3],
              [21, 4],
              [21, 4],
              [21, 5],
              [30, 3],
              [30, 2],
              [31, 3],
              [58, 1],
              [58, 3],
              [32, 1],
              [32, 1],
              [32, 1],
              [32, 1],
              [53, 3],
              [53, 2],
              [53, 2],
              [53, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [67, 1],
              [67, 1],
              [27, 3],
              [27, 4],
              [27, 3],
              [27, 4],
              [27, 4],
              [27, 5],
              [27, 3],
              [27, 4],
              [27, 4],
              [27, 5],
              [27, 4],
              [27, 5],
              [27, 5],
              [27, 6],
              [28, 3],
              [29, 3],
              [59, 1],
              [59, 3],
              [84, 1],
              [84, 2],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [91, 1],
              [91, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [94, 1],
              [94, 1],
              [94, 1],
              [94, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [17, 1],
              [55, 1],
            ],
            performAction: a(function (bt, ct, Lt, Z, Mt, W, Gt) {
              var j = W.length - 1
              switch (Mt) {
                case 8:
                  this.$ = W[j - 1]
                  break
                case 9:
                case 10:
                case 13:
                case 15:
                  this.$ = W[j]
                  break
                case 11:
                case 14:
                  this.$ = W[j - 2] + '.' + W[j]
                  break
                case 12:
                case 16:
                  this.$ = W[j - 1] + W[j]
                  break
                case 17:
                case 18:
                  this.$ = W[j - 1] + '~' + W[j] + '~'
                  break
                case 19:
                  Z.addRelation(W[j])
                  break
                case 20:
                  ;(W[j - 1].title = Z.cleanupLabel(W[j])), Z.addRelation(W[j - 1])
                  break
                case 31:
                  ;(this.$ = W[j].trim()), Z.setAccTitle(this.$)
                  break
                case 32:
                case 33:
                  ;(this.$ = W[j].trim()), Z.setAccDescription(this.$)
                  break
                case 34:
                  Z.addClassesToNamespace(W[j - 3], W[j - 1])
                  break
                case 35:
                  Z.addClassesToNamespace(W[j - 4], W[j - 1])
                  break
                case 36:
                  ;(this.$ = W[j]), Z.addNamespace(W[j])
                  break
                case 37:
                  this.$ = [W[j]]
                  break
                case 38:
                  this.$ = [W[j - 1]]
                  break
                case 39:
                  W[j].unshift(W[j - 2]), (this.$ = W[j])
                  break
                case 41:
                  Z.setCssClass(W[j - 2], W[j])
                  break
                case 42:
                  Z.addMembers(W[j - 3], W[j - 1])
                  break
                case 44:
                  Z.setCssClass(W[j - 5], W[j - 3]), Z.addMembers(W[j - 5], W[j - 1])
                  break
                case 45:
                  ;(this.$ = W[j]), Z.addClass(W[j])
                  break
                case 46:
                  ;(this.$ = W[j - 1]), Z.addClass(W[j - 1]), Z.setClassLabel(W[j - 1], W[j])
                  break
                case 50:
                  Z.addAnnotation(W[j], W[j - 2])
                  break
                case 51:
                case 64:
                  this.$ = [W[j]]
                  break
                case 52:
                  W[j].push(W[j - 1]), (this.$ = W[j])
                  break
                case 53:
                  break
                case 54:
                  Z.addMember(W[j - 1], Z.cleanupLabel(W[j]))
                  break
                case 55:
                  break
                case 56:
                  break
                case 57:
                  this.$ = {
                    id1: W[j - 2],
                    id2: W[j],
                    relation: W[j - 1],
                    relationTitle1: 'none',
                    relationTitle2: 'none',
                  }
                  break
                case 58:
                  this.$ = {
                    id1: W[j - 3],
                    id2: W[j],
                    relation: W[j - 1],
                    relationTitle1: W[j - 2],
                    relationTitle2: 'none',
                  }
                  break
                case 59:
                  this.$ = {
                    id1: W[j - 3],
                    id2: W[j],
                    relation: W[j - 2],
                    relationTitle1: 'none',
                    relationTitle2: W[j - 1],
                  }
                  break
                case 60:
                  this.$ = {
                    id1: W[j - 4],
                    id2: W[j],
                    relation: W[j - 2],
                    relationTitle1: W[j - 3],
                    relationTitle2: W[j - 1],
                  }
                  break
                case 61:
                  Z.addNote(W[j], W[j - 1])
                  break
                case 62:
                  Z.addNote(W[j])
                  break
                case 63:
                  ;(this.$ = W[j - 2]), Z.defineClass(W[j - 1], W[j])
                  break
                case 65:
                  this.$ = W[j - 2].concat([W[j]])
                  break
                case 66:
                  Z.setDirection('TB')
                  break
                case 67:
                  Z.setDirection('BT')
                  break
                case 68:
                  Z.setDirection('RL')
                  break
                case 69:
                  Z.setDirection('LR')
                  break
                case 70:
                  this.$ = { type1: W[j - 2], type2: W[j], lineType: W[j - 1] }
                  break
                case 71:
                  this.$ = { type1: 'none', type2: W[j], lineType: W[j - 1] }
                  break
                case 72:
                  this.$ = { type1: W[j - 1], type2: 'none', lineType: W[j] }
                  break
                case 73:
                  this.$ = { type1: 'none', type2: 'none', lineType: W[j] }
                  break
                case 74:
                  this.$ = Z.relationType.AGGREGATION
                  break
                case 75:
                  this.$ = Z.relationType.EXTENSION
                  break
                case 76:
                  this.$ = Z.relationType.COMPOSITION
                  break
                case 77:
                  this.$ = Z.relationType.DEPENDENCY
                  break
                case 78:
                  this.$ = Z.relationType.LOLLIPOP
                  break
                case 79:
                  this.$ = Z.lineType.LINE
                  break
                case 80:
                  this.$ = Z.lineType.DOTTED_LINE
                  break
                case 81:
                case 87:
                  ;(this.$ = W[j - 2]), Z.setClickEvent(W[j - 1], W[j])
                  break
                case 82:
                case 88:
                  ;(this.$ = W[j - 3]), Z.setClickEvent(W[j - 2], W[j - 1]), Z.setTooltip(W[j - 2], W[j])
                  break
                case 83:
                  ;(this.$ = W[j - 2]), Z.setLink(W[j - 1], W[j])
                  break
                case 84:
                  ;(this.$ = W[j - 3]), Z.setLink(W[j - 2], W[j - 1], W[j])
                  break
                case 85:
                  ;(this.$ = W[j - 3]), Z.setLink(W[j - 2], W[j - 1]), Z.setTooltip(W[j - 2], W[j])
                  break
                case 86:
                  ;(this.$ = W[j - 4]), Z.setLink(W[j - 3], W[j - 2], W[j]), Z.setTooltip(W[j - 3], W[j - 1])
                  break
                case 89:
                  ;(this.$ = W[j - 3]), Z.setClickEvent(W[j - 2], W[j - 1], W[j])
                  break
                case 90:
                  ;(this.$ = W[j - 4]), Z.setClickEvent(W[j - 3], W[j - 2], W[j - 1]), Z.setTooltip(W[j - 3], W[j])
                  break
                case 91:
                  ;(this.$ = W[j - 3]), Z.setLink(W[j - 2], W[j])
                  break
                case 92:
                  ;(this.$ = W[j - 4]), Z.setLink(W[j - 3], W[j - 1], W[j])
                  break
                case 93:
                  ;(this.$ = W[j - 4]), Z.setLink(W[j - 3], W[j - 1]), Z.setTooltip(W[j - 3], W[j])
                  break
                case 94:
                  ;(this.$ = W[j - 5]), Z.setLink(W[j - 4], W[j - 2], W[j]), Z.setTooltip(W[j - 4], W[j - 1])
                  break
                case 95:
                  ;(this.$ = W[j - 2]), Z.setCssStyle(W[j - 1], W[j])
                  break
                case 96:
                  Z.setCssClass(W[j - 1], W[j])
                  break
                case 97:
                  this.$ = [W[j]]
                  break
                case 98:
                  W[j - 2].push(W[j]), (this.$ = W[j - 2])
                  break
                case 100:
                  this.$ = W[j - 1] + W[j]
                  break
              }
            }, 'anonymous'),
            table: [
              {
                3: 1,
                4: 2,
                5: 3,
                6: 4,
                7: [1, 6],
                10: 5,
                16: 39,
                17: 40,
                19: 21,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: t,
                35: r,
                37: n,
                38: 22,
                42: i,
                43: 23,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: A,
                83: w,
                86: D,
                100: G,
                102: v,
                103: R,
              },
              { 1: [3] },
              { 1: [2, 1] },
              { 1: [2, 2] },
              { 1: [2, 3] },
              e(F, [2, 5], { 8: [1, 48] }),
              { 8: [1, 49] },
              e(S, [2, 19], { 22: [1, 50] }),
              e(S, [2, 21]),
              e(S, [2, 22]),
              e(S, [2, 23]),
              e(S, [2, 24]),
              e(S, [2, 25]),
              e(S, [2, 26]),
              e(S, [2, 27]),
              e(S, [2, 28]),
              e(S, [2, 29]),
              e(S, [2, 30]),
              { 34: [1, 51] },
              { 36: [1, 52] },
              e(S, [2, 33]),
              e(S, [2, 53], {
                53: 53,
                66: 56,
                67: 57,
                13: [1, 54],
                22: [1, 55],
                68: O,
                69: E,
                70: _,
                71: L,
                72: N,
                73: P,
                74: I,
              }),
              { 39: [1, 65] },
              e(M, [2, 40], { 39: [1, 67], 44: [1, 66] }),
              e(S, [2, 55]),
              e(S, [2, 56]),
              { 16: 68, 60: p, 86: D, 100: G, 102: v },
              { 16: 39, 17: 40, 19: 69, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 16: 39, 17: 40, 19: 70, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 16: 39, 17: 40, 19: 71, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 60: [1, 72] },
              { 13: [1, 73] },
              { 16: 39, 17: 40, 19: 74, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 13: V, 55: 75 },
              { 58: 77, 60: [1, 78] },
              e(S, [2, 66]),
              e(S, [2, 67]),
              e(S, [2, 68]),
              e(S, [2, 69]),
              e($, [2, 13], { 16: 39, 17: 40, 19: 80, 18: [1, 79], 20: [1, 81], 60: p, 86: D, 100: G, 102: v, 103: R }),
              e($, [2, 15], { 20: [1, 82] }),
              { 15: 83, 16: 84, 17: 85, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 16: 39, 17: 40, 19: 86, 60: p, 86: D, 100: G, 102: v, 103: R },
              e(q, [2, 123]),
              e(q, [2, 124]),
              e(q, [2, 125]),
              e(q, [2, 126]),
              e([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], [2, 127]),
              e(F, [2, 6], {
                10: 5,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                19: 21,
                38: 22,
                43: 23,
                16: 39,
                17: 40,
                5: 87,
                33: t,
                35: r,
                37: n,
                42: i,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: A,
                83: w,
                86: D,
                100: G,
                102: v,
                103: R,
              }),
              {
                5: 88,
                10: 5,
                16: 39,
                17: 40,
                19: 21,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: t,
                35: r,
                37: n,
                38: 22,
                42: i,
                43: 23,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: A,
                83: w,
                86: D,
                100: G,
                102: v,
                103: R,
              },
              e(S, [2, 20]),
              e(S, [2, 31]),
              e(S, [2, 32]),
              { 13: [1, 90], 16: 39, 17: 40, 19: 89, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 53: 91, 66: 56, 67: 57, 68: O, 69: E, 70: _, 71: L, 72: N, 73: P, 74: I },
              e(S, [2, 54]),
              { 67: 92, 73: P, 74: I },
              e(tt, [2, 73], { 66: 93, 68: O, 69: E, 70: _, 71: L, 72: N }),
              e(ft, [2, 74]),
              e(ft, [2, 75]),
              e(ft, [2, 76]),
              e(ft, [2, 77]),
              e(ft, [2, 78]),
              e(H, [2, 79]),
              e(H, [2, 80]),
              { 8: [1, 95], 24: 96, 40: 94, 43: 23, 46: s },
              { 16: 97, 60: p, 86: D, 100: G, 102: v },
              { 41: [1, 99], 45: 98, 51: kt },
              { 50: [1, 101] },
              { 13: [1, 102] },
              { 13: [1, 103] },
              { 79: [1, 104], 81: [1, 105] },
              { 22: ht, 48: yt, 59: 106, 60: ot, 82: dt, 84: 107, 85: 108, 86: it, 87: Q, 88: et, 89: X, 90: st },
              { 60: [1, 118] },
              { 13: V, 55: 119 },
              e(S, [2, 62]),
              e(S, [2, 128]),
              {
                22: ht,
                48: yt,
                59: 120,
                60: ot,
                61: [1, 121],
                82: dt,
                84: 107,
                85: 108,
                86: it,
                87: Q,
                88: et,
                89: X,
                90: st,
              },
              e(U, [2, 64]),
              { 16: 39, 17: 40, 19: 122, 60: p, 86: D, 100: G, 102: v, 103: R },
              e($, [2, 16]),
              e($, [2, 17]),
              e($, [2, 18]),
              { 39: [2, 36] },
              { 15: 124, 16: 84, 17: 85, 18: [1, 123], 39: [2, 9], 60: p, 86: D, 100: G, 102: v, 103: R },
              { 39: [2, 10] },
              e(gt, [2, 45], { 11: 125, 12: [1, 126] }),
              e(F, [2, 7]),
              { 9: [1, 127] },
              e(z, [2, 57]),
              { 16: 39, 17: 40, 19: 128, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 13: [1, 130], 16: 39, 17: 40, 19: 129, 60: p, 86: D, 100: G, 102: v, 103: R },
              e(tt, [2, 72], { 66: 131, 68: O, 69: E, 70: _, 71: L, 72: N }),
              e(tt, [2, 71]),
              { 41: [1, 132] },
              { 24: 96, 40: 133, 43: 23, 46: s },
              { 8: [1, 134], 41: [2, 37] },
              e(M, [2, 41], { 39: [1, 135] }),
              { 41: [1, 136] },
              e(M, [2, 43]),
              { 41: [2, 51], 45: 137, 51: kt },
              { 16: 39, 17: 40, 19: 138, 60: p, 86: D, 100: G, 102: v, 103: R },
              e(S, [2, 81], { 13: [1, 139] }),
              e(S, [2, 83], { 13: [1, 141], 77: [1, 140] }),
              e(S, [2, 87], { 13: [1, 142], 80: [1, 143] }),
              { 13: [1, 144] },
              e(S, [2, 95], { 61: ge }),
              e(lt, [2, 97], { 85: 146, 22: ht, 48: yt, 60: ot, 82: dt, 86: it, 87: Q, 88: et, 89: X, 90: st }),
              e(jt, [2, 99]),
              e(jt, [2, 101]),
              e(jt, [2, 102]),
              e(jt, [2, 103]),
              e(jt, [2, 104]),
              e(jt, [2, 105]),
              e(jt, [2, 106]),
              e(jt, [2, 107]),
              e(jt, [2, 108]),
              e(jt, [2, 109]),
              e(S, [2, 96]),
              e(S, [2, 61]),
              e(S, [2, 63], { 61: ge }),
              { 60: [1, 147] },
              e($, [2, 14]),
              { 15: 148, 16: 84, 17: 85, 60: p, 86: D, 100: G, 102: v, 103: R },
              { 39: [2, 12] },
              e(gt, [2, 46]),
              { 13: [1, 149] },
              { 1: [2, 4] },
              e(z, [2, 59]),
              e(z, [2, 58]),
              { 16: 39, 17: 40, 19: 150, 60: p, 86: D, 100: G, 102: v, 103: R },
              e(tt, [2, 70]),
              e(S, [2, 34]),
              { 41: [1, 151] },
              { 24: 96, 40: 152, 41: [2, 38], 43: 23, 46: s },
              { 45: 153, 51: kt },
              e(M, [2, 42]),
              { 41: [2, 52] },
              e(S, [2, 50]),
              e(S, [2, 82]),
              e(S, [2, 84]),
              e(S, [2, 85], { 77: [1, 154] }),
              e(S, [2, 88]),
              e(S, [2, 89], { 13: [1, 155] }),
              e(S, [2, 91], { 13: [1, 157], 77: [1, 156] }),
              { 22: ht, 48: yt, 60: ot, 82: dt, 84: 158, 85: 108, 86: it, 87: Q, 88: et, 89: X, 90: st },
              e(jt, [2, 100]),
              e(U, [2, 65]),
              { 39: [2, 11] },
              { 14: [1, 159] },
              e(z, [2, 60]),
              e(S, [2, 35]),
              { 41: [2, 39] },
              { 41: [1, 160] },
              e(S, [2, 86]),
              e(S, [2, 90]),
              e(S, [2, 92]),
              e(S, [2, 93], { 77: [1, 161] }),
              e(lt, [2, 98], { 85: 146, 22: ht, 48: yt, 60: ot, 82: dt, 86: it, 87: Q, 88: et, 89: X, 90: st }),
              e(gt, [2, 8]),
              e(M, [2, 44]),
              e(S, [2, 94]),
            ],
            defaultActions: {
              2: [2, 1],
              3: [2, 2],
              4: [2, 3],
              83: [2, 36],
              85: [2, 10],
              124: [2, 12],
              127: [2, 4],
              137: [2, 52],
              148: [2, 11],
              152: [2, 39],
            },
            parseError: a(function (bt, ct) {
              if (ct.recoverable) this.trace(bt)
              else {
                var Lt = new Error(bt)
                throw ((Lt.hash = ct), Lt)
              }
            }, 'parseError'),
            parse: a(function (bt) {
              var ct = this,
                Lt = [0],
                Z = [],
                Mt = [null],
                W = [],
                Gt = this.table,
                j = '',
                vt = 0,
                mt = 0,
                Xt = 0,
                Ft = 2,
                _t = 1,
                Qe = W.slice.call(arguments, 1),
                It = Object.create(this.lexer),
                xr = { yy: {} }
              for (var Ze in this.yy) Object.prototype.hasOwnProperty.call(this.yy, Ze) && (xr.yy[Ze] = this.yy[Ze])
              It.setInput(bt, xr.yy),
                (xr.yy.lexer = It),
                (xr.yy.parser = this),
                typeof It.yylloc > 'u' && (It.yylloc = {})
              var yn = It.yylloc
              W.push(yn)
              var Ae = It.options && It.options.ranges
              typeof xr.yy.parseError == 'function'
                ? (this.parseError = xr.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function Se(ne) {
                ;(Lt.length = Lt.length - 2 * ne), (Mt.length = Mt.length - ne), (W.length = W.length - ne)
              }
              a(Se, 'popStack')
              function Je() {
                var ne
                return (
                  (ne = Z.pop() || It.lex() || _t),
                  typeof ne != 'number' &&
                    (ne instanceof Array && ((Z = ne), (ne = Z.pop())), (ne = ct.symbols_[ne] || ne)),
                  ne
                )
              }
              a(Je, 'lex')
              for (var _e, hr, Cn, ve, $e, Le, xe = {}, ce, ye, be, Ht; ; ) {
                if (
                  ((Cn = Lt[Lt.length - 1]),
                  this.defaultActions[Cn]
                    ? (ve = this.defaultActions[Cn])
                    : ((_e === null || typeof _e > 'u') && (_e = Je()), (ve = Gt[Cn] && Gt[Cn][_e])),
                  typeof ve > 'u' || !ve.length || !ve[0])
                ) {
                  var Nn = ''
                  Ht = []
                  for (ce in Gt[Cn]) this.terminals_[ce] && ce > Ft && Ht.push("'" + this.terminals_[ce] + "'")
                  It.showPosition
                    ? (Nn =
                        'Parse error on line ' +
                        (vt + 1) +
                        `:
` +
                        It.showPosition() +
                        `
Expecting ` +
                        Ht.join(', ') +
                        ", got '" +
                        (this.terminals_[_e] || _e) +
                        "'")
                    : (Nn =
                        'Parse error on line ' +
                        (vt + 1) +
                        ': Unexpected ' +
                        (_e == _t ? 'end of input' : "'" + (this.terminals_[_e] || _e) + "'")),
                    this.parseError(Nn, {
                      text: It.match,
                      token: this.terminals_[_e] || _e,
                      line: It.yylineno,
                      loc: yn,
                      expected: Ht,
                    })
                }
                if (ve[0] instanceof Array && ve.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + Cn + ', token: ' + _e)
                switch (ve[0]) {
                  case 1:
                    Lt.push(_e),
                      Mt.push(It.yytext),
                      W.push(It.yylloc),
                      Lt.push(ve[1]),
                      (_e = null),
                      hr
                        ? ((_e = hr), (hr = null))
                        : ((mt = It.yyleng), (j = It.yytext), (vt = It.yylineno), (yn = It.yylloc), Xt > 0 && Xt--)
                    break
                  case 2:
                    if (
                      ((ye = this.productions_[ve[1]][1]),
                      (xe.$ = Mt[Mt.length - ye]),
                      (xe._$ = {
                        first_line: W[W.length - (ye || 1)].first_line,
                        last_line: W[W.length - 1].last_line,
                        first_column: W[W.length - (ye || 1)].first_column,
                        last_column: W[W.length - 1].last_column,
                      }),
                      Ae && (xe._$.range = [W[W.length - (ye || 1)].range[0], W[W.length - 1].range[1]]),
                      (Le = this.performAction.apply(xe, [j, mt, vt, xr.yy, ve[1], Mt, W].concat(Qe))),
                      typeof Le < 'u')
                    )
                      return Le
                    ye && ((Lt = Lt.slice(0, -1 * ye * 2)), (Mt = Mt.slice(0, -1 * ye)), (W = W.slice(0, -1 * ye))),
                      Lt.push(this.productions_[ve[1]][0]),
                      Mt.push(xe.$),
                      W.push(xe._$),
                      (be = Gt[Lt[Lt.length - 2]][Lt[Lt.length - 1]]),
                      Lt.push(be)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          se = (function () {
            var At = {
              EOF: 1,
              parseError: a(function (ct, Lt) {
                if (this.yy.parser) this.yy.parser.parseError(ct, Lt)
                else throw new Error(ct)
              }, 'parseError'),
              setInput: a(function (bt, ct) {
                return (
                  (this.yy = ct || this.yy || {}),
                  (this._input = bt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var bt = this._input[0]
                ;(this.yytext += bt), this.yyleng++, this.offset++, (this.match += bt), (this.matched += bt)
                var ct = bt.match(/(?:\r\n?|\n).*/g)
                return (
                  ct ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  bt
                )
              }, 'input'),
              unput: a(function (bt) {
                var ct = bt.length,
                  Lt = bt.split(/(?:\r\n?|\n)/g)
                ;(this._input = bt + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - ct)),
                  (this.offset -= ct)
                var Z = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  Lt.length - 1 && (this.yylineno -= Lt.length - 1)
                var Mt = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Lt
                      ? (Lt.length === Z.length ? this.yylloc.first_column : 0) +
                        Z[Z.length - Lt.length].length -
                        Lt[0].length
                      : this.yylloc.first_column - ct,
                  }),
                  this.options.ranges && (this.yylloc.range = [Mt[0], Mt[0] + this.yyleng - ct]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (bt) {
                this.unput(this.match.slice(bt))
              }, 'less'),
              pastInput: a(function () {
                var bt = this.matched.substr(0, this.matched.length - this.match.length)
                return (bt.length > 20 ? '...' : '') + bt.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var bt = this.match
                return (
                  bt.length < 20 && (bt += this._input.substr(0, 20 - bt.length)),
                  (bt.substr(0, 20) + (bt.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var bt = this.pastInput(),
                  ct = new Array(bt.length + 1).join('-')
                return (
                  bt +
                  this.upcomingInput() +
                  `
` +
                  ct +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (bt, ct) {
                var Lt, Z, Mt
                if (
                  (this.options.backtrack_lexer &&
                    ((Mt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (Mt.yylloc.range = this.yylloc.range.slice(0))),
                  (Z = bt[0].match(/(?:\r\n?|\n).*/g)),
                  Z && (this.yylineno += Z.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Z
                      ? Z[Z.length - 1].length - Z[Z.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + bt[0].length,
                  }),
                  (this.yytext += bt[0]),
                  (this.match += bt[0]),
                  (this.matches = bt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(bt[0].length)),
                  (this.matched += bt[0]),
                  (Lt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    ct,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Lt)
                )
                  return Lt
                if (this._backtrack) {
                  for (var W in Mt) this[W] = Mt[W]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var bt, ct, Lt, Z
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var Mt = this._currentRules(), W = 0; W < Mt.length; W++)
                  if (((Lt = this._input.match(this.rules[Mt[W]])), Lt && (!ct || Lt[0].length > ct[0].length))) {
                    if (((ct = Lt), (Z = W), this.options.backtrack_lexer)) {
                      if (((bt = this.test_match(Lt, Mt[W])), bt !== !1)) return bt
                      if (this._backtrack) {
                        ct = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return ct
                  ? ((bt = this.test_match(ct, Mt[Z])), bt !== !1 ? bt : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var ct = this.next()
                return ct || this.lex()
              }, 'lex'),
              begin: a(function (ct) {
                this.conditionStack.push(ct)
              }, 'begin'),
              popState: a(function () {
                var ct = this.conditionStack.length - 1
                return ct > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (ct) {
                return (
                  (ct = this.conditionStack.length - 1 - Math.abs(ct || 0)),
                  ct >= 0 ? this.conditionStack[ct] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (ct) {
                this.begin(ct)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: {},
              performAction: a(function (ct, Lt, Z, Mt) {
                var W = Mt
                switch (Z) {
                  case 0:
                    return 62
                  case 1:
                    return 63
                  case 2:
                    return 64
                  case 3:
                    return 65
                  case 4:
                    break
                  case 5:
                    break
                  case 6:
                    return this.begin('acc_title'), 33
                    break
                  case 7:
                    return this.popState(), 'acc_title_value'
                    break
                  case 8:
                    return this.begin('acc_descr'), 35
                    break
                  case 9:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 10:
                    this.begin('acc_descr_multiline')
                    break
                  case 11:
                    this.popState()
                    break
                  case 12:
                    return 'acc_descr_multiline_value'
                  case 13:
                    return 8
                  case 14:
                    break
                  case 15:
                    return 7
                  case 16:
                    return 7
                  case 17:
                    return 'EDGE_STATE'
                  case 18:
                    this.begin('callback_name')
                    break
                  case 19:
                    this.popState()
                    break
                  case 20:
                    this.popState(), this.begin('callback_args')
                    break
                  case 21:
                    return 79
                  case 22:
                    this.popState()
                    break
                  case 23:
                    return 80
                  case 24:
                    this.popState()
                    break
                  case 25:
                    return 'STR'
                  case 26:
                    this.begin('string')
                    break
                  case 27:
                    return 82
                  case 28:
                    return 57
                  case 29:
                    return this.begin('namespace'), 42
                    break
                  case 30:
                    return this.popState(), 8
                    break
                  case 31:
                    break
                  case 32:
                    return this.begin('namespace-body'), 39
                    break
                  case 33:
                    return this.popState(), 41
                    break
                  case 34:
                    return 'EOF_IN_STRUCT'
                  case 35:
                    return 8
                  case 36:
                    break
                  case 37:
                    return 'EDGE_STATE'
                  case 38:
                    return this.begin('class'), 46
                    break
                  case 39:
                    return this.popState(), 8
                    break
                  case 40:
                    break
                  case 41:
                    return this.popState(), this.popState(), 41
                    break
                  case 42:
                    return this.begin('class-body'), 39
                    break
                  case 43:
                    return this.popState(), 41
                    break
                  case 44:
                    return 'EOF_IN_STRUCT'
                  case 45:
                    return 'EDGE_STATE'
                  case 46:
                    return 'OPEN_IN_STRUCT'
                  case 47:
                    break
                  case 48:
                    return 'MEMBER'
                  case 49:
                    return 83
                  case 50:
                    return 75
                  case 51:
                    return 76
                  case 52:
                    return 78
                  case 53:
                    return 54
                  case 54:
                    return 56
                  case 55:
                    return 49
                  case 56:
                    return 50
                  case 57:
                    return 81
                  case 58:
                    this.popState()
                    break
                  case 59:
                    return 'GENERICTYPE'
                  case 60:
                    this.begin('generic')
                    break
                  case 61:
                    this.popState()
                    break
                  case 62:
                    return 'BQUOTE_STR'
                  case 63:
                    this.begin('bqstring')
                    break
                  case 64:
                    return 77
                  case 65:
                    return 77
                  case 66:
                    return 77
                  case 67:
                    return 77
                  case 68:
                    return 69
                  case 69:
                    return 69
                  case 70:
                    return 71
                  case 71:
                    return 71
                  case 72:
                    return 70
                  case 73:
                    return 68
                  case 74:
                    return 72
                  case 75:
                    return 73
                  case 76:
                    return 74
                  case 77:
                    return 22
                  case 78:
                    return 44
                  case 79:
                    return 100
                  case 80:
                    return 18
                  case 81:
                    return 'PLUS'
                  case 82:
                    return 87
                  case 83:
                    return 61
                  case 84:
                    return 89
                  case 85:
                    return 89
                  case 86:
                    return 90
                  case 87:
                    return 'EQUALS'
                  case 88:
                    return 'EQUALS'
                  case 89:
                    return 60
                  case 90:
                    return 12
                  case 91:
                    return 14
                  case 92:
                    return 'PUNCTUATION'
                  case 93:
                    return 86
                  case 94:
                    return 102
                  case 95:
                    return 48
                  case 96:
                    return 48
                  case 97:
                    return 9
                }
              }, 'anonymous'),
              rules: [
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
                /^(?:%%[^\n]*(\r?\n)*)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:classDiagram-v2\b)/,
                /^(?:classDiagram\b)/,
                /^(?:\[\*\])/,
                /^(?:call[\s]+)/,
                /^(?:\([\s]*\))/,
                /^(?:\()/,
                /^(?:[^(]*)/,
                /^(?:\))/,
                /^(?:[^)]*)/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:["])/,
                /^(?:style\b)/,
                /^(?:classDef\b)/,
                /^(?:namespace\b)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:[{])/,
                /^(?:[}])/,
                /^(?:$)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:\[\*\])/,
                /^(?:class\b)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:[}])/,
                /^(?:[{])/,
                /^(?:[}])/,
                /^(?:$)/,
                /^(?:\[\*\])/,
                /^(?:[{])/,
                /^(?:[\n])/,
                /^(?:[^{}\n]*)/,
                /^(?:cssClass\b)/,
                /^(?:callback\b)/,
                /^(?:link\b)/,
                /^(?:click\b)/,
                /^(?:note for\b)/,
                /^(?:note\b)/,
                /^(?:<<)/,
                /^(?:>>)/,
                /^(?:href\b)/,
                /^(?:[~])/,
                /^(?:[^~]*)/,
                /^(?:~)/,
                /^(?:[`])/,
                /^(?:[^`]+)/,
                /^(?:[`])/,
                /^(?:_self\b)/,
                /^(?:_blank\b)/,
                /^(?:_parent\b)/,
                /^(?:_top\b)/,
                /^(?:\s*<\|)/,
                /^(?:\s*\|>)/,
                /^(?:\s*>)/,
                /^(?:\s*<)/,
                /^(?:\s*\*)/,
                /^(?:\s*o\b)/,
                /^(?:\s*\(\))/,
                /^(?:--)/,
                /^(?:\.\.)/,
                /^(?::{1}[^:\n;]+)/,
                /^(?::{3})/,
                /^(?:-)/,
                /^(?:\.)/,
                /^(?:\+)/,
                /^(?::)/,
                /^(?:,)/,
                /^(?:#)/,
                /^(?:#)/,
                /^(?:%)/,
                /^(?:=)/,
                /^(?:=)/,
                /^(?:\w+)/,
                /^(?:\[)/,
                /^(?:\])/,
                /^(?:[!"#$%&'*+,-.`?\\/])/,
                /^(?:[0-9]+)/,
                /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
                /^(?:\s)/,
                /^(?:\s)/,
                /^(?:$)/,
              ],
              conditions: {
                'namespace-body': {
                  rules: [
                    26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                namespace: {
                  rules: [
                    26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                'class-body': {
                  rules: [
                    26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70,
                    71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                class: {
                  rules: [
                    26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                    73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_descr_multiline: {
                  rules: [
                    11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_descr: {
                  rules: [
                    9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
                    76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_title: {
                  rules: [
                    7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
                    76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                callback_args: {
                  rules: [
                    22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                callback_name: {
                  rules: [
                    19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
                    74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                href: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                    77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                struct: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                    77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                generic: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                bqstring: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                string: {
                  rules: [
                    24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                    75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55,
                    56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
                    85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
                  ],
                  inclusive: !0,
                },
              },
            }
            return At
          })()
        Me.lexer = se
        function Nt() {
          this.yy = {}
        }
        return a(Nt, 'Parser'), (Nt.prototype = Me), (Me.Parser = Nt), new Nt()
      })()
      kN.parser = kN
      B_ = kN
    })
  var Wnt,
    Wy,
    Unt = x(() => {
      'use strict'
      pe()
      Be()
      ;(Wnt = ['#', '+', '~', '-', '']),
        (Wy = class {
          static {
            a(this, 'ClassMember')
          }
          constructor(t, r) {
            ;(this.memberType = r), (this.visibility = ''), (this.classifier = ''), (this.text = '')
            let n = Ie(t, K())
            this.parseMember(n)
          }
          getDisplayDetails() {
            let t = this.visibility + eo(this.id)
            this.memberType === 'method' &&
              ((t += `(${eo(this.parameters.trim())})`), this.returnType && (t += ' : ' + eo(this.returnType))),
              (t = t.trim())
            let r = this.parseClassifier()
            return { displayText: t, cssStyle: r }
          }
          parseMember(t) {
            let r = ''
            if (this.memberType === 'method') {
              let s = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(t)
              if (s) {
                let o = s[1] ? s[1].trim() : ''
                if (
                  (Wnt.includes(o) && (this.visibility = o),
                  (this.id = s[2]),
                  (this.parameters = s[3] ? s[3].trim() : ''),
                  (r = s[4] ? s[4].trim() : ''),
                  (this.returnType = s[5] ? s[5].trim() : ''),
                  r === '')
                ) {
                  let l = this.returnType.substring(this.returnType.length - 1)
                  ;/[$*]/.exec(l) &&
                    ((r = l), (this.returnType = this.returnType.substring(0, this.returnType.length - 1)))
                }
              }
            } else {
              let i = t.length,
                s = t.substring(0, 1),
                o = t.substring(i - 1)
              Wnt.includes(s) && (this.visibility = s),
                /[$*]/.exec(o) && (r = o),
                (this.id = t.substring(this.visibility === '' ? 0 : 1, r === '' ? i : i - 1))
            }
            ;(this.classifier = r), (this.id = this.id.startsWith(' ') ? ' ' + this.id.trim() : this.id.trim())
            let n = `${this.visibility ? '\\' + this.visibility : ''}${eo(this.id)}${this.memberType === 'method' ? `(${eo(this.parameters)})${this.returnType ? ' : ' + eo(this.returnType) : ''}` : ''}`
            ;(this.text = n.replaceAll('<', '&lt;').replaceAll('>', '&gt;')),
              this.text.startsWith('\\&lt;') && (this.text = this.text.replace('\\&lt;', '~'))
          }
          parseClassifier() {
            switch (this.classifier) {
              case '*':
                return 'font-style:italic;'
              case '$':
                return 'text-decoration:underline;'
              default:
                return ''
            }
          }
        })
    })
  var F_,
    jnt,
    Zh,
    Cm,
    SN = x(() => {
      'use strict'
      Ge()
      Vt()
      pe()
      Be()
      Ce()
      bn()
      Unt()
      ;(F_ = 'classId-'),
        (jnt = 0),
        (Zh = a((e) => Rt.sanitizeText(e, K()), 'sanitizeText')),
        (Cm = class {
          constructor() {
            this.relations = []
            this.classes = new Map()
            this.styleClasses = new Map()
            this.notes = []
            this.interfaces = []
            this.namespaces = new Map()
            this.namespaceCounter = 0
            this.functions = []
            this.lineType = { LINE: 0, DOTTED_LINE: 1 }
            this.relationType = { AGGREGATION: 0, EXTENSION: 1, COMPOSITION: 2, DEPENDENCY: 3, LOLLIPOP: 4 }
            this.setupToolTips = a((t) => {
              let r = xt('.mermaidTooltip')
              ;(r._groups || r)[0][0] === null &&
                (r = xt('body').append('div').attr('class', 'mermaidTooltip').style('opacity', 0)),
                xt(t)
                  .select('svg')
                  .selectAll('g.node')
                  .on('mouseover', (s) => {
                    let o = xt(s.currentTarget)
                    if (o.attr('title') === null) return
                    let u = this.getBoundingClientRect()
                    r.transition().duration(200).style('opacity', '.9'),
                      r
                        .text(o.attr('title'))
                        .style('left', window.scrollX + u.left + (u.right - u.left) / 2 + 'px')
                        .style('top', window.scrollY + u.top - 14 + document.body.scrollTop + 'px'),
                      r.html(r.html().replace(/&lt;br\/&gt;/g, '<br/>')),
                      o.classed('hover', !0)
                  })
                  .on('mouseout', (s) => {
                    r.transition().duration(500).style('opacity', 0), xt(s.currentTarget).classed('hover', !1)
                  })
            }, 'setupToolTips')
            this.direction = 'TB'
            this.setAccTitle = Xe
            this.getAccTitle = tr
            this.setAccDescription = er
            this.getAccDescription = rr
            this.setDiagramTitle = lr
            this.getDiagramTitle = nr
            this.getConfig = a(() => K().class, 'getConfig')
            this.functions.push(this.setupToolTips.bind(this)),
              this.clear(),
              (this.addRelation = this.addRelation.bind(this)),
              (this.addClassesToNamespace = this.addClassesToNamespace.bind(this)),
              (this.addNamespace = this.addNamespace.bind(this)),
              (this.setCssClass = this.setCssClass.bind(this)),
              (this.addMembers = this.addMembers.bind(this)),
              (this.addClass = this.addClass.bind(this)),
              (this.setClassLabel = this.setClassLabel.bind(this)),
              (this.addAnnotation = this.addAnnotation.bind(this)),
              (this.addMember = this.addMember.bind(this)),
              (this.cleanupLabel = this.cleanupLabel.bind(this)),
              (this.addNote = this.addNote.bind(this)),
              (this.defineClass = this.defineClass.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.setLink = this.setLink.bind(this)),
              (this.bindFunctions = this.bindFunctions.bind(this)),
              (this.clear = this.clear.bind(this)),
              (this.setTooltip = this.setTooltip.bind(this)),
              (this.setClickEvent = this.setClickEvent.bind(this)),
              (this.setCssStyle = this.setCssStyle.bind(this))
          }
          static {
            a(this, 'ClassDB')
          }
          splitClassNameAndType(t) {
            let r = Rt.sanitizeText(t, K()),
              n = '',
              i = r
            if (r.indexOf('~') > 0) {
              let s = r.split('~')
              ;(i = Zh(s[0])), (n = Zh(s[1]))
            }
            return { className: i, type: n }
          }
          setClassLabel(t, r) {
            let n = Rt.sanitizeText(t, K())
            r && (r = Zh(r))
            let { className: i } = this.splitClassNameAndType(n)
            ;(this.classes.get(i).label = r),
              (this.classes.get(i).text = `${r}${this.classes.get(i).type ? `<${this.classes.get(i).type}>` : ''}`)
          }
          addClass(t) {
            let r = Rt.sanitizeText(t, K()),
              { className: n, type: i } = this.splitClassNameAndType(r)
            if (this.classes.has(n)) return
            let s = Rt.sanitizeText(n, K())
            this.classes.set(s, {
              id: s,
              type: i,
              label: s,
              text: `${s}${i ? `&lt;${i}&gt;` : ''}`,
              shape: 'classBox',
              cssClasses: 'default',
              methods: [],
              members: [],
              annotations: [],
              styles: [],
              domId: F_ + s + '-' + jnt,
            }),
              jnt++
          }
          addInterface(t, r) {
            let n = { id: `interface${this.interfaces.length}`, label: t, classId: r }
            this.interfaces.push(n)
          }
          lookUpDomId(t) {
            let r = Rt.sanitizeText(t, K())
            if (this.classes.has(r)) return this.classes.get(r).domId
            throw new Error('Class not found: ' + r)
          }
          clear() {
            ;(this.relations = []),
              (this.classes = new Map()),
              (this.notes = []),
              (this.interfaces = []),
              (this.functions = []),
              this.functions.push(this.setupToolTips.bind(this)),
              (this.namespaces = new Map()),
              (this.namespaceCounter = 0),
              (this.direction = 'TB'),
              Ye()
          }
          getClass(t) {
            return this.classes.get(t)
          }
          getClasses() {
            return this.classes
          }
          getRelations() {
            return this.relations
          }
          getNotes() {
            return this.notes
          }
          addRelation(t) {
            B.debug('Adding relation: ' + JSON.stringify(t))
            let r = [
              this.relationType.LOLLIPOP,
              this.relationType.AGGREGATION,
              this.relationType.COMPOSITION,
              this.relationType.DEPENDENCY,
              this.relationType.EXTENSION,
            ]
            t.relation.type1 === this.relationType.LOLLIPOP && !r.includes(t.relation.type2)
              ? (this.addClass(t.id2),
                this.addInterface(t.id1, t.id2),
                (t.id1 = `interface${this.interfaces.length - 1}`))
              : t.relation.type2 === this.relationType.LOLLIPOP && !r.includes(t.relation.type1)
                ? (this.addClass(t.id1),
                  this.addInterface(t.id2, t.id1),
                  (t.id2 = `interface${this.interfaces.length - 1}`))
                : (this.addClass(t.id1), this.addClass(t.id2)),
              (t.id1 = this.splitClassNameAndType(t.id1).className),
              (t.id2 = this.splitClassNameAndType(t.id2).className),
              (t.relationTitle1 = Rt.sanitizeText(t.relationTitle1.trim(), K())),
              (t.relationTitle2 = Rt.sanitizeText(t.relationTitle2.trim(), K())),
              this.relations.push(t)
          }
          addAnnotation(t, r) {
            let n = this.splitClassNameAndType(t).className
            this.classes.get(n).annotations.push(r)
          }
          addMember(t, r) {
            this.addClass(t)
            let n = this.splitClassNameAndType(t).className,
              i = this.classes.get(n)
            if (typeof r == 'string') {
              let s = r.trim()
              s.startsWith('<<') && s.endsWith('>>')
                ? i.annotations.push(Zh(s.substring(2, s.length - 2)))
                : s.indexOf(')') > 0
                  ? i.methods.push(new Wy(s, 'method'))
                  : s && i.members.push(new Wy(s, 'attribute'))
            }
          }
          addMembers(t, r) {
            Array.isArray(r) && (r.reverse(), r.forEach((n) => this.addMember(t, n)))
          }
          addNote(t, r) {
            let n = { id: `note${this.notes.length}`, class: r, text: t }
            this.notes.push(n)
          }
          cleanupLabel(t) {
            return t.startsWith(':') && (t = t.substring(1)), Zh(t.trim())
          }
          setCssClass(t, r) {
            t.split(',').forEach((n) => {
              let i = n
              ;/\d/.exec(n[0]) && (i = F_ + i)
              let s = this.classes.get(i)
              s && (s.cssClasses += ' ' + r)
            })
          }
          defineClass(t, r) {
            for (let n of t) {
              let i = this.styleClasses.get(n)
              i === void 0 && ((i = { id: n, styles: [], textStyles: [] }), this.styleClasses.set(n, i)),
                r &&
                  r.forEach((s) => {
                    if (/color/.exec(s)) {
                      let o = s.replace('fill', 'bgFill')
                      i.textStyles.push(o)
                    }
                    i.styles.push(s)
                  }),
                this.classes.forEach((s) => {
                  s.cssClasses.includes(n) && s.styles.push(...r.flatMap((o) => o.split(',')))
                })
            }
          }
          setTooltip(t, r) {
            t.split(',').forEach((n) => {
              r !== void 0 && (this.classes.get(n).tooltip = Zh(r))
            })
          }
          getTooltip(t, r) {
            return r && this.namespaces.has(r)
              ? this.namespaces.get(r).classes.get(t).tooltip
              : this.classes.get(t).tooltip
          }
          setLink(t, r, n) {
            let i = K()
            t.split(',').forEach((s) => {
              let o = s
              ;/\d/.exec(s[0]) && (o = F_ + o)
              let l = this.classes.get(o)
              l &&
                ((l.link = le.formatUrl(r, i)),
                i.securityLevel === 'sandbox'
                  ? (l.linkTarget = '_top')
                  : typeof n == 'string'
                    ? (l.linkTarget = Zh(n))
                    : (l.linkTarget = '_blank'))
            }),
              this.setCssClass(t, 'clickable')
          }
          setClickEvent(t, r, n) {
            t.split(',').forEach((i) => {
              this.setClickFunc(i, r, n), (this.classes.get(i).haveCallback = !0)
            }),
              this.setCssClass(t, 'clickable')
          }
          setClickFunc(t, r, n) {
            let i = Rt.sanitizeText(t, K())
            if (K().securityLevel !== 'loose' || r === void 0) return
            let o = i
            if (this.classes.has(o)) {
              let l = this.lookUpDomId(o),
                u = []
              if (typeof n == 'string') {
                u = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
                for (let h = 0; h < u.length; h++) {
                  let f = u[h].trim()
                  f.startsWith('"') && f.endsWith('"') && (f = f.substr(1, f.length - 2)), (u[h] = f)
                }
              }
              u.length === 0 && u.push(l),
                this.functions.push(() => {
                  let h = document.querySelector(`[id="${l}"]`)
                  h !== null &&
                    h.addEventListener(
                      'click',
                      () => {
                        le.runFunc(r, ...u)
                      },
                      !1,
                    )
                })
            }
          }
          bindFunctions(t) {
            this.functions.forEach((r) => {
              r(t)
            })
          }
          getDirection() {
            return this.direction
          }
          setDirection(t) {
            this.direction = t
          }
          addNamespace(t) {
            this.namespaces.has(t) ||
              (this.namespaces.set(t, {
                id: t,
                classes: new Map(),
                children: {},
                domId: F_ + t + '-' + this.namespaceCounter,
              }),
              this.namespaceCounter++)
          }
          getNamespace(t) {
            return this.namespaces.get(t)
          }
          getNamespaces() {
            return this.namespaces
          }
          addClassesToNamespace(t, r) {
            if (this.namespaces.has(t))
              for (let n of r) {
                let { className: i } = this.splitClassNameAndType(n)
                ;(this.classes.get(i).parent = t), this.namespaces.get(t).classes.set(i, this.classes.get(i))
              }
          }
          setCssStyle(t, r) {
            let n = this.classes.get(t)
            if (!(!r || !n)) for (let i of r) i.includes(',') ? n.styles.push(...i.split(',')) : n.styles.push(i)
          }
          getArrowMarker(t) {
            let r
            switch (t) {
              case 0:
                r = 'aggregation'
                break
              case 1:
                r = 'extension'
                break
              case 2:
                r = 'composition'
                break
              case 3:
                r = 'dependency'
                break
              case 4:
                r = 'lollipop'
                break
              default:
                r = 'none'
            }
            return r
          }
          getData() {
            let t = [],
              r = [],
              n = K()
            for (let s of this.namespaces.keys()) {
              let o = this.namespaces.get(s)
              if (o) {
                let l = {
                  id: o.id,
                  label: o.id,
                  isGroup: !0,
                  padding: n.class.padding ?? 16,
                  shape: 'rect',
                  cssStyles: ['fill: none', 'stroke: black'],
                  look: n.look,
                }
                t.push(l)
              }
            }
            for (let s of this.classes.keys()) {
              let o = this.classes.get(s)
              if (o) {
                let l = o
                ;(l.parentId = o.parent), (l.look = n.look), t.push(l)
              }
            }
            let i = 0
            for (let s of this.notes) {
              i++
              let o = {
                id: s.id,
                label: s.text,
                isGroup: !1,
                shape: 'note',
                padding: n.class.padding ?? 6,
                cssStyles: [
                  'text-align: left',
                  'white-space: nowrap',
                  `fill: ${n.themeVariables.noteBkgColor}`,
                  `stroke: ${n.themeVariables.noteBorderColor}`,
                ],
                look: n.look,
              }
              t.push(o)
              let l = this.classes.get(s.class)?.id ?? ''
              if (l) {
                let u = {
                  id: `edgeNote${i}`,
                  start: s.id,
                  end: l,
                  type: 'normal',
                  thickness: 'normal',
                  classes: 'relation',
                  arrowTypeStart: 'none',
                  arrowTypeEnd: 'none',
                  arrowheadStyle: '',
                  labelStyle: [''],
                  style: ['fill: none'],
                  pattern: 'dotted',
                  look: n.look,
                }
                r.push(u)
              }
            }
            for (let s of this.interfaces) {
              let o = { id: s.id, label: s.label, isGroup: !1, shape: 'rect', cssStyles: ['opacity: 0;'], look: n.look }
              t.push(o)
            }
            i = 0
            for (let s of this.relations) {
              i++
              let o = {
                id: kc(s.id1, s.id2, { prefix: 'id', counter: i }),
                start: s.id1,
                end: s.id2,
                type: 'normal',
                label: s.title,
                labelpos: 'c',
                thickness: 'normal',
                classes: 'relation',
                arrowTypeStart: this.getArrowMarker(s.relation.type1),
                arrowTypeEnd: this.getArrowMarker(s.relation.type2),
                startLabelRight: s.relationTitle1 === 'none' ? '' : s.relationTitle1,
                endLabelLeft: s.relationTitle2 === 'none' ? '' : s.relationTitle2,
                arrowheadStyle: '',
                labelStyle: ['display: inline-block'],
                style: s.style || '',
                pattern: s.relation.lineType == 1 ? 'dashed' : 'solid',
                look: n.look,
              }
              r.push(o)
            }
            return { nodes: t, edges: r, other: {}, config: n, direction: this.getDirection() }
          }
        })
    })
  var kDt,
    $_,
    _N = x(() => {
      'use strict'
      Md()
      ;(kDt = a(
        (e) => `g.classGroup text {
  fill: ${e.nodeBorder || e.classText};
  stroke: none;
  font-family: ${e.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${e.classText};
}
.edgeLabel .label rect {
  fill: ${e.mainBkg};
}
.label text {
  fill: ${e.classText};
}

.labelBkg {
  background: ${e.mainBkg};
}
.edgeLabel .label span {
  background: ${e.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.classGroup line {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${e.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${e.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
  ${No()}
`,
        'getStyles',
      )),
        ($_ = kDt)
    })
  var TDt,
    SDt,
    _Dt,
    G_,
    CN = x(() => {
      'use strict'
      pe()
      Vt()
      hd()
      ph()
      mh()
      Ce()
      ;(TDt = a((e, t = 'TB') => {
        if (!e.doc) return t
        let r = t
        for (let n of e.doc) n.stmt === 'dir' && (r = n.value)
        return r
      }, 'getDir')),
        (SDt = a(function (e, t) {
          return t.db.getClasses()
        }, 'getClasses')),
        (_Dt = a(async function (e, t, r, n) {
          B.info('REF0:'), B.info('Drawing class diagram (v3)', t)
          let { securityLevel: i, state: s, layout: o } = K(),
            l = n.db.getData(),
            u = So(t, i)
          ;(l.type = n.type),
            (l.layoutAlgorithm = Gc(o)),
            (l.nodeSpacing = s?.nodeSpacing || 50),
            (l.rankSpacing = s?.rankSpacing || 50),
            (l.markers = ['aggregation', 'extension', 'composition', 'dependency', 'lollipop']),
            (l.diagramId = t),
            await Do(l, u)
          let h = 8
          le.insertTitle(u, 'classDiagramTitleText', s?.titleTopMargin ?? 25, n.db.getDiagramTitle()),
            la(u, h, 'classDiagram', s?.useMaxWidth ?? !0)
        }, 'draw')),
        (G_ = { getClasses: SDt, draw: _Dt, getDir: TDt })
    })
  var qnt = {}
  Oe(qnt, { diagram: () => CDt })
  var CDt,
    Hnt = x(() => {
      'use strict'
      TN()
      SN()
      _N()
      CN()
      CDt = {
        parser: B_,
        get db() {
          return new Cm()
        },
        renderer: G_,
        styles: $_,
        init: a((e) => {
          e.class || (e.class = {}), (e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute)
        }, 'init'),
      }
    })
  var Knt = {}
  Oe(Knt, { diagram: () => ADt })
  var ADt,
    Qnt = x(() => {
      'use strict'
      TN()
      SN()
      _N()
      CN()
      ADt = {
        parser: B_,
        get db() {
          return new Cm()
        },
        renderer: G_,
        styles: $_,
        init: a((e) => {
          e.class || (e.class = {}), (e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute)
        }, 'init'),
      }
    })
  var wN,
    V_,
    EN = x(() => {
      'use strict'
      wN = (function () {
        var e = a(function (M, V, $, q) {
            for ($ = $ || {}, q = M.length; q--; $[M[q]] = V);
            return $
          }, 'o'),
          t = [1, 2],
          r = [1, 3],
          n = [1, 4],
          i = [2, 4],
          s = [1, 9],
          o = [1, 11],
          l = [1, 16],
          u = [1, 17],
          h = [1, 18],
          f = [1, 19],
          d = [1, 33],
          p = [1, 20],
          m = [1, 21],
          g = [1, 22],
          y = [1, 23],
          b = [1, 24],
          k = [1, 26],
          T = [1, 27],
          C = [1, 28],
          A = [1, 29],
          w = [1, 30],
          D = [1, 31],
          G = [1, 32],
          v = [1, 35],
          R = [1, 36],
          F = [1, 37],
          S = [1, 38],
          O = [1, 34],
          E = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57],
          _ = [
            1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 39, 40, 41, 45, 48, 51, 52, 53,
            54, 57,
          ],
          L = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57],
          N = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SPACE: 4,
              NL: 5,
              SD: 6,
              document: 7,
              line: 8,
              statement: 9,
              classDefStatement: 10,
              styleStatement: 11,
              cssClassStatement: 12,
              idStatement: 13,
              DESCR: 14,
              '-->': 15,
              HIDE_EMPTY: 16,
              scale: 17,
              WIDTH: 18,
              COMPOSIT_STATE: 19,
              STRUCT_START: 20,
              STRUCT_STOP: 21,
              STATE_DESCR: 22,
              AS: 23,
              ID: 24,
              FORK: 25,
              JOIN: 26,
              CHOICE: 27,
              CONCURRENT: 28,
              note: 29,
              notePosition: 30,
              NOTE_TEXT: 31,
              direction: 32,
              acc_title: 33,
              acc_title_value: 34,
              acc_descr: 35,
              acc_descr_value: 36,
              acc_descr_multiline_value: 37,
              CLICK: 38,
              STRING: 39,
              HREF: 40,
              classDef: 41,
              CLASSDEF_ID: 42,
              CLASSDEF_STYLEOPTS: 43,
              DEFAULT: 44,
              style: 45,
              STYLE_IDS: 46,
              STYLEDEF_STYLEOPTS: 47,
              class: 48,
              CLASSENTITY_IDS: 49,
              STYLECLASS: 50,
              direction_tb: 51,
              direction_bt: 52,
              direction_rl: 53,
              direction_lr: 54,
              eol: 55,
              ';': 56,
              EDGE_STATE: 57,
              STYLE_SEPARATOR: 58,
              left_of: 59,
              right_of: 60,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'SPACE',
              5: 'NL',
              6: 'SD',
              14: 'DESCR',
              15: '-->',
              16: 'HIDE_EMPTY',
              17: 'scale',
              18: 'WIDTH',
              19: 'COMPOSIT_STATE',
              20: 'STRUCT_START',
              21: 'STRUCT_STOP',
              22: 'STATE_DESCR',
              23: 'AS',
              24: 'ID',
              25: 'FORK',
              26: 'JOIN',
              27: 'CHOICE',
              28: 'CONCURRENT',
              29: 'note',
              31: 'NOTE_TEXT',
              33: 'acc_title',
              34: 'acc_title_value',
              35: 'acc_descr',
              36: 'acc_descr_value',
              37: 'acc_descr_multiline_value',
              38: 'CLICK',
              39: 'STRING',
              40: 'HREF',
              41: 'classDef',
              42: 'CLASSDEF_ID',
              43: 'CLASSDEF_STYLEOPTS',
              44: 'DEFAULT',
              45: 'style',
              46: 'STYLE_IDS',
              47: 'STYLEDEF_STYLEOPTS',
              48: 'class',
              49: 'CLASSENTITY_IDS',
              50: 'STYLECLASS',
              51: 'direction_tb',
              52: 'direction_bt',
              53: 'direction_rl',
              54: 'direction_lr',
              56: ';',
              57: 'EDGE_STATE',
              58: 'STYLE_SEPARATOR',
              59: 'left_of',
              60: 'right_of',
            },
            productions_: [
              0,
              [3, 2],
              [3, 2],
              [3, 2],
              [7, 0],
              [7, 2],
              [8, 2],
              [8, 1],
              [8, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 3],
              [9, 4],
              [9, 1],
              [9, 2],
              [9, 1],
              [9, 4],
              [9, 3],
              [9, 6],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 4],
              [9, 4],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 5],
              [9, 5],
              [10, 3],
              [10, 3],
              [11, 3],
              [12, 3],
              [32, 1],
              [32, 1],
              [32, 1],
              [32, 1],
              [55, 1],
              [55, 1],
              [13, 1],
              [13, 1],
              [13, 3],
              [13, 3],
              [30, 1],
              [30, 1],
            ],
            performAction: a(function (V, $, q, tt, ft, H, kt) {
              var ht = H.length - 1
              switch (ft) {
                case 3:
                  return tt.setRootDoc(H[ht]), H[ht]
                  break
                case 4:
                  this.$ = []
                  break
                case 5:
                  H[ht] != 'nl' && (H[ht - 1].push(H[ht]), (this.$ = H[ht - 1]))
                  break
                case 6:
                case 7:
                  this.$ = H[ht]
                  break
                case 8:
                  this.$ = 'nl'
                  break
                case 12:
                  this.$ = H[ht]
                  break
                case 13:
                  let it = H[ht - 1]
                  ;(it.description = tt.trimColon(H[ht])), (this.$ = it)
                  break
                case 14:
                  this.$ = { stmt: 'relation', state1: H[ht - 2], state2: H[ht] }
                  break
                case 15:
                  let Q = tt.trimColon(H[ht])
                  this.$ = { stmt: 'relation', state1: H[ht - 3], state2: H[ht - 1], description: Q }
                  break
                case 19:
                  this.$ = { stmt: 'state', id: H[ht - 3], type: 'default', description: '', doc: H[ht - 1] }
                  break
                case 20:
                  var yt = H[ht],
                    ot = H[ht - 2].trim()
                  if (H[ht].match(':')) {
                    var dt = H[ht].split(':')
                    ;(yt = dt[0]), (ot = [ot, dt[1]])
                  }
                  this.$ = { stmt: 'state', id: yt, type: 'default', description: ot }
                  break
                case 21:
                  this.$ = { stmt: 'state', id: H[ht - 3], type: 'default', description: H[ht - 5], doc: H[ht - 1] }
                  break
                case 22:
                  this.$ = { stmt: 'state', id: H[ht], type: 'fork' }
                  break
                case 23:
                  this.$ = { stmt: 'state', id: H[ht], type: 'join' }
                  break
                case 24:
                  this.$ = { stmt: 'state', id: H[ht], type: 'choice' }
                  break
                case 25:
                  this.$ = { stmt: 'state', id: tt.getDividerId(), type: 'divider' }
                  break
                case 26:
                  this.$ = {
                    stmt: 'state',
                    id: H[ht - 1].trim(),
                    note: { position: H[ht - 2].trim(), text: H[ht].trim() },
                  }
                  break
                case 29:
                  ;(this.$ = H[ht].trim()), tt.setAccTitle(this.$)
                  break
                case 30:
                case 31:
                  ;(this.$ = H[ht].trim()), tt.setAccDescription(this.$)
                  break
                case 32:
                  this.$ = { stmt: 'click', id: H[ht - 3], url: H[ht - 2], tooltip: H[ht - 1] }
                  break
                case 33:
                  this.$ = { stmt: 'click', id: H[ht - 3], url: H[ht - 1], tooltip: '' }
                  break
                case 34:
                case 35:
                  this.$ = { stmt: 'classDef', id: H[ht - 1].trim(), classes: H[ht].trim() }
                  break
                case 36:
                  this.$ = { stmt: 'style', id: H[ht - 1].trim(), styleClass: H[ht].trim() }
                  break
                case 37:
                  this.$ = { stmt: 'applyClass', id: H[ht - 1].trim(), styleClass: H[ht].trim() }
                  break
                case 38:
                  tt.setDirection('TB'), (this.$ = { stmt: 'dir', value: 'TB' })
                  break
                case 39:
                  tt.setDirection('BT'), (this.$ = { stmt: 'dir', value: 'BT' })
                  break
                case 40:
                  tt.setDirection('RL'), (this.$ = { stmt: 'dir', value: 'RL' })
                  break
                case 41:
                  tt.setDirection('LR'), (this.$ = { stmt: 'dir', value: 'LR' })
                  break
                case 44:
                case 45:
                  this.$ = { stmt: 'state', id: H[ht].trim(), type: 'default', description: '' }
                  break
                case 46:
                  this.$ = {
                    stmt: 'state',
                    id: H[ht - 2].trim(),
                    classes: [H[ht].trim()],
                    type: 'default',
                    description: '',
                  }
                  break
                case 47:
                  this.$ = {
                    stmt: 'state',
                    id: H[ht - 2].trim(),
                    classes: [H[ht].trim()],
                    type: 'default',
                    description: '',
                  }
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: t, 5: r, 6: n },
              { 1: [3] },
              { 3: 5, 4: t, 5: r, 6: n },
              { 3: 6, 4: t, 5: r, 6: n },
              e([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], i, {
                7: 7,
              }),
              { 1: [2, 1] },
              { 1: [2, 2] },
              {
                1: [2, 3],
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: A,
                41: w,
                45: D,
                48: G,
                51: v,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(E, [2, 5]),
              {
                9: 39,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: A,
                41: w,
                45: D,
                48: G,
                51: v,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(E, [2, 7]),
              e(E, [2, 8]),
              e(E, [2, 9]),
              e(E, [2, 10]),
              e(E, [2, 11]),
              e(E, [2, 12], { 14: [1, 40], 15: [1, 41] }),
              e(E, [2, 16]),
              { 18: [1, 42] },
              e(E, [2, 18], { 20: [1, 43] }),
              { 23: [1, 44] },
              e(E, [2, 22]),
              e(E, [2, 23]),
              e(E, [2, 24]),
              e(E, [2, 25]),
              { 30: 45, 31: [1, 46], 59: [1, 47], 60: [1, 48] },
              e(E, [2, 28]),
              { 34: [1, 49] },
              { 36: [1, 50] },
              e(E, [2, 31]),
              { 13: 51, 24: d, 57: O },
              { 42: [1, 52], 44: [1, 53] },
              { 46: [1, 54] },
              { 49: [1, 55] },
              e(_, [2, 44], { 58: [1, 56] }),
              e(_, [2, 45], { 58: [1, 57] }),
              e(E, [2, 38]),
              e(E, [2, 39]),
              e(E, [2, 40]),
              e(E, [2, 41]),
              e(E, [2, 6]),
              e(E, [2, 13]),
              { 13: 58, 24: d, 57: O },
              e(E, [2, 17]),
              e(L, i, { 7: 59 }),
              { 24: [1, 60] },
              { 24: [1, 61] },
              { 23: [1, 62] },
              { 24: [2, 48] },
              { 24: [2, 49] },
              e(E, [2, 29]),
              e(E, [2, 30]),
              { 39: [1, 63], 40: [1, 64] },
              { 43: [1, 65] },
              { 43: [1, 66] },
              { 47: [1, 67] },
              { 50: [1, 68] },
              { 24: [1, 69] },
              { 24: [1, 70] },
              e(E, [2, 14], { 14: [1, 71] }),
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                21: [1, 72],
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: A,
                41: w,
                45: D,
                48: G,
                51: v,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(E, [2, 20], { 20: [1, 73] }),
              { 31: [1, 74] },
              { 24: [1, 75] },
              { 39: [1, 76] },
              { 39: [1, 77] },
              e(E, [2, 34]),
              e(E, [2, 35]),
              e(E, [2, 36]),
              e(E, [2, 37]),
              e(_, [2, 46]),
              e(_, [2, 47]),
              e(E, [2, 15]),
              e(E, [2, 19]),
              e(L, i, { 7: 78 }),
              e(E, [2, 26]),
              e(E, [2, 27]),
              { 5: [1, 79] },
              { 5: [1, 80] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                21: [1, 81],
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: A,
                41: w,
                45: D,
                48: G,
                51: v,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(E, [2, 32]),
              e(E, [2, 33]),
              e(E, [2, 21]),
            ],
            defaultActions: { 5: [2, 1], 6: [2, 2], 47: [2, 48], 48: [2, 49] },
            parseError: a(function (V, $) {
              if ($.recoverable) this.trace(V)
              else {
                var q = new Error(V)
                throw ((q.hash = $), q)
              }
            }, 'parseError'),
            parse: a(function (V) {
              var $ = this,
                q = [0],
                tt = [],
                ft = [null],
                H = [],
                kt = this.table,
                ht = '',
                yt = 0,
                ot = 0,
                dt = 0,
                it = 2,
                Q = 1,
                et = H.slice.call(arguments, 1),
                X = Object.create(this.lexer),
                st = { yy: {} }
              for (var U in this.yy) Object.prototype.hasOwnProperty.call(this.yy, U) && (st.yy[U] = this.yy[U])
              X.setInput(V, st.yy), (st.yy.lexer = X), (st.yy.parser = this), typeof X.yylloc > 'u' && (X.yylloc = {})
              var gt = X.yylloc
              H.push(gt)
              var z = X.options && X.options.ranges
              typeof st.yy.parseError == 'function'
                ? (this.parseError = st.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function ge(j) {
                ;(q.length = q.length - 2 * j), (ft.length = ft.length - j), (H.length = H.length - j)
              }
              a(ge, 'popStack')
              function lt() {
                var j
                return (
                  (j = tt.pop() || X.lex() || Q),
                  typeof j != 'number' && (j instanceof Array && ((tt = j), (j = tt.pop())), (j = $.symbols_[j] || j)),
                  j
                )
              }
              a(lt, 'lex')
              for (var jt, Me, se, Nt, At, bt, ct = {}, Lt, Z, Mt, W; ; ) {
                if (
                  ((se = q[q.length - 1]),
                  this.defaultActions[se]
                    ? (Nt = this.defaultActions[se])
                    : ((jt === null || typeof jt > 'u') && (jt = lt()), (Nt = kt[se] && kt[se][jt])),
                  typeof Nt > 'u' || !Nt.length || !Nt[0])
                ) {
                  var Gt = ''
                  W = []
                  for (Lt in kt[se]) this.terminals_[Lt] && Lt > it && W.push("'" + this.terminals_[Lt] + "'")
                  X.showPosition
                    ? (Gt =
                        'Parse error on line ' +
                        (yt + 1) +
                        `:
` +
                        X.showPosition() +
                        `
Expecting ` +
                        W.join(', ') +
                        ", got '" +
                        (this.terminals_[jt] || jt) +
                        "'")
                    : (Gt =
                        'Parse error on line ' +
                        (yt + 1) +
                        ': Unexpected ' +
                        (jt == Q ? 'end of input' : "'" + (this.terminals_[jt] || jt) + "'")),
                    this.parseError(Gt, {
                      text: X.match,
                      token: this.terminals_[jt] || jt,
                      line: X.yylineno,
                      loc: gt,
                      expected: W,
                    })
                }
                if (Nt[0] instanceof Array && Nt.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + se + ', token: ' + jt)
                switch (Nt[0]) {
                  case 1:
                    q.push(jt),
                      ft.push(X.yytext),
                      H.push(X.yylloc),
                      q.push(Nt[1]),
                      (jt = null),
                      Me
                        ? ((jt = Me), (Me = null))
                        : ((ot = X.yyleng), (ht = X.yytext), (yt = X.yylineno), (gt = X.yylloc), dt > 0 && dt--)
                    break
                  case 2:
                    if (
                      ((Z = this.productions_[Nt[1]][1]),
                      (ct.$ = ft[ft.length - Z]),
                      (ct._$ = {
                        first_line: H[H.length - (Z || 1)].first_line,
                        last_line: H[H.length - 1].last_line,
                        first_column: H[H.length - (Z || 1)].first_column,
                        last_column: H[H.length - 1].last_column,
                      }),
                      z && (ct._$.range = [H[H.length - (Z || 1)].range[0], H[H.length - 1].range[1]]),
                      (bt = this.performAction.apply(ct, [ht, ot, yt, st.yy, Nt[1], ft, H].concat(et))),
                      typeof bt < 'u')
                    )
                      return bt
                    Z && ((q = q.slice(0, -1 * Z * 2)), (ft = ft.slice(0, -1 * Z)), (H = H.slice(0, -1 * Z))),
                      q.push(this.productions_[Nt[1]][0]),
                      ft.push(ct.$),
                      H.push(ct._$),
                      (Mt = kt[q[q.length - 2]][q[q.length - 1]]),
                      q.push(Mt)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          P = (function () {
            var M = {
              EOF: 1,
              parseError: a(function ($, q) {
                if (this.yy.parser) this.yy.parser.parseError($, q)
                else throw new Error($)
              }, 'parseError'),
              setInput: a(function (V, $) {
                return (
                  (this.yy = $ || this.yy || {}),
                  (this._input = V),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var V = this._input[0]
                ;(this.yytext += V), this.yyleng++, this.offset++, (this.match += V), (this.matched += V)
                var $ = V.match(/(?:\r\n?|\n).*/g)
                return (
                  $ ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  V
                )
              }, 'input'),
              unput: a(function (V) {
                var $ = V.length,
                  q = V.split(/(?:\r\n?|\n)/g)
                ;(this._input = V + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - $)),
                  (this.offset -= $)
                var tt = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  q.length - 1 && (this.yylineno -= q.length - 1)
                var ft = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: q
                      ? (q.length === tt.length ? this.yylloc.first_column : 0) +
                        tt[tt.length - q.length].length -
                        q[0].length
                      : this.yylloc.first_column - $,
                  }),
                  this.options.ranges && (this.yylloc.range = [ft[0], ft[0] + this.yyleng - $]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (V) {
                this.unput(this.match.slice(V))
              }, 'less'),
              pastInput: a(function () {
                var V = this.matched.substr(0, this.matched.length - this.match.length)
                return (V.length > 20 ? '...' : '') + V.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var V = this.match
                return (
                  V.length < 20 && (V += this._input.substr(0, 20 - V.length)),
                  (V.substr(0, 20) + (V.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var V = this.pastInput(),
                  $ = new Array(V.length + 1).join('-')
                return (
                  V +
                  this.upcomingInput() +
                  `
` +
                  $ +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (V, $) {
                var q, tt, ft
                if (
                  (this.options.backtrack_lexer &&
                    ((ft = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (ft.yylloc.range = this.yylloc.range.slice(0))),
                  (tt = V[0].match(/(?:\r\n?|\n).*/g)),
                  tt && (this.yylineno += tt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: tt
                      ? tt[tt.length - 1].length - tt[tt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + V[0].length,
                  }),
                  (this.yytext += V[0]),
                  (this.match += V[0]),
                  (this.matches = V),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(V[0].length)),
                  (this.matched += V[0]),
                  (q = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    $,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  q)
                )
                  return q
                if (this._backtrack) {
                  for (var H in ft) this[H] = ft[H]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var V, $, q, tt
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var ft = this._currentRules(), H = 0; H < ft.length; H++)
                  if (((q = this._input.match(this.rules[ft[H]])), q && (!$ || q[0].length > $[0].length))) {
                    if ((($ = q), (tt = H), this.options.backtrack_lexer)) {
                      if (((V = this.test_match(q, ft[H])), V !== !1)) return V
                      if (this._backtrack) {
                        $ = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return $
                  ? ((V = this.test_match($, ft[tt])), V !== !1 ? V : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var $ = this.next()
                return $ || this.lex()
              }, 'lex'),
              begin: a(function ($) {
                this.conditionStack.push($)
              }, 'begin'),
              popState: a(function () {
                var $ = this.conditionStack.length - 1
                return $ > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function ($) {
                return (
                  ($ = this.conditionStack.length - 1 - Math.abs($ || 0)), $ >= 0 ? this.conditionStack[$] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function ($) {
                this.begin($)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function ($, q, tt, ft) {
                var H = ft
                switch (tt) {
                  case 0:
                    return 38
                  case 1:
                    return 40
                  case 2:
                    return 39
                  case 3:
                    return 44
                  case 4:
                    return 51
                  case 5:
                    return 52
                  case 6:
                    return 53
                  case 7:
                    return 54
                  case 8:
                    break
                  case 9:
                    break
                  case 10:
                    return 5
                  case 11:
                    break
                  case 12:
                    break
                  case 13:
                    break
                  case 14:
                    break
                  case 15:
                    return this.pushState('SCALE'), 17
                    break
                  case 16:
                    return 18
                  case 17:
                    this.popState()
                    break
                  case 18:
                    return this.begin('acc_title'), 33
                    break
                  case 19:
                    return this.popState(), 'acc_title_value'
                    break
                  case 20:
                    return this.begin('acc_descr'), 35
                    break
                  case 21:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 22:
                    this.begin('acc_descr_multiline')
                    break
                  case 23:
                    this.popState()
                    break
                  case 24:
                    return 'acc_descr_multiline_value'
                  case 25:
                    return this.pushState('CLASSDEF'), 41
                    break
                  case 26:
                    return this.popState(), this.pushState('CLASSDEFID'), 'DEFAULT_CLASSDEF_ID'
                    break
                  case 27:
                    return this.popState(), this.pushState('CLASSDEFID'), 42
                    break
                  case 28:
                    return this.popState(), 43
                    break
                  case 29:
                    return this.pushState('CLASS'), 48
                    break
                  case 30:
                    return this.popState(), this.pushState('CLASS_STYLE'), 49
                    break
                  case 31:
                    return this.popState(), 50
                    break
                  case 32:
                    return this.pushState('STYLE'), 45
                    break
                  case 33:
                    return this.popState(), this.pushState('STYLEDEF_STYLES'), 46
                    break
                  case 34:
                    return this.popState(), 47
                    break
                  case 35:
                    return this.pushState('SCALE'), 17
                    break
                  case 36:
                    return 18
                  case 37:
                    this.popState()
                    break
                  case 38:
                    this.pushState('STATE')
                    break
                  case 39:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -8).trim()), 25
                    break
                  case 40:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -8).trim()), 26
                    break
                  case 41:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -10).trim()), 27
                    break
                  case 42:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -8).trim()), 25
                    break
                  case 43:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -8).trim()), 26
                    break
                  case 44:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -10).trim()), 27
                    break
                  case 45:
                    return 51
                  case 46:
                    return 52
                  case 47:
                    return 53
                  case 48:
                    return 54
                  case 49:
                    this.pushState('STATE_STRING')
                    break
                  case 50:
                    return this.pushState('STATE_ID'), 'AS'
                    break
                  case 51:
                    return this.popState(), 'ID'
                    break
                  case 52:
                    this.popState()
                    break
                  case 53:
                    return 'STATE_DESCR'
                  case 54:
                    return 19
                  case 55:
                    this.popState()
                    break
                  case 56:
                    return this.popState(), this.pushState('struct'), 20
                    break
                  case 57:
                    break
                  case 58:
                    return this.popState(), 21
                    break
                  case 59:
                    break
                  case 60:
                    return this.begin('NOTE'), 29
                    break
                  case 61:
                    return this.popState(), this.pushState('NOTE_ID'), 59
                    break
                  case 62:
                    return this.popState(), this.pushState('NOTE_ID'), 60
                    break
                  case 63:
                    this.popState(), this.pushState('FLOATING_NOTE')
                    break
                  case 64:
                    return this.popState(), this.pushState('FLOATING_NOTE_ID'), 'AS'
                    break
                  case 65:
                    break
                  case 66:
                    return 'NOTE_TEXT'
                  case 67:
                    return this.popState(), 'ID'
                    break
                  case 68:
                    return this.popState(), this.pushState('NOTE_TEXT'), 24
                    break
                  case 69:
                    return this.popState(), (q.yytext = q.yytext.substr(2).trim()), 31
                    break
                  case 70:
                    return this.popState(), (q.yytext = q.yytext.slice(0, -8).trim()), 31
                    break
                  case 71:
                    return 6
                  case 72:
                    return 6
                  case 73:
                    return 16
                  case 74:
                    return 57
                  case 75:
                    return 24
                  case 76:
                    return (q.yytext = q.yytext.trim()), 14
                    break
                  case 77:
                    return 15
                  case 78:
                    return 28
                  case 79:
                    return 58
                  case 80:
                    return 5
                  case 81:
                    return 'INVALID'
                }
              }, 'anonymous'),
              rules: [
                /^(?:click\b)/i,
                /^(?:href\b)/i,
                /^(?:"[^"]*")/i,
                /^(?:default\b)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:[\s]+)/i,
                /^(?:((?!\n)\s)+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:classDef\s+)/i,
                /^(?:DEFAULT\s+)/i,
                /^(?:\w+\s+)/i,
                /^(?:[^\n]*)/i,
                /^(?:class\s+)/i,
                /^(?:(\w+)+((,\s*\w+)*))/i,
                /^(?:[^\n]*)/i,
                /^(?:style\s+)/i,
                /^(?:[\w,]+\s+)/i,
                /^(?:[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:state\s+)/i,
                /^(?:.*<<fork>>)/i,
                /^(?:.*<<join>>)/i,
                /^(?:.*<<choice>>)/i,
                /^(?:.*\[\[fork\]\])/i,
                /^(?:.*\[\[join\]\])/i,
                /^(?:.*\[\[choice\]\])/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:["])/i,
                /^(?:\s*as\s+)/i,
                /^(?:[^\n\{]*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n\s\{]+)/i,
                /^(?:\n)/i,
                /^(?:\{)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:\})/i,
                /^(?:[\n])/i,
                /^(?:note\s+)/i,
                /^(?:left of\b)/i,
                /^(?:right of\b)/i,
                /^(?:")/i,
                /^(?:\s*as\s*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n]*)/i,
                /^(?:\s*[^:\n\s\-]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:[\s\S]*?end note\b)/i,
                /^(?:stateDiagram\s+)/i,
                /^(?:stateDiagram-v2\s+)/i,
                /^(?:hide empty description\b)/i,
                /^(?:\[\*\])/i,
                /^(?:[^:\n\s\-\{]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:-->)/i,
                /^(?:--)/i,
                /^(?::::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                LINE: { rules: [12, 13], inclusive: !1 },
                struct: {
                  rules: [12, 13, 25, 29, 32, 38, 45, 46, 47, 48, 57, 58, 59, 60, 74, 75, 76, 77, 78],
                  inclusive: !1,
                },
                FLOATING_NOTE_ID: { rules: [67], inclusive: !1 },
                FLOATING_NOTE: { rules: [64, 65, 66], inclusive: !1 },
                NOTE_TEXT: { rules: [69, 70], inclusive: !1 },
                NOTE_ID: { rules: [68], inclusive: !1 },
                NOTE: { rules: [61, 62, 63], inclusive: !1 },
                STYLEDEF_STYLEOPTS: { rules: [], inclusive: !1 },
                STYLEDEF_STYLES: { rules: [34], inclusive: !1 },
                STYLE_IDS: { rules: [], inclusive: !1 },
                STYLE: { rules: [33], inclusive: !1 },
                CLASS_STYLE: { rules: [31], inclusive: !1 },
                CLASS: { rules: [30], inclusive: !1 },
                CLASSDEFID: { rules: [28], inclusive: !1 },
                CLASSDEF: { rules: [26, 27], inclusive: !1 },
                acc_descr_multiline: { rules: [23, 24], inclusive: !1 },
                acc_descr: { rules: [21], inclusive: !1 },
                acc_title: { rules: [19], inclusive: !1 },
                SCALE: { rules: [16, 17, 36, 37], inclusive: !1 },
                ALIAS: { rules: [], inclusive: !1 },
                STATE_ID: { rules: [51], inclusive: !1 },
                STATE_STRING: { rules: [52, 53], inclusive: !1 },
                FORK_STATE: { rules: [], inclusive: !1 },
                STATE: { rules: [12, 13, 39, 40, 41, 42, 43, 44, 49, 50, 54, 55, 56], inclusive: !1 },
                ID: { rules: [12, 13], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, 20, 22, 25, 29, 32, 35, 38, 56, 60, 71, 72,
                    73, 74, 75, 76, 77, 79, 80, 81,
                  ],
                  inclusive: !0,
                },
              },
            }
            return M
          })()
        N.lexer = P
        function I() {
          this.yy = {}
        }
        return a(I, 'Parser'), (I.prototype = N), (N.Parser = I), new I()
      })()
      wN.parser = wN
      V_ = wN
    })
  var nu,
    Jh,
    Uy,
    tit,
    eit,
    rit,
    tf,
    z_,
    vN,
    AN,
    LN,
    RN,
    W_,
    U_,
    nit,
    iit,
    DN,
    NN,
    sit,
    ait,
    wm,
    NDt,
    oit,
    IN,
    IDt,
    MDt,
    lit,
    cit,
    ODt,
    uit,
    PDt,
    hit,
    MN,
    ON,
    fit,
    j_,
    dit,
    PN,
    q_ = x(() => {
      'use strict'
      ;(nu = 'state'),
        (Jh = 'root'),
        (Uy = 'relation'),
        (tit = 'classDef'),
        (eit = 'style'),
        (rit = 'applyClass'),
        (tf = 'default'),
        (z_ = 'divider'),
        (vN = 'fill:none'),
        (AN = 'fill: #333'),
        (LN = 'text'),
        (RN = 'normal'),
        (W_ = 'rect'),
        (U_ = 'rectWithTitle'),
        (nit = 'stateStart'),
        (iit = 'stateEnd'),
        (DN = 'divider'),
        (NN = 'roundedWithTitle'),
        (sit = 'note'),
        (ait = 'noteGroup'),
        (wm = 'statediagram'),
        (NDt = 'state'),
        (oit = `${wm}-${NDt}`),
        (IN = 'transition'),
        (IDt = 'note'),
        (MDt = 'note-edge'),
        (lit = `${IN} ${MDt}`),
        (cit = `${wm}-${IDt}`),
        (ODt = 'cluster'),
        (uit = `${wm}-${ODt}`),
        (PDt = 'cluster-alt'),
        (hit = `${wm}-${PDt}`),
        (MN = 'parent'),
        (ON = 'note'),
        (fit = 'state'),
        (j_ = '----'),
        (dit = `${j_}${ON}`),
        (PN = `${j_}${MN}`)
    })
  function BN(e = '', t = 0, r = '', n = j_) {
    let i = r !== null && r.length > 0 ? `${n}${r}` : ''
    return `${fit}-${e}${i}-${t}`
  }
  function H_(e, t, r) {
    if (!t.id || t.id === '</join></fork>' || t.id === '</choice>') return
    t.cssClasses &&
      (Array.isArray(t.cssCompiledStyles) || (t.cssCompiledStyles = []),
      t.cssClasses.split(' ').forEach((i) => {
        let s = r.get(i)
        s && (t.cssCompiledStyles = [...(t.cssCompiledStyles ?? []), ...s.styles])
      }))
    let n = e.find((i) => i.id === t.id)
    n ? Object.assign(n, t) : e.push(t)
  }
  function FDt(e) {
    return e?.classes?.join(' ') ?? ''
  }
  function $Dt(e) {
    return e?.styles ?? []
  }
  var Y_,
    iu,
    BDt,
    pit,
    Em,
    git,
    yit = x(() => {
      'use strict'
      pe()
      Vt()
      Be()
      q_()
      ;(Y_ = new Map()), (iu = 0)
      a(BN, 'stateDomId')
      ;(BDt = a((e, t, r, n, i, s, o, l) => {
        B.trace('items', t),
          t.forEach((u) => {
            switch (u.stmt) {
              case nu:
                Em(e, u, r, n, i, s, o, l)
                break
              case tf:
                Em(e, u, r, n, i, s, o, l)
                break
              case Uy:
                {
                  Em(e, u.state1, r, n, i, s, o, l), Em(e, u.state2, r, n, i, s, o, l)
                  let h = {
                    id: 'edge' + iu,
                    start: u.state1.id,
                    end: u.state2.id,
                    arrowhead: 'normal',
                    arrowTypeEnd: 'arrow_barb',
                    style: vN,
                    labelStyle: '',
                    label: Rt.sanitizeText(u.description ?? '', K()),
                    arrowheadStyle: AN,
                    labelpos: 'c',
                    labelType: LN,
                    thickness: RN,
                    classes: IN,
                    look: o,
                  }
                  i.push(h), iu++
                }
                break
            }
          })
      }, 'setupDoc')),
        (pit = a((e, t = 'TB') => {
          let r = t
          if (e.doc) for (let n of e.doc) n.stmt === 'dir' && (r = n.value)
          return r
        }, 'getDir'))
      a(H_, 'insertOrUpdateNode')
      a(FDt, 'getClassesFromDbInfo')
      a($Dt, 'getStylesFromDbInfo')
      ;(Em = a((e, t, r, n, i, s, o, l) => {
        let u = t.id,
          h = r.get(u),
          f = FDt(h),
          d = $Dt(h),
          p = K()
        if ((B.info('dataFetcher parsedItem', t, h, d), u !== 'root')) {
          let m = W_
          t.start === !0 ? (m = nit) : t.start === !1 && (m = iit),
            t.type !== tf && (m = t.type),
            Y_.get(u) ||
              Y_.set(u, {
                id: u,
                shape: m,
                description: Rt.sanitizeText(u, p),
                cssClasses: `${f} ${oit}`,
                cssStyles: d,
              })
          let g = Y_.get(u)
          t.description &&
            (Array.isArray(g.description)
              ? ((g.shape = U_), g.description.push(t.description))
              : g.description?.length && g.description.length > 0
                ? ((g.shape = U_),
                  g.description === u
                    ? (g.description = [t.description])
                    : (g.description = [g.description, t.description]))
                : ((g.shape = W_), (g.description = t.description)),
            (g.description = Rt.sanitizeTextOrArray(g.description, p))),
            g.description?.length === 1 && g.shape === U_ && (g.type === 'group' ? (g.shape = NN) : (g.shape = W_)),
            !g.type &&
              t.doc &&
              (B.info('Setting cluster for XCX', u, pit(t)),
              (g.type = 'group'),
              (g.isGroup = !0),
              (g.dir = pit(t)),
              (g.shape = t.type === z_ ? DN : NN),
              (g.cssClasses = `${g.cssClasses} ${uit} ${s ? hit : ''}`))
          let y = {
            labelStyle: '',
            shape: g.shape,
            label: g.description,
            cssClasses: g.cssClasses,
            cssCompiledStyles: [],
            cssStyles: g.cssStyles,
            id: u,
            dir: g.dir,
            domId: BN(u, iu),
            type: g.type,
            isGroup: g.type === 'group',
            padding: 8,
            rx: 10,
            ry: 10,
            look: o,
          }
          if (
            (y.shape === DN && (y.label = ''),
            e &&
              e.id !== 'root' &&
              (B.trace('Setting node ', u, ' to be child of its parent ', e.id), (y.parentId = e.id)),
            (y.centerLabel = !0),
            t.note)
          ) {
            let b = {
                labelStyle: '',
                shape: sit,
                label: t.note.text,
                cssClasses: cit,
                cssStyles: [],
                cssCompiledStyles: [],
                id: u + dit + '-' + iu,
                domId: BN(u, iu, ON),
                type: g.type,
                isGroup: g.type === 'group',
                padding: p.flowchart?.padding,
                look: o,
                position: t.note.position,
              },
              k = u + PN,
              T = {
                labelStyle: '',
                shape: ait,
                label: t.note.text,
                cssClasses: g.cssClasses,
                cssStyles: [],
                id: u + PN,
                domId: BN(u, iu, MN),
                type: 'group',
                isGroup: !0,
                padding: 16,
                look: o,
                position: t.note.position,
              }
            iu++, (T.id = k), (b.parentId = k), H_(n, T, l), H_(n, b, l), H_(n, y, l)
            let C = u,
              A = b.id
            t.note.position === 'left of' && ((C = b.id), (A = u)),
              i.push({
                id: C + '-' + A,
                start: C,
                end: A,
                arrowhead: 'none',
                arrowTypeEnd: '',
                style: vN,
                labelStyle: '',
                classes: lit,
                arrowheadStyle: AN,
                labelpos: 'c',
                labelType: LN,
                thickness: RN,
                look: o,
              })
          } else H_(n, y, l)
        }
        t.doc && (B.trace('Adding nodes children '), BDt(t, t.doc, r, n, i, !s, o, l))
      }, 'dataFetcher')),
        (git = a(() => {
          Y_.clear(), (iu = 0)
        }, 'reset'))
    })
  var $N,
    GDt,
    VDt,
    xit,
    GN = x(() => {
      'use strict'
      pe()
      Vt()
      hd()
      ph()
      mh()
      Ce()
      q_()
      ;($N = a((e, t = 'TB') => {
        if (!e.doc) return t
        let r = t
        for (let n of e.doc) n.stmt === 'dir' && (r = n.value)
        return r
      }, 'getDir')),
        (GDt = a(function (e, t) {
          return t.db.getClasses()
        }, 'getClasses')),
        (VDt = a(async function (e, t, r, n) {
          B.info('REF0:'), B.info('Drawing state diagram (v2)', t)
          let { securityLevel: i, state: s, layout: o } = K()
          n.db.extract(n.db.getRootDocV2())
          let l = n.db.getData(),
            u = So(t, i)
          ;(l.type = n.type),
            (l.layoutAlgorithm = o),
            (l.nodeSpacing = s?.nodeSpacing || 50),
            (l.rankSpacing = s?.rankSpacing || 50),
            (l.markers = ['barb']),
            (l.diagramId = t),
            await Do(l, u)
          let h = 8
          try {
            ;(typeof n.db.getLinks == 'function' ? n.db.getLinks() : new Map()).forEach((d, p) => {
              let m = typeof p == 'string' ? p : typeof p?.id == 'string' ? p.id : ''
              if (!m) {
                B.warn('\u26A0\uFE0F Invalid or missing stateId from key:', JSON.stringify(p))
                return
              }
              let g = u.node()?.querySelectorAll('g'),
                y
              if (
                (g?.forEach((C) => {
                  C.textContent?.trim() === m && (y = C)
                }),
                !y)
              ) {
                B.warn('\u26A0\uFE0F Could not find node matching text:', m)
                return
              }
              let b = y.parentNode
              if (!b) {
                B.warn('\u26A0\uFE0F Node has no parent, cannot wrap:', m)
                return
              }
              let k = document.createElementNS('http://www.w3.org/2000/svg', 'a'),
                T = d.url.replace(/^"+|"+$/g, '')
              if (
                (k.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', T),
                k.setAttribute('target', '_blank'),
                d.tooltip)
              ) {
                let C = d.tooltip.replace(/^"+|"+$/g, '')
                k.setAttribute('title', C)
              }
              b.replaceChild(k, y), k.appendChild(y), B.info('\u{1F517} Wrapped node in <a> tag for:', m, d.url)
            })
          } catch (f) {
            B.error('\u274C Error injecting clickable links:', f)
          }
          le.insertTitle(u, 'statediagramTitleText', s?.titleTopMargin ?? 25, n.db.getDiagramTitle()),
            la(u, h, wm, s?.useMaxWidth ?? !0)
        }, 'draw')),
        (xit = { getClasses: GDt, draw: VDt, getDir: $N })
    })
  var Zi,
    kit,
    Tit,
    X_,
    ma,
    K_ = x(() => {
      'use strict'
      pe()
      Vt()
      Ce()
      Be()
      bn()
      yit()
      GN()
      q_()
      ;(Zi = {
        START_NODE: '[*]',
        START_TYPE: 'start',
        END_NODE: '[*]',
        END_TYPE: 'end',
        COLOR_KEYWORD: 'color',
        FILL_KEYWORD: 'fill',
        BG_FILL: 'bgFill',
        STYLECLASS_SEP: ',',
      }),
        (kit = a(() => new Map(), 'newClassesList')),
        (Tit = a(() => ({ relations: [], states: new Map(), documents: {} }), 'newDoc')),
        (X_ = a((e) => JSON.parse(JSON.stringify(e)), 'clone')),
        (ma = class {
          constructor(t) {
            this.version = t
            this.nodes = []
            this.edges = []
            this.rootDoc = []
            this.classes = kit()
            this.documents = { root: Tit() }
            this.currentDocument = this.documents.root
            this.startEndCount = 0
            this.dividerCnt = 0
            this.links = new Map()
            this.getAccTitle = tr
            this.setAccTitle = Xe
            this.getAccDescription = rr
            this.setAccDescription = er
            this.setDiagramTitle = lr
            this.getDiagramTitle = nr
            this.clear(),
              (this.setRootDoc = this.setRootDoc.bind(this)),
              (this.getDividerId = this.getDividerId.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.trimColon = this.trimColon.bind(this))
          }
          static {
            a(this, 'StateDB')
          }
          static {
            this.relationType = { AGGREGATION: 0, EXTENSION: 1, COMPOSITION: 2, DEPENDENCY: 3 }
          }
          extract(t) {
            this.clear(!0)
            for (let i of Array.isArray(t) ? t : t.doc)
              switch (i.stmt) {
                case nu:
                  this.addState(i.id.trim(), i.type, i.doc, i.description, i.note)
                  break
                case Uy:
                  this.addRelation(i.state1, i.state2, i.description)
                  break
                case tit:
                  this.addStyleClass(i.id.trim(), i.classes)
                  break
                case eit:
                  this.handleStyleDef(i)
                  break
                case rit:
                  this.setCssClass(i.id.trim(), i.styleClass)
                  break
                case 'click':
                  this.addLink(i.id, i.url, i.tooltip)
                  break
              }
            let r = this.getStates(),
              n = K()
            git(), Em(void 0, this.getRootDocV2(), r, this.nodes, this.edges, !0, n.look, this.classes)
            for (let i of this.nodes)
              if (Array.isArray(i.label)) {
                if (((i.description = i.label.slice(1)), i.isGroup && i.description.length > 0))
                  throw new Error(
                    `Group nodes can only have label. Remove the additional description for node [${i.id}]`,
                  )
                i.label = i.label[0]
              }
          }
          handleStyleDef(t) {
            let r = t.id.trim().split(','),
              n = t.styleClass.split(',')
            for (let i of r) {
              let s = this.getState(i)
              if (!s) {
                let o = i.trim()
                this.addState(o), (s = this.getState(o))
              }
              s && (s.styles = n.map((o) => o.replace(/;/g, '')?.trim()))
            }
          }
          setRootDoc(t) {
            B.info('Setting root doc', t),
              (this.rootDoc = t),
              this.version === 1 ? this.extract(t) : this.extract(this.getRootDocV2())
          }
          docTranslator(t, r, n) {
            if (r.stmt === Uy) {
              this.docTranslator(t, r.state1, !0), this.docTranslator(t, r.state2, !1)
              return
            }
            if (
              (r.stmt === nu &&
                (r.id === Zi.START_NODE
                  ? ((r.id = t.id + (n ? '_start' : '_end')), (r.start = n))
                  : (r.id = r.id.trim())),
              (r.stmt !== Jh && r.stmt !== nu) || !r.doc)
            )
              return
            let i = [],
              s = []
            for (let o of r.doc)
              if (o.type === z_) {
                let l = X_(o)
                ;(l.doc = X_(s)), i.push(l), (s = [])
              } else s.push(o)
            if (i.length > 0 && s.length > 0) {
              let o = { stmt: nu, id: v4(), type: 'divider', doc: X_(s) }
              i.push(X_(o)), (r.doc = i)
            }
            r.doc.forEach((o) => this.docTranslator(r, o, !0))
          }
          getRootDocV2() {
            return (
              this.docTranslator({ id: Jh, stmt: Jh }, { id: Jh, stmt: Jh, doc: this.rootDoc }, !0),
              { id: Jh, doc: this.rootDoc }
            )
          }
          addState(t, r = tf, n = void 0, i = void 0, s = void 0, o = void 0, l = void 0, u = void 0) {
            let h = t?.trim()
            if (!this.currentDocument.states.has(h))
              B.info('Adding state ', h, i),
                this.currentDocument.states.set(h, {
                  stmt: nu,
                  id: h,
                  descriptions: [],
                  type: r,
                  doc: n,
                  note: s,
                  classes: [],
                  styles: [],
                  textStyles: [],
                })
            else {
              let f = this.currentDocument.states.get(h)
              if (!f) throw new Error(`State not found: ${h}`)
              f.doc || (f.doc = n), f.type || (f.type = r)
            }
            if (
              (i &&
                (B.info('Setting state description', h, i),
                (Array.isArray(i) ? i : [i]).forEach((d) => this.addDescription(h, d.trim()))),
              s)
            ) {
              let f = this.currentDocument.states.get(h)
              if (!f) throw new Error(`State not found: ${h}`)
              ;(f.note = s), (f.note.text = Rt.sanitizeText(f.note.text, K()))
            }
            o &&
              (B.info('Setting state classes', h, o),
              (Array.isArray(o) ? o : [o]).forEach((d) => this.setCssClass(h, d.trim()))),
              l &&
                (B.info('Setting state styles', h, l),
                (Array.isArray(l) ? l : [l]).forEach((d) => this.setStyle(h, d.trim()))),
              u &&
                (B.info('Setting state styles', h, l),
                (Array.isArray(u) ? u : [u]).forEach((d) => this.setTextStyle(h, d.trim())))
          }
          clear(t) {
            ;(this.nodes = []),
              (this.edges = []),
              (this.documents = { root: Tit() }),
              (this.currentDocument = this.documents.root),
              (this.startEndCount = 0),
              (this.classes = kit()),
              t || ((this.links = new Map()), Ye())
          }
          getState(t) {
            return this.currentDocument.states.get(t)
          }
          getStates() {
            return this.currentDocument.states
          }
          logDocuments() {
            B.info('Documents = ', this.documents)
          }
          getRelations() {
            return this.currentDocument.relations
          }
          addLink(t, r, n) {
            this.links.set(t, { url: r, tooltip: n }), B.warn('Adding link', t, r, n)
          }
          getLinks() {
            return this.links
          }
          startIdIfNeeded(t = '') {
            return t === Zi.START_NODE ? (this.startEndCount++, `${Zi.START_TYPE}${this.startEndCount}`) : t
          }
          startTypeIfNeeded(t = '', r = tf) {
            return t === Zi.START_NODE ? Zi.START_TYPE : r
          }
          endIdIfNeeded(t = '') {
            return t === Zi.END_NODE ? (this.startEndCount++, `${Zi.END_TYPE}${this.startEndCount}`) : t
          }
          endTypeIfNeeded(t = '', r = tf) {
            return t === Zi.END_NODE ? Zi.END_TYPE : r
          }
          addRelationObjs(t, r, n = '') {
            let i = this.startIdIfNeeded(t.id.trim()),
              s = this.startTypeIfNeeded(t.id.trim(), t.type),
              o = this.startIdIfNeeded(r.id.trim()),
              l = this.startTypeIfNeeded(r.id.trim(), r.type)
            this.addState(i, s, t.doc, t.description, t.note, t.classes, t.styles, t.textStyles),
              this.addState(o, l, r.doc, r.description, r.note, r.classes, r.styles, r.textStyles),
              this.currentDocument.relations.push({ id1: i, id2: o, relationTitle: Rt.sanitizeText(n, K()) })
          }
          addRelation(t, r, n) {
            if (typeof t == 'object' && typeof r == 'object') this.addRelationObjs(t, r, n)
            else if (typeof t == 'string' && typeof r == 'string') {
              let i = this.startIdIfNeeded(t.trim()),
                s = this.startTypeIfNeeded(t),
                o = this.endIdIfNeeded(r.trim()),
                l = this.endTypeIfNeeded(r)
              this.addState(i, s),
                this.addState(o, l),
                this.currentDocument.relations.push({
                  id1: i,
                  id2: o,
                  relationTitle: n ? Rt.sanitizeText(n, K()) : void 0,
                })
            }
          }
          addDescription(t, r) {
            let n = this.currentDocument.states.get(t),
              i = r.startsWith(':') ? r.replace(':', '').trim() : r
            n?.descriptions?.push(Rt.sanitizeText(i, K()))
          }
          cleanupLabel(t) {
            return t.startsWith(':') ? t.slice(2).trim() : t.trim()
          }
          getDividerId() {
            return this.dividerCnt++, `divider-id-${this.dividerCnt}`
          }
          addStyleClass(t, r = '') {
            this.classes.has(t) || this.classes.set(t, { id: t, styles: [], textStyles: [] })
            let n = this.classes.get(t)
            r &&
              n &&
              r.split(Zi.STYLECLASS_SEP).forEach((i) => {
                let s = i.replace(/([^;]*);/, '$1').trim()
                if (RegExp(Zi.COLOR_KEYWORD).exec(i)) {
                  let l = s.replace(Zi.FILL_KEYWORD, Zi.BG_FILL).replace(Zi.COLOR_KEYWORD, Zi.FILL_KEYWORD)
                  n.textStyles.push(l)
                }
                n.styles.push(s)
              })
          }
          getClasses() {
            return this.classes
          }
          setCssClass(t, r) {
            t.split(',').forEach((n) => {
              let i = this.getState(n)
              if (!i) {
                let s = n.trim()
                this.addState(s), (i = this.getState(s))
              }
              i?.classes?.push(r)
            })
          }
          setStyle(t, r) {
            this.getState(t)?.styles?.push(r)
          }
          setTextStyle(t, r) {
            this.getState(t)?.textStyles?.push(r)
          }
          getDirectionStatement() {
            return this.rootDoc.find((t) => t.stmt === 'dir')
          }
          getDirection() {
            return this.getDirectionStatement()?.value ?? 'TB'
          }
          setDirection(t) {
            let r = this.getDirectionStatement()
            r ? (r.value = t) : this.rootDoc.unshift({ stmt: 'dir', value: t })
          }
          trimColon(t) {
            return t.startsWith(':') ? t.slice(1).trim() : t.trim()
          }
          getData() {
            let t = K()
            return { nodes: this.nodes, edges: this.edges, other: {}, config: t, direction: $N(this.getRootDocV2()) }
          }
          getConfig() {
            return K().state
          }
        })
    })
  var WDt,
    Q_,
    VN = x(() => {
      'use strict'
      ;(WDt = a(
        (e) => `
defs #statediagram-barbEnd {
    fill: ${e.transitionColor};
    stroke: ${e.transitionColor};
  }
g.stateGroup text {
  fill: ${e.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${e.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${e.stateLabelColor};
}

g.stateGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.stateGroup line {
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${e.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${e.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${e.noteBorderColor};
  fill: ${e.noteBkgColor};

  text {
    fill: ${e.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${e.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${e.edgeLabelBackground};
  p {
    background-color: ${e.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${e.edgeLabelBackground};
    fill: ${e.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${e.transitionLabelColor || e.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${e.transitionLabelColor || e.tertiaryTextColor};
}

.stateLabel text {
  fill: ${e.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node .fork-join {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node circle.state-end {
  fill: ${e.innerEndBackground};
  stroke: ${e.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${e.compositeBackground || e.background};
  // stroke: ${e.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${e.stateBkg || e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${e.lineColor};
}

.statediagram-cluster rect {
  fill: ${e.compositeTitleBackground};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${e.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${e.stateBorder || e.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${e.compositeBackground || e.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${e.altBackground ? e.altBackground : '#efefef'};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${e.altBackground ? e.altBackground : '#efefef'};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${e.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${e.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${e.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${e.lineColor};
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`,
        'getStyles',
      )),
        (Q_ = WDt)
    })
  var UDt,
    jDt,
    qDt,
    HDt,
    _it,
    YDt,
    XDt,
    KDt,
    QDt,
    zN,
    Sit,
    Cit,
    wit = x(() => {
      'use strict'
      Ge()
      K_()
      Ce()
      Be()
      pe()
      Vt()
      ;(UDt = a(
        (e) =>
          e
            .append('circle')
            .attr('class', 'start-state')
            .attr('r', K().state.sizeUnit)
            .attr('cx', K().state.padding + K().state.sizeUnit)
            .attr('cy', K().state.padding + K().state.sizeUnit),
        'drawStartState',
      )),
        (jDt = a(
          (e) =>
            e
              .append('line')
              .style('stroke', 'grey')
              .style('stroke-dasharray', '3')
              .attr('x1', K().state.textHeight)
              .attr('class', 'divider')
              .attr('x2', K().state.textHeight * 2)
              .attr('y1', 0)
              .attr('y2', 0),
          'drawDivider',
        )),
        (qDt = a((e, t) => {
          let r = e
              .append('text')
              .attr('x', 2 * K().state.padding)
              .attr('y', K().state.textHeight + 2 * K().state.padding)
              .attr('font-size', K().state.fontSize)
              .attr('class', 'state-title')
              .text(t.id),
            n = r.node().getBBox()
          return (
            e
              .insert('rect', ':first-child')
              .attr('x', K().state.padding)
              .attr('y', K().state.padding)
              .attr('width', n.width + 2 * K().state.padding)
              .attr('height', n.height + 2 * K().state.padding)
              .attr('rx', K().state.radius),
            r
          )
        }, 'drawSimpleState')),
        (HDt = a((e, t) => {
          let r = a(function (p, m, g) {
              let y = p
                .append('tspan')
                .attr('x', 2 * K().state.padding)
                .text(m)
              g || y.attr('dy', K().state.textHeight)
            }, 'addTspan'),
            i = e
              .append('text')
              .attr('x', 2 * K().state.padding)
              .attr('y', K().state.textHeight + 1.3 * K().state.padding)
              .attr('font-size', K().state.fontSize)
              .attr('class', 'state-title')
              .text(t.descriptions[0])
              .node()
              .getBBox(),
            s = i.height,
            o = e
              .append('text')
              .attr('x', K().state.padding)
              .attr('y', s + K().state.padding * 0.4 + K().state.dividerMargin + K().state.textHeight)
              .attr('class', 'state-description'),
            l = !0,
            u = !0
          t.descriptions.forEach(function (p) {
            l || (r(o, p, u), (u = !1)), (l = !1)
          })
          let h = e
              .append('line')
              .attr('x1', K().state.padding)
              .attr('y1', K().state.padding + s + K().state.dividerMargin / 2)
              .attr('y2', K().state.padding + s + K().state.dividerMargin / 2)
              .attr('class', 'descr-divider'),
            f = o.node().getBBox(),
            d = Math.max(f.width, i.width)
          return (
            h.attr('x2', d + 3 * K().state.padding),
            e
              .insert('rect', ':first-child')
              .attr('x', K().state.padding)
              .attr('y', K().state.padding)
              .attr('width', d + 2 * K().state.padding)
              .attr('height', f.height + s + 2 * K().state.padding)
              .attr('rx', K().state.radius),
            e
          )
        }, 'drawDescrState')),
        (_it = a((e, t, r) => {
          let n = K().state.padding,
            i = 2 * K().state.padding,
            s = e.node().getBBox(),
            o = s.width,
            l = s.x,
            u = e
              .append('text')
              .attr('x', 0)
              .attr('y', K().state.titleShift)
              .attr('font-size', K().state.fontSize)
              .attr('class', 'state-title')
              .text(t.id),
            f = u.node().getBBox().width + i,
            d = Math.max(f, o)
          d === o && (d = d + i)
          let p,
            m = e.node().getBBox()
          t.doc, (p = l - n), f > o && (p = (o - d) / 2 + n), Math.abs(l - m.x) < n && f > o && (p = l - (f - o) / 2)
          let g = 1 - K().state.textHeight
          return (
            e
              .insert('rect', ':first-child')
              .attr('x', p)
              .attr('y', g)
              .attr('class', r ? 'alt-composit' : 'composit')
              .attr('width', d)
              .attr('height', m.height + K().state.textHeight + K().state.titleShift + 1)
              .attr('rx', '0'),
            u.attr('x', p + n),
            f <= o && u.attr('x', l + (d - i) / 2 - f / 2 + n),
            e
              .insert('rect', ':first-child')
              .attr('x', p)
              .attr('y', K().state.titleShift - K().state.textHeight - K().state.padding)
              .attr('width', d)
              .attr('height', K().state.textHeight * 3)
              .attr('rx', K().state.radius),
            e
              .insert('rect', ':first-child')
              .attr('x', p)
              .attr('y', K().state.titleShift - K().state.textHeight - K().state.padding)
              .attr('width', d)
              .attr('height', m.height + 3 + 2 * K().state.textHeight)
              .attr('rx', K().state.radius),
            e
          )
        }, 'addTitleAndBox')),
        (YDt = a(
          (e) => (
            e
              .append('circle')
              .attr('class', 'end-state-outer')
              .attr('r', K().state.sizeUnit + K().state.miniPadding)
              .attr('cx', K().state.padding + K().state.sizeUnit + K().state.miniPadding)
              .attr('cy', K().state.padding + K().state.sizeUnit + K().state.miniPadding),
            e
              .append('circle')
              .attr('class', 'end-state-inner')
              .attr('r', K().state.sizeUnit)
              .attr('cx', K().state.padding + K().state.sizeUnit + 2)
              .attr('cy', K().state.padding + K().state.sizeUnit + 2)
          ),
          'drawEndState',
        )),
        (XDt = a((e, t) => {
          let r = K().state.forkWidth,
            n = K().state.forkHeight
          if (t.parentId) {
            let i = r
            ;(r = n), (n = i)
          }
          return e
            .append('rect')
            .style('stroke', 'black')
            .style('fill', 'black')
            .attr('width', r)
            .attr('height', n)
            .attr('x', K().state.padding)
            .attr('y', K().state.padding)
        }, 'drawForkJoinState')),
        (KDt = a((e, t, r, n) => {
          let i = 0,
            s = n.append('text')
          s.style('text-anchor', 'start'), s.attr('class', 'noteText')
          let o = e.replace(/\r\n/g, '<br/>')
          o = o.replace(/\n/g, '<br/>')
          let l = o.split(Rt.lineBreakRegex),
            u = 1.25 * K().state.noteMargin
          for (let h of l) {
            let f = h.trim()
            if (f.length > 0) {
              let d = s.append('tspan')
              if ((d.text(f), u === 0)) {
                let p = d.node().getBBox()
                u += p.height
              }
              ;(i += u), d.attr('x', t + K().state.noteMargin), d.attr('y', r + i + 1.25 * K().state.noteMargin)
            }
          }
          return { textWidth: s.node().getBBox().width, textHeight: i }
        }, '_drawLongText')),
        (QDt = a((e, t) => {
          t.attr('class', 'state-note')
          let r = t.append('rect').attr('x', 0).attr('y', K().state.padding),
            n = t.append('g'),
            { textWidth: i, textHeight: s } = KDt(e, 0, 0, n)
          return r.attr('height', s + 2 * K().state.noteMargin), r.attr('width', i + K().state.noteMargin * 2), r
        }, 'drawNote')),
        (zN = a(function (e, t) {
          let r = t.id,
            n = { id: r, label: t.id, width: 0, height: 0 },
            i = e.append('g').attr('id', r).attr('class', 'stateGroup')
          t.type === 'start' && UDt(i),
            t.type === 'end' && YDt(i),
            (t.type === 'fork' || t.type === 'join') && XDt(i, t),
            t.type === 'note' && QDt(t.note.text, i),
            t.type === 'divider' && jDt(i),
            t.type === 'default' && t.descriptions.length === 0 && qDt(i, t),
            t.type === 'default' && t.descriptions.length > 0 && HDt(i, t)
          let s = i.node().getBBox()
          return (n.width = s.width + 2 * K().state.padding), (n.height = s.height + 2 * K().state.padding), n
        }, 'drawState')),
        (Sit = 0),
        (Cit = a(function (e, t, r) {
          let n = a(function (u) {
            switch (u) {
              case ma.relationType.AGGREGATION:
                return 'aggregation'
              case ma.relationType.EXTENSION:
                return 'extension'
              case ma.relationType.COMPOSITION:
                return 'composition'
              case ma.relationType.DEPENDENCY:
                return 'dependency'
            }
          }, 'getRelationType')
          t.points = t.points.filter((u) => !Number.isNaN(u.y))
          let i = t.points,
            s = Ma()
              .x(function (u) {
                return u.x
              })
              .y(function (u) {
                return u.y
              })
              .curve(Xs),
            o = e
              .append('path')
              .attr('d', s(i))
              .attr('id', 'edge' + Sit)
              .attr('class', 'transition'),
            l = ''
          if (
            (K().state.arrowMarkerAbsolute && (l = yu(!0)),
            o.attr('marker-end', 'url(' + l + '#' + n(ma.relationType.DEPENDENCY) + 'End)'),
            r.title !== void 0)
          ) {
            let u = e.append('g').attr('class', 'stateLabel'),
              { x: h, y: f } = le.calcLabelPosition(t.points),
              d = Rt.getRows(r.title),
              p = 0,
              m = [],
              g = 0,
              y = 0
            for (let T = 0; T <= d.length; T++) {
              let C = u
                  .append('text')
                  .attr('text-anchor', 'middle')
                  .text(d[T])
                  .attr('x', h)
                  .attr('y', f + p),
                A = C.node().getBBox()
              ;(g = Math.max(g, A.width)),
                (y = Math.min(y, A.x)),
                B.info(A.x, h, f + p),
                p === 0 && ((p = C.node().getBBox().height), B.info('Title height', p, f)),
                m.push(C)
            }
            let b = p * d.length
            if (d.length > 1) {
              let T = (d.length - 1) * p * 0.5
              m.forEach((C, A) => C.attr('y', f + A * p - T)), (b = p * d.length)
            }
            let k = u.node().getBBox()
            u
              .insert('rect', ':first-child')
              .attr('class', 'box')
              .attr('x', h - g / 2 - K().state.padding / 2)
              .attr('y', f - b / 2 - K().state.padding / 2 - 3.5)
              .attr('width', g + K().state.padding)
              .attr('height', b + K().state.padding),
              B.info(k)
          }
          Sit++
        }, 'drawEdge'))
    })
  var Gs,
    WN,
    ZDt,
    JDt,
    tNt,
    eNt,
    Eit,
    vit,
    Ait = x(() => {
      'use strict'
      Ge()
      Q5()
      aa()
      Vt()
      Be()
      wit()
      pe()
      On()
      ;(WN = {}),
        (ZDt = a(function () {}, 'setConf')),
        (JDt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'dependencyEnd')
            .attr('refX', 19)
            .attr('refY', 7)
            .attr('markerWidth', 20)
            .attr('markerHeight', 28)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z')
        }, 'insertMarkers')),
        (tNt = a(function (e, t, r, n) {
          Gs = K().state
          let i = K().securityLevel,
            s
          i === 'sandbox' && (s = xt('#i' + t))
          let o = i === 'sandbox' ? xt(s.nodes()[0].contentDocument.body) : xt('body'),
            l = i === 'sandbox' ? s.nodes()[0].contentDocument : document
          B.debug('Rendering diagram ' + e)
          let u = o.select(`[id='${t}']`)
          JDt(u)
          let h = n.db.getRootDoc()
          Eit(h, u, void 0, !1, o, l, n)
          let f = Gs.padding,
            d = u.node().getBBox(),
            p = d.width + f * 2,
            m = d.height + f * 2,
            g = p * 1.75
          Ar(u, m, g, Gs.useMaxWidth), u.attr('viewBox', `${d.x - Gs.padding}  ${d.y - Gs.padding} ` + p + ' ' + m)
        }, 'draw')),
        (eNt = a((e) => (e ? e.length * Gs.fontSizeFactor : 1), 'getLabelWidth')),
        (Eit = a((e, t, r, n, i, s, o) => {
          let l = new _r({ compound: !0, multigraph: !0 }),
            u,
            h = !0
          for (u = 0; u < e.length; u++)
            if (e[u].stmt === 'relation') {
              h = !1
              break
            }
          r
            ? l.setGraph({
                rankdir: 'LR',
                multigraph: !0,
                compound: !0,
                ranker: 'tight-tree',
                ranksep: h ? 1 : Gs.edgeLengthFactor,
                nodeSep: h ? 1 : 50,
                isMultiGraph: !0,
              })
            : l.setGraph({
                rankdir: 'TB',
                multigraph: !0,
                compound: !0,
                ranksep: h ? 1 : Gs.edgeLengthFactor,
                nodeSep: h ? 1 : 50,
                ranker: 'tight-tree',
                isMultiGraph: !0,
              }),
            l.setDefaultEdgeLabel(function () {
              return {}
            })
          let f = o.db.getStates(),
            d = o.db.getRelations(),
            p = Object.keys(f),
            m = !0
          for (let T of p) {
            let C = f[T]
            r && (C.parentId = r)
            let A
            if (C.doc) {
              let w = t.append('g').attr('id', C.id).attr('class', 'stateGroup')
              if (((A = Eit(C.doc, w, C.id, !n, i, s, o)), m)) {
                w = _it(w, C, n)
                let D = w.node().getBBox()
                ;(A.width = D.width), (A.height = D.height + Gs.padding / 2), (WN[C.id] = { y: Gs.compositTitleSize })
              } else {
                let D = w.node().getBBox()
                ;(A.width = D.width), (A.height = D.height)
              }
            } else A = zN(t, C, l)
            if (C.note) {
              let w = { descriptions: [], id: C.id + '-note', note: C.note, type: 'note' },
                D = zN(t, w, l)
              C.note.position === 'left of'
                ? (l.setNode(A.id + '-note', D), l.setNode(A.id, A))
                : (l.setNode(A.id, A), l.setNode(A.id + '-note', D)),
                l.setParent(A.id, A.id + '-group'),
                l.setParent(A.id + '-note', A.id + '-group')
            } else l.setNode(A.id, A)
          }
          B.debug('Count=', l.nodeCount(), l)
          let g = 0
          d.forEach(function (T) {
            g++,
              B.debug('Setting edge', T),
              l.setEdge(
                T.id1,
                T.id2,
                {
                  relation: T,
                  width: eNt(T.title),
                  height: Gs.labelHeight * Rt.getRows(T.title).length,
                  labelpos: 'c',
                },
                'id' + g,
              )
          }),
            Y0(l),
            B.debug('Graph after layout', l.nodes())
          let y = t.node()
          l.nodes().forEach(function (T) {
            T !== void 0 && l.node(T) !== void 0
              ? (B.warn('Node ' + T + ': ' + JSON.stringify(l.node(T))),
                i
                  .select('#' + y.id + ' #' + T)
                  .attr(
                    'transform',
                    'translate(' +
                      (l.node(T).x - l.node(T).width / 2) +
                      ',' +
                      (l.node(T).y + (WN[T] ? WN[T].y : 0) - l.node(T).height / 2) +
                      ' )',
                  ),
                i.select('#' + y.id + ' #' + T).attr('data-x-shift', l.node(T).x - l.node(T).width / 2),
                s.querySelectorAll('#' + y.id + ' #' + T + ' .divider').forEach((A) => {
                  let w = A.parentElement,
                    D = 0,
                    G = 0
                  w &&
                    (w.parentElement && (D = w.parentElement.getBBox().width),
                    (G = parseInt(w.getAttribute('data-x-shift'), 10)),
                    Number.isNaN(G) && (G = 0)),
                    A.setAttribute('x1', 0 - G + 8),
                    A.setAttribute('x2', D - G - 8)
                }))
              : B.debug('No Node ' + T + ': ' + JSON.stringify(l.node(T)))
          })
          let b = y.getBBox()
          l.edges().forEach(function (T) {
            T !== void 0 &&
              l.edge(T) !== void 0 &&
              (B.debug('Edge ' + T.v + ' -> ' + T.w + ': ' + JSON.stringify(l.edge(T))),
              Cit(t, l.edge(T), l.edge(T).relation))
          }),
            (b = y.getBBox())
          let k = { id: r || 'root', label: r || 'root', width: 0, height: 0 }
          return (
            (k.width = b.width + 2 * Gs.padding),
            (k.height = b.height + 2 * Gs.padding),
            B.debug('Doc rendered', k, l),
            k
          )
        }, 'renderDoc')),
        (vit = { setConf: ZDt, draw: tNt })
    })
  var Lit = {}
  Oe(Lit, { diagram: () => rNt })
  var rNt,
    Rit = x(() => {
      'use strict'
      EN()
      K_()
      VN()
      Ait()
      rNt = {
        parser: V_,
        get db() {
          return new ma(1)
        },
        renderer: vit,
        styles: Q_,
        init: a((e) => {
          e.state || (e.state = {}), (e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute)
        }, 'init'),
      }
    })
  var Iit = {}
  Oe(Iit, { diagram: () => aNt })
  var aNt,
    Mit = x(() => {
      'use strict'
      EN()
      K_()
      VN()
      GN()
      aNt = {
        parser: V_,
        get db() {
          return new ma(2)
        },
        renderer: xit,
        styles: Q_,
        init: a((e) => {
          e.state || (e.state = {}), (e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute)
        }, 'init'),
      }
    })
  var UN,
    Bit,
    Fit = x(() => {
      'use strict'
      UN = (function () {
        var e = a(function (d, p, m, g) {
            for (m = m || {}, g = d.length; g--; m[d[g]] = p);
            return m
          }, 'o'),
          t = [6, 8, 10, 11, 12, 14, 16, 17, 18],
          r = [1, 9],
          n = [1, 10],
          i = [1, 11],
          s = [1, 12],
          o = [1, 13],
          l = [1, 14],
          u = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              journey: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              title: 11,
              acc_title: 12,
              acc_title_value: 13,
              acc_descr: 14,
              acc_descr_value: 15,
              acc_descr_multiline_value: 16,
              section: 17,
              taskName: 18,
              taskData: 19,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'journey',
              6: 'EOF',
              8: 'SPACE',
              10: 'NEWLINE',
              11: 'title',
              12: 'acc_title',
              13: 'acc_title_value',
              14: 'acc_descr',
              15: 'acc_descr_value',
              16: 'acc_descr_multiline_value',
              17: 'section',
              18: 'taskName',
              19: 'taskData',
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 2],
            ],
            performAction: a(function (p, m, g, y, b, k, T) {
              var C = k.length - 1
              switch (b) {
                case 1:
                  return k[C - 1]
                case 2:
                  this.$ = []
                  break
                case 3:
                  k[C - 1].push(k[C]), (this.$ = k[C - 1])
                  break
                case 4:
                case 5:
                  this.$ = k[C]
                  break
                case 6:
                case 7:
                  this.$ = []
                  break
                case 8:
                  y.setDiagramTitle(k[C].substr(6)), (this.$ = k[C].substr(6))
                  break
                case 9:
                  ;(this.$ = k[C].trim()), y.setAccTitle(this.$)
                  break
                case 10:
                case 11:
                  ;(this.$ = k[C].trim()), y.setAccDescription(this.$)
                  break
                case 12:
                  y.addSection(k[C].substr(8)), (this.$ = k[C].substr(8))
                  break
                case 13:
                  y.addTask(k[C - 1], k[C]), (this.$ = 'task')
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: n, 14: i, 16: s, 17: o, 18: l },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              { 9: 15, 11: r, 12: n, 14: i, 16: s, 17: o, 18: l },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 8]),
              { 13: [1, 16] },
              { 15: [1, 17] },
              e(t, [2, 11]),
              e(t, [2, 12]),
              { 19: [1, 18] },
              e(t, [2, 4]),
              e(t, [2, 9]),
              e(t, [2, 10]),
              e(t, [2, 13]),
            ],
            defaultActions: {},
            parseError: a(function (p, m) {
              if (m.recoverable) this.trace(p)
              else {
                var g = new Error(p)
                throw ((g.hash = m), g)
              }
            }, 'parseError'),
            parse: a(function (p) {
              var m = this,
                g = [0],
                y = [],
                b = [null],
                k = [],
                T = this.table,
                C = '',
                A = 0,
                w = 0,
                D = 0,
                G = 2,
                v = 1,
                R = k.slice.call(arguments, 1),
                F = Object.create(this.lexer),
                S = { yy: {} }
              for (var O in this.yy) Object.prototype.hasOwnProperty.call(this.yy, O) && (S.yy[O] = this.yy[O])
              F.setInput(p, S.yy), (S.yy.lexer = F), (S.yy.parser = this), typeof F.yylloc > 'u' && (F.yylloc = {})
              var E = F.yylloc
              k.push(E)
              var _ = F.options && F.options.ranges
              typeof S.yy.parseError == 'function'
                ? (this.parseError = S.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function L(ot) {
                ;(g.length = g.length - 2 * ot), (b.length = b.length - ot), (k.length = k.length - ot)
              }
              a(L, 'popStack')
              function N() {
                var ot
                return (
                  (ot = y.pop() || F.lex() || v),
                  typeof ot != 'number' &&
                    (ot instanceof Array && ((y = ot), (ot = y.pop())), (ot = m.symbols_[ot] || ot)),
                  ot
                )
              }
              a(N, 'lex')
              for (var P, I, M, V, $, q, tt = {}, ft, H, kt, ht; ; ) {
                if (
                  ((M = g[g.length - 1]),
                  this.defaultActions[M]
                    ? (V = this.defaultActions[M])
                    : ((P === null || typeof P > 'u') && (P = N()), (V = T[M] && T[M][P])),
                  typeof V > 'u' || !V.length || !V[0])
                ) {
                  var yt = ''
                  ht = []
                  for (ft in T[M]) this.terminals_[ft] && ft > G && ht.push("'" + this.terminals_[ft] + "'")
                  F.showPosition
                    ? (yt =
                        'Parse error on line ' +
                        (A + 1) +
                        `:
` +
                        F.showPosition() +
                        `
Expecting ` +
                        ht.join(', ') +
                        ", got '" +
                        (this.terminals_[P] || P) +
                        "'")
                    : (yt =
                        'Parse error on line ' +
                        (A + 1) +
                        ': Unexpected ' +
                        (P == v ? 'end of input' : "'" + (this.terminals_[P] || P) + "'")),
                    this.parseError(yt, {
                      text: F.match,
                      token: this.terminals_[P] || P,
                      line: F.yylineno,
                      loc: E,
                      expected: ht,
                    })
                }
                if (V[0] instanceof Array && V.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + M + ', token: ' + P)
                switch (V[0]) {
                  case 1:
                    g.push(P),
                      b.push(F.yytext),
                      k.push(F.yylloc),
                      g.push(V[1]),
                      (P = null),
                      I
                        ? ((P = I), (I = null))
                        : ((w = F.yyleng), (C = F.yytext), (A = F.yylineno), (E = F.yylloc), D > 0 && D--)
                    break
                  case 2:
                    if (
                      ((H = this.productions_[V[1]][1]),
                      (tt.$ = b[b.length - H]),
                      (tt._$ = {
                        first_line: k[k.length - (H || 1)].first_line,
                        last_line: k[k.length - 1].last_line,
                        first_column: k[k.length - (H || 1)].first_column,
                        last_column: k[k.length - 1].last_column,
                      }),
                      _ && (tt._$.range = [k[k.length - (H || 1)].range[0], k[k.length - 1].range[1]]),
                      (q = this.performAction.apply(tt, [C, w, A, S.yy, V[1], b, k].concat(R))),
                      typeof q < 'u')
                    )
                      return q
                    H && ((g = g.slice(0, -1 * H * 2)), (b = b.slice(0, -1 * H)), (k = k.slice(0, -1 * H))),
                      g.push(this.productions_[V[1]][0]),
                      b.push(tt.$),
                      k.push(tt._$),
                      (kt = T[g[g.length - 2]][g[g.length - 1]]),
                      g.push(kt)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          h = (function () {
            var d = {
              EOF: 1,
              parseError: a(function (m, g) {
                if (this.yy.parser) this.yy.parser.parseError(m, g)
                else throw new Error(m)
              }, 'parseError'),
              setInput: a(function (p, m) {
                return (
                  (this.yy = m || this.yy || {}),
                  (this._input = p),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var p = this._input[0]
                ;(this.yytext += p), this.yyleng++, this.offset++, (this.match += p), (this.matched += p)
                var m = p.match(/(?:\r\n?|\n).*/g)
                return (
                  m ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  p
                )
              }, 'input'),
              unput: a(function (p) {
                var m = p.length,
                  g = p.split(/(?:\r\n?|\n)/g)
                ;(this._input = p + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - m)),
                  (this.offset -= m)
                var y = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  g.length - 1 && (this.yylineno -= g.length - 1)
                var b = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: g
                      ? (g.length === y.length ? this.yylloc.first_column : 0) +
                        y[y.length - g.length].length -
                        g[0].length
                      : this.yylloc.first_column - m,
                  }),
                  this.options.ranges && (this.yylloc.range = [b[0], b[0] + this.yyleng - m]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (p) {
                this.unput(this.match.slice(p))
              }, 'less'),
              pastInput: a(function () {
                var p = this.matched.substr(0, this.matched.length - this.match.length)
                return (p.length > 20 ? '...' : '') + p.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var p = this.match
                return (
                  p.length < 20 && (p += this._input.substr(0, 20 - p.length)),
                  (p.substr(0, 20) + (p.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var p = this.pastInput(),
                  m = new Array(p.length + 1).join('-')
                return (
                  p +
                  this.upcomingInput() +
                  `
` +
                  m +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (p, m) {
                var g, y, b
                if (
                  (this.options.backtrack_lexer &&
                    ((b = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (b.yylloc.range = this.yylloc.range.slice(0))),
                  (y = p[0].match(/(?:\r\n?|\n).*/g)),
                  y && (this.yylineno += y.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: y
                      ? y[y.length - 1].length - y[y.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + p[0].length,
                  }),
                  (this.yytext += p[0]),
                  (this.match += p[0]),
                  (this.matches = p),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(p[0].length)),
                  (this.matched += p[0]),
                  (g = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    m,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  g)
                )
                  return g
                if (this._backtrack) {
                  for (var k in b) this[k] = b[k]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var p, m, g, y
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var b = this._currentRules(), k = 0; k < b.length; k++)
                  if (((g = this._input.match(this.rules[b[k]])), g && (!m || g[0].length > m[0].length))) {
                    if (((m = g), (y = k), this.options.backtrack_lexer)) {
                      if (((p = this.test_match(g, b[k])), p !== !1)) return p
                      if (this._backtrack) {
                        m = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return m
                  ? ((p = this.test_match(m, b[y])), p !== !1 ? p : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var m = this.next()
                return m || this.lex()
              }, 'lex'),
              begin: a(function (m) {
                this.conditionStack.push(m)
              }, 'begin'),
              popState: a(function () {
                var m = this.conditionStack.length - 1
                return m > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (m) {
                return (
                  (m = this.conditionStack.length - 1 - Math.abs(m || 0)), m >= 0 ? this.conditionStack[m] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (m) {
                this.begin(m)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (m, g, y, b) {
                var k = b
                switch (y) {
                  case 0:
                    break
                  case 1:
                    break
                  case 2:
                    return 10
                  case 3:
                    break
                  case 4:
                    break
                  case 5:
                    return 4
                  case 6:
                    return 11
                  case 7:
                    return this.begin('acc_title'), 12
                    break
                  case 8:
                    return this.popState(), 'acc_title_value'
                    break
                  case 9:
                    return this.begin('acc_descr'), 14
                    break
                  case 10:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 11:
                    this.begin('acc_descr_multiline')
                    break
                  case 12:
                    this.popState()
                    break
                  case 13:
                    return 'acc_descr_multiline_value'
                  case 14:
                    return 17
                  case 15:
                    return 18
                  case 16:
                    return 19
                  case 17:
                    return ':'
                  case 18:
                    return 6
                  case 19:
                    return 'INVALID'
                }
              }, 'anonymous'),
              rules: [
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:journey\b)/i,
                /^(?:title\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:section\s[^#:\n;]+)/i,
                /^(?:[^#:\n;]+)/i,
                /^(?::[^#\n;]+)/i,
                /^(?::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19], inclusive: !0 },
              },
            }
            return d
          })()
        u.lexer = h
        function f() {
          this.yy = {}
        }
        return a(f, 'Parser'), (f.prototype = u), (u.Parser = f), new f()
      })()
      UN.parser = UN
      Bit = UN
    })
  var vm,
    jN,
    jy,
    qy,
    uNt,
    hNt,
    fNt,
    dNt,
    pNt,
    mNt,
    gNt,
    $it,
    yNt,
    qN,
    Git = x(() => {
      'use strict'
      pe()
      bn()
      ;(vm = ''),
        (jN = []),
        (jy = []),
        (qy = []),
        (uNt = a(function () {
          ;(jN.length = 0), (jy.length = 0), (vm = ''), (qy.length = 0), Ye()
        }, 'clear')),
        (hNt = a(function (e) {
          ;(vm = e), jN.push(e)
        }, 'addSection')),
        (fNt = a(function () {
          return jN
        }, 'getSections')),
        (dNt = a(function () {
          let e = $it(),
            t = 100,
            r = 0
          for (; !e && r < t; ) (e = $it()), r++
          return jy.push(...qy), jy
        }, 'getTasks')),
        (pNt = a(function () {
          let e = []
          return (
            jy.forEach((r) => {
              r.people && e.push(...r.people)
            }),
            [...new Set(e)].sort()
          )
        }, 'updateActors')),
        (mNt = a(function (e, t) {
          let r = t.substr(1).split(':'),
            n = 0,
            i = []
          r.length === 1 ? ((n = Number(r[0])), (i = [])) : ((n = Number(r[0])), (i = r[1].split(',')))
          let s = i.map((l) => l.trim()),
            o = { section: vm, type: vm, people: s, task: e, score: n }
          qy.push(o)
        }, 'addTask')),
        (gNt = a(function (e) {
          let t = { section: vm, type: vm, description: e, task: e, classes: [] }
          jy.push(t)
        }, 'addTaskOrg')),
        ($it = a(function () {
          let e = a(function (r) {
              return qy[r].processed
            }, 'compileTask'),
            t = !0
          for (let [r, n] of qy.entries()) e(r), (t = t && n.processed)
          return t
        }, 'compileTasks')),
        (yNt = a(function () {
          return pNt()
        }, 'getActors')),
        (qN = {
          getConfig: a(() => K().journey, 'getConfig'),
          clear: uNt,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setAccTitle: Xe,
          getAccTitle: tr,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: hNt,
          getSections: fNt,
          getTasks: dNt,
          addTask: mNt,
          addTaskOrg: gNt,
          getActors: yNt,
        })
    })
  var xNt,
    Vit,
    zit = x(() => {
      'use strict'
      Md()
      ;(xNt = a(
        (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${e.textColor}
  }

  .legend {
    fill: ${e.textColor};
    font-family: ${e.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${e.textColor}
  }

  .face {
    ${e.faceColor ? `fill: ${e.faceColor}` : 'fill: #FFF8DC'};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${e.fillType0 ? `fill: ${e.fillType0}` : ''};
  }
  .task-type-1, .section-type-1  {
    ${e.fillType0 ? `fill: ${e.fillType1}` : ''};
  }
  .task-type-2, .section-type-2  {
    ${e.fillType0 ? `fill: ${e.fillType2}` : ''};
  }
  .task-type-3, .section-type-3  {
    ${e.fillType0 ? `fill: ${e.fillType3}` : ''};
  }
  .task-type-4, .section-type-4  {
    ${e.fillType0 ? `fill: ${e.fillType4}` : ''};
  }
  .task-type-5, .section-type-5  {
    ${e.fillType0 ? `fill: ${e.fillType5}` : ''};
  }
  .task-type-6, .section-type-6  {
    ${e.fillType0 ? `fill: ${e.fillType6}` : ''};
  }
  .task-type-7, .section-type-7  {
    ${e.fillType0 ? `fill: ${e.fillType7}` : ''};
  }

  .actor-0 {
    ${e.actor0 ? `fill: ${e.actor0}` : ''};
  }
  .actor-1 {
    ${e.actor1 ? `fill: ${e.actor1}` : ''};
  }
  .actor-2 {
    ${e.actor2 ? `fill: ${e.actor2}` : ''};
  }
  .actor-3 {
    ${e.actor3 ? `fill: ${e.actor3}` : ''};
  }
  .actor-4 {
    ${e.actor4 ? `fill: ${e.actor4}` : ''};
  }
  .actor-5 {
    ${e.actor5 ? `fill: ${e.actor5}` : ''};
  }
  ${No()}
`,
        'getStyles',
      )),
        (Vit = xNt)
    })
  var HN,
    bNt,
    Uit,
    jit,
    kNt,
    TNt,
    Wit,
    SNt,
    _Nt,
    qit,
    CNt,
    Am,
    Hit = x(() => {
      'use strict'
      Ge()
      a0()
      ;(HN = a(function (e, t) {
        return Vu(e, t)
      }, 'drawRect')),
        (bNt = a(function (e, t) {
          let n = e
              .append('circle')
              .attr('cx', t.cx)
              .attr('cy', t.cy)
              .attr('class', 'face')
              .attr('r', 15)
              .attr('stroke-width', 2)
              .attr('overflow', 'visible'),
            i = e.append('g')
          i
            .append('circle')
            .attr('cx', t.cx - 15 / 3)
            .attr('cy', t.cy - 15 / 3)
            .attr('r', 1.5)
            .attr('stroke-width', 2)
            .attr('fill', '#666')
            .attr('stroke', '#666'),
            i
              .append('circle')
              .attr('cx', t.cx + 15 / 3)
              .attr('cy', t.cy - 15 / 3)
              .attr('r', 1.5)
              .attr('stroke-width', 2)
              .attr('fill', '#666')
              .attr('stroke', '#666')
          function s(u) {
            let h = Ia()
              .startAngle(Math.PI / 2)
              .endAngle(3 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175)
            u.append('path')
              .attr('class', 'mouth')
              .attr('d', h)
              .attr('transform', 'translate(' + t.cx + ',' + (t.cy + 2) + ')')
          }
          a(s, 'smile')
          function o(u) {
            let h = Ia()
              .startAngle((3 * Math.PI) / 2)
              .endAngle(5 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175)
            u.append('path')
              .attr('class', 'mouth')
              .attr('d', h)
              .attr('transform', 'translate(' + t.cx + ',' + (t.cy + 7) + ')')
          }
          a(o, 'sad')
          function l(u) {
            u.append('line')
              .attr('class', 'mouth')
              .attr('stroke', 2)
              .attr('x1', t.cx - 5)
              .attr('y1', t.cy + 7)
              .attr('x2', t.cx + 5)
              .attr('y2', t.cy + 7)
              .attr('class', 'mouth')
              .attr('stroke-width', '1px')
              .attr('stroke', '#666')
          }
          return a(l, 'ambivalent'), t.score > 3 ? s(i) : t.score < 3 ? o(i) : l(i), n
        }, 'drawFace')),
        (Uit = a(function (e, t) {
          let r = e.append('circle')
          return (
            r.attr('cx', t.cx),
            r.attr('cy', t.cy),
            r.attr('class', 'actor-' + t.pos),
            r.attr('fill', t.fill),
            r.attr('stroke', t.stroke),
            r.attr('r', t.r),
            r.class !== void 0 && r.attr('class', r.class),
            t.title !== void 0 && r.append('title').text(t.title),
            r
          )
        }, 'drawCircle')),
        (jit = a(function (e, t) {
          return zB(e, t)
        }, 'drawText')),
        (kNt = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              (s + l - u) +
              ' ' +
              (i + o - u * 1.2) +
              ',' +
              (s + l) +
              ' ' +
              i +
              ',' +
              (s + l)
            )
          }
          a(r, 'genPoints')
          let n = e.append('polygon')
          n.attr('points', r(t.x, t.y, 50, 20, 7)),
            n.attr('class', 'labelBox'),
            (t.y = t.y + t.labelMargin),
            (t.x = t.x + 0.5 * t.labelMargin),
            jit(e, t)
        }, 'drawLabel')),
        (TNt = a(function (e, t, r) {
          let n = e.append('g'),
            i = ri()
          ;(i.x = t.x),
            (i.y = t.y),
            (i.fill = t.fill),
            (i.width = r.width * t.taskCount + r.diagramMarginX * (t.taskCount - 1)),
            (i.height = r.height),
            (i.class = 'journey-section section-type-' + t.num),
            (i.rx = 3),
            (i.ry = 3),
            HN(n, i),
            qit(r)(
              t.text,
              n,
              i.x,
              i.y,
              i.width,
              i.height,
              { class: 'journey-section section-type-' + t.num },
              r,
              t.colour,
            )
        }, 'drawSection')),
        (Wit = -1),
        (SNt = a(function (e, t, r) {
          let n = t.x + r.width / 2,
            i = e.append('g')
          Wit++,
            i
              .append('line')
              .attr('id', 'task' + Wit)
              .attr('x1', n)
              .attr('y1', t.y)
              .attr('x2', n)
              .attr('y2', 450)
              .attr('class', 'task-line')
              .attr('stroke-width', '1px')
              .attr('stroke-dasharray', '4 2')
              .attr('stroke', '#666'),
            bNt(i, { cx: n, cy: 300 + (5 - t.score) * 30, score: t.score })
          let o = ri()
          ;(o.x = t.x),
            (o.y = t.y),
            (o.fill = t.fill),
            (o.width = r.width),
            (o.height = r.height),
            (o.class = 'task task-type-' + t.num),
            (o.rx = 3),
            (o.ry = 3),
            HN(i, o)
          let l = t.x + 14
          t.people.forEach((u) => {
            let h = t.actors[u].color,
              f = { cx: l, cy: t.y, r: 7, fill: h, stroke: '#000', title: u, pos: t.actors[u].position }
            Uit(i, f), (l += 10)
          }),
            qit(r)(t.task, i, o.x, o.y, o.width, o.height, { class: 'task' }, r, t.colour)
        }, 'drawTask')),
        (_Nt = a(function (e, t) {
          U2(e, t)
        }, 'drawBackgroundRect')),
        (qit = (function () {
          function e(i, s, o, l, u, h, f, d) {
            let p = s
              .append('text')
              .attr('x', o + u / 2)
              .attr('y', l + h / 2 + 5)
              .style('font-color', d)
              .style('text-anchor', 'middle')
              .text(i)
            n(p, f)
          }
          a(e, 'byText')
          function t(i, s, o, l, u, h, f, d, p) {
            let { taskFontSize: m, taskFontFamily: g } = d,
              y = i.split(/<br\s*\/?>/gi)
            for (let b = 0; b < y.length; b++) {
              let k = b * m - (m * (y.length - 1)) / 2,
                T = s
                  .append('text')
                  .attr('x', o + u / 2)
                  .attr('y', l)
                  .attr('fill', p)
                  .style('text-anchor', 'middle')
                  .style('font-size', m)
                  .style('font-family', g)
              T.append('tspan')
                .attr('x', o + u / 2)
                .attr('dy', k)
                .text(y[b]),
                T.attr('y', l + h / 2)
                  .attr('dominant-baseline', 'central')
                  .attr('alignment-baseline', 'central'),
                n(T, f)
            }
          }
          a(t, 'byTspan')
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append('switch'),
              g = p
                .append('foreignObject')
                .attr('x', o)
                .attr('y', l)
                .attr('width', u)
                .attr('height', h)
                .attr('position', 'fixed')
                .append('xhtml:div')
                .style('display', 'table')
                .style('height', '100%')
                .style('width', '100%')
            g
              .append('div')
              .attr('class', 'label')
              .style('display', 'table-cell')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f)
          }
          a(r, 'byFo')
          function n(i, s) {
            for (let o in s) o in s && i.attr(o, s[o])
          }
          return (
            a(n, '_setTextAttrs'),
            function (i) {
              return i.textPlacement === 'fo' ? r : i.textPlacement === 'old' ? e : t
            }
          )
        })()),
        (CNt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'arrowhead')
            .attr('refX', 5)
            .attr('refY', 2)
            .attr('markerWidth', 6)
            .attr('markerHeight', 4)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0,0 V 4 L6,2 Z')
        }, 'initGraphics')),
        (Am = {
          drawRect: HN,
          drawCircle: Uit,
          drawSection: TNt,
          drawText: jit,
          drawLabel: kNt,
          drawTask: SNt,
          drawBackgroundRect: _Nt,
          initGraphics: CNt,
        })
    })
  function ENt(e) {
    let t = K().journey,
      r = t.maxLabelWidth
    Z_ = 0
    let n = 60
    Object.keys(Gl).forEach((i) => {
      let s = Gl[i].color,
        o = { cx: 20, cy: n, r: 7, fill: s, stroke: '#000', pos: Gl[i].position }
      Am.drawCircle(e, o)
      let l = e.append('text').attr('visibility', 'hidden').text(i),
        u = l.node().getBoundingClientRect().width
      l.remove()
      let h = []
      if (u <= r) h = [i]
      else {
        let f = i.split(' '),
          d = ''
        ;(l = e.append('text').attr('visibility', 'hidden')),
          f.forEach((p) => {
            let m = d ? `${d} ${p}` : p
            if ((l.text(m), l.node().getBoundingClientRect().width > r)) {
              if ((d && h.push(d), (d = p), l.text(p), l.node().getBoundingClientRect().width > r)) {
                let y = ''
                for (let b of p)
                  (y += b),
                    l.text(y + '-'),
                    l.node().getBoundingClientRect().width > r && (h.push(y.slice(0, -1) + '-'), (y = b))
                d = y
              }
            } else d = m
          }),
          d && h.push(d),
          l.remove()
      }
      h.forEach((f, d) => {
        let p = { x: 40, y: n + 7 + d * 20, fill: '#666', text: f, textMargin: t.boxTextMargin ?? 5 },
          g = Am.drawText(e, p).node().getBoundingClientRect().width
        g > Z_ && g > t.leftMargin - g && (Z_ = g)
      }),
        (n += Math.max(20, h.length * 20))
    })
  }
  var wNt,
    Gl,
    Z_,
    Ka,
    su,
    vNt,
    ga,
    YN,
    Yit,
    ANt,
    XN,
    Xit = x(() => {
      'use strict'
      Ge()
      Hit()
      pe()
      On()
      ;(wNt = a(function (e) {
        Object.keys(e).forEach(function (r) {
          Ka[r] = e[r]
        })
      }, 'setConf')),
        (Gl = {}),
        (Z_ = 0)
      a(ENt, 'drawActorLegend')
      ;(Ka = K().journey),
        (su = 0),
        (vNt = a(function (e, t, r, n) {
          let i = K(),
            s = i.journey.titleColor,
            o = i.journey.titleFontSize,
            l = i.journey.titleFontFamily,
            u = i.securityLevel,
            h
          u === 'sandbox' && (h = xt('#i' + t))
          let f = u === 'sandbox' ? xt(h.nodes()[0].contentDocument.body) : xt('body')
          ga.init()
          let d = f.select('#' + t)
          Am.initGraphics(d)
          let p = n.db.getTasks(),
            m = n.db.getDiagramTitle(),
            g = n.db.getActors()
          for (let A in Gl) delete Gl[A]
          let y = 0
          g.forEach((A) => {
            ;(Gl[A] = { color: Ka.actorColours[y % Ka.actorColours.length], position: y }), y++
          }),
            ENt(d),
            (su = Ka.leftMargin + Z_),
            ga.insert(0, 0, su, Object.keys(Gl).length * 50),
            ANt(d, p, 0)
          let b = ga.getBounds()
          m &&
            d
              .append('text')
              .text(m)
              .attr('x', su)
              .attr('font-size', o)
              .attr('font-weight', 'bold')
              .attr('y', 25)
              .attr('fill', s)
              .attr('font-family', l)
          let k = b.stopy - b.starty + 2 * Ka.diagramMarginY,
            T = su + b.stopx + 2 * Ka.diagramMarginX
          Ar(d, k, T, Ka.useMaxWidth),
            d
              .append('line')
              .attr('x1', su)
              .attr('y1', Ka.height * 4)
              .attr('x2', T - su - 4)
              .attr('y2', Ka.height * 4)
              .attr('stroke-width', 4)
              .attr('stroke', 'black')
              .attr('marker-end', 'url(#arrowhead)')
          let C = m ? 70 : 0
          d.attr('viewBox', `${b.startx} -25 ${T} ${k + C}`),
            d.attr('preserveAspectRatio', 'xMinYMin meet'),
            d.attr('height', k + C + 25)
        }, 'draw')),
        (ga = {
          data: { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0 },
          verticalPos: 0,
          sequenceItems: [],
          init: a(function () {
            ;(this.sequenceItems = []),
              (this.data = { startx: void 0, stopx: void 0, starty: void 0, stopy: void 0 }),
              (this.verticalPos = 0)
          }, 'init'),
          updateVal: a(function (e, t, r, n) {
            e[t] === void 0 ? (e[t] = r) : (e[t] = n(r, e[t]))
          }, 'updateVal'),
          updateBounds: a(function (e, t, r, n) {
            let i = K().journey,
              s = this,
              o = 0
            function l(u) {
              return a(function (f) {
                o++
                let d = s.sequenceItems.length - o + 1
                s.updateVal(f, 'starty', t - d * i.boxMargin, Math.min),
                  s.updateVal(f, 'stopy', n + d * i.boxMargin, Math.max),
                  s.updateVal(ga.data, 'startx', e - d * i.boxMargin, Math.min),
                  s.updateVal(ga.data, 'stopx', r + d * i.boxMargin, Math.max),
                  u !== 'activation' &&
                    (s.updateVal(f, 'startx', e - d * i.boxMargin, Math.min),
                    s.updateVal(f, 'stopx', r + d * i.boxMargin, Math.max),
                    s.updateVal(ga.data, 'starty', t - d * i.boxMargin, Math.min),
                    s.updateVal(ga.data, 'stopy', n + d * i.boxMargin, Math.max))
              }, 'updateItemBounds')
            }
            a(l, 'updateFn'), this.sequenceItems.forEach(l())
          }, 'updateBounds'),
          insert: a(function (e, t, r, n) {
            let i = Math.min(e, r),
              s = Math.max(e, r),
              o = Math.min(t, n),
              l = Math.max(t, n)
            this.updateVal(ga.data, 'startx', i, Math.min),
              this.updateVal(ga.data, 'starty', o, Math.min),
              this.updateVal(ga.data, 'stopx', s, Math.max),
              this.updateVal(ga.data, 'stopy', l, Math.max),
              this.updateBounds(i, o, s, l)
          }, 'insert'),
          bumpVerticalPos: a(function (e) {
            ;(this.verticalPos = this.verticalPos + e), (this.data.stopy = this.verticalPos)
          }, 'bumpVerticalPos'),
          getVerticalPos: a(function () {
            return this.verticalPos
          }, 'getVerticalPos'),
          getBounds: a(function () {
            return this.data
          }, 'getBounds'),
        }),
        (YN = Ka.sectionFills),
        (Yit = Ka.sectionColours),
        (ANt = a(function (e, t, r) {
          let n = K().journey,
            i = '',
            s = n.height * 2 + n.diagramMarginY,
            o = r + s,
            l = 0,
            u = '#CCC',
            h = 'black',
            f = 0
          for (let [d, p] of t.entries()) {
            if (i !== p.section) {
              ;(u = YN[l % YN.length]), (f = l % YN.length), (h = Yit[l % Yit.length])
              let g = 0,
                y = p.section
              for (let k = d; k < t.length && t[k].section == y; k++) g = g + 1
              let b = {
                x: d * n.taskMargin + d * n.width + su,
                y: 50,
                text: p.section,
                fill: u,
                num: f,
                colour: h,
                taskCount: g,
              }
              Am.drawSection(e, b, n), (i = p.section), l++
            }
            let m = p.people.reduce((g, y) => (Gl[y] && (g[y] = Gl[y]), g), {})
            ;(p.x = d * n.taskMargin + d * n.width + su),
              (p.y = o),
              (p.width = n.diagramMarginX),
              (p.height = n.diagramMarginY),
              (p.colour = h),
              (p.fill = u),
              (p.num = f),
              (p.actors = m),
              Am.drawTask(e, p, n),
              ga.insert(p.x, p.y, p.x + p.width + n.taskMargin, 450)
          }
        }, 'drawTasks')),
        (XN = { setConf: wNt, draw: vNt })
    })
  var Kit = {}
  Oe(Kit, { diagram: () => LNt })
  var LNt,
    Qit = x(() => {
      'use strict'
      Fit()
      Git()
      zit()
      Xit()
      LNt = {
        parser: Bit,
        db: qN,
        renderer: XN,
        styles: Vit,
        init: a((e) => {
          XN.setConf(e.journey), qN.clear()
        }, 'init'),
      }
    })
  var QN,
    rst,
    nst = x(() => {
      'use strict'
      QN = (function () {
        var e = a(function (p, m, g, y) {
            for (g = g || {}, y = p.length; y--; g[p[y]] = m);
            return g
          }, 'o'),
          t = [6, 8, 10, 11, 12, 14, 16, 17, 20, 21],
          r = [1, 9],
          n = [1, 10],
          i = [1, 11],
          s = [1, 12],
          o = [1, 13],
          l = [1, 16],
          u = [1, 17],
          h = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              timeline: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              title: 11,
              acc_title: 12,
              acc_title_value: 13,
              acc_descr: 14,
              acc_descr_value: 15,
              acc_descr_multiline_value: 16,
              section: 17,
              period_statement: 18,
              event_statement: 19,
              period: 20,
              event: 21,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'timeline',
              6: 'EOF',
              8: 'SPACE',
              10: 'NEWLINE',
              11: 'title',
              12: 'acc_title',
              13: 'acc_title_value',
              14: 'acc_descr',
              15: 'acc_descr_value',
              16: 'acc_descr_multiline_value',
              17: 'section',
              20: 'period',
              21: 'event',
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [18, 1],
              [19, 1],
            ],
            performAction: a(function (m, g, y, b, k, T, C) {
              var A = T.length - 1
              switch (k) {
                case 1:
                  return T[A - 1]
                case 2:
                  this.$ = []
                  break
                case 3:
                  T[A - 1].push(T[A]), (this.$ = T[A - 1])
                  break
                case 4:
                case 5:
                  this.$ = T[A]
                  break
                case 6:
                case 7:
                  this.$ = []
                  break
                case 8:
                  b.getCommonDb().setDiagramTitle(T[A].substr(6)), (this.$ = T[A].substr(6))
                  break
                case 9:
                  ;(this.$ = T[A].trim()), b.getCommonDb().setAccTitle(this.$)
                  break
                case 10:
                case 11:
                  ;(this.$ = T[A].trim()), b.getCommonDb().setAccDescription(this.$)
                  break
                case 12:
                  b.addSection(T[A].substr(8)), (this.$ = T[A].substr(8))
                  break
                case 15:
                  b.addTask(T[A], 0, ''), (this.$ = T[A])
                  break
                case 16:
                  b.addEvent(T[A].substr(2)), (this.$ = T[A])
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: r,
                12: n,
                14: i,
                16: s,
                17: o,
                18: 14,
                19: 15,
                20: l,
                21: u,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              { 9: 18, 11: r, 12: n, 14: i, 16: s, 17: o, 18: 14, 19: 15, 20: l, 21: u },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 8]),
              { 13: [1, 19] },
              { 15: [1, 20] },
              e(t, [2, 11]),
              e(t, [2, 12]),
              e(t, [2, 13]),
              e(t, [2, 14]),
              e(t, [2, 15]),
              e(t, [2, 16]),
              e(t, [2, 4]),
              e(t, [2, 9]),
              e(t, [2, 10]),
            ],
            defaultActions: {},
            parseError: a(function (m, g) {
              if (g.recoverable) this.trace(m)
              else {
                var y = new Error(m)
                throw ((y.hash = g), y)
              }
            }, 'parseError'),
            parse: a(function (m) {
              var g = this,
                y = [0],
                b = [],
                k = [null],
                T = [],
                C = this.table,
                A = '',
                w = 0,
                D = 0,
                G = 0,
                v = 2,
                R = 1,
                F = T.slice.call(arguments, 1),
                S = Object.create(this.lexer),
                O = { yy: {} }
              for (var E in this.yy) Object.prototype.hasOwnProperty.call(this.yy, E) && (O.yy[E] = this.yy[E])
              S.setInput(m, O.yy), (O.yy.lexer = S), (O.yy.parser = this), typeof S.yylloc > 'u' && (S.yylloc = {})
              var _ = S.yylloc
              T.push(_)
              var L = S.options && S.options.ranges
              typeof O.yy.parseError == 'function'
                ? (this.parseError = O.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function N(dt) {
                ;(y.length = y.length - 2 * dt), (k.length = k.length - dt), (T.length = T.length - dt)
              }
              a(N, 'popStack')
              function P() {
                var dt
                return (
                  (dt = b.pop() || S.lex() || R),
                  typeof dt != 'number' &&
                    (dt instanceof Array && ((b = dt), (dt = b.pop())), (dt = g.symbols_[dt] || dt)),
                  dt
                )
              }
              a(P, 'lex')
              for (var I, M, V, $, q, tt, ft = {}, H, kt, ht, yt; ; ) {
                if (
                  ((V = y[y.length - 1]),
                  this.defaultActions[V]
                    ? ($ = this.defaultActions[V])
                    : ((I === null || typeof I > 'u') && (I = P()), ($ = C[V] && C[V][I])),
                  typeof $ > 'u' || !$.length || !$[0])
                ) {
                  var ot = ''
                  yt = []
                  for (H in C[V]) this.terminals_[H] && H > v && yt.push("'" + this.terminals_[H] + "'")
                  S.showPosition
                    ? (ot =
                        'Parse error on line ' +
                        (w + 1) +
                        `:
` +
                        S.showPosition() +
                        `
Expecting ` +
                        yt.join(', ') +
                        ", got '" +
                        (this.terminals_[I] || I) +
                        "'")
                    : (ot =
                        'Parse error on line ' +
                        (w + 1) +
                        ': Unexpected ' +
                        (I == R ? 'end of input' : "'" + (this.terminals_[I] || I) + "'")),
                    this.parseError(ot, {
                      text: S.match,
                      token: this.terminals_[I] || I,
                      line: S.yylineno,
                      loc: _,
                      expected: yt,
                    })
                }
                if ($[0] instanceof Array && $.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + V + ', token: ' + I)
                switch ($[0]) {
                  case 1:
                    y.push(I),
                      k.push(S.yytext),
                      T.push(S.yylloc),
                      y.push($[1]),
                      (I = null),
                      M
                        ? ((I = M), (M = null))
                        : ((D = S.yyleng), (A = S.yytext), (w = S.yylineno), (_ = S.yylloc), G > 0 && G--)
                    break
                  case 2:
                    if (
                      ((kt = this.productions_[$[1]][1]),
                      (ft.$ = k[k.length - kt]),
                      (ft._$ = {
                        first_line: T[T.length - (kt || 1)].first_line,
                        last_line: T[T.length - 1].last_line,
                        first_column: T[T.length - (kt || 1)].first_column,
                        last_column: T[T.length - 1].last_column,
                      }),
                      L && (ft._$.range = [T[T.length - (kt || 1)].range[0], T[T.length - 1].range[1]]),
                      (tt = this.performAction.apply(ft, [A, D, w, O.yy, $[1], k, T].concat(F))),
                      typeof tt < 'u')
                    )
                      return tt
                    kt && ((y = y.slice(0, -1 * kt * 2)), (k = k.slice(0, -1 * kt)), (T = T.slice(0, -1 * kt))),
                      y.push(this.productions_[$[1]][0]),
                      k.push(ft.$),
                      T.push(ft._$),
                      (ht = C[y[y.length - 2]][y[y.length - 1]]),
                      y.push(ht)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          f = (function () {
            var p = {
              EOF: 1,
              parseError: a(function (g, y) {
                if (this.yy.parser) this.yy.parser.parseError(g, y)
                else throw new Error(g)
              }, 'parseError'),
              setInput: a(function (m, g) {
                return (
                  (this.yy = g || this.yy || {}),
                  (this._input = m),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var m = this._input[0]
                ;(this.yytext += m), this.yyleng++, this.offset++, (this.match += m), (this.matched += m)
                var g = m.match(/(?:\r\n?|\n).*/g)
                return (
                  g ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  m
                )
              }, 'input'),
              unput: a(function (m) {
                var g = m.length,
                  y = m.split(/(?:\r\n?|\n)/g)
                ;(this._input = m + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - g)),
                  (this.offset -= g)
                var b = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  y.length - 1 && (this.yylineno -= y.length - 1)
                var k = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: y
                      ? (y.length === b.length ? this.yylloc.first_column : 0) +
                        b[b.length - y.length].length -
                        y[0].length
                      : this.yylloc.first_column - g,
                  }),
                  this.options.ranges && (this.yylloc.range = [k[0], k[0] + this.yyleng - g]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (m) {
                this.unput(this.match.slice(m))
              }, 'less'),
              pastInput: a(function () {
                var m = this.matched.substr(0, this.matched.length - this.match.length)
                return (m.length > 20 ? '...' : '') + m.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var m = this.match
                return (
                  m.length < 20 && (m += this._input.substr(0, 20 - m.length)),
                  (m.substr(0, 20) + (m.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var m = this.pastInput(),
                  g = new Array(m.length + 1).join('-')
                return (
                  m +
                  this.upcomingInput() +
                  `
` +
                  g +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (m, g) {
                var y, b, k
                if (
                  (this.options.backtrack_lexer &&
                    ((k = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (k.yylloc.range = this.yylloc.range.slice(0))),
                  (b = m[0].match(/(?:\r\n?|\n).*/g)),
                  b && (this.yylineno += b.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b
                      ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + m[0].length,
                  }),
                  (this.yytext += m[0]),
                  (this.match += m[0]),
                  (this.matches = m),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(m[0].length)),
                  (this.matched += m[0]),
                  (y = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    g,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  y)
                )
                  return y
                if (this._backtrack) {
                  for (var T in k) this[T] = k[T]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var m, g, y, b
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var k = this._currentRules(), T = 0; T < k.length; T++)
                  if (((y = this._input.match(this.rules[k[T]])), y && (!g || y[0].length > g[0].length))) {
                    if (((g = y), (b = T), this.options.backtrack_lexer)) {
                      if (((m = this.test_match(y, k[T])), m !== !1)) return m
                      if (this._backtrack) {
                        g = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return g
                  ? ((m = this.test_match(g, k[b])), m !== !1 ? m : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var g = this.next()
                return g || this.lex()
              }, 'lex'),
              begin: a(function (g) {
                this.conditionStack.push(g)
              }, 'begin'),
              popState: a(function () {
                var g = this.conditionStack.length - 1
                return g > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (g) {
                return (
                  (g = this.conditionStack.length - 1 - Math.abs(g || 0)), g >= 0 ? this.conditionStack[g] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (g) {
                this.begin(g)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (g, y, b, k) {
                var T = k
                switch (b) {
                  case 0:
                    break
                  case 1:
                    break
                  case 2:
                    return 10
                  case 3:
                    break
                  case 4:
                    break
                  case 5:
                    return 4
                  case 6:
                    return 11
                  case 7:
                    return this.begin('acc_title'), 12
                    break
                  case 8:
                    return this.popState(), 'acc_title_value'
                    break
                  case 9:
                    return this.begin('acc_descr'), 14
                    break
                  case 10:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 11:
                    this.begin('acc_descr_multiline')
                    break
                  case 12:
                    this.popState()
                    break
                  case 13:
                    return 'acc_descr_multiline_value'
                  case 14:
                    return 17
                  case 15:
                    return 21
                  case 16:
                    return 20
                  case 17:
                    return 6
                  case 18:
                    return 'INVALID'
                }
              }, 'anonymous'),
              rules: [
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:timeline\b)/i,
                /^(?:title\s[^\n]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:section\s[^:\n]+)/i,
                /^(?::\s(?:[^:\n]|:(?!\s))+)/i,
                /^(?:[^#:\n]+)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18], inclusive: !0 },
              },
            }
            return p
          })()
        h.lexer = f
        function d() {
          this.yy = {}
        }
        return a(d, 'Parser'), (d.prototype = h), (h.Parser = d), new d()
      })()
      QN.parser = QN
      rst = QN
    })
  var JN = {}
  Oe(JN, {
    addEvent: () => fst,
    addSection: () => lst,
    addTask: () => hst,
    addTaskOrg: () => dst,
    clear: () => ost,
    default: () => ONt,
    getCommonDb: () => ast,
    getSections: () => cst,
    getTasks: () => ust,
  })
  var Lm,
    sst,
    ZN,
    J_,
    Rm,
    ast,
    ost,
    lst,
    cst,
    ust,
    hst,
    fst,
    dst,
    ist,
    ONt,
    pst = x(() => {
      'use strict'
      bn()
      ;(Lm = ''),
        (sst = 0),
        (ZN = []),
        (J_ = []),
        (Rm = []),
        (ast = a(() => ag, 'getCommonDb')),
        (ost = a(function () {
          ;(ZN.length = 0), (J_.length = 0), (Lm = ''), (Rm.length = 0), Ye()
        }, 'clear')),
        (lst = a(function (e) {
          ;(Lm = e), ZN.push(e)
        }, 'addSection')),
        (cst = a(function () {
          return ZN
        }, 'getSections')),
        (ust = a(function () {
          let e = ist(),
            t = 100,
            r = 0
          for (; !e && r < t; ) (e = ist()), r++
          return J_.push(...Rm), J_
        }, 'getTasks')),
        (hst = a(function (e, t, r) {
          let n = { id: sst++, section: Lm, type: Lm, task: e, score: t || 0, events: r ? [r] : [] }
          Rm.push(n)
        }, 'addTask')),
        (fst = a(function (e) {
          Rm.find((r) => r.id === sst - 1).events.push(e)
        }, 'addEvent')),
        (dst = a(function (e) {
          let t = { section: Lm, type: Lm, description: e, task: e, classes: [] }
          J_.push(t)
        }, 'addTaskOrg')),
        (ist = a(function () {
          let e = a(function (r) {
              return Rm[r].processed
            }, 'compileTask'),
            t = !0
          for (let [r, n] of Rm.entries()) e(r), (t = t && n.processed)
          return t
        }, 'compileTasks')),
        (ONt = {
          clear: ost,
          getCommonDb: ast,
          addSection: lst,
          getSections: cst,
          getTasks: ust,
          addTask: hst,
          addTaskOrg: dst,
          addEvent: fst,
        })
    })
  function xst(e, t) {
    e.each(function () {
      var r = xt(this),
        n = r
          .text()
          .split(/(\s+|<br>)/)
          .reverse(),
        i,
        s = [],
        o = 1.1,
        l = r.attr('y'),
        u = parseFloat(r.attr('dy')),
        h = r
          .text(null)
          .append('tspan')
          .attr('x', 0)
          .attr('y', l)
          .attr('dy', u + 'em')
      for (let f = 0; f < n.length; f++)
        (i = n[n.length - 1 - f]),
          s.push(i),
          h.text(s.join(' ').trim()),
          (h.node().getComputedTextLength() > t || i === '<br>') &&
            (s.pop(),
            h.text(s.join(' ').trim()),
            i === '<br>' ? (s = ['']) : (s = [i]),
            (h = r
              .append('tspan')
              .attr('x', 0)
              .attr('y', l)
              .attr('dy', o + 'em')
              .text(i)))
    })
  }
  var PNt,
    tC,
    BNt,
    FNt,
    gst,
    $Nt,
    GNt,
    mst,
    VNt,
    zNt,
    WNt,
    t8,
    yst,
    UNt,
    jNt,
    qNt,
    HNt,
    au,
    bst = x(() => {
      'use strict'
      Ge()
      ;(PNt = 12),
        (tC = a(function (e, t) {
          let r = e.append('rect')
          return (
            r.attr('x', t.x),
            r.attr('y', t.y),
            r.attr('fill', t.fill),
            r.attr('stroke', t.stroke),
            r.attr('width', t.width),
            r.attr('height', t.height),
            r.attr('rx', t.rx),
            r.attr('ry', t.ry),
            t.class !== void 0 && r.attr('class', t.class),
            r
          )
        }, 'drawRect')),
        (BNt = a(function (e, t) {
          let n = e
              .append('circle')
              .attr('cx', t.cx)
              .attr('cy', t.cy)
              .attr('class', 'face')
              .attr('r', 15)
              .attr('stroke-width', 2)
              .attr('overflow', 'visible'),
            i = e.append('g')
          i
            .append('circle')
            .attr('cx', t.cx - 15 / 3)
            .attr('cy', t.cy - 15 / 3)
            .attr('r', 1.5)
            .attr('stroke-width', 2)
            .attr('fill', '#666')
            .attr('stroke', '#666'),
            i
              .append('circle')
              .attr('cx', t.cx + 15 / 3)
              .attr('cy', t.cy - 15 / 3)
              .attr('r', 1.5)
              .attr('stroke-width', 2)
              .attr('fill', '#666')
              .attr('stroke', '#666')
          function s(u) {
            let h = Ia()
              .startAngle(Math.PI / 2)
              .endAngle(3 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175)
            u.append('path')
              .attr('class', 'mouth')
              .attr('d', h)
              .attr('transform', 'translate(' + t.cx + ',' + (t.cy + 2) + ')')
          }
          a(s, 'smile')
          function o(u) {
            let h = Ia()
              .startAngle((3 * Math.PI) / 2)
              .endAngle(5 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175)
            u.append('path')
              .attr('class', 'mouth')
              .attr('d', h)
              .attr('transform', 'translate(' + t.cx + ',' + (t.cy + 7) + ')')
          }
          a(o, 'sad')
          function l(u) {
            u.append('line')
              .attr('class', 'mouth')
              .attr('stroke', 2)
              .attr('x1', t.cx - 5)
              .attr('y1', t.cy + 7)
              .attr('x2', t.cx + 5)
              .attr('y2', t.cy + 7)
              .attr('class', 'mouth')
              .attr('stroke-width', '1px')
              .attr('stroke', '#666')
          }
          return a(l, 'ambivalent'), t.score > 3 ? s(i) : t.score < 3 ? o(i) : l(i), n
        }, 'drawFace')),
        (FNt = a(function (e, t) {
          let r = e.append('circle')
          return (
            r.attr('cx', t.cx),
            r.attr('cy', t.cy),
            r.attr('class', 'actor-' + t.pos),
            r.attr('fill', t.fill),
            r.attr('stroke', t.stroke),
            r.attr('r', t.r),
            r.class !== void 0 && r.attr('class', r.class),
            t.title !== void 0 && r.append('title').text(t.title),
            r
          )
        }, 'drawCircle')),
        (gst = a(function (e, t) {
          let r = t.text.replace(/<br\s*\/?>/gi, ' '),
            n = e.append('text')
          n.attr('x', t.x),
            n.attr('y', t.y),
            n.attr('class', 'legend'),
            n.style('text-anchor', t.anchor),
            t.class !== void 0 && n.attr('class', t.class)
          let i = n.append('tspan')
          return i.attr('x', t.x + t.textMargin * 2), i.text(r), n
        }, 'drawText')),
        ($Nt = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              s +
              ' ' +
              (i + o) +
              ',' +
              (s + l - u) +
              ' ' +
              (i + o - u * 1.2) +
              ',' +
              (s + l) +
              ' ' +
              i +
              ',' +
              (s + l)
            )
          }
          a(r, 'genPoints')
          let n = e.append('polygon')
          n.attr('points', r(t.x, t.y, 50, 20, 7)),
            n.attr('class', 'labelBox'),
            (t.y = t.y + t.labelMargin),
            (t.x = t.x + 0.5 * t.labelMargin),
            gst(e, t)
        }, 'drawLabel')),
        (GNt = a(function (e, t, r) {
          let n = e.append('g'),
            i = t8()
          ;(i.x = t.x),
            (i.y = t.y),
            (i.fill = t.fill),
            (i.width = r.width),
            (i.height = r.height),
            (i.class = 'journey-section section-type-' + t.num),
            (i.rx = 3),
            (i.ry = 3),
            tC(n, i),
            yst(r)(
              t.text,
              n,
              i.x,
              i.y,
              i.width,
              i.height,
              { class: 'journey-section section-type-' + t.num },
              r,
              t.colour,
            )
        }, 'drawSection')),
        (mst = -1),
        (VNt = a(function (e, t, r) {
          let n = t.x + r.width / 2,
            i = e.append('g')
          mst++,
            i
              .append('line')
              .attr('id', 'task' + mst)
              .attr('x1', n)
              .attr('y1', t.y)
              .attr('x2', n)
              .attr('y2', 450)
              .attr('class', 'task-line')
              .attr('stroke-width', '1px')
              .attr('stroke-dasharray', '4 2')
              .attr('stroke', '#666'),
            BNt(i, { cx: n, cy: 300 + (5 - t.score) * 30, score: t.score })
          let o = t8()
          ;(o.x = t.x),
            (o.y = t.y),
            (o.fill = t.fill),
            (o.width = r.width),
            (o.height = r.height),
            (o.class = 'task task-type-' + t.num),
            (o.rx = 3),
            (o.ry = 3),
            tC(i, o),
            yst(r)(t.task, i, o.x, o.y, o.width, o.height, { class: 'task' }, r, t.colour)
        }, 'drawTask')),
        (zNt = a(function (e, t) {
          tC(e, {
            x: t.startx,
            y: t.starty,
            width: t.stopx - t.startx,
            height: t.stopy - t.starty,
            fill: t.fill,
            class: 'rect',
          }).lower()
        }, 'drawBackgroundRect')),
        (WNt = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            'text-anchor': 'start',
            width: 100,
            height: 100,
            textMargin: 0,
            rx: 0,
            ry: 0,
          }
        }, 'getTextObj')),
        (t8 = a(function () {
          return { x: 0, y: 0, width: 100, anchor: 'start', height: 100, rx: 0, ry: 0 }
        }, 'getNoteRect')),
        (yst = (function () {
          function e(i, s, o, l, u, h, f, d) {
            let p = s
              .append('text')
              .attr('x', o + u / 2)
              .attr('y', l + h / 2 + 5)
              .style('font-color', d)
              .style('text-anchor', 'middle')
              .text(i)
            n(p, f)
          }
          a(e, 'byText')
          function t(i, s, o, l, u, h, f, d, p) {
            let { taskFontSize: m, taskFontFamily: g } = d,
              y = i.split(/<br\s*\/?>/gi)
            for (let b = 0; b < y.length; b++) {
              let k = b * m - (m * (y.length - 1)) / 2,
                T = s
                  .append('text')
                  .attr('x', o + u / 2)
                  .attr('y', l)
                  .attr('fill', p)
                  .style('text-anchor', 'middle')
                  .style('font-size', m)
                  .style('font-family', g)
              T.append('tspan')
                .attr('x', o + u / 2)
                .attr('dy', k)
                .text(y[b]),
                T.attr('y', l + h / 2)
                  .attr('dominant-baseline', 'central')
                  .attr('alignment-baseline', 'central'),
                n(T, f)
            }
          }
          a(t, 'byTspan')
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append('switch'),
              g = p
                .append('foreignObject')
                .attr('x', o)
                .attr('y', l)
                .attr('width', u)
                .attr('height', h)
                .attr('position', 'fixed')
                .append('xhtml:div')
                .style('display', 'table')
                .style('height', '100%')
                .style('width', '100%')
            g
              .append('div')
              .attr('class', 'label')
              .style('display', 'table-cell')
              .style('text-align', 'center')
              .style('vertical-align', 'middle')
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f)
          }
          a(r, 'byFo')
          function n(i, s) {
            for (let o in s) o in s && i.attr(o, s[o])
          }
          return (
            a(n, '_setTextAttrs'),
            function (i) {
              return i.textPlacement === 'fo' ? r : i.textPlacement === 'old' ? e : t
            }
          )
        })()),
        (UNt = a(function (e) {
          e.append('defs')
            .append('marker')
            .attr('id', 'arrowhead')
            .attr('refX', 5)
            .attr('refY', 2)
            .attr('markerWidth', 6)
            .attr('markerHeight', 4)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0,0 V 4 L6,2 Z')
        }, 'initGraphics'))
      a(xst, 'wrap')
      ;(jNt = a(function (e, t, r, n) {
        let i = (r % PNt) - 1,
          s = e.append('g')
        ;(t.section = i), s.attr('class', (t.class ? t.class + ' ' : '') + 'timeline-node ' + ('section-' + i))
        let o = s.append('g'),
          l = s.append('g'),
          h = l
            .append('text')
            .text(t.descr)
            .attr('dy', '1em')
            .attr('alignment-baseline', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .call(xst, t.width)
            .node()
            .getBBox(),
          f = n.fontSize?.replace ? n.fontSize.replace('px', '') : n.fontSize
        return (
          (t.height = h.height + f * 1.1 * 0.5 + t.padding),
          (t.height = Math.max(t.height, t.maxHeight)),
          (t.width = t.width + 2 * t.padding),
          l.attr('transform', 'translate(' + t.width / 2 + ', ' + t.padding / 2 + ')'),
          HNt(o, t, i, n),
          t
        )
      }, 'drawNode')),
        (qNt = a(function (e, t, r) {
          let n = e.append('g'),
            s = n
              .append('text')
              .text(t.descr)
              .attr('dy', '1em')
              .attr('alignment-baseline', 'middle')
              .attr('dominant-baseline', 'middle')
              .attr('text-anchor', 'middle')
              .call(xst, t.width)
              .node()
              .getBBox(),
            o = r.fontSize?.replace ? r.fontSize.replace('px', '') : r.fontSize
          return n.remove(), s.height + o * 1.1 * 0.5 + t.padding
        }, 'getVirtualNodeHeight')),
        (HNt = a(function (e, t, r) {
          e
            .append('path')
            .attr('id', 'node-' + t.id)
            .attr('class', 'node-bkg node-' + t.type)
            .attr(
              'd',
              `M0 ${t.height - 5} v${-t.height + 10} q0,-5 5,-5 h${t.width - 10} q5,0 5,5 v${t.height - 5} H0 Z`,
            ),
            e
              .append('line')
              .attr('class', 'node-line-' + r)
              .attr('x1', 0)
              .attr('y1', t.height)
              .attr('x2', t.width)
              .attr('y2', t.height)
        }, 'defaultBkg')),
        (au = {
          drawRect: tC,
          drawCircle: FNt,
          drawSection: GNt,
          drawText: gst,
          drawLabel: $Nt,
          drawTask: VNt,
          drawBackgroundRect: zNt,
          getTextObj: WNt,
          getNoteRect: t8,
          initGraphics: UNt,
          drawNode: jNt,
          getVirtualNodeHeight: qNt,
        })
    })
  var YNt,
    kst,
    XNt,
    Tst,
    Sst = x(() => {
      'use strict'
      Ge()
      bst()
      Vt()
      pe()
      On()
      ;(YNt = a(function (e, t, r, n) {
        let i = K(),
          s = i.timeline?.leftMargin ?? 50
        B.debug('timeline', n.db)
        let o = i.securityLevel,
          l
        o === 'sandbox' && (l = xt('#i' + t))
        let h = (o === 'sandbox' ? xt(l.nodes()[0].contentDocument.body) : xt('body')).select('#' + t)
        h.append('g')
        let f = n.db.getTasks(),
          d = n.db.getCommonDb().getDiagramTitle()
        B.debug('task', f), au.initGraphics(h)
        let p = n.db.getSections()
        B.debug('sections', p)
        let m = 0,
          g = 0,
          y = 0,
          b = 0,
          k = 50 + s,
          T = 50
        b = 50
        let C = 0,
          A = !0
        p.forEach(function (R) {
          let F = { number: C, descr: R, section: C, width: 150, padding: 20, maxHeight: m },
            S = au.getVirtualNodeHeight(h, F, i)
          B.debug('sectionHeight before draw', S), (m = Math.max(m, S + 20))
        })
        let w = 0,
          D = 0
        B.debug('tasks.length', f.length)
        for (let [R, F] of f.entries()) {
          let S = { number: R, descr: F, section: F.section, width: 150, padding: 20, maxHeight: g },
            O = au.getVirtualNodeHeight(h, S, i)
          B.debug('taskHeight before draw', O), (g = Math.max(g, O + 20)), (w = Math.max(w, F.events.length))
          let E = 0
          for (let _ of F.events) {
            let L = { descr: _, section: F.section, number: F.section, width: 150, padding: 20, maxHeight: 50 }
            E += au.getVirtualNodeHeight(h, L, i)
          }
          F.events.length > 0 && (E += (F.events.length - 1) * 10), (D = Math.max(D, E))
        }
        B.debug('maxSectionHeight before draw', m),
          B.debug('maxTaskHeight before draw', g),
          p && p.length > 0
            ? p.forEach((R) => {
                let F = f.filter((_) => _.section === R),
                  S = {
                    number: C,
                    descr: R,
                    section: C,
                    width: 200 * Math.max(F.length, 1) - 50,
                    padding: 20,
                    maxHeight: m,
                  }
                B.debug('sectionNode', S)
                let O = h.append('g'),
                  E = au.drawNode(O, S, C, i)
                B.debug('sectionNode output', E),
                  O.attr('transform', `translate(${k}, ${b})`),
                  (T += m + 50),
                  F.length > 0 && kst(h, F, C, k, T, g, i, w, D, m, !1),
                  (k += 200 * Math.max(F.length, 1)),
                  (T = b),
                  C++
              })
            : ((A = !1), kst(h, f, C, k, T, g, i, w, D, m, !0))
        let G = h.node().getBBox()
        B.debug('bounds', G),
          d &&
            h
              .append('text')
              .text(d)
              .attr('x', G.width / 2 - s)
              .attr('font-size', '4ex')
              .attr('font-weight', 'bold')
              .attr('y', 20),
          (y = A ? m + g + 150 : g + 100),
          h
            .append('g')
            .attr('class', 'lineWrapper')
            .append('line')
            .attr('x1', s)
            .attr('y1', y)
            .attr('x2', G.width + 3 * s)
            .attr('y2', y)
            .attr('stroke-width', 4)
            .attr('stroke', 'black')
            .attr('marker-end', 'url(#arrowhead)'),
          Kl(void 0, h, i.timeline?.padding ?? 50, i.timeline?.useMaxWidth ?? !1)
      }, 'draw')),
        (kst = a(function (e, t, r, n, i, s, o, l, u, h, f) {
          for (let d of t) {
            let p = { descr: d.task, section: r, number: r, width: 150, padding: 20, maxHeight: s }
            B.debug('taskNode', p)
            let m = e.append('g').attr('class', 'taskWrapper'),
              y = au.drawNode(m, p, r, o).height
            if (
              (B.debug('taskHeight after draw', y),
              m.attr('transform', `translate(${n}, ${i})`),
              (s = Math.max(s, y)),
              d.events)
            ) {
              let b = e.append('g').attr('class', 'lineWrapper'),
                k = s
              ;(i += 100),
                (k = k + XNt(e, d.events, r, n, i, o)),
                (i -= 100),
                b
                  .append('line')
                  .attr('x1', n + 190 / 2)
                  .attr('y1', i + s)
                  .attr('x2', n + 190 / 2)
                  .attr('y2', i + s + 100 + u + 100)
                  .attr('stroke-width', 2)
                  .attr('stroke', 'black')
                  .attr('marker-end', 'url(#arrowhead)')
                  .attr('stroke-dasharray', '5,5')
            }
            ;(n = n + 200), f && !o.timeline?.disableMulticolor && r++
          }
          i = i - 10
        }, 'drawTasks')),
        (XNt = a(function (e, t, r, n, i, s) {
          let o = 0,
            l = i
          i = i + 100
          for (let u of t) {
            let h = { descr: u, section: r, number: r, width: 150, padding: 20, maxHeight: 50 }
            B.debug('eventNode', h)
            let f = e.append('g').attr('class', 'eventWrapper'),
              p = au.drawNode(f, h, r, s).height
            ;(o = o + p), f.attr('transform', `translate(${n}, ${i})`), (i = i + 10 + p)
          }
          return (i = l), o
        }, 'drawEvents')),
        (Tst = { setConf: a(() => {}, 'setConf'), draw: YNt })
    })
  var KNt,
    QNt,
    _st,
    Cst = x(() => {
      'use strict'
      js()
      ;(KNt = a((e) => {
        let t = ''
        for (let r = 0; r < e.THEME_COLOR_LIMIT; r++)
          (e['lineColor' + r] = e['lineColor' + r] || e['cScaleInv' + r]),
            Ii(e['lineColor' + r])
              ? (e['lineColor' + r] = Yt(e['lineColor' + r], 20))
              : (e['lineColor' + r] = ee(e['lineColor' + r], 20))
        for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
          let n = '' + (17 - 3 * r)
          t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${e['cScale' + r]};
    }
    .section-${r - 1} text {
     fill: ${e['cScaleLabel' + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e['cScaleLabel' + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e['cScale' + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${e['cScaleInv' + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${e['cScaleLabel' + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `
        }
        return t
      }, 'genSections')),
        (QNt = a(
          (e) => `
  .edge {
    stroke-width: 3;
  }
  ${KNt(e)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`,
          'getStyles',
        )),
        (_st = QNt)
    })
  var wst = {}
  Oe(wst, { diagram: () => ZNt })
  var ZNt,
    Est = x(() => {
      'use strict'
      nst()
      pst()
      Sst()
      Cst()
      ZNt = { db: JN, renderer: Tst, parser: rst, styles: _st }
    })
  var e8,
    Lst,
    Rst = x(() => {
      'use strict'
      e8 = (function () {
        var e = a(function (G, v, R, F) {
            for (R = R || {}, F = G.length; F--; R[G[F]] = v);
            return R
          }, 'o'),
          t = [1, 4],
          r = [1, 13],
          n = [1, 12],
          i = [1, 15],
          s = [1, 16],
          o = [1, 20],
          l = [1, 19],
          u = [6, 7, 8],
          h = [1, 26],
          f = [1, 24],
          d = [1, 25],
          p = [6, 7, 11],
          m = [1, 31],
          g = [6, 7, 11, 24],
          y = [1, 6, 13, 16, 17, 20, 23],
          b = [1, 35],
          k = [1, 36],
          T = [1, 6, 7, 11, 13, 16, 17, 20, 23],
          C = [1, 38],
          A = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mindMap: 4,
              spaceLines: 5,
              SPACELINE: 6,
              NL: 7,
              KANBAN: 8,
              document: 9,
              stop: 10,
              EOF: 11,
              statement: 12,
              SPACELIST: 13,
              node: 14,
              shapeData: 15,
              ICON: 16,
              CLASS: 17,
              nodeWithId: 18,
              nodeWithoutId: 19,
              NODE_DSTART: 20,
              NODE_DESCR: 21,
              NODE_DEND: 22,
              NODE_ID: 23,
              SHAPE_DATA: 24,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              6: 'SPACELINE',
              7: 'NL',
              8: 'KANBAN',
              11: 'EOF',
              13: 'SPACELIST',
              16: 'ICON',
              17: 'CLASS',
              20: 'NODE_DSTART',
              21: 'NODE_DESCR',
              22: 'NODE_DEND',
              23: 'NODE_ID',
              24: 'SHAPE_DATA',
            },
            productions_: [
              0,
              [3, 1],
              [3, 2],
              [5, 1],
              [5, 2],
              [5, 2],
              [4, 2],
              [4, 3],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 2],
              [10, 2],
              [9, 3],
              [9, 2],
              [12, 3],
              [12, 2],
              [12, 2],
              [12, 2],
              [12, 1],
              [12, 2],
              [12, 1],
              [12, 1],
              [12, 1],
              [12, 1],
              [14, 1],
              [14, 1],
              [19, 3],
              [18, 1],
              [18, 4],
              [15, 2],
              [15, 1],
            ],
            performAction: a(function (v, R, F, S, O, E, _) {
              var L = E.length - 1
              switch (O) {
                case 6:
                case 7:
                  return S
                case 8:
                  S.getLogger().trace('Stop NL ')
                  break
                case 9:
                  S.getLogger().trace('Stop EOF ')
                  break
                case 11:
                  S.getLogger().trace('Stop NL2 ')
                  break
                case 12:
                  S.getLogger().trace('Stop EOF2 ')
                  break
                case 15:
                  S.getLogger().info('Node: ', E[L - 1].id),
                    S.addNode(E[L - 2].length, E[L - 1].id, E[L - 1].descr, E[L - 1].type, E[L])
                  break
                case 16:
                  S.getLogger().info('Node: ', E[L].id), S.addNode(E[L - 1].length, E[L].id, E[L].descr, E[L].type)
                  break
                case 17:
                  S.getLogger().trace('Icon: ', E[L]), S.decorateNode({ icon: E[L] })
                  break
                case 18:
                case 23:
                  S.decorateNode({ class: E[L] })
                  break
                case 19:
                  S.getLogger().trace('SPACELIST')
                  break
                case 20:
                  S.getLogger().trace('Node: ', E[L - 1].id),
                    S.addNode(0, E[L - 1].id, E[L - 1].descr, E[L - 1].type, E[L])
                  break
                case 21:
                  S.getLogger().trace('Node: ', E[L].id), S.addNode(0, E[L].id, E[L].descr, E[L].type)
                  break
                case 22:
                  S.decorateNode({ icon: E[L] })
                  break
                case 27:
                  S.getLogger().trace('node found ..', E[L - 2]),
                    (this.$ = { id: E[L - 1], descr: E[L - 1], type: S.getType(E[L - 2], E[L]) })
                  break
                case 28:
                  this.$ = { id: E[L], descr: E[L], type: 0 }
                  break
                case 29:
                  S.getLogger().trace('node found ..', E[L - 3]),
                    (this.$ = { id: E[L - 3], descr: E[L - 1], type: S.getType(E[L - 2], E[L]) })
                  break
                case 30:
                  this.$ = E[L - 1] + E[L]
                  break
                case 31:
                  this.$ = E[L]
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: t },
              { 1: [3] },
              { 1: [2, 1] },
              { 4: 6, 6: [1, 7], 7: [1, 8], 8: t },
              { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: n, 14: 14, 16: i, 17: s, 18: 17, 19: 18, 20: o, 23: l },
              e(u, [2, 3]),
              { 1: [2, 2] },
              e(u, [2, 4]),
              e(u, [2, 5]),
              { 1: [2, 6], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: s, 18: 17, 19: 18, 20: o, 23: l },
              { 6: r, 9: 22, 12: 11, 13: n, 14: 14, 16: i, 17: s, 18: 17, 19: 18, 20: o, 23: l },
              { 6: h, 7: f, 10: 23, 11: d },
              e(p, [2, 24], { 18: 17, 19: 18, 14: 27, 16: [1, 28], 17: [1, 29], 20: o, 23: l }),
              e(p, [2, 19]),
              e(p, [2, 21], { 15: 30, 24: m }),
              e(p, [2, 22]),
              e(p, [2, 23]),
              e(g, [2, 25]),
              e(g, [2, 26]),
              e(g, [2, 28], { 20: [1, 32] }),
              { 21: [1, 33] },
              { 6: h, 7: f, 10: 34, 11: d },
              { 1: [2, 7], 6: r, 12: 21, 13: n, 14: 14, 16: i, 17: s, 18: 17, 19: 18, 20: o, 23: l },
              e(y, [2, 14], { 7: b, 11: k }),
              e(T, [2, 8]),
              e(T, [2, 9]),
              e(T, [2, 10]),
              e(p, [2, 16], { 15: 37, 24: m }),
              e(p, [2, 17]),
              e(p, [2, 18]),
              e(p, [2, 20], { 24: C }),
              e(g, [2, 31]),
              { 21: [1, 39] },
              { 22: [1, 40] },
              e(y, [2, 13], { 7: b, 11: k }),
              e(T, [2, 11]),
              e(T, [2, 12]),
              e(p, [2, 15], { 24: C }),
              e(g, [2, 30]),
              { 22: [1, 41] },
              e(g, [2, 27]),
              e(g, [2, 29]),
            ],
            defaultActions: { 2: [2, 1], 6: [2, 2] },
            parseError: a(function (v, R) {
              if (R.recoverable) this.trace(v)
              else {
                var F = new Error(v)
                throw ((F.hash = R), F)
              }
            }, 'parseError'),
            parse: a(function (v) {
              var R = this,
                F = [0],
                S = [],
                O = [null],
                E = [],
                _ = this.table,
                L = '',
                N = 0,
                P = 0,
                I = 0,
                M = 2,
                V = 1,
                $ = E.slice.call(arguments, 1),
                q = Object.create(this.lexer),
                tt = { yy: {} }
              for (var ft in this.yy) Object.prototype.hasOwnProperty.call(this.yy, ft) && (tt.yy[ft] = this.yy[ft])
              q.setInput(v, tt.yy), (tt.yy.lexer = q), (tt.yy.parser = this), typeof q.yylloc > 'u' && (q.yylloc = {})
              var H = q.yylloc
              E.push(H)
              var kt = q.options && q.options.ranges
              typeof tt.yy.parseError == 'function'
                ? (this.parseError = tt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function ht(jt) {
                ;(F.length = F.length - 2 * jt), (O.length = O.length - jt), (E.length = E.length - jt)
              }
              a(ht, 'popStack')
              function yt() {
                var jt
                return (
                  (jt = S.pop() || q.lex() || V),
                  typeof jt != 'number' &&
                    (jt instanceof Array && ((S = jt), (jt = S.pop())), (jt = R.symbols_[jt] || jt)),
                  jt
                )
              }
              a(yt, 'lex')
              for (var ot, dt, it, Q, et, X, st = {}, U, gt, z, ge; ; ) {
                if (
                  ((it = F[F.length - 1]),
                  this.defaultActions[it]
                    ? (Q = this.defaultActions[it])
                    : ((ot === null || typeof ot > 'u') && (ot = yt()), (Q = _[it] && _[it][ot])),
                  typeof Q > 'u' || !Q.length || !Q[0])
                ) {
                  var lt = ''
                  ge = []
                  for (U in _[it]) this.terminals_[U] && U > M && ge.push("'" + this.terminals_[U] + "'")
                  q.showPosition
                    ? (lt =
                        'Parse error on line ' +
                        (N + 1) +
                        `:
` +
                        q.showPosition() +
                        `
Expecting ` +
                        ge.join(', ') +
                        ", got '" +
                        (this.terminals_[ot] || ot) +
                        "'")
                    : (lt =
                        'Parse error on line ' +
                        (N + 1) +
                        ': Unexpected ' +
                        (ot == V ? 'end of input' : "'" + (this.terminals_[ot] || ot) + "'")),
                    this.parseError(lt, {
                      text: q.match,
                      token: this.terminals_[ot] || ot,
                      line: q.yylineno,
                      loc: H,
                      expected: ge,
                    })
                }
                if (Q[0] instanceof Array && Q.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + it + ', token: ' + ot)
                switch (Q[0]) {
                  case 1:
                    F.push(ot),
                      O.push(q.yytext),
                      E.push(q.yylloc),
                      F.push(Q[1]),
                      (ot = null),
                      dt
                        ? ((ot = dt), (dt = null))
                        : ((P = q.yyleng), (L = q.yytext), (N = q.yylineno), (H = q.yylloc), I > 0 && I--)
                    break
                  case 2:
                    if (
                      ((gt = this.productions_[Q[1]][1]),
                      (st.$ = O[O.length - gt]),
                      (st._$ = {
                        first_line: E[E.length - (gt || 1)].first_line,
                        last_line: E[E.length - 1].last_line,
                        first_column: E[E.length - (gt || 1)].first_column,
                        last_column: E[E.length - 1].last_column,
                      }),
                      kt && (st._$.range = [E[E.length - (gt || 1)].range[0], E[E.length - 1].range[1]]),
                      (X = this.performAction.apply(st, [L, P, N, tt.yy, Q[1], O, E].concat($))),
                      typeof X < 'u')
                    )
                      return X
                    gt && ((F = F.slice(0, -1 * gt * 2)), (O = O.slice(0, -1 * gt)), (E = E.slice(0, -1 * gt))),
                      F.push(this.productions_[Q[1]][0]),
                      O.push(st.$),
                      E.push(st._$),
                      (z = _[F[F.length - 2]][F[F.length - 1]]),
                      F.push(z)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          w = (function () {
            var G = {
              EOF: 1,
              parseError: a(function (R, F) {
                if (this.yy.parser) this.yy.parser.parseError(R, F)
                else throw new Error(R)
              }, 'parseError'),
              setInput: a(function (v, R) {
                return (
                  (this.yy = R || this.yy || {}),
                  (this._input = v),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var v = this._input[0]
                ;(this.yytext += v), this.yyleng++, this.offset++, (this.match += v), (this.matched += v)
                var R = v.match(/(?:\r\n?|\n).*/g)
                return (
                  R ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  v
                )
              }, 'input'),
              unput: a(function (v) {
                var R = v.length,
                  F = v.split(/(?:\r\n?|\n)/g)
                ;(this._input = v + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - R)),
                  (this.offset -= R)
                var S = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  F.length - 1 && (this.yylineno -= F.length - 1)
                var O = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: F
                      ? (F.length === S.length ? this.yylloc.first_column : 0) +
                        S[S.length - F.length].length -
                        F[0].length
                      : this.yylloc.first_column - R,
                  }),
                  this.options.ranges && (this.yylloc.range = [O[0], O[0] + this.yyleng - R]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (v) {
                this.unput(this.match.slice(v))
              }, 'less'),
              pastInput: a(function () {
                var v = this.matched.substr(0, this.matched.length - this.match.length)
                return (v.length > 20 ? '...' : '') + v.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var v = this.match
                return (
                  v.length < 20 && (v += this._input.substr(0, 20 - v.length)),
                  (v.substr(0, 20) + (v.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var v = this.pastInput(),
                  R = new Array(v.length + 1).join('-')
                return (
                  v +
                  this.upcomingInput() +
                  `
` +
                  R +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (v, R) {
                var F, S, O
                if (
                  (this.options.backtrack_lexer &&
                    ((O = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (O.yylloc.range = this.yylloc.range.slice(0))),
                  (S = v[0].match(/(?:\r\n?|\n).*/g)),
                  S && (this.yylineno += S.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: S
                      ? S[S.length - 1].length - S[S.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + v[0].length,
                  }),
                  (this.yytext += v[0]),
                  (this.match += v[0]),
                  (this.matches = v),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(v[0].length)),
                  (this.matched += v[0]),
                  (F = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    R,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  F)
                )
                  return F
                if (this._backtrack) {
                  for (var E in O) this[E] = O[E]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var v, R, F, S
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var O = this._currentRules(), E = 0; E < O.length; E++)
                  if (((F = this._input.match(this.rules[O[E]])), F && (!R || F[0].length > R[0].length))) {
                    if (((R = F), (S = E), this.options.backtrack_lexer)) {
                      if (((v = this.test_match(F, O[E])), v !== !1)) return v
                      if (this._backtrack) {
                        R = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return R
                  ? ((v = this.test_match(R, O[S])), v !== !1 ? v : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var R = this.next()
                return R || this.lex()
              }, 'lex'),
              begin: a(function (R) {
                this.conditionStack.push(R)
              }, 'begin'),
              popState: a(function () {
                var R = this.conditionStack.length - 1
                return R > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (R) {
                return (
                  (R = this.conditionStack.length - 1 - Math.abs(R || 0)), R >= 0 ? this.conditionStack[R] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (R) {
                this.begin(R)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (R, F, S, O) {
                var E = O
                switch (S) {
                  case 0:
                    return this.pushState('shapeData'), (F.yytext = ''), 24
                    break
                  case 1:
                    return this.pushState('shapeDataStr'), 24
                    break
                  case 2:
                    return this.popState(), 24
                    break
                  case 3:
                    let _ = /\n\s*/g
                    return (F.yytext = F.yytext.replace(_, '<br/>')), 24
                    break
                  case 4:
                    return 24
                  case 5:
                    this.popState()
                    break
                  case 6:
                    return R.getLogger().trace('Found comment', F.yytext), 6
                    break
                  case 7:
                    return 8
                  case 8:
                    this.begin('CLASS')
                    break
                  case 9:
                    return this.popState(), 17
                    break
                  case 10:
                    this.popState()
                    break
                  case 11:
                    R.getLogger().trace('Begin icon'), this.begin('ICON')
                    break
                  case 12:
                    return R.getLogger().trace('SPACELINE'), 6
                    break
                  case 13:
                    return 7
                  case 14:
                    return 16
                  case 15:
                    R.getLogger().trace('end icon'), this.popState()
                    break
                  case 16:
                    return R.getLogger().trace('Exploding node'), this.begin('NODE'), 20
                    break
                  case 17:
                    return R.getLogger().trace('Cloud'), this.begin('NODE'), 20
                    break
                  case 18:
                    return R.getLogger().trace('Explosion Bang'), this.begin('NODE'), 20
                    break
                  case 19:
                    return R.getLogger().trace('Cloud Bang'), this.begin('NODE'), 20
                    break
                  case 20:
                    return this.begin('NODE'), 20
                    break
                  case 21:
                    return this.begin('NODE'), 20
                    break
                  case 22:
                    return this.begin('NODE'), 20
                    break
                  case 23:
                    return this.begin('NODE'), 20
                    break
                  case 24:
                    return 13
                  case 25:
                    return 23
                  case 26:
                    return 11
                  case 27:
                    this.begin('NSTR2')
                    break
                  case 28:
                    return 'NODE_DESCR'
                  case 29:
                    this.popState()
                    break
                  case 30:
                    R.getLogger().trace('Starting NSTR'), this.begin('NSTR')
                    break
                  case 31:
                    return R.getLogger().trace('description:', F.yytext), 'NODE_DESCR'
                    break
                  case 32:
                    this.popState()
                    break
                  case 33:
                    return this.popState(), R.getLogger().trace('node end ))'), 'NODE_DEND'
                    break
                  case 34:
                    return this.popState(), R.getLogger().trace('node end )'), 'NODE_DEND'
                    break
                  case 35:
                    return this.popState(), R.getLogger().trace('node end ...', F.yytext), 'NODE_DEND'
                    break
                  case 36:
                    return this.popState(), R.getLogger().trace('node end (('), 'NODE_DEND'
                    break
                  case 37:
                    return this.popState(), R.getLogger().trace('node end (-'), 'NODE_DEND'
                    break
                  case 38:
                    return this.popState(), R.getLogger().trace('node end (-'), 'NODE_DEND'
                    break
                  case 39:
                    return this.popState(), R.getLogger().trace('node end (('), 'NODE_DEND'
                    break
                  case 40:
                    return this.popState(), R.getLogger().trace('node end (('), 'NODE_DEND'
                    break
                  case 41:
                    return R.getLogger().trace('Long description:', F.yytext), 21
                    break
                  case 42:
                    return R.getLogger().trace('Long description:', F.yytext), 21
                    break
                }
              }, 'anonymous'),
              rules: [
                /^(?:@\{)/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^\"]+)/i,
                /^(?:[^}^"]+)/i,
                /^(?:\})/i,
                /^(?:\s*%%.*)/i,
                /^(?:kanban\b)/i,
                /^(?::::)/i,
                /^(?:.+)/i,
                /^(?:\n)/i,
                /^(?:::icon\()/i,
                /^(?:[\s]+[\n])/i,
                /^(?:[\n]+)/i,
                /^(?:[^\)]+)/i,
                /^(?:\))/i,
                /^(?:-\))/i,
                /^(?:\(-)/i,
                /^(?:\)\))/i,
                /^(?:\))/i,
                /^(?:\(\()/i,
                /^(?:\{\{)/i,
                /^(?:\()/i,
                /^(?:\[)/i,
                /^(?:[\s]+)/i,
                /^(?:[^\(\[\n\)\{\}@]+)/i,
                /^(?:$)/i,
                /^(?:["][`])/i,
                /^(?:[^`"]+)/i,
                /^(?:[`]["])/i,
                /^(?:["])/i,
                /^(?:[^"]+)/i,
                /^(?:["])/i,
                /^(?:[\)]\))/i,
                /^(?:[\)])/i,
                /^(?:[\]])/i,
                /^(?:\}\})/i,
                /^(?:\(-)/i,
                /^(?:-\))/i,
                /^(?:\(\()/i,
                /^(?:\()/i,
                /^(?:[^\)\]\(\}]+)/i,
                /^(?:.+(?!\(\())/i,
              ],
              conditions: {
                shapeDataEndBracket: { rules: [], inclusive: !1 },
                shapeDataStr: { rules: [2, 3], inclusive: !1 },
                shapeData: { rules: [1, 4, 5], inclusive: !1 },
                CLASS: { rules: [9, 10], inclusive: !1 },
                ICON: { rules: [14, 15], inclusive: !1 },
                NSTR2: { rules: [28, 29], inclusive: !1 },
                NSTR: { rules: [31, 32], inclusive: !1 },
                NODE: { rules: [27, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: !1 },
                INITIAL: { rules: [0, 6, 7, 8, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], inclusive: !0 },
              },
            }
            return G
          })()
        A.lexer = w
        function D() {
          this.yy = {}
        }
        return a(D, 'Parser'), (D.prototype = A), (A.Parser = D), new D()
      })()
      e8.parser = e8
      Lst = e8
    })
  var ya,
    n8,
    r8,
    i8,
    r8t,
    n8t,
    Dst,
    i8t,
    s8t,
    Gn,
    a8t,
    o8t,
    l8t,
    c8t,
    u8t,
    h8t,
    f8t,
    Nst,
    Ist = x(() => {
      'use strict'
      pe()
      Be()
      Vt()
      _s()
      E0()
      ;(ya = []),
        (n8 = []),
        (r8 = 0),
        (i8 = {}),
        (r8t = a(() => {
          ;(ya = []), (n8 = []), (r8 = 0), (i8 = {})
        }, 'clear')),
        (n8t = a((e) => {
          if (ya.length === 0) return null
          let t = ya[0].level,
            r = null
          for (let n = ya.length - 1; n >= 0; n--)
            if ((ya[n].level === t && !r && (r = ya[n]), ya[n].level < t))
              throw new Error('Items without section detected, found section ("' + ya[n].label + '")')
          return e === r?.level ? null : r
        }, 'getSection')),
        (Dst = a(function () {
          return n8
        }, 'getSections')),
        (i8t = a(function () {
          let e = [],
            t = [],
            r = Dst(),
            n = K()
          for (let i of r) {
            let s = {
              id: i.id,
              label: Ie(i.label ?? '', n),
              isGroup: !0,
              ticket: i.ticket,
              shape: 'kanbanSection',
              level: i.level,
              look: n.look,
            }
            t.push(s)
            let o = ya.filter((l) => l.parentId === i.id)
            for (let l of o) {
              let u = {
                id: l.id,
                parentId: i.id,
                label: Ie(l.label ?? '', n),
                isGroup: !1,
                ticket: l?.ticket,
                priority: l?.priority,
                assigned: l?.assigned,
                icon: l?.icon,
                shape: 'kanbanItem',
                level: l.level,
                rx: 5,
                ry: 5,
                cssStyles: ['text-align: left'],
              }
              t.push(u)
            }
          }
          return { nodes: t, edges: e, other: {}, config: K() }
        }, 'getData')),
        (s8t = a((e, t, r, n, i) => {
          let s = K(),
            o = s.mindmap?.padding ?? ze.mindmap.padding
          switch (n) {
            case Gn.ROUNDED_RECT:
            case Gn.RECT:
            case Gn.HEXAGON:
              o *= 2
          }
          let l = {
            id: Ie(t, s) || 'kbn' + r8++,
            level: e,
            label: Ie(r, s),
            width: s.mindmap?.maxNodeWidth ?? ze.mindmap.maxNodeWidth,
            padding: o,
            isGroup: !1,
          }
          if (i !== void 0) {
            let h
            i.includes(`
`)
              ? (h =
                  i +
                  `
`)
              : (h =
                  `{
` +
                  i +
                  `
}`)
            let f = Cc(h, { schema: _c })
            if (f.shape && (f.shape !== f.shape.toLowerCase() || f.shape.includes('_')))
              throw new Error(`No such shape: ${f.shape}. Shape names should be lowercase.`)
            f?.shape && f.shape === 'kanbanItem' && (l.shape = f?.shape),
              f?.label && (l.label = f?.label),
              f?.icon && (l.icon = f?.icon.toString()),
              f?.assigned && (l.assigned = f?.assigned.toString()),
              f?.ticket && (l.ticket = f?.ticket.toString()),
              f?.priority && (l.priority = f?.priority)
          }
          let u = n8t(e)
          u ? (l.parentId = u.id || 'kbn' + r8++) : n8.push(l), ya.push(l)
        }, 'addNode')),
        (Gn = { DEFAULT: 0, NO_BORDER: 0, ROUNDED_RECT: 1, RECT: 2, CIRCLE: 3, CLOUD: 4, BANG: 5, HEXAGON: 6 }),
        (a8t = a((e, t) => {
          switch ((B.debug('In get type', e, t), e)) {
            case '[':
              return Gn.RECT
            case '(':
              return t === ')' ? Gn.ROUNDED_RECT : Gn.CLOUD
            case '((':
              return Gn.CIRCLE
            case ')':
              return Gn.CLOUD
            case '))':
              return Gn.BANG
            case '{{':
              return Gn.HEXAGON
            default:
              return Gn.DEFAULT
          }
        }, 'getType')),
        (o8t = a((e, t) => {
          i8[e] = t
        }, 'setElementForId')),
        (l8t = a((e) => {
          if (!e) return
          let t = K(),
            r = ya[ya.length - 1]
          e.icon && (r.icon = Ie(e.icon, t)), e.class && (r.cssClasses = Ie(e.class, t))
        }, 'decorateNode')),
        (c8t = a((e) => {
          switch (e) {
            case Gn.DEFAULT:
              return 'no-border'
            case Gn.RECT:
              return 'rect'
            case Gn.ROUNDED_RECT:
              return 'rounded-rect'
            case Gn.CIRCLE:
              return 'circle'
            case Gn.CLOUD:
              return 'cloud'
            case Gn.BANG:
              return 'bang'
            case Gn.HEXAGON:
              return 'hexgon'
            default:
              return 'no-border'
          }
        }, 'type2Str')),
        (u8t = a(() => B, 'getLogger')),
        (h8t = a((e) => i8[e], 'getElementById')),
        (f8t = {
          clear: r8t,
          addNode: s8t,
          getSections: Dst,
          getData: i8t,
          nodeType: Gn,
          getType: a8t,
          setElementForId: o8t,
          decorateNode: l8t,
          type2Str: c8t,
          getLogger: u8t,
          getElementById: h8t,
        }),
        (Nst = f8t)
    })
  var d8t,
    Mst,
    Ost = x(() => {
      'use strict'
      pe()
      Vt()
      Bl()
      On()
      _s()
      Hb()
      ik()
      ;(d8t = a(async (e, t, r, n) => {
        B.debug(
          `Rendering kanban diagram
` + e,
        )
        let s = n.db.getData(),
          o = K()
        o.htmlLabels = !1
        let l = Ai(t),
          u = l.append('g')
        u.attr('class', 'sections')
        let h = l.append('g')
        h.attr('class', 'items')
        let f = s.nodes.filter((b) => b.isGroup),
          d = 0,
          p = 10,
          m = [],
          g = 25
        for (let b of f) {
          let k = o?.kanban?.sectionWidth || 200
          ;(d = d + 1),
            (b.x = k * d + ((d - 1) * p) / 2),
            (b.width = k),
            (b.y = 0),
            (b.height = k * 3),
            (b.rx = 5),
            (b.ry = 5),
            (b.cssClasses = b.cssClasses + ' section-' + d)
          let T = await fd(u, b)
          ;(g = Math.max(g, T?.labelBBox?.height)), m.push(T)
        }
        let y = 0
        for (let b of f) {
          let k = m[y]
          y = y + 1
          let T = o?.kanban?.sectionWidth || 200,
            C = (-T * 3) / 2 + g,
            A = C,
            w = s.nodes.filter((v) => v.parentId === b.id)
          for (let v of w) {
            if (v.isGroup) throw new Error('Groups within groups are not allowed in Kanban diagrams')
            ;(v.x = b.x), (v.width = T - 1.5 * p)
            let F = (await dd(h, v, { config: o })).node().getBBox()
            ;(v.y = A + F.height / 2), await G0(v), (A = v.y + F.height / 2 + p / 2)
          }
          let D = k.cluster.select('rect'),
            G = Math.max(A - C + 3 * p, 50) + (g - 25)
          D.attr('height', G)
        }
        Kl(void 0, l, o.mindmap?.padding ?? ze.kanban.padding, o.mindmap?.useMaxWidth ?? ze.kanban.useMaxWidth)
      }, 'draw')),
        (Mst = { draw: d8t })
    })
  var p8t,
    m8t,
    Pst,
    Bst = x(() => {
      'use strict'
      js()
      Md()
      ;(p8t = a((e) => {
        let t = ''
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++)
          (e['lineColor' + n] = e['lineColor' + n] || e['cScaleInv' + n]),
            Ii(e['lineColor' + n])
              ? (e['lineColor' + n] = Yt(e['lineColor' + n], 20))
              : (e['lineColor' + n] = ee(e['lineColor' + n], 20))
        let r = a((n, i) => (e.darkMode ? ee(n, i) : Yt(n, i)), 'adjuster')
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++) {
          let i = '' + (17 - 3 * n)
          t += `
    .section-${n - 1} rect, .section-${n - 1} path, .section-${n - 1} circle, .section-${n - 1} polygon, .section-${n - 1} path  {
      fill: ${r(e['cScale' + n], 10)};
      stroke: ${r(e['cScale' + n], 10)};

    }
    .section-${n - 1} text {
     fill: ${e['cScaleLabel' + n]};
    }
    .node-icon-${n - 1} {
      font-size: 40px;
      color: ${e['cScaleLabel' + n]};
    }
    .section-edge-${n - 1}{
      stroke: ${e['cScale' + n]};
    }
    .edge-depth-${n - 1}{
      stroke-width: ${i};
    }
    .section-${n - 1} line {
      stroke: ${e['cScaleInv' + n]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    text-decoration: underline;
  }
    `
        }
        return t
      }, 'genSections')),
        (m8t = a(
          (e) => `
  .edge {
    stroke-width: 3;
  }
  ${p8t(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${e.textColor};
    fill: ${e.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${No()}
`,
          'getStyles',
        )),
        (Pst = m8t)
    })
  var Fst = {}
  Oe(Fst, { diagram: () => g8t })
  var g8t,
    $st = x(() => {
      'use strict'
      Rst()
      Ist()
      Ost()
      Bst()
      g8t = { db: Nst, renderer: Mst, parser: Lst, styles: Pst }
    })
  var s8,
    Hy,
    zst = x(() => {
      'use strict'
      s8 = (function () {
        var e = a(function (l, u, h, f) {
            for (h = h || {}, f = l.length; f--; h[l[f]] = u);
            return h
          }, 'o'),
          t = [1, 9],
          r = [1, 10],
          n = [1, 5, 10, 12],
          i = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SANKEY: 4,
              NEWLINE: 5,
              csv: 6,
              opt_eof: 7,
              record: 8,
              csv_tail: 9,
              EOF: 10,
              'field[source]': 11,
              COMMA: 12,
              'field[target]': 13,
              'field[value]': 14,
              field: 15,
              escaped: 16,
              non_escaped: 17,
              DQUOTE: 18,
              ESCAPED_TEXT: 19,
              NON_ESCAPED_TEXT: 20,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'SANKEY',
              5: 'NEWLINE',
              10: 'EOF',
              11: 'field[source]',
              12: 'COMMA',
              13: 'field[target]',
              14: 'field[value]',
              18: 'DQUOTE',
              19: 'ESCAPED_TEXT',
              20: 'NON_ESCAPED_TEXT',
            },
            productions_: [
              0,
              [3, 4],
              [6, 2],
              [9, 2],
              [9, 0],
              [7, 1],
              [7, 0],
              [8, 5],
              [15, 1],
              [15, 1],
              [16, 3],
              [17, 1],
            ],
            performAction: a(function (u, h, f, d, p, m, g) {
              var y = m.length - 1
              switch (p) {
                case 7:
                  let b = d.findOrCreateNode(m[y - 4].trim().replaceAll('""', '"')),
                    k = d.findOrCreateNode(m[y - 2].trim().replaceAll('""', '"')),
                    T = parseFloat(m[y].trim())
                  d.addLink(b, k, T)
                  break
                case 8:
                case 9:
                case 11:
                  this.$ = m[y]
                  break
                case 10:
                  this.$ = m[y - 1]
                  break
              }
            }, 'anonymous'),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              { 5: [1, 3] },
              { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r },
              { 1: [2, 6], 7: 11, 10: [1, 12] },
              e(r, [2, 4], { 9: 13, 5: [1, 14] }),
              { 12: [1, 15] },
              e(n, [2, 8]),
              e(n, [2, 9]),
              { 19: [1, 16] },
              e(n, [2, 11]),
              { 1: [2, 1] },
              { 1: [2, 5] },
              e(r, [2, 2]),
              { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r },
              { 15: 18, 16: 7, 17: 8, 18: t, 20: r },
              { 18: [1, 19] },
              e(r, [2, 3]),
              { 12: [1, 20] },
              e(n, [2, 10]),
              { 15: 21, 16: 7, 17: 8, 18: t, 20: r },
              e([1, 5, 10], [2, 7]),
            ],
            defaultActions: { 11: [2, 1], 12: [2, 5] },
            parseError: a(function (u, h) {
              if (h.recoverable) this.trace(u)
              else {
                var f = new Error(u)
                throw ((f.hash = h), f)
              }
            }, 'parseError'),
            parse: a(function (u) {
              var h = this,
                f = [0],
                d = [],
                p = [null],
                m = [],
                g = this.table,
                y = '',
                b = 0,
                k = 0,
                T = 0,
                C = 2,
                A = 1,
                w = m.slice.call(arguments, 1),
                D = Object.create(this.lexer),
                G = { yy: {} }
              for (var v in this.yy) Object.prototype.hasOwnProperty.call(this.yy, v) && (G.yy[v] = this.yy[v])
              D.setInput(u, G.yy), (G.yy.lexer = D), (G.yy.parser = this), typeof D.yylloc > 'u' && (D.yylloc = {})
              var R = D.yylloc
              m.push(R)
              var F = D.options && D.options.ranges
              typeof G.yy.parseError == 'function'
                ? (this.parseError = G.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function S(H) {
                ;(f.length = f.length - 2 * H), (p.length = p.length - H), (m.length = m.length - H)
              }
              a(S, 'popStack')
              function O() {
                var H
                return (
                  (H = d.pop() || D.lex() || A),
                  typeof H != 'number' && (H instanceof Array && ((d = H), (H = d.pop())), (H = h.symbols_[H] || H)),
                  H
                )
              }
              a(O, 'lex')
              for (var E, _, L, N, P, I, M = {}, V, $, q, tt; ; ) {
                if (
                  ((L = f[f.length - 1]),
                  this.defaultActions[L]
                    ? (N = this.defaultActions[L])
                    : ((E === null || typeof E > 'u') && (E = O()), (N = g[L] && g[L][E])),
                  typeof N > 'u' || !N.length || !N[0])
                ) {
                  var ft = ''
                  tt = []
                  for (V in g[L]) this.terminals_[V] && V > C && tt.push("'" + this.terminals_[V] + "'")
                  D.showPosition
                    ? (ft =
                        'Parse error on line ' +
                        (b + 1) +
                        `:
` +
                        D.showPosition() +
                        `
Expecting ` +
                        tt.join(', ') +
                        ", got '" +
                        (this.terminals_[E] || E) +
                        "'")
                    : (ft =
                        'Parse error on line ' +
                        (b + 1) +
                        ': Unexpected ' +
                        (E == A ? 'end of input' : "'" + (this.terminals_[E] || E) + "'")),
                    this.parseError(ft, {
                      text: D.match,
                      token: this.terminals_[E] || E,
                      line: D.yylineno,
                      loc: R,
                      expected: tt,
                    })
                }
                if (N[0] instanceof Array && N.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + L + ', token: ' + E)
                switch (N[0]) {
                  case 1:
                    f.push(E),
                      p.push(D.yytext),
                      m.push(D.yylloc),
                      f.push(N[1]),
                      (E = null),
                      _
                        ? ((E = _), (_ = null))
                        : ((k = D.yyleng), (y = D.yytext), (b = D.yylineno), (R = D.yylloc), T > 0 && T--)
                    break
                  case 2:
                    if (
                      (($ = this.productions_[N[1]][1]),
                      (M.$ = p[p.length - $]),
                      (M._$ = {
                        first_line: m[m.length - ($ || 1)].first_line,
                        last_line: m[m.length - 1].last_line,
                        first_column: m[m.length - ($ || 1)].first_column,
                        last_column: m[m.length - 1].last_column,
                      }),
                      F && (M._$.range = [m[m.length - ($ || 1)].range[0], m[m.length - 1].range[1]]),
                      (I = this.performAction.apply(M, [y, k, b, G.yy, N[1], p, m].concat(w))),
                      typeof I < 'u')
                    )
                      return I
                    $ && ((f = f.slice(0, -1 * $ * 2)), (p = p.slice(0, -1 * $)), (m = m.slice(0, -1 * $))),
                      f.push(this.productions_[N[1]][0]),
                      p.push(M.$),
                      m.push(M._$),
                      (q = g[f[f.length - 2]][f[f.length - 1]]),
                      f.push(q)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          s = (function () {
            var l = {
              EOF: 1,
              parseError: a(function (h, f) {
                if (this.yy.parser) this.yy.parser.parseError(h, f)
                else throw new Error(h)
              }, 'parseError'),
              setInput: a(function (u, h) {
                return (
                  (this.yy = h || this.yy || {}),
                  (this._input = u),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var u = this._input[0]
                ;(this.yytext += u), this.yyleng++, this.offset++, (this.match += u), (this.matched += u)
                var h = u.match(/(?:\r\n?|\n).*/g)
                return (
                  h ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  u
                )
              }, 'input'),
              unput: a(function (u) {
                var h = u.length,
                  f = u.split(/(?:\r\n?|\n)/g)
                ;(this._input = u + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - h)),
                  (this.offset -= h)
                var d = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  f.length - 1 && (this.yylineno -= f.length - 1)
                var p = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: f
                      ? (f.length === d.length ? this.yylloc.first_column : 0) +
                        d[d.length - f.length].length -
                        f[0].length
                      : this.yylloc.first_column - h,
                  }),
                  this.options.ranges && (this.yylloc.range = [p[0], p[0] + this.yyleng - h]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (u) {
                this.unput(this.match.slice(u))
              }, 'less'),
              pastInput: a(function () {
                var u = this.matched.substr(0, this.matched.length - this.match.length)
                return (u.length > 20 ? '...' : '') + u.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var u = this.match
                return (
                  u.length < 20 && (u += this._input.substr(0, 20 - u.length)),
                  (u.substr(0, 20) + (u.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var u = this.pastInput(),
                  h = new Array(u.length + 1).join('-')
                return (
                  u +
                  this.upcomingInput() +
                  `
` +
                  h +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (u, h) {
                var f, d, p
                if (
                  (this.options.backtrack_lexer &&
                    ((p = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (p.yylloc.range = this.yylloc.range.slice(0))),
                  (d = u[0].match(/(?:\r\n?|\n).*/g)),
                  d && (this.yylineno += d.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: d
                      ? d[d.length - 1].length - d[d.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + u[0].length,
                  }),
                  (this.yytext += u[0]),
                  (this.match += u[0]),
                  (this.matches = u),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(u[0].length)),
                  (this.matched += u[0]),
                  (f = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    h,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  f)
                )
                  return f
                if (this._backtrack) {
                  for (var m in p) this[m] = p[m]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var u, h, f, d
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var p = this._currentRules(), m = 0; m < p.length; m++)
                  if (((f = this._input.match(this.rules[p[m]])), f && (!h || f[0].length > h[0].length))) {
                    if (((h = f), (d = m), this.options.backtrack_lexer)) {
                      if (((u = this.test_match(f, p[m])), u !== !1)) return u
                      if (this._backtrack) {
                        h = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return h
                  ? ((u = this.test_match(h, p[d])), u !== !1 ? u : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var h = this.next()
                return h || this.lex()
              }, 'lex'),
              begin: a(function (h) {
                this.conditionStack.push(h)
              }, 'begin'),
              popState: a(function () {
                var h = this.conditionStack.length - 1
                return h > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (h) {
                return (
                  (h = this.conditionStack.length - 1 - Math.abs(h || 0)), h >= 0 ? this.conditionStack[h] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (h) {
                this.begin(h)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: { 'case-insensitive': !0 },
              performAction: a(function (h, f, d, p) {
                var m = p
                switch (d) {
                  case 0:
                    return this.pushState('csv'), 4
                    break
                  case 1:
                    return this.pushState('csv'), 4
                    break
                  case 2:
                    return 10
                  case 3:
                    return 5
                  case 4:
                    return 12
                  case 5:
                    return this.pushState('escaped_text'), 18
                    break
                  case 6:
                    return 20
                  case 7:
                    return this.popState('escaped_text'), 18
                    break
                  case 8:
                    return 19
                }
              }, 'anonymous'),
              rules: [
                /^(?:sankey-beta\b)/i,
                /^(?:sankey\b)/i,
                /^(?:$)/i,
                /^(?:((\u000D\u000A)|(\u000A)))/i,
                /^(?:(\u002C))/i,
                /^(?:(\u0022))/i,
                /^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i,
                /^(?:(\u0022)(?!(\u0022)))/i,
                /^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i,
              ],
              conditions: {
                csv: { rules: [2, 3, 4, 5, 6, 7, 8], inclusive: !1 },
                escaped_text: { rules: [7, 8], inclusive: !1 },
                INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8], inclusive: !0 },
              },
            }
            return l
          })()
        i.lexer = s
        function o() {
          this.yy = {}
        }
        return a(o, 'Parser'), (o.prototype = i), (i.Parser = o), new o()
      })()
      s8.parser = s8
      Hy = s8
    })
  var rC,
    nC,
    eC,
    k8t,
    a8,
    T8t,
    o8,
    S8t,
    _8t,
    C8t,
    w8t,
    Wst,
    Ust = x(() => {
      'use strict'
      pe()
      Be()
      bn()
      ;(rC = []),
        (nC = []),
        (eC = new Map()),
        (k8t = a(() => {
          ;(rC = []), (nC = []), (eC = new Map()), Ye()
        }, 'clear')),
        (a8 = class {
          constructor(t, r, n = 0) {
            this.source = t
            this.target = r
            this.value = n
          }
          static {
            a(this, 'SankeyLink')
          }
        }),
        (T8t = a((e, t, r) => {
          rC.push(new a8(e, t, r))
        }, 'addLink')),
        (o8 = class {
          constructor(t) {
            this.ID = t
          }
          static {
            a(this, 'SankeyNode')
          }
        }),
        (S8t = a((e) => {
          e = Rt.sanitizeText(e, K())
          let t = eC.get(e)
          return t === void 0 && ((t = new o8(e)), eC.set(e, t), nC.push(t)), t
        }, 'findOrCreateNode')),
        (_8t = a(() => nC, 'getNodes')),
        (C8t = a(() => rC, 'getLinks')),
        (w8t = a(
          () => ({
            nodes: nC.map((e) => ({ id: e.ID })),
            links: rC.map((e) => ({ source: e.source.ID, target: e.target.ID, value: e.value })),
          }),
          'getGraph',
        )),
        (Wst = {
          nodesMap: eC,
          getConfig: a(() => K().sankey, 'getConfig'),
          getNodes: _8t,
          getLinks: C8t,
          getGraph: w8t,
          addLink: T8t,
          findOrCreateNode: S8t,
          getAccTitle: tr,
          setAccTitle: Xe,
          getAccDescription: rr,
          setAccDescription: er,
          getDiagramTitle: nr,
          setDiagramTitle: lr,
          clear: k8t,
        })
    })
  function Yy(e, t) {
    let r
    if (t === void 0) for (let n of e) n != null && (r < n || (r === void 0 && n >= n)) && (r = n)
    else {
      let n = -1
      for (let i of e) (i = t(i, ++n, e)) != null && (r < i || (r === void 0 && i >= i)) && (r = i)
    }
    return r
  }
  var jst = x(() => {
    'use strict'
    a(Yy, 'max')
  })
  function Dm(e, t) {
    let r
    if (t === void 0) for (let n of e) n != null && (r > n || (r === void 0 && n >= n)) && (r = n)
    else {
      let n = -1
      for (let i of e) (i = t(i, ++n, e)) != null && (r > i || (r === void 0 && i >= i)) && (r = i)
    }
    return r
  }
  var qst = x(() => {
    'use strict'
    a(Dm, 'min')
  })
  function Nm(e, t) {
    let r = 0
    if (t === void 0) for (let n of e) (n = +n) && (r += n)
    else {
      let n = -1
      for (let i of e) (i = +t(i, ++n, e)) && (r += i)
    }
    return r
  }
  var Hst = x(() => {
    'use strict'
    a(Nm, 'sum')
  })
  var l8 = x(() => {
    'use strict'
    jst()
    qst()
    Hst()
  })
  function E8t(e) {
    return e.target.depth
  }
  function c8(e) {
    return e.depth
  }
  function u8(e, t) {
    return t - 1 - e.height
  }
  function Xy(e, t) {
    return e.sourceLinks.length ? e.depth : t - 1
  }
  function h8(e) {
    return e.targetLinks.length ? e.depth : e.sourceLinks.length ? Dm(e.sourceLinks, E8t) - 1 : 0
  }
  var f8 = x(() => {
    'use strict'
    l8()
    a(E8t, 'targetDepth')
    a(c8, 'left')
    a(u8, 'right')
    a(Xy, 'justify')
    a(h8, 'center')
  })
  function Im(e) {
    return function () {
      return e
    }
  }
  var Yst = x(() => {
    'use strict'
    a(Im, 'constant')
  })
  function Xst(e, t) {
    return iC(e.source, t.source) || e.index - t.index
  }
  function Kst(e, t) {
    return iC(e.target, t.target) || e.index - t.index
  }
  function iC(e, t) {
    return e.y0 - t.y0
  }
  function d8(e) {
    return e.value
  }
  function v8t(e) {
    return e.index
  }
  function A8t(e) {
    return e.nodes
  }
  function L8t(e) {
    return e.links
  }
  function Qst(e, t) {
    let r = e.get(t)
    if (!r) throw new Error('missing: ' + t)
    return r
  }
  function Zst({ nodes: e }) {
    for (let t of e) {
      let r = t.y0,
        n = r
      for (let i of t.sourceLinks) (i.y0 = r + i.width / 2), (r += i.width)
      for (let i of t.targetLinks) (i.y1 = n + i.width / 2), (n += i.width)
    }
  }
  function sC() {
    let e = 0,
      t = 0,
      r = 1,
      n = 1,
      i = 24,
      s = 8,
      o,
      l = v8t,
      u = Xy,
      h,
      f,
      d = A8t,
      p = L8t,
      m = 6
    function g() {
      let L = { nodes: d.apply(null, arguments), links: p.apply(null, arguments) }
      return y(L), b(L), k(L), T(L), w(L), Zst(L), L
    }
    a(g, 'sankey'),
      (g.update = function (L) {
        return Zst(L), L
      }),
      (g.nodeId = function (L) {
        return arguments.length ? ((l = typeof L == 'function' ? L : Im(L)), g) : l
      }),
      (g.nodeAlign = function (L) {
        return arguments.length ? ((u = typeof L == 'function' ? L : Im(L)), g) : u
      }),
      (g.nodeSort = function (L) {
        return arguments.length ? ((h = L), g) : h
      }),
      (g.nodeWidth = function (L) {
        return arguments.length ? ((i = +L), g) : i
      }),
      (g.nodePadding = function (L) {
        return arguments.length ? ((s = o = +L), g) : s
      }),
      (g.nodes = function (L) {
        return arguments.length ? ((d = typeof L == 'function' ? L : Im(L)), g) : d
      }),
      (g.links = function (L) {
        return arguments.length ? ((p = typeof L == 'function' ? L : Im(L)), g) : p
      }),
      (g.linkSort = function (L) {
        return arguments.length ? ((f = L), g) : f
      }),
      (g.size = function (L) {
        return arguments.length ? ((e = t = 0), (r = +L[0]), (n = +L[1]), g) : [r - e, n - t]
      }),
      (g.extent = function (L) {
        return arguments.length
          ? ((e = +L[0][0]), (r = +L[1][0]), (t = +L[0][1]), (n = +L[1][1]), g)
          : [
              [e, t],
              [r, n],
            ]
      }),
      (g.iterations = function (L) {
        return arguments.length ? ((m = +L), g) : m
      })
    function y({ nodes: L, links: N }) {
      for (let [I, M] of L.entries()) (M.index = I), (M.sourceLinks = []), (M.targetLinks = [])
      let P = new Map(L.map((I, M) => [l(I, M, L), I]))
      for (let [I, M] of N.entries()) {
        M.index = I
        let { source: V, target: $ } = M
        typeof V != 'object' && (V = M.source = Qst(P, V)),
          typeof $ != 'object' && ($ = M.target = Qst(P, $)),
          V.sourceLinks.push(M),
          $.targetLinks.push(M)
      }
      if (f != null) for (let { sourceLinks: I, targetLinks: M } of L) I.sort(f), M.sort(f)
    }
    a(y, 'computeNodeLinks')
    function b({ nodes: L }) {
      for (let N of L)
        N.value = N.fixedValue === void 0 ? Math.max(Nm(N.sourceLinks, d8), Nm(N.targetLinks, d8)) : N.fixedValue
    }
    a(b, 'computeNodeValues')
    function k({ nodes: L }) {
      let N = L.length,
        P = new Set(L),
        I = new Set(),
        M = 0
      for (; P.size; ) {
        for (let V of P) {
          V.depth = M
          for (let { target: $ } of V.sourceLinks) I.add($)
        }
        if (++M > N) throw new Error('circular link')
        ;(P = I), (I = new Set())
      }
    }
    a(k, 'computeNodeDepths')
    function T({ nodes: L }) {
      let N = L.length,
        P = new Set(L),
        I = new Set(),
        M = 0
      for (; P.size; ) {
        for (let V of P) {
          V.height = M
          for (let { source: $ } of V.targetLinks) I.add($)
        }
        if (++M > N) throw new Error('circular link')
        ;(P = I), (I = new Set())
      }
    }
    a(T, 'computeNodeHeights')
    function C({ nodes: L }) {
      let N = Yy(L, (M) => M.depth) + 1,
        P = (r - e - i) / (N - 1),
        I = new Array(N)
      for (let M of L) {
        let V = Math.max(0, Math.min(N - 1, Math.floor(u.call(null, M, N))))
        ;(M.layer = V), (M.x0 = e + V * P), (M.x1 = M.x0 + i), I[V] ? I[V].push(M) : (I[V] = [M])
      }
      if (h) for (let M of I) M.sort(h)
      return I
    }
    a(C, 'computeNodeLayers')
    function A(L) {
      let N = Dm(L, (P) => (n - t - (P.length - 1) * o) / Nm(P, d8))
      for (let P of L) {
        let I = t
        for (let M of P) {
          ;(M.y0 = I), (M.y1 = I + M.value * N), (I = M.y1 + o)
          for (let V of M.sourceLinks) V.width = V.value * N
        }
        I = (n - I + o) / (P.length + 1)
        for (let M = 0; M < P.length; ++M) {
          let V = P[M]
          ;(V.y0 += I * (M + 1)), (V.y1 += I * (M + 1))
        }
        O(P)
      }
    }
    a(A, 'initializeNodeBreadths')
    function w(L) {
      let N = C(L)
      ;(o = Math.min(s, (n - t) / (Yy(N, (P) => P.length) - 1))), A(N)
      for (let P = 0; P < m; ++P) {
        let I = Math.pow(0.99, P),
          M = Math.max(1 - I, (P + 1) / m)
        G(N, I, M), D(N, I, M)
      }
    }
    a(w, 'computeNodeBreadths')
    function D(L, N, P) {
      for (let I = 1, M = L.length; I < M; ++I) {
        let V = L[I]
        for (let $ of V) {
          let q = 0,
            tt = 0
          for (let { source: H, value: kt } of $.targetLinks) {
            let ht = kt * ($.layer - H.layer)
            ;(q += E(H, $) * ht), (tt += ht)
          }
          if (!(tt > 0)) continue
          let ft = (q / tt - $.y0) * N
          ;($.y0 += ft), ($.y1 += ft), S($)
        }
        h === void 0 && V.sort(iC), v(V, P)
      }
    }
    a(D, 'relaxLeftToRight')
    function G(L, N, P) {
      for (let I = L.length, M = I - 2; M >= 0; --M) {
        let V = L[M]
        for (let $ of V) {
          let q = 0,
            tt = 0
          for (let { target: H, value: kt } of $.sourceLinks) {
            let ht = kt * (H.layer - $.layer)
            ;(q += _($, H) * ht), (tt += ht)
          }
          if (!(tt > 0)) continue
          let ft = (q / tt - $.y0) * N
          ;($.y0 += ft), ($.y1 += ft), S($)
        }
        h === void 0 && V.sort(iC), v(V, P)
      }
    }
    a(G, 'relaxRightToLeft')
    function v(L, N) {
      let P = L.length >> 1,
        I = L[P]
      F(L, I.y0 - o, P - 1, N), R(L, I.y1 + o, P + 1, N), F(L, n, L.length - 1, N), R(L, t, 0, N)
    }
    a(v, 'resolveCollisions')
    function R(L, N, P, I) {
      for (; P < L.length; ++P) {
        let M = L[P],
          V = (N - M.y0) * I
        V > 1e-6 && ((M.y0 += V), (M.y1 += V)), (N = M.y1 + o)
      }
    }
    a(R, 'resolveCollisionsTopToBottom')
    function F(L, N, P, I) {
      for (; P >= 0; --P) {
        let M = L[P],
          V = (M.y1 - N) * I
        V > 1e-6 && ((M.y0 -= V), (M.y1 -= V)), (N = M.y0 - o)
      }
    }
    a(F, 'resolveCollisionsBottomToTop')
    function S({ sourceLinks: L, targetLinks: N }) {
      if (f === void 0) {
        for (let {
          source: { sourceLinks: P },
        } of N)
          P.sort(Kst)
        for (let {
          target: { targetLinks: P },
        } of L)
          P.sort(Xst)
      }
    }
    a(S, 'reorderNodeLinks')
    function O(L) {
      if (f === void 0) for (let { sourceLinks: N, targetLinks: P } of L) N.sort(Kst), P.sort(Xst)
    }
    a(O, 'reorderLinks')
    function E(L, N) {
      let P = L.y0 - ((L.sourceLinks.length - 1) * o) / 2
      for (let { target: I, width: M } of L.sourceLinks) {
        if (I === N) break
        P += M + o
      }
      for (let { source: I, width: M } of N.targetLinks) {
        if (I === L) break
        P -= M
      }
      return P
    }
    a(E, 'targetTop')
    function _(L, N) {
      let P = N.y0 - ((N.targetLinks.length - 1) * o) / 2
      for (let { source: I, width: M } of N.targetLinks) {
        if (I === L) break
        P += M + o
      }
      for (let { target: I, width: M } of L.sourceLinks) {
        if (I === N) break
        P -= M
      }
      return P
    }
    return a(_, 'sourceTop'), g
  }
  var Jst = x(() => {
    'use strict'
    l8()
    f8()
    Yst()
    a(Xst, 'ascendingSourceBreadth')
    a(Kst, 'ascendingTargetBreadth')
    a(iC, 'ascendingBreadth')
    a(d8, 'value')
    a(v8t, 'defaultId')
    a(A8t, 'defaultNodes')
    a(L8t, 'defaultLinks')
    a(Qst, 'find')
    a(Zst, 'computeLinkBreadths')
    a(sC, 'Sankey')
  })
  function g8() {
    ;(this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = '')
  }
  function tat() {
    return new g8()
  }
  var p8,
    m8,
    ef,
    R8t,
    y8,
    eat = x(() => {
      'use strict'
      ;(p8 = Math.PI), (m8 = 2 * p8), (ef = 1e-6), (R8t = m8 - ef)
      a(g8, 'Path')
      a(tat, 'path')
      g8.prototype = tat.prototype = {
        constructor: g8,
        moveTo: a(function (e, t) {
          this._ += 'M' + (this._x0 = this._x1 = +e) + ',' + (this._y0 = this._y1 = +t)
        }, 'moveTo'),
        closePath: a(function () {
          this._x1 !== null && ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += 'Z'))
        }, 'closePath'),
        lineTo: a(function (e, t) {
          this._ += 'L' + (this._x1 = +e) + ',' + (this._y1 = +t)
        }, 'lineTo'),
        quadraticCurveTo: a(function (e, t, r, n) {
          this._ += 'Q' + +e + ',' + +t + ',' + (this._x1 = +r) + ',' + (this._y1 = +n)
        }, 'quadraticCurveTo'),
        bezierCurveTo: a(function (e, t, r, n, i, s) {
          this._ += 'C' + +e + ',' + +t + ',' + +r + ',' + +n + ',' + (this._x1 = +i) + ',' + (this._y1 = +s)
        }, 'bezierCurveTo'),
        arcTo: a(function (e, t, r, n, i) {
          ;(e = +e), (t = +t), (r = +r), (n = +n), (i = +i)
          var s = this._x1,
            o = this._y1,
            l = r - e,
            u = n - t,
            h = s - e,
            f = o - t,
            d = h * h + f * f
          if (i < 0) throw new Error('negative radius: ' + i)
          if (this._x1 === null) this._ += 'M' + (this._x1 = e) + ',' + (this._y1 = t)
          else if (d > ef)
            if (!(Math.abs(f * l - u * h) > ef) || !i) this._ += 'L' + (this._x1 = e) + ',' + (this._y1 = t)
            else {
              var p = r - s,
                m = n - o,
                g = l * l + u * u,
                y = p * p + m * m,
                b = Math.sqrt(g),
                k = Math.sqrt(d),
                T = i * Math.tan((p8 - Math.acos((g + d - y) / (2 * b * k))) / 2),
                C = T / k,
                A = T / b
              Math.abs(C - 1) > ef && (this._ += 'L' + (e + C * h) + ',' + (t + C * f)),
                (this._ +=
                  'A' +
                  i +
                  ',' +
                  i +
                  ',0,0,' +
                  +(f * p > h * m) +
                  ',' +
                  (this._x1 = e + A * l) +
                  ',' +
                  (this._y1 = t + A * u))
            }
        }, 'arcTo'),
        arc: a(function (e, t, r, n, i, s) {
          ;(e = +e), (t = +t), (r = +r), (s = !!s)
          var o = r * Math.cos(n),
            l = r * Math.sin(n),
            u = e + o,
            h = t + l,
            f = 1 ^ s,
            d = s ? n - i : i - n
          if (r < 0) throw new Error('negative radius: ' + r)
          this._x1 === null
            ? (this._ += 'M' + u + ',' + h)
            : (Math.abs(this._x1 - u) > ef || Math.abs(this._y1 - h) > ef) && (this._ += 'L' + u + ',' + h),
            r &&
              (d < 0 && (d = (d % m8) + m8),
              d > R8t
                ? (this._ +=
                    'A' +
                    r +
                    ',' +
                    r +
                    ',0,1,' +
                    f +
                    ',' +
                    (e - o) +
                    ',' +
                    (t - l) +
                    'A' +
                    r +
                    ',' +
                    r +
                    ',0,1,' +
                    f +
                    ',' +
                    (this._x1 = u) +
                    ',' +
                    (this._y1 = h))
                : d > ef &&
                  (this._ +=
                    'A' +
                    r +
                    ',' +
                    r +
                    ',0,' +
                    +(d >= p8) +
                    ',' +
                    f +
                    ',' +
                    (this._x1 = e + r * Math.cos(i)) +
                    ',' +
                    (this._y1 = t + r * Math.sin(i))))
        }, 'arc'),
        rect: a(function (e, t, r, n) {
          this._ +=
            'M' + (this._x0 = this._x1 = +e) + ',' + (this._y0 = this._y1 = +t) + 'h' + +r + 'v' + +n + 'h' + -r + 'Z'
        }, 'rect'),
        toString: a(function () {
          return this._
        }, 'toString'),
      }
      y8 = tat
    })
  var rat = x(() => {
    'use strict'
    eat()
  })
  function aC(e) {
    return a(function () {
      return e
    }, 'constant')
  }
  var nat = x(() => {
    'use strict'
    a(aC, 'default')
  })
  function iat(e) {
    return e[0]
  }
  function sat(e) {
    return e[1]
  }
  var aat = x(() => {
    'use strict'
    a(iat, 'x')
    a(sat, 'y')
  })
  var oat,
    lat = x(() => {
      'use strict'
      oat = Array.prototype.slice
    })
  function D8t(e) {
    return e.source
  }
  function N8t(e) {
    return e.target
  }
  function I8t(e) {
    var t = D8t,
      r = N8t,
      n = iat,
      i = sat,
      s = null
    function o() {
      var l,
        u = oat.call(arguments),
        h = t.apply(this, u),
        f = r.apply(this, u)
      if (
        (s || (s = l = y8()),
        e(s, +n.apply(this, ((u[0] = h), u)), +i.apply(this, u), +n.apply(this, ((u[0] = f), u)), +i.apply(this, u)),
        l)
      )
        return (s = null), l + '' || null
    }
    return (
      a(o, 'link'),
      (o.source = function (l) {
        return arguments.length ? ((t = l), o) : t
      }),
      (o.target = function (l) {
        return arguments.length ? ((r = l), o) : r
      }),
      (o.x = function (l) {
        return arguments.length ? ((n = typeof l == 'function' ? l : aC(+l)), o) : n
      }),
      (o.y = function (l) {
        return arguments.length ? ((i = typeof l == 'function' ? l : aC(+l)), o) : i
      }),
      (o.context = function (l) {
        return arguments.length ? ((s = l ?? null), o) : s
      }),
      o
    )
  }
  function M8t(e, t, r, n, i) {
    e.moveTo(t, r), e.bezierCurveTo((t = (t + n) / 2), r, t, i, n, i)
  }
  function x8() {
    return I8t(M8t)
  }
  var cat = x(() => {
    'use strict'
    rat()
    lat()
    nat()
    aat()
    a(D8t, 'linkSource')
    a(N8t, 'linkTarget')
    a(I8t, 'link')
    a(M8t, 'curveHorizontal')
    a(x8, 'linkHorizontal')
  })
  var uat = x(() => {
    'use strict'
    cat()
  })
  function O8t(e) {
    return [e.source.x1, e.y0]
  }
  function P8t(e) {
    return [e.target.x0, e.y1]
  }
  function oC() {
    return x8().source(O8t).target(P8t)
  }
  var hat = x(() => {
    'use strict'
    uat()
    a(O8t, 'horizontalSource')
    a(P8t, 'horizontalTarget')
    a(oC, 'default')
  })
  var fat = x(() => {
    'use strict'
    Jst()
    f8()
    hat()
  })
  var Ky,
    dat = x(() => {
      'use strict'
      Ky = class e {
        static {
          a(this, 'Uid')
        }
        static {
          this.count = 0
        }
        static next(t) {
          return new e(t + ++e.count)
        }
        constructor(t) {
          ;(this.id = t), (this.href = `#${t}`)
        }
        toString() {
          return 'url(' + this.href + ')'
        }
      }
    })
  var B8t,
    F8t,
    pat,
    mat = x(() => {
      'use strict'
      pe()
      Ge()
      fat()
      On()
      dat()
      ;(B8t = { left: c8, right: u8, center: h8, justify: Xy }),
        (F8t = a(function (e, t, r, n) {
          let { securityLevel: i, sankey: s } = K(),
            o = wx.sankey,
            l
          i === 'sandbox' && (l = xt('#i' + t))
          let u = i === 'sandbox' ? xt(l.nodes()[0].contentDocument.body) : xt('body'),
            h = i === 'sandbox' ? u.select(`[id="${t}"]`) : xt(`[id="${t}"]`),
            f = s?.width ?? o.width,
            d = s?.height ?? o.width,
            p = s?.useMaxWidth ?? o.useMaxWidth,
            m = s?.nodeAlignment ?? o.nodeAlignment,
            g = s?.prefix ?? o.prefix,
            y = s?.suffix ?? o.suffix,
            b = s?.showValues ?? o.showValues,
            k = n.db.getGraph(),
            T = B8t[m]
          sC()
            .nodeId((F) => F.id)
            .nodeWidth(10)
            .nodePadding(10 + (b ? 15 : 0))
            .nodeAlign(T)
            .extent([
              [0, 0],
              [f, d],
            ])(k)
          let w = Cs(I3)
          h.append('g')
            .attr('class', 'nodes')
            .selectAll('.node')
            .data(k.nodes)
            .join('g')
            .attr('class', 'node')
            .attr('id', (F) => (F.uid = Ky.next('node-')).id)
            .attr('transform', function (F) {
              return 'translate(' + F.x0 + ',' + F.y0 + ')'
            })
            .attr('x', (F) => F.x0)
            .attr('y', (F) => F.y0)
            .append('rect')
            .attr('height', (F) => F.y1 - F.y0)
            .attr('width', (F) => F.x1 - F.x0)
            .attr('fill', (F) => w(F.id))
          let D = a(
            ({ id: F, value: S }) =>
              b
                ? `${F}
${g}${Math.round(S * 100) / 100}${y}`
                : F,
            'getText',
          )
          h.append('g')
            .attr('class', 'node-labels')
            .attr('font-size', 14)
            .selectAll('text')
            .data(k.nodes)
            .join('text')
            .attr('x', (F) => (F.x0 < f / 2 ? F.x1 + 6 : F.x0 - 6))
            .attr('y', (F) => (F.y1 + F.y0) / 2)
            .attr('dy', `${b ? '0' : '0.35'}em`)
            .attr('text-anchor', (F) => (F.x0 < f / 2 ? 'start' : 'end'))
            .text(D)
          let G = h
              .append('g')
              .attr('class', 'links')
              .attr('fill', 'none')
              .attr('stroke-opacity', 0.5)
              .selectAll('.link')
              .data(k.links)
              .join('g')
              .attr('class', 'link')
              .style('mix-blend-mode', 'multiply'),
            v = s?.linkColor ?? 'gradient'
          if (v === 'gradient') {
            let F = G.append('linearGradient')
              .attr('id', (S) => (S.uid = Ky.next('linearGradient-')).id)
              .attr('gradientUnits', 'userSpaceOnUse')
              .attr('x1', (S) => S.source.x1)
              .attr('x2', (S) => S.target.x0)
            F.append('stop')
              .attr('offset', '0%')
              .attr('stop-color', (S) => w(S.source.id)),
              F.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', (S) => w(S.target.id))
          }
          let R
          switch (v) {
            case 'gradient':
              R = a((F) => F.uid, 'coloring')
              break
            case 'source':
              R = a((F) => w(F.source.id), 'coloring')
              break
            case 'target':
              R = a((F) => w(F.target.id), 'coloring')
              break
            default:
              R = v
          }
          G.append('path')
            .attr('d', oC())
            .attr('stroke', R)
            .attr('stroke-width', (F) => Math.max(1, F.width)),
            Kl(void 0, h, 0, p)
        }, 'draw')),
        (pat = { draw: F8t })
    })
  var gat,
    yat = x(() => {
      'use strict'
      gat = a(
        (e) =>
          e
            .replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, '')
            .replaceAll(
              /([\n\r])+/g,
              `
`,
            )
            .trim(),
        'prepareTextForParsing',
      )
    })
  var $8t,
    xat,
    bat = x(() => {
      'use strict'
      ;($8t = a(
        (e) => `.label {
      font-family: ${e.fontFamily};
    }`,
        'getStyles',
      )),
        (xat = $8t)
    })
  var kat = {}
  Oe(kat, { diagram: () => V8t })
  var G8t,
    V8t,
    Tat = x(() => {
      'use strict'
      zst()
      Ust()
      mat()
      yat()
      bat()
      G8t = Hy.parse.bind(Hy)
      Hy.parse = (e) => G8t(gat(e))
      V8t = { styles: xat, parser: Hy, db: Wst, renderer: pat }
    })
  var j8t,
    Mm,
    b8 = x(() => {
      'use strict'
      fn()
      _s()
      Ce()
      bn()
      ;(j8t = ze.packet),
        (Mm = class {
          constructor() {
            this.packet = []
            this.setAccTitle = Xe
            this.getAccTitle = tr
            this.setDiagramTitle = lr
            this.getDiagramTitle = nr
            this.getAccDescription = rr
            this.setAccDescription = er
          }
          static {
            a(this, 'PacketDB')
          }
          getConfig() {
            let t = ln({ ...j8t, ...Te().packet })
            return t.showBits && (t.paddingY += 10), t
          }
          getPacket() {
            return this.packet
          }
          pushWord(t) {
            t.length > 0 && this.packet.push(t)
          }
          clear() {
            Ye(), (this.packet = [])
          }
        })
    })
  var q8t,
    H8t,
    Y8t,
    k8,
    Cat = x(() => {
      'use strict'
      jh()
      Vt()
      gm()
      b8()
      ;(q8t = 1e4),
        (H8t = a((e, t) => {
          jo(e, t)
          let r = -1,
            n = [],
            i = 1,
            { bitsPerRow: s } = t.getConfig()
          for (let { start: o, end: l, bits: u, label: h } of e.blocks) {
            if (o !== void 0 && l !== void 0 && l < o)
              throw new Error(`Packet block ${o} - ${l} is invalid. End must be greater than start.`)
            if (((o ??= r + 1), o !== r + 1))
              throw new Error(`Packet block ${o} - ${l ?? o} is not contiguous. It should start from ${r + 1}.`)
            if (u === 0) throw new Error(`Packet block ${o} is invalid. Cannot have a zero bit field.`)
            for (
              l ??= o + (u ?? 1) - 1, u ??= l - o + 1, r = l, B.debug(`Packet block ${o} - ${r} with label ${h}`);
              n.length <= s + 1 && t.getPacket().length < q8t;

            ) {
              let [f, d] = Y8t({ start: o, end: l, bits: u, label: h }, i, s)
              if ((n.push(f), f.end + 1 === i * s && (t.pushWord(n), (n = []), i++), !d)) break
              ;({ start: o, end: l, bits: u, label: h } = d)
            }
          }
          t.pushWord(n)
        }, 'populate')),
        (Y8t = a((e, t, r) => {
          if (e.start === void 0) throw new Error('start should have been set during first phase')
          if (e.end === void 0) throw new Error('end should have been set during first phase')
          if (e.start > e.end) throw new Error(`Block start ${e.start} is greater than block end ${e.end}.`)
          if (e.end + 1 <= t * r) return [e, void 0]
          let n = t * r - 1,
            i = t * r
          return [
            { start: e.start, end: n, label: e.label, bits: n - e.start },
            { start: i, end: e.end, label: e.label, bits: e.end - i },
          ]
        }, 'getNextFittingBlock')),
        (k8 = {
          parser: { yy: void 0 },
          parse: a(async (e) => {
            let t = await Fs('packet', e),
              r = k8.parser?.yy
            if (!(r instanceof Mm))
              throw new Error(
                'parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.',
              )
            B.debug(t), H8t(t, r)
          }, 'parse'),
        })
    })
  var X8t,
    K8t,
    wat,
    Eat = x(() => {
      'use strict'
      Bl()
      On()
      ;(X8t = a((e, t, r, n) => {
        let i = n.db,
          s = i.getConfig(),
          { rowHeight: o, paddingY: l, bitWidth: u, bitsPerRow: h } = s,
          f = i.getPacket(),
          d = i.getDiagramTitle(),
          p = o + l,
          m = p * (f.length + 1) - (d ? 0 : o),
          g = u * h + 2,
          y = Ai(t)
        y.attr('viewbox', `0 0 ${g} ${m}`), Ar(y, m, g, s.useMaxWidth)
        for (let [b, k] of f.entries()) K8t(y, k, b, s)
        y.append('text')
          .text(d)
          .attr('x', g / 2)
          .attr('y', m - p / 2)
          .attr('dominant-baseline', 'middle')
          .attr('text-anchor', 'middle')
          .attr('class', 'packetTitle')
      }, 'draw')),
        (K8t = a((e, t, r, { rowHeight: n, paddingX: i, paddingY: s, bitWidth: o, bitsPerRow: l, showBits: u }) => {
          let h = e.append('g'),
            f = r * (n + s) + s
          for (let d of t) {
            let p = (d.start % l) * o + 1,
              m = (d.end - d.start + 1) * o - i
            if (
              (h
                .append('rect')
                .attr('x', p)
                .attr('y', f)
                .attr('width', m)
                .attr('height', n)
                .attr('class', 'packetBlock'),
              h
                .append('text')
                .attr('x', p + m / 2)
                .attr('y', f + n / 2)
                .attr('class', 'packetLabel')
                .attr('dominant-baseline', 'middle')
                .attr('text-anchor', 'middle')
                .text(d.label),
              !u)
            )
              continue
            let g = d.end === d.start,
              y = f - 2
            h
              .append('text')
              .attr('x', p + (g ? m / 2 : 0))
              .attr('y', y)
              .attr('class', 'packetByte start')
              .attr('dominant-baseline', 'auto')
              .attr('text-anchor', g ? 'middle' : 'start')
              .text(d.start),
              g ||
                h
                  .append('text')
                  .attr('x', p + m)
                  .attr('y', y)
                  .attr('class', 'packetByte end')
                  .attr('dominant-baseline', 'auto')
                  .attr('text-anchor', 'end')
                  .text(d.end)
          }
        }, 'drawWord')),
        (wat = { draw: X8t })
    })
  var Q8t,
    vat,
    Aat = x(() => {
      'use strict'
      Ce()
      ;(Q8t = {
        byteFontSize: '10px',
        startByteColor: 'black',
        endByteColor: 'black',
        labelColor: 'black',
        labelFontSize: '12px',
        titleColor: 'black',
        titleFontSize: '14px',
        blockStrokeColor: 'black',
        blockStrokeWidth: '1',
        blockFillColor: '#efefef',
      }),
        (vat = a(({ packet: e } = {}) => {
          let t = ln(Q8t, e)
          return `
	.packetByte {
		font-size: ${t.byteFontSize};
	}
	.packetByte.start {
		fill: ${t.startByteColor};
	}
	.packetByte.end {
		fill: ${t.endByteColor};
	}
	.packetLabel {
		fill: ${t.labelColor};
		font-size: ${t.labelFontSize};
	}
	.packetTitle {
		fill: ${t.titleColor};
		font-size: ${t.titleFontSize};
	}
	.packetBlock {
		stroke: ${t.blockStrokeColor};
		stroke-width: ${t.blockStrokeWidth};
		fill: ${t.blockFillColor};
	}
	`
        }, 'styles'))
    })
  var Lat = {}
  Oe(Lat, { diagram: () => Z8t })
  var Z8t,
    Rat = x(() => {
      'use strict'
      b8()
      Cat()
      Eat()
      Aat()
      Z8t = {
        parser: k8,
        get db() {
          return new Mm()
        },
        renderer: wat,
        styles: vat,
      }
    })
  var Om,
    Iat,
    rf,
    e7t,
    r7t,
    Mat,
    n7t,
    i7t,
    s7t,
    a7t,
    o7t,
    l7t,
    c7t,
    nf,
    T8 = x(() => {
      'use strict'
      fn()
      _s()
      Ce()
      bn()
      ;(Om = { showLegend: !0, ticks: 5, max: null, min: 0, graticule: 'circle' }),
        (Iat = { axes: [], curves: [], options: Om }),
        (rf = structuredClone(Iat)),
        (e7t = ze.radar),
        (r7t = a(() => ln({ ...e7t, ...Te().radar }), 'getConfig')),
        (Mat = a(() => rf.axes, 'getAxes')),
        (n7t = a(() => rf.curves, 'getCurves')),
        (i7t = a(() => rf.options, 'getOptions')),
        (s7t = a((e) => {
          rf.axes = e.map((t) => ({ name: t.name, label: t.label ?? t.name }))
        }, 'setAxes')),
        (a7t = a((e) => {
          rf.curves = e.map((t) => ({ name: t.name, label: t.label ?? t.name, entries: o7t(t.entries) }))
        }, 'setCurves')),
        (o7t = a((e) => {
          if (e[0].axis == null) return e.map((r) => r.value)
          let t = Mat()
          if (t.length === 0) throw new Error('Axes must be populated before curves for reference entries')
          return t.map((r) => {
            let n = e.find((i) => i.axis?.$refText === r.name)
            if (n === void 0) throw new Error('Missing entry for axis ' + r.label)
            return n.value
          })
        }, 'computeCurveEntries')),
        (l7t = a((e) => {
          let t = e.reduce((r, n) => ((r[n.name] = n), r), {})
          rf.options = {
            showLegend: t.showLegend?.value ?? Om.showLegend,
            ticks: t.ticks?.value ?? Om.ticks,
            max: t.max?.value ?? Om.max,
            min: t.min?.value ?? Om.min,
            graticule: t.graticule?.value ?? Om.graticule,
          }
        }, 'setOptions')),
        (c7t = a(() => {
          Ye(), (rf = structuredClone(Iat))
        }, 'clear')),
        (nf = {
          getAxes: Mat,
          getCurves: n7t,
          getOptions: i7t,
          setAxes: s7t,
          setCurves: a7t,
          setOptions: l7t,
          getConfig: r7t,
          clear: c7t,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
        })
    })
  var u7t,
    Oat,
    Pat = x(() => {
      'use strict'
      jh()
      Vt()
      gm()
      T8()
      ;(u7t = a((e) => {
        jo(e, nf)
        let { axes: t, curves: r, options: n } = e
        nf.setAxes(t), nf.setCurves(r), nf.setOptions(n)
      }, 'populate')),
        (Oat = {
          parse: a(async (e) => {
            let t = await Fs('radar', e)
            B.debug(t), u7t(t)
          }, 'parse'),
        })
    })
  function m7t(e, t, r, n, i, s, o) {
    let l = t.length,
      u = Math.min(o.width, o.height) / 2
    r.forEach((h, f) => {
      if (h.entries.length !== l) return
      let d = h.entries.map((p, m) => {
        let g = (2 * Math.PI * m) / l - Math.PI / 2,
          y = g7t(p, n, i, u),
          b = y * Math.cos(g),
          k = y * Math.sin(g)
        return { x: b, y: k }
      })
      s === 'circle'
        ? e.append('path').attr('d', y7t(d, o.curveTension)).attr('class', `radarCurve-${f}`)
        : s === 'polygon' &&
          e
            .append('polygon')
            .attr('points', d.map((p) => `${p.x},${p.y}`).join(' '))
            .attr('class', `radarCurve-${f}`)
    })
  }
  function g7t(e, t, r, n) {
    let i = Math.min(Math.max(e, t), r)
    return (n * (i - t)) / (r - t)
  }
  function y7t(e, t) {
    let r = e.length,
      n = `M${e[0].x},${e[0].y}`
    for (let i = 0; i < r; i++) {
      let s = e[(i - 1 + r) % r],
        o = e[i],
        l = e[(i + 1) % r],
        u = e[(i + 2) % r],
        h = { x: o.x + (l.x - s.x) * t, y: o.y + (l.y - s.y) * t },
        f = { x: l.x - (u.x - o.x) * t, y: l.y - (u.y - o.y) * t }
      n += ` C${h.x},${h.y} ${f.x},${f.y} ${l.x},${l.y}`
    }
    return `${n} Z`
  }
  function x7t(e, t, r, n) {
    if (!r) return
    let i = ((n.width / 2 + n.marginRight) * 3) / 4,
      s = (-(n.height / 2 + n.marginTop) * 3) / 4,
      o = 20
    t.forEach((l, u) => {
      let h = e.append('g').attr('transform', `translate(${i}, ${s + u * o})`)
      h.append('rect').attr('width', 12).attr('height', 12).attr('class', `radarLegendBox-${u}`),
        h.append('text').attr('x', 16).attr('y', 0).attr('class', 'radarLegendText').text(l.label)
    })
  }
  var h7t,
    f7t,
    d7t,
    p7t,
    Bat,
    Fat = x(() => {
      'use strict'
      Bl()
      ;(h7t = a((e, t, r, n) => {
        let i = n.db,
          s = i.getAxes(),
          o = i.getCurves(),
          l = i.getOptions(),
          u = i.getConfig(),
          h = i.getDiagramTitle(),
          f = Ai(t),
          d = f7t(f, u),
          p = l.max ?? Math.max(...o.map((y) => Math.max(...y.entries))),
          m = l.min,
          g = Math.min(u.width, u.height) / 2
        d7t(d, s, g, l.ticks, l.graticule),
          p7t(d, s, g, u),
          m7t(d, s, o, m, p, l.graticule, u),
          x7t(d, o, l.showLegend, u),
          d
            .append('text')
            .attr('class', 'radarTitle')
            .text(h)
            .attr('x', 0)
            .attr('y', -u.height / 2 - u.marginTop)
      }, 'draw')),
        (f7t = a((e, t) => {
          let r = t.width + t.marginLeft + t.marginRight,
            n = t.height + t.marginTop + t.marginBottom,
            i = { x: t.marginLeft + t.width / 2, y: t.marginTop + t.height / 2 }
          return (
            e.attr('viewbox', `0 0 ${r} ${n}`).attr('width', r).attr('height', n),
            e.append('g').attr('transform', `translate(${i.x}, ${i.y})`)
          )
        }, 'drawFrame')),
        (d7t = a((e, t, r, n, i) => {
          if (i === 'circle')
            for (let s = 0; s < n; s++) {
              let o = (r * (s + 1)) / n
              e.append('circle').attr('r', o).attr('class', 'radarGraticule')
            }
          else if (i === 'polygon') {
            let s = t.length
            for (let o = 0; o < n; o++) {
              let l = (r * (o + 1)) / n,
                u = t
                  .map((h, f) => {
                    let d = (2 * f * Math.PI) / s - Math.PI / 2,
                      p = l * Math.cos(d),
                      m = l * Math.sin(d)
                    return `${p},${m}`
                  })
                  .join(' ')
              e.append('polygon').attr('points', u).attr('class', 'radarGraticule')
            }
          }
        }, 'drawGraticule')),
        (p7t = a((e, t, r, n) => {
          let i = t.length
          for (let s = 0; s < i; s++) {
            let o = t[s].label,
              l = (2 * s * Math.PI) / i - Math.PI / 2
            e
              .append('line')
              .attr('x1', 0)
              .attr('y1', 0)
              .attr('x2', r * n.axisScaleFactor * Math.cos(l))
              .attr('y2', r * n.axisScaleFactor * Math.sin(l))
              .attr('class', 'radarAxisLine'),
              e
                .append('text')
                .text(o)
                .attr('x', r * n.axisLabelFactor * Math.cos(l))
                .attr('y', r * n.axisLabelFactor * Math.sin(l))
                .attr('class', 'radarAxisLabel')
          }
        }, 'drawAxes'))
      a(m7t, 'drawCurves')
      a(g7t, 'relativeRadius')
      a(y7t, 'closedRoundCurve')
      a(x7t, 'drawLegend')
      Bat = { draw: h7t }
    })
  var b7t,
    k7t,
    $at,
    Gat = x(() => {
      'use strict'
      Ce()
      Qm()
      fn()
      ;(b7t = a((e, t) => {
        let r = ''
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++) {
          let i = e[`cScale${n}`]
          r += `
		.radarCurve-${n} {
			color: ${i};
			fill: ${i};
			fill-opacity: ${t.curveOpacity};
			stroke: ${i};
			stroke-width: ${t.curveStrokeWidth};
		}
		.radarLegendBox-${n} {
			fill: ${i};
			fill-opacity: ${t.curveOpacity};
			stroke: ${i};
		}
		`
        }
        return r
      }, 'genIndexStyles')),
        (k7t = a((e) => {
          let t = ql(),
            r = Te(),
            n = ln(t, r.themeVariables),
            i = ln(n.radar, e)
          return { themeVariables: n, radarOptions: i }
        }, 'buildRadarStyleOptions')),
        ($at = a(({ radar: e } = {}) => {
          let { themeVariables: t, radarOptions: r } = k7t(e)
          return `
	.radarTitle {
		font-size: ${t.fontSize};
		color: ${t.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${b7t(t, r)}
	`
        }, 'styles'))
    })
  var Vat = {}
  Oe(Vat, { diagram: () => T7t })
  var T7t,
    zat = x(() => {
      'use strict'
      T8()
      Pat()
      Fat()
      Gat()
      T7t = { parser: Oat, db: nf, renderer: Bat, styles: $at }
    })
  var S8,
    jat,
    qat = x(() => {
      'use strict'
      S8 = (function () {
        var e = a(function (C, A, w, D) {
            for (w = w || {}, D = C.length; D--; w[C[D]] = A);
            return w
          }, 'o'),
          t = [1, 15],
          r = [1, 7],
          n = [1, 13],
          i = [1, 14],
          s = [1, 19],
          o = [1, 16],
          l = [1, 17],
          u = [1, 18],
          h = [8, 30],
          f = [8, 10, 21, 28, 29, 30, 31, 39, 43, 46],
          d = [1, 23],
          p = [1, 24],
          m = [8, 10, 15, 16, 21, 28, 29, 30, 31, 39, 43, 46],
          g = [8, 10, 15, 16, 21, 27, 28, 29, 30, 31, 39, 43, 46],
          y = [1, 49],
          b = {
            trace: a(function () {}, 'trace'),
            yy: {},
            symbols_: {
              error: 2,
              spaceLines: 3,
              SPACELINE: 4,
              NL: 5,
              separator: 6,
              SPACE: 7,
              EOF: 8,
              start: 9,
              BLOCK_DIAGRAM_KEY: 10,
              document: 11,
              stop: 12,
              statement: 13,
              link: 14,
              LINK: 15,
              START_LINK: 16,
              LINK_LABEL: 17,
              STR: 18,
              nodeStatement: 19,
              columnsStatement: 20,
              SPACE_BLOCK: 21,
              blockStatement: 22,
              classDefStatement: 23,
              cssClassStatement: 24,
              styleStatement: 25,
              node: 26,
              SIZE: 27,
              COLUMNS: 28,
              'id-block': 29,
              end: 30,
              NODE_ID: 31,
              nodeShapeNLabel: 32,
              dirList: 33,
              DIR: 34,
              NODE_DSTART: 35,
              NODE_DEND: 36,
              BLOCK_ARROW_START: 37,
              BLOCK_ARROW_END: 38,
              classDef: 39,
              CLASSDEF_ID: 40,
              CLASSDEF_STYLEOPTS: 41,
              DEFAULT: 42,
              class: 43,
              CLASSENTITY_IDS: 44,
              STYLECLASS: 45,
              style: 46,
              STYLE_ENTITY_IDS: 47,
              STYLE_DEFINITION_DATA: 48,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: 'error',
              4: 'SPACELINE',
              5: 'NL',
              7: 'SPACE',
              8: 'EOF',
              10: 'BLOCK_DIAGRAM_KEY',
              15: 'LINK',
              16: 'START_LINK',
              17: 'LINK_LABEL',
              18: 'STR',
              21: 'SPACE_BLOCK',
              27: 'SIZE',
              28: 'COLUMNS',
              29: 'id-block',
              30: 'end',
              31: 'NODE_ID',
              34: 'DIR',
              35: 'NODE_DSTART',
              36: 'NODE_DEND',
              37: 'BLOCK_ARROW_START',
              38: 'BLOCK_ARROW_END',
              39: 'classDef',
              40: 'CLASSDEF_ID',
              41: 'CLASSDEF_STYLEOPTS',
              42: 'DEFAULT',
              43: 'class',
              44: 'CLASSENTITY_IDS',
              45: 'STYLECLASS',
              46: 'style',
              47: 'STYLE_ENTITY_IDS',
              48: 'STYLE_DEFINITION_DATA',
            },
            productions_: [
              0,
              [3, 1],
              [3, 2],
              [3, 2],
              [6, 1],
              [6, 1],
              [6, 1],
              [9, 3],
              [12, 1],
              [12, 1],
              [12, 2],
              [12, 2],
              [11, 1],
              [11, 2],
              [14, 1],
              [14, 4],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [19, 3],
              [19, 2],
              [19, 1],
              [20, 1],
              [22, 4],
              [22, 3],
              [26, 1],
              [26, 2],
              [33, 1],
              [33, 2],
              [32, 3],
              [32, 4],
              [23, 3],
              [23, 3],
              [24, 3],
              [25, 3],
            ],
            performAction: a(function (A, w, D, G, v, R, F) {
              var S = R.length - 1
              switch (v) {
                case 4:
                  G.getLogger().debug('Rule: separator (NL) ')
                  break
                case 5:
                  G.getLogger().debug('Rule: separator (Space) ')
                  break
                case 6:
                  G.getLogger().debug('Rule: separator (EOF) ')
                  break
                case 7:
                  G.getLogger().debug('Rule: hierarchy: ', R[S - 1]), G.setHierarchy(R[S - 1])
                  break
                case 8:
                  G.getLogger().debug('Stop NL ')
                  break
                case 9:
                  G.getLogger().debug('Stop EOF ')
                  break
                case 10:
                  G.getLogger().debug('Stop NL2 ')
                  break
                case 11:
                  G.getLogger().debug('Stop EOF2 ')
                  break
                case 12:
                  G.getLogger().debug('Rule: statement: ', R[S]),
                    typeof R[S].length == 'number' ? (this.$ = R[S]) : (this.$ = [R[S]])
                  break
                case 13:
                  G.getLogger().debug('Rule: statement #2: ', R[S - 1]), (this.$ = [R[S - 1]].concat(R[S]))
                  break
                case 14:
                  G.getLogger().debug('Rule: link: ', R[S], A), (this.$ = { edgeTypeStr: R[S], label: '' })
                  break
                case 15:
                  G.getLogger().debug('Rule: LABEL link: ', R[S - 3], R[S - 1], R[S]),
                    (this.$ = { edgeTypeStr: R[S], label: R[S - 1] })
                  break
                case 18:
                  let O = parseInt(R[S]),
                    E = G.generateId()
                  this.$ = { id: E, type: 'space', label: '', width: O, children: [] }
                  break
                case 23:
                  G.getLogger().debug(
                    'Rule: (nodeStatement link node) ',
                    R[S - 2],
                    R[S - 1],
                    R[S],
                    ' typestr: ',
                    R[S - 1].edgeTypeStr,
                  )
                  let _ = G.edgeStrToEdgeData(R[S - 1].edgeTypeStr)
                  this.$ = [
                    { id: R[S - 2].id, label: R[S - 2].label, type: R[S - 2].type, directions: R[S - 2].directions },
                    {
                      id: R[S - 2].id + '-' + R[S].id,
                      start: R[S - 2].id,
                      end: R[S].id,
                      label: R[S - 1].label,
                      type: 'edge',
                      directions: R[S].directions,
                      arrowTypeEnd: _,
                      arrowTypeStart: 'arrow_open',
                    },
                    { id: R[S].id, label: R[S].label, type: G.typeStr2Type(R[S].typeStr), directions: R[S].directions },
                  ]
                  break
                case 24:
                  G.getLogger().debug('Rule: nodeStatement (abc88 node size) ', R[S - 1], R[S]),
                    (this.$ = {
                      id: R[S - 1].id,
                      label: R[S - 1].label,
                      type: G.typeStr2Type(R[S - 1].typeStr),
                      directions: R[S - 1].directions,
                      widthInColumns: parseInt(R[S], 10),
                    })
                  break
                case 25:
                  G.getLogger().debug('Rule: nodeStatement (node) ', R[S]),
                    (this.$ = {
                      id: R[S].id,
                      label: R[S].label,
                      type: G.typeStr2Type(R[S].typeStr),
                      directions: R[S].directions,
                      widthInColumns: 1,
                    })
                  break
                case 26:
                  G.getLogger().debug('APA123', this ? this : 'na'),
                    G.getLogger().debug('COLUMNS: ', R[S]),
                    (this.$ = { type: 'column-setting', columns: R[S] === 'auto' ? -1 : parseInt(R[S]) })
                  break
                case 27:
                  G.getLogger().debug('Rule: id-block statement : ', R[S - 2], R[S - 1])
                  let L = G.generateId()
                  this.$ = { ...R[S - 2], type: 'composite', children: R[S - 1] }
                  break
                case 28:
                  G.getLogger().debug('Rule: blockStatement : ', R[S - 2], R[S - 1], R[S])
                  let N = G.generateId()
                  this.$ = { id: N, type: 'composite', label: '', children: R[S - 1] }
                  break
                case 29:
                  G.getLogger().debug('Rule: node (NODE_ID separator): ', R[S]), (this.$ = { id: R[S] })
                  break
                case 30:
                  G.getLogger().debug('Rule: node (NODE_ID nodeShapeNLabel separator): ', R[S - 1], R[S]),
                    (this.$ = { id: R[S - 1], label: R[S].label, typeStr: R[S].typeStr, directions: R[S].directions })
                  break
                case 31:
                  G.getLogger().debug('Rule: dirList: ', R[S]), (this.$ = [R[S]])
                  break
                case 32:
                  G.getLogger().debug('Rule: dirList: ', R[S - 1], R[S]), (this.$ = [R[S - 1]].concat(R[S]))
                  break
                case 33:
                  G.getLogger().debug('Rule: nodeShapeNLabel: ', R[S - 2], R[S - 1], R[S]),
                    (this.$ = { typeStr: R[S - 2] + R[S], label: R[S - 1] })
                  break
                case 34:
                  G.getLogger().debug(
                    'Rule: BLOCK_ARROW nodeShapeNLabel: ',
                    R[S - 3],
                    R[S - 2],
                    ' #3:',
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = { typeStr: R[S - 3] + R[S], label: R[S - 2], directions: R[S - 1] })
                  break
                case 35:
                case 36:
                  this.$ = { type: 'classDef', id: R[S - 1].trim(), css: R[S].trim() }
                  break
                case 37:
                  this.$ = { type: 'applyClass', id: R[S - 1].trim(), styleClass: R[S].trim() }
                  break
                case 38:
                  this.$ = { type: 'applyStyles', id: R[S - 1].trim(), stylesStr: R[S].trim() }
                  break
              }
            }, 'anonymous'),
            table: [
              { 9: 1, 10: [1, 2] },
              { 1: [3] },
              {
                10: t,
                11: 3,
                13: 4,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 8: [1, 20] },
              e(h, [2, 12], {
                13: 4,
                19: 5,
                20: 6,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                11: 21,
                10: t,
                21: r,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              }),
              e(f, [2, 16], { 14: 22, 15: d, 16: p }),
              e(f, [2, 17]),
              e(f, [2, 18]),
              e(f, [2, 19]),
              e(f, [2, 20]),
              e(f, [2, 21]),
              e(f, [2, 22]),
              e(m, [2, 25], { 27: [1, 25] }),
              e(f, [2, 26]),
              { 19: 26, 26: 12, 31: s },
              {
                10: t,
                11: 27,
                13: 4,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 40: [1, 28], 42: [1, 29] },
              { 44: [1, 30] },
              { 47: [1, 31] },
              e(g, [2, 29], { 32: 32, 35: [1, 33], 37: [1, 34] }),
              { 1: [2, 7] },
              e(h, [2, 13]),
              { 26: 35, 31: s },
              { 31: [2, 14] },
              { 17: [1, 36] },
              e(m, [2, 24]),
              {
                10: t,
                11: 37,
                13: 4,
                14: 22,
                15: d,
                16: p,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 30: [1, 38] },
              { 41: [1, 39] },
              { 41: [1, 40] },
              { 45: [1, 41] },
              { 48: [1, 42] },
              e(g, [2, 30]),
              { 18: [1, 43] },
              { 18: [1, 44] },
              e(m, [2, 23]),
              { 18: [1, 45] },
              { 30: [1, 46] },
              e(f, [2, 28]),
              e(f, [2, 35]),
              e(f, [2, 36]),
              e(f, [2, 37]),
              e(f, [2, 38]),
              { 36: [1, 47] },
              { 33: 48, 34: y },
              { 15: [1, 50] },
              e(f, [2, 27]),
              e(g, [2, 33]),
              { 38: [1, 51] },
              { 33: 52, 34: y, 38: [2, 31] },
              { 31: [2, 15] },
              e(g, [2, 34]),
              { 38: [2, 32] },
            ],
            defaultActions: { 20: [2, 7], 23: [2, 14], 50: [2, 15], 52: [2, 32] },
            parseError: a(function (A, w) {
              if (w.recoverable) this.trace(A)
              else {
                var D = new Error(A)
                throw ((D.hash = w), D)
              }
            }, 'parseError'),
            parse: a(function (A) {
              var w = this,
                D = [0],
                G = [],
                v = [null],
                R = [],
                F = this.table,
                S = '',
                O = 0,
                E = 0,
                _ = 0,
                L = 2,
                N = 1,
                P = R.slice.call(arguments, 1),
                I = Object.create(this.lexer),
                M = { yy: {} }
              for (var V in this.yy) Object.prototype.hasOwnProperty.call(this.yy, V) && (M.yy[V] = this.yy[V])
              I.setInput(A, M.yy), (M.yy.lexer = I), (M.yy.parser = this), typeof I.yylloc > 'u' && (I.yylloc = {})
              var $ = I.yylloc
              R.push($)
              var q = I.options && I.options.ranges
              typeof M.yy.parseError == 'function'
                ? (this.parseError = M.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError)
              function tt(gt) {
                ;(D.length = D.length - 2 * gt), (v.length = v.length - gt), (R.length = R.length - gt)
              }
              a(tt, 'popStack')
              function ft() {
                var gt
                return (
                  (gt = G.pop() || I.lex() || N),
                  typeof gt != 'number' &&
                    (gt instanceof Array && ((G = gt), (gt = G.pop())), (gt = w.symbols_[gt] || gt)),
                  gt
                )
              }
              a(ft, 'lex')
              for (var H, kt, ht, yt, ot, dt, it = {}, Q, et, X, st; ; ) {
                if (
                  ((ht = D[D.length - 1]),
                  this.defaultActions[ht]
                    ? (yt = this.defaultActions[ht])
                    : ((H === null || typeof H > 'u') && (H = ft()), (yt = F[ht] && F[ht][H])),
                  typeof yt > 'u' || !yt.length || !yt[0])
                ) {
                  var U = ''
                  st = []
                  for (Q in F[ht]) this.terminals_[Q] && Q > L && st.push("'" + this.terminals_[Q] + "'")
                  I.showPosition
                    ? (U =
                        'Parse error on line ' +
                        (O + 1) +
                        `:
` +
                        I.showPosition() +
                        `
Expecting ` +
                        st.join(', ') +
                        ", got '" +
                        (this.terminals_[H] || H) +
                        "'")
                    : (U =
                        'Parse error on line ' +
                        (O + 1) +
                        ': Unexpected ' +
                        (H == N ? 'end of input' : "'" + (this.terminals_[H] || H) + "'")),
                    this.parseError(U, {
                      text: I.match,
                      token: this.terminals_[H] || H,
                      line: I.yylineno,
                      loc: $,
                      expected: st,
                    })
                }
                if (yt[0] instanceof Array && yt.length > 1)
                  throw new Error('Parse Error: multiple actions possible at state: ' + ht + ', token: ' + H)
                switch (yt[0]) {
                  case 1:
                    D.push(H),
                      v.push(I.yytext),
                      R.push(I.yylloc),
                      D.push(yt[1]),
                      (H = null),
                      kt
                        ? ((H = kt), (kt = null))
                        : ((E = I.yyleng), (S = I.yytext), (O = I.yylineno), ($ = I.yylloc), _ > 0 && _--)
                    break
                  case 2:
                    if (
                      ((et = this.productions_[yt[1]][1]),
                      (it.$ = v[v.length - et]),
                      (it._$ = {
                        first_line: R[R.length - (et || 1)].first_line,
                        last_line: R[R.length - 1].last_line,
                        first_column: R[R.length - (et || 1)].first_column,
                        last_column: R[R.length - 1].last_column,
                      }),
                      q && (it._$.range = [R[R.length - (et || 1)].range[0], R[R.length - 1].range[1]]),
                      (dt = this.performAction.apply(it, [S, E, O, M.yy, yt[1], v, R].concat(P))),
                      typeof dt < 'u')
                    )
                      return dt
                    et && ((D = D.slice(0, -1 * et * 2)), (v = v.slice(0, -1 * et)), (R = R.slice(0, -1 * et))),
                      D.push(this.productions_[yt[1]][0]),
                      v.push(it.$),
                      R.push(it._$),
                      (X = F[D[D.length - 2]][D[D.length - 1]]),
                      D.push(X)
                    break
                  case 3:
                    return !0
                }
              }
              return !0
            }, 'parse'),
          },
          k = (function () {
            var C = {
              EOF: 1,
              parseError: a(function (w, D) {
                if (this.yy.parser) this.yy.parser.parseError(w, D)
                else throw new Error(w)
              }, 'parseError'),
              setInput: a(function (A, w) {
                return (
                  (this.yy = w || this.yy || {}),
                  (this._input = A),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ''),
                  (this.conditionStack = ['INITIAL']),
                  (this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                )
              }, 'setInput'),
              input: a(function () {
                var A = this._input[0]
                ;(this.yytext += A), this.yyleng++, this.offset++, (this.match += A), (this.matched += A)
                var w = A.match(/(?:\r\n?|\n).*/g)
                return (
                  w ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  A
                )
              }, 'input'),
              unput: a(function (A) {
                var w = A.length,
                  D = A.split(/(?:\r\n?|\n)/g)
                ;(this._input = A + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - w)),
                  (this.offset -= w)
                var G = this.match.split(/(?:\r\n?|\n)/g)
                ;(this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(0, this.matched.length - 1)),
                  D.length - 1 && (this.yylineno -= D.length - 1)
                var v = this.yylloc.range
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: D
                      ? (D.length === G.length ? this.yylloc.first_column : 0) +
                        G[G.length - D.length].length -
                        D[0].length
                      : this.yylloc.first_column - w,
                  }),
                  this.options.ranges && (this.yylloc.range = [v[0], v[0] + this.yyleng - w]),
                  (this.yyleng = this.yytext.length),
                  this
                )
              }, 'unput'),
              more: a(function () {
                return (this._more = !0), this
              }, 'more'),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0
                else
                  return this.parseError(
                    'Lexical error on line ' +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: '', token: null, line: this.yylineno },
                  )
                return this
              }, 'reject'),
              less: a(function (A) {
                this.unput(this.match.slice(A))
              }, 'less'),
              pastInput: a(function () {
                var A = this.matched.substr(0, this.matched.length - this.match.length)
                return (A.length > 20 ? '...' : '') + A.substr(-20).replace(/\n/g, '')
              }, 'pastInput'),
              upcomingInput: a(function () {
                var A = this.match
                return (
                  A.length < 20 && (A += this._input.substr(0, 20 - A.length)),
                  (A.substr(0, 20) + (A.length > 20 ? '...' : '')).replace(/\n/g, '')
                )
              }, 'upcomingInput'),
              showPosition: a(function () {
                var A = this.pastInput(),
                  w = new Array(A.length + 1).join('-')
                return (
                  A +
                  this.upcomingInput() +
                  `
` +
                  w +
                  '^'
                )
              }, 'showPosition'),
              test_match: a(function (A, w) {
                var D, G, v
                if (
                  (this.options.backtrack_lexer &&
                    ((v = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges && (v.yylloc.range = this.yylloc.range.slice(0))),
                  (G = A[0].match(/(?:\r\n?|\n).*/g)),
                  G && (this.yylineno += G.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: G
                      ? G[G.length - 1].length - G[G.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + A[0].length,
                  }),
                  (this.yytext += A[0]),
                  (this.match += A[0]),
                  (this.matches = A),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges && (this.yylloc.range = [this.offset, (this.offset += this.yyleng)]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(A[0].length)),
                  (this.matched += A[0]),
                  (D = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    w,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  D)
                )
                  return D
                if (this._backtrack) {
                  for (var R in v) this[R] = v[R]
                  return !1
                }
                return !1
              }, 'test_match'),
              next: a(function () {
                if (this.done) return this.EOF
                this._input || (this.done = !0)
                var A, w, D, G
                this._more || ((this.yytext = ''), (this.match = ''))
                for (var v = this._currentRules(), R = 0; R < v.length; R++)
                  if (((D = this._input.match(this.rules[v[R]])), D && (!w || D[0].length > w[0].length))) {
                    if (((w = D), (G = R), this.options.backtrack_lexer)) {
                      if (((A = this.test_match(D, v[R])), A !== !1)) return A
                      if (this._backtrack) {
                        w = !1
                        continue
                      } else return !1
                    } else if (!this.options.flex) break
                  }
                return w
                  ? ((A = this.test_match(w, v[G])), A !== !1 ? A : !1)
                  : this._input === ''
                    ? this.EOF
                    : this.parseError(
                        'Lexical error on line ' +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: '', token: null, line: this.yylineno },
                      )
              }, 'next'),
              lex: a(function () {
                var w = this.next()
                return w || this.lex()
              }, 'lex'),
              begin: a(function (w) {
                this.conditionStack.push(w)
              }, 'begin'),
              popState: a(function () {
                var w = this.conditionStack.length - 1
                return w > 0 ? this.conditionStack.pop() : this.conditionStack[0]
              }, 'popState'),
              _currentRules: a(function () {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                  : this.conditions.INITIAL.rules
              }, '_currentRules'),
              topState: a(function (w) {
                return (
                  (w = this.conditionStack.length - 1 - Math.abs(w || 0)), w >= 0 ? this.conditionStack[w] : 'INITIAL'
                )
              }, 'topState'),
              pushState: a(function (w) {
                this.begin(w)
              }, 'pushState'),
              stateStackSize: a(function () {
                return this.conditionStack.length
              }, 'stateStackSize'),
              options: {},
              performAction: a(function (w, D, G, v) {
                var R = v
                switch (G) {
                  case 0:
                    return w.getLogger().debug('Found block-beta'), 10
                    break
                  case 1:
                    return w.getLogger().debug('Found id-block'), 29
                    break
                  case 2:
                    return w.getLogger().debug('Found block'), 10
                    break
                  case 3:
                    w.getLogger().debug('.', D.yytext)
                    break
                  case 4:
                    w.getLogger().debug('_', D.yytext)
                    break
                  case 5:
                    return 5
                  case 6:
                    return (D.yytext = -1), 28
                    break
                  case 7:
                    return (
                      (D.yytext = D.yytext.replace(/columns\s+/, '')),
                      w.getLogger().debug('COLUMNS (LEX)', D.yytext),
                      28
                    )
                    break
                  case 8:
                    this.pushState('md_string')
                    break
                  case 9:
                    return 'MD_STR'
                  case 10:
                    this.popState()
                    break
                  case 11:
                    this.pushState('string')
                    break
                  case 12:
                    w.getLogger().debug('LEX: POPPING STR:', D.yytext), this.popState()
                    break
                  case 13:
                    return w.getLogger().debug('LEX: STR end:', D.yytext), 'STR'
                    break
                  case 14:
                    return (
                      (D.yytext = D.yytext.replace(/space\:/, '')), w.getLogger().debug('SPACE NUM (LEX)', D.yytext), 21
                    )
                    break
                  case 15:
                    return (D.yytext = '1'), w.getLogger().debug('COLUMNS (LEX)', D.yytext), 21
                    break
                  case 16:
                    return 42
                  case 17:
                    return 'LINKSTYLE'
                  case 18:
                    return 'INTERPOLATE'
                  case 19:
                    return this.pushState('CLASSDEF'), 39
                    break
                  case 20:
                    return this.popState(), this.pushState('CLASSDEFID'), 'DEFAULT_CLASSDEF_ID'
                    break
                  case 21:
                    return this.popState(), this.pushState('CLASSDEFID'), 40
                    break
                  case 22:
                    return this.popState(), 41
                    break
                  case 23:
                    return this.pushState('CLASS'), 43
                    break
                  case 24:
                    return this.popState(), this.pushState('CLASS_STYLE'), 44
                    break
                  case 25:
                    return this.popState(), 45
                    break
                  case 26:
                    return this.pushState('STYLE_STMNT'), 46
                    break
                  case 27:
                    return this.popState(), this.pushState('STYLE_DEFINITION'), 47
                    break
                  case 28:
                    return this.popState(), 48
                    break
                  case 29:
                    return this.pushState('acc_title'), 'acc_title'
                    break
                  case 30:
                    return this.popState(), 'acc_title_value'
                    break
                  case 31:
                    return this.pushState('acc_descr'), 'acc_descr'
                    break
                  case 32:
                    return this.popState(), 'acc_descr_value'
                    break
                  case 33:
                    this.pushState('acc_descr_multiline')
                    break
                  case 34:
                    this.popState()
                    break
                  case 35:
                    return 'acc_descr_multiline_value'
                  case 36:
                    return 30
                  case 37:
                    return this.popState(), w.getLogger().debug('Lex: (('), 'NODE_DEND'
                    break
                  case 38:
                    return this.popState(), w.getLogger().debug('Lex: (('), 'NODE_DEND'
                    break
                  case 39:
                    return this.popState(), w.getLogger().debug('Lex: ))'), 'NODE_DEND'
                    break
                  case 40:
                    return this.popState(), w.getLogger().debug('Lex: (('), 'NODE_DEND'
                    break
                  case 41:
                    return this.popState(), w.getLogger().debug('Lex: (('), 'NODE_DEND'
                    break
                  case 42:
                    return this.popState(), w.getLogger().debug('Lex: (-'), 'NODE_DEND'
                    break
                  case 43:
                    return this.popState(), w.getLogger().debug('Lex: -)'), 'NODE_DEND'
                    break
                  case 44:
                    return this.popState(), w.getLogger().debug('Lex: (('), 'NODE_DEND'
                    break
                  case 45:
                    return this.popState(), w.getLogger().debug('Lex: ]]'), 'NODE_DEND'
                    break
                  case 46:
                    return this.popState(), w.getLogger().debug('Lex: ('), 'NODE_DEND'
                    break
                  case 47:
                    return this.popState(), w.getLogger().debug('Lex: ])'), 'NODE_DEND'
                    break
                  case 48:
                    return this.popState(), w.getLogger().debug('Lex: /]'), 'NODE_DEND'
                    break
                  case 49:
                    return this.popState(), w.getLogger().debug('Lex: /]'), 'NODE_DEND'
                    break
                  case 50:
                    return this.popState(), w.getLogger().debug('Lex: )]'), 'NODE_DEND'
                    break
                  case 51:
                    return this.popState(), w.getLogger().debug('Lex: )'), 'NODE_DEND'
                    break
                  case 52:
                    return this.popState(), w.getLogger().debug('Lex: ]>'), 'NODE_DEND'
                    break
                  case 53:
                    return this.popState(), w.getLogger().debug('Lex: ]'), 'NODE_DEND'
                    break
                  case 54:
                    return w.getLogger().debug('Lexa: -)'), this.pushState('NODE'), 35
                    break
                  case 55:
                    return w.getLogger().debug('Lexa: (-'), this.pushState('NODE'), 35
                    break
                  case 56:
                    return w.getLogger().debug('Lexa: ))'), this.pushState('NODE'), 35
                    break
                  case 57:
                    return w.getLogger().debug('Lexa: )'), this.pushState('NODE'), 35
                    break
                  case 58:
                    return w.getLogger().debug('Lex: ((('), this.pushState('NODE'), 35
                    break
                  case 59:
                    return w.getLogger().debug('Lexa: )'), this.pushState('NODE'), 35
                    break
                  case 60:
                    return w.getLogger().debug('Lexa: )'), this.pushState('NODE'), 35
                    break
                  case 61:
                    return w.getLogger().debug('Lexa: )'), this.pushState('NODE'), 35
                    break
                  case 62:
                    return w.getLogger().debug('Lexc: >'), this.pushState('NODE'), 35
                    break
                  case 63:
                    return w.getLogger().debug('Lexa: (['), this.pushState('NODE'), 35
                    break
                  case 64:
                    return w.getLogger().debug('Lexa: )'), this.pushState('NODE'), 35
                    break
                  case 65:
                    return this.pushState('NODE'), 35
                    break
                  case 66:
                    return this.pushState('NODE'), 35
                    break
                  case 67:
                    return this.pushState('NODE'), 35
                    break
                  case 68:
                    return this.pushState('NODE'), 35
                    break
                  case 69:
                    return this.pushState('NODE'), 35
                    break
                  case 70:
                    return this.pushState('NODE'), 35
                    break
                  case 71:
                    return this.pushState('NODE'), 35
                    break
                  case 72:
                    return w.getLogger().debug('Lexa: ['), this.pushState('NODE'), 35
                    break
                  case 73:
                    return this.pushState('BLOCK_ARROW'), w.getLogger().debug('LEX ARR START'), 37
                    break
                  case 74:
                    return w.getLogger().debug('Lex: NODE_ID', D.yytext), 31
                    break
                  case 75:
                    return w.getLogger().debug('Lex: EOF', D.yytext), 8
                    break
                  case 76:
                    this.pushState('md_string')
                    break
                  case 77:
                    this.pushState('md_string')
                    break
                  case 78:
                    return 'NODE_DESCR'
                  case 79:
                    this.popState()
                    break
                  case 80:
                    w.getLogger().debug('Lex: Starting string'), this.pushState('string')
                    break
                  case 81:
                    w.getLogger().debug('LEX ARR: Starting string'), this.pushState('string')
                    break
                  case 82:
                    return w.getLogger().debug('LEX: NODE_DESCR:', D.yytext), 'NODE_DESCR'
                    break
                  case 83:
                    w.getLogger().debug('LEX POPPING'), this.popState()
                    break
                  case 84:
                    w.getLogger().debug('Lex: =>BAE'), this.pushState('ARROW_DIR')
                    break
                  case 85:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, '')),
                      w.getLogger().debug('Lex (right): dir:', D.yytext),
                      'DIR'
                    )
                    break
                  case 86:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, '')), w.getLogger().debug('Lex (left):', D.yytext), 'DIR'
                    )
                    break
                  case 87:
                    return (D.yytext = D.yytext.replace(/^,\s*/, '')), w.getLogger().debug('Lex (x):', D.yytext), 'DIR'
                    break
                  case 88:
                    return (D.yytext = D.yytext.replace(/^,\s*/, '')), w.getLogger().debug('Lex (y):', D.yytext), 'DIR'
                    break
                  case 89:
                    return (D.yytext = D.yytext.replace(/^,\s*/, '')), w.getLogger().debug('Lex (up):', D.yytext), 'DIR'
                    break
                  case 90:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, '')), w.getLogger().debug('Lex (down):', D.yytext), 'DIR'
                    )
                    break
                  case 91:
                    return (
                      (D.yytext = ']>'),
                      w.getLogger().debug('Lex (ARROW_DIR end):', D.yytext),
                      this.popState(),
                      this.popState(),
                      'BLOCK_ARROW_END'
                    )
                    break
                  case 92:
                    return w.getLogger().debug('Lex: LINK', '#' + D.yytext + '#'), 15
                    break
                  case 93:
                    return w.getLogger().debug('Lex: LINK', D.yytext), 15
                    break
                  case 94:
                    return w.getLogger().debug('Lex: LINK', D.yytext), 15
                    break
                  case 95:
                    return w.getLogger().debug('Lex: LINK', D.yytext), 15
                    break
                  case 96:
                    return w.getLogger().debug('Lex: START_LINK', D.yytext), this.pushState('LLABEL'), 16
                    break
                  case 97:
                    return w.getLogger().debug('Lex: START_LINK', D.yytext), this.pushState('LLABEL'), 16
                    break
                  case 98:
                    return w.getLogger().debug('Lex: START_LINK', D.yytext), this.pushState('LLABEL'), 16
                    break
                  case 99:
                    this.pushState('md_string')
                    break
                  case 100:
                    return w.getLogger().debug('Lex: Starting string'), this.pushState('string'), 'LINK_LABEL'
                    break
                  case 101:
                    return this.popState(), w.getLogger().debug('Lex: LINK', '#' + D.yytext + '#'), 15
                    break
                  case 102:
                    return this.popState(), w.getLogger().debug('Lex: LINK', D.yytext), 15
                    break
                  case 103:
                    return this.popState(), w.getLogger().debug('Lex: LINK', D.yytext), 15
                    break
                  case 104:
                    return w.getLogger().debug('Lex: COLON', D.yytext), (D.yytext = D.yytext.slice(1)), 27
                    break
                }
              }, 'anonymous'),
              rules: [
                /^(?:block-beta\b)/,
                /^(?:block:)/,
                /^(?:block\b)/,
                /^(?:[\s]+)/,
                /^(?:[\n]+)/,
                /^(?:((\u000D\u000A)|(\u000A)))/,
                /^(?:columns\s+auto\b)/,
                /^(?:columns\s+[\d]+)/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:space[:]\d+)/,
                /^(?:space\b)/,
                /^(?:default\b)/,
                /^(?:linkStyle\b)/,
                /^(?:interpolate\b)/,
                /^(?:classDef\s+)/,
                /^(?:DEFAULT\s+)/,
                /^(?:\w+\s+)/,
                /^(?:[^\n]*)/,
                /^(?:class\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:style\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:end\b\s*)/,
                /^(?:\(\(\()/,
                /^(?:\)\)\))/,
                /^(?:[\)]\))/,
                /^(?:\}\})/,
                /^(?:\})/,
                /^(?:\(-)/,
                /^(?:-\))/,
                /^(?:\(\()/,
                /^(?:\]\])/,
                /^(?:\()/,
                /^(?:\]\))/,
                /^(?:\\\])/,
                /^(?:\/\])/,
                /^(?:\)\])/,
                /^(?:[\)])/,
                /^(?:\]>)/,
                /^(?:[\]])/,
                /^(?:-\))/,
                /^(?:\(-)/,
                /^(?:\)\))/,
                /^(?:\))/,
                /^(?:\(\(\()/,
                /^(?:\(\()/,
                /^(?:\{\{)/,
                /^(?:\{)/,
                /^(?:>)/,
                /^(?:\(\[)/,
                /^(?:\()/,
                /^(?:\[\[)/,
                /^(?:\[\|)/,
                /^(?:\[\()/,
                /^(?:\)\)\))/,
                /^(?:\[\\)/,
                /^(?:\[\/)/,
                /^(?:\[\\)/,
                /^(?:\[)/,
                /^(?:<\[)/,
                /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
                /^(?:$)/,
                /^(?:["][`])/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:\]>\s*\()/,
                /^(?:,?\s*right\s*)/,
                /^(?:,?\s*left\s*)/,
                /^(?:,?\s*x\s*)/,
                /^(?:,?\s*y\s*)/,
                /^(?:,?\s*up\s*)/,
                /^(?:,?\s*down\s*)/,
                /^(?:\)\s*)/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?:\s*~~[\~]+\s*)/,
                /^(?:\s*[xo<]?--\s*)/,
                /^(?:\s*[xo<]?==\s*)/,
                /^(?:\s*[xo<]?-\.\s*)/,
                /^(?:["][`])/,
                /^(?:["])/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?::\d+)/,
              ],
              conditions: {
                STYLE_DEFINITION: { rules: [28], inclusive: !1 },
                STYLE_STMNT: { rules: [27], inclusive: !1 },
                CLASSDEFID: { rules: [22], inclusive: !1 },
                CLASSDEF: { rules: [20, 21], inclusive: !1 },
                CLASS_STYLE: { rules: [25], inclusive: !1 },
                CLASS: { rules: [24], inclusive: !1 },
                LLABEL: { rules: [99, 100, 101, 102, 103], inclusive: !1 },
                ARROW_DIR: { rules: [85, 86, 87, 88, 89, 90, 91], inclusive: !1 },
                BLOCK_ARROW: { rules: [76, 81, 84], inclusive: !1 },
                NODE: {
                  rules: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 77, 80],
                  inclusive: !1,
                },
                md_string: { rules: [9, 10, 78, 79], inclusive: !1 },
                space: { rules: [], inclusive: !1 },
                string: { rules: [12, 13, 82, 83], inclusive: !1 },
                acc_descr_multiline: { rules: [34, 35], inclusive: !1 },
                acc_descr: { rules: [32], inclusive: !1 },
                acc_title: { rules: [30], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 14, 15, 16, 17, 18, 19, 23, 26, 29, 31, 33, 36, 54, 55, 56, 57, 58,
                    59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 92, 93, 94, 95, 96, 97, 98, 104,
                  ],
                  inclusive: !0,
                },
              },
            }
            return C
          })()
        b.lexer = k
        function T() {
          this.yy = {}
        }
        return a(T, 'Parser'), (T.prototype = b), (b.Parser = T), new T()
      })()
      S8.parser = S8
      jat = S8
    })
  function D7t(e) {
    switch ((B.debug('typeStr2Type', e), e)) {
      case '[]':
        return 'square'
      case '()':
        return B.debug('we have a round'), 'round'
      case '(())':
        return 'circle'
      case '>]':
        return 'rect_left_inv_arrow'
      case '{}':
        return 'diamond'
      case '{{}}':
        return 'hexagon'
      case '([])':
        return 'stadium'
      case '[[]]':
        return 'subroutine'
      case '[()]':
        return 'cylinder'
      case '((()))':
        return 'doublecircle'
      case '[//]':
        return 'lean_right'
      case '[\\\\]':
        return 'lean_left'
      case '[/\\]':
        return 'trapezoid'
      case '[\\/]':
        return 'inv_trapezoid'
      case '<[]>':
        return 'block_arrow'
      default:
        return 'na'
    }
  }
  function N7t(e) {
    switch ((B.debug('typeStr2Type', e), e)) {
      case '==':
        return 'thick'
      default:
        return 'normal'
    }
  }
  function I7t(e) {
    switch (e.replace(/^[\s-]+|[\s-]+$/g, '')) {
      case 'x':
        return 'arrow_cross'
      case 'o':
        return 'arrow_circle'
      case '>':
        return 'arrow_point'
      default:
        return ''
    }
  }
  var Qa,
    C8,
    _8,
    Hat,
    Yat,
    C7t,
    Kat,
    w7t,
    lC,
    E7t,
    v7t,
    A7t,
    L7t,
    Qat,
    w8,
    Qy,
    R7t,
    Xat,
    M7t,
    O7t,
    P7t,
    B7t,
    F7t,
    $7t,
    G7t,
    V7t,
    z7t,
    W7t,
    U7t,
    Zat,
    Jat = x(() => {
      'use strict'
      QA()
      fn()
      pe()
      Vt()
      Be()
      bn()
      ;(Qa = new Map()),
        (C8 = []),
        (_8 = new Map()),
        (Hat = 'color'),
        (Yat = 'fill'),
        (C7t = 'bgFill'),
        (Kat = ','),
        (w7t = K()),
        (lC = new Map()),
        (E7t = a((e) => Rt.sanitizeText(e, w7t), 'sanitizeText')),
        (v7t = a(function (e, t = '') {
          let r = lC.get(e)
          r || ((r = { id: e, styles: [], textStyles: [] }), lC.set(e, r)),
            t?.split(Kat).forEach((n) => {
              let i = n.replace(/([^;]*);/, '$1').trim()
              if (RegExp(Hat).exec(n)) {
                let o = i.replace(Yat, C7t).replace(Hat, Yat)
                r.textStyles.push(o)
              }
              r.styles.push(i)
            })
        }, 'addStyleClass')),
        (A7t = a(function (e, t = '') {
          let r = Qa.get(e)
          t != null && (r.styles = t.split(Kat))
        }, 'addStyle2Node')),
        (L7t = a(function (e, t) {
          e.split(',').forEach(function (r) {
            let n = Qa.get(r)
            if (n === void 0) {
              let i = r.trim()
              ;(n = { id: i, type: 'na', children: [] }), Qa.set(i, n)
            }
            n.classes || (n.classes = []), n.classes.push(t)
          })
        }, 'setCssClass')),
        (Qat = a((e, t) => {
          let r = e.flat(),
            n = [],
            s = r.find((o) => o?.type === 'column-setting')?.columns ?? -1
          for (let o of r) {
            if (
              (typeof s == 'number' &&
                s > 0 &&
                o.type !== 'column-setting' &&
                typeof o.widthInColumns == 'number' &&
                o.widthInColumns > s &&
                B.warn(`Block ${o.id} width ${o.widthInColumns} exceeds configured column width ${s}`),
              o.label && (o.label = E7t(o.label)),
              o.type === 'classDef')
            ) {
              v7t(o.id, o.css)
              continue
            }
            if (o.type === 'applyClass') {
              L7t(o.id, o?.styleClass ?? '')
              continue
            }
            if (o.type === 'applyStyles') {
              o?.stylesStr && A7t(o.id, o?.stylesStr)
              continue
            }
            if (o.type === 'column-setting') t.columns = o.columns ?? -1
            else if (o.type === 'edge') {
              let l = (_8.get(o.id) ?? 0) + 1
              _8.set(o.id, l), (o.id = l + '-' + o.id), C8.push(o)
            } else {
              o.label || (o.type === 'composite' ? (o.label = '') : (o.label = o.id))
              let l = Qa.get(o.id)
              if (
                (l === void 0
                  ? Qa.set(o.id, o)
                  : (o.type !== 'na' && (l.type = o.type), o.label !== o.id && (l.label = o.label)),
                o.children && Qat(o.children, o),
                o.type === 'space')
              ) {
                let u = o.width ?? 1
                for (let h = 0; h < u; h++) {
                  let f = Sr(o)
                  ;(f.id = f.id + '-' + h), Qa.set(f.id, f), n.push(f)
                }
              } else l === void 0 && n.push(o)
            }
          }
          t.children = n
        }, 'populateBlockDatabase')),
        (w8 = []),
        (Qy = { id: 'root', type: 'composite', children: [], columns: -1 }),
        (R7t = a(() => {
          B.debug('Clear called'),
            Ye(),
            (Qy = { id: 'root', type: 'composite', children: [], columns: -1 }),
            (Qa = new Map([['root', Qy]])),
            (w8 = []),
            (lC = new Map()),
            (C8 = []),
            (_8 = new Map())
        }, 'clear'))
      a(D7t, 'typeStr2Type')
      a(N7t, 'edgeTypeStr2Type')
      a(I7t, 'edgeStrToEdgeData')
      ;(Xat = 0),
        (M7t = a(() => (Xat++, 'id-' + Math.random().toString(36).substr(2, 12) + '-' + Xat), 'generateId')),
        (O7t = a((e) => {
          ;(Qy.children = e), Qat(e, Qy), (w8 = Qy.children)
        }, 'setHierarchy')),
        (P7t = a((e) => {
          let t = Qa.get(e)
          return t ? (t.columns ? t.columns : t.children ? t.children.length : -1) : -1
        }, 'getColumns')),
        (B7t = a(() => [...Qa.values()], 'getBlocksFlat')),
        (F7t = a(() => w8 || [], 'getBlocks')),
        ($7t = a(() => C8, 'getEdges')),
        (G7t = a((e) => Qa.get(e), 'getBlock')),
        (V7t = a((e) => {
          Qa.set(e.id, e)
        }, 'setBlock')),
        (z7t = a(() => B, 'getLogger')),
        (W7t = a(function () {
          return lC
        }, 'getClasses')),
        (U7t = {
          getConfig: a(() => Te().block, 'getConfig'),
          typeStr2Type: D7t,
          edgeTypeStr2Type: N7t,
          edgeStrToEdgeData: I7t,
          getLogger: z7t,
          getBlocksFlat: B7t,
          getBlocks: F7t,
          getEdges: $7t,
          setHierarchy: O7t,
          getBlock: G7t,
          setBlock: V7t,
          getColumns: P7t,
          getClasses: W7t,
          clear: R7t,
          generateId: M7t,
        }),
        (Zat = U7t)
    })
  var cC,
    j7t,
    tot,
    eot = x(() => {
      'use strict'
      js()
      Md()
      ;(cC = a((e, t) => {
        let r = gu,
          n = r(e, 'r'),
          i = r(e, 'g'),
          s = r(e, 'b')
        return Ni(n, i, s, t)
      }, 'fade')),
        (j7t = a(
          (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${cC(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${cC(e.mainBkg, 0.5)};
    fill: ${cC(e.clusterBkg, 0.5)};
    stroke: ${cC(e.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  ${No()}
`,
          'getStyles',
        )),
        (tot = j7t)
    })
  var q7t,
    H7t,
    Y7t,
    X7t,
    K7t,
    Q7t,
    Z7t,
    J7t,
    tIt,
    eIt,
    rIt,
    rot,
    not = x(() => {
      'use strict'
      Vt()
      ;(q7t = a((e, t, r, n) => {
        t.forEach((i) => {
          rIt[i](e, r, n)
        })
      }, 'insertMarkers')),
        (H7t = a((e, t, r) => {
          B.trace('Making markers for ', r),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-extensionStart')
              .attr('class', 'marker extension ' + t)
              .attr('refX', 18)
              .attr('refY', 7)
              .attr('markerWidth', 190)
              .attr('markerHeight', 240)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,7 L18,13 V 1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-extensionEnd')
              .attr('class', 'marker extension ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,1 V 13 L18,7 Z')
        }, 'extension')),
        (Y7t = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-compositionStart')
            .attr('class', 'marker composition ' + t)
            .attr('refX', 18)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-compositionEnd')
              .attr('class', 'marker composition ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z')
        }, 'composition')),
        (X7t = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-aggregationStart')
            .attr('class', 'marker aggregation ' + t)
            .attr('refX', 18)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-aggregationEnd')
              .attr('class', 'marker aggregation ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z')
        }, 'aggregation')),
        (K7t = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-dependencyStart')
            .attr('class', 'marker dependency ' + t)
            .attr('refX', 6)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 5,7 L9,13 L1,7 L9,1 Z'),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-dependencyEnd')
              .attr('class', 'marker dependency ' + t)
              .attr('refX', 13)
              .attr('refY', 7)
              .attr('markerWidth', 20)
              .attr('markerHeight', 28)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z')
        }, 'dependency')),
        (Q7t = a((e, t, r) => {
          e
            .append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-lollipopStart')
            .attr('class', 'marker lollipop ' + t)
            .attr('refX', 13)
            .attr('refY', 7)
            .attr('markerWidth', 190)
            .attr('markerHeight', 240)
            .attr('orient', 'auto')
            .append('circle')
            .attr('stroke', 'black')
            .attr('fill', 'transparent')
            .attr('cx', 7)
            .attr('cy', 7)
            .attr('r', 6),
            e
              .append('defs')
              .append('marker')
              .attr('id', r + '_' + t + '-lollipopEnd')
              .attr('class', 'marker lollipop ' + t)
              .attr('refX', 1)
              .attr('refY', 7)
              .attr('markerWidth', 190)
              .attr('markerHeight', 240)
              .attr('orient', 'auto')
              .append('circle')
              .attr('stroke', 'black')
              .attr('fill', 'transparent')
              .attr('cx', 7)
              .attr('cy', 7)
              .attr('r', 6)
        }, 'lollipop')),
        (Z7t = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-pointEnd')
            .attr('class', 'marker ' + t)
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 6)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 12)
            .attr('markerHeight', 12)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-pointStart')
              .attr('class', 'marker ' + t)
              .attr('viewBox', '0 0 10 10')
              .attr('refX', 4.5)
              .attr('refY', 5)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 12)
              .attr('markerHeight', 12)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 0 5 L 10 10 L 10 0 z')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 1)
              .style('stroke-dasharray', '1,0')
        }, 'point')),
        (J7t = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-circleEnd')
            .attr('class', 'marker ' + t)
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 11)
            .attr('refY', 5)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 11)
            .attr('markerHeight', 11)
            .attr('orient', 'auto')
            .append('circle')
            .attr('cx', '5')
            .attr('cy', '5')
            .attr('r', '5')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 1)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-circleStart')
              .attr('class', 'marker ' + t)
              .attr('viewBox', '0 0 10 10')
              .attr('refX', -1)
              .attr('refY', 5)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 11)
              .attr('markerHeight', 11)
              .attr('orient', 'auto')
              .append('circle')
              .attr('cx', '5')
              .attr('cy', '5')
              .attr('r', '5')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 1)
              .style('stroke-dasharray', '1,0')
        }, 'circle')),
        (tIt = a((e, t, r) => {
          e
            .append('marker')
            .attr('id', r + '_' + t + '-crossEnd')
            .attr('class', 'marker cross ' + t)
            .attr('viewBox', '0 0 11 11')
            .attr('refX', 12)
            .attr('refY', 5.2)
            .attr('markerUnits', 'userSpaceOnUse')
            .attr('markerWidth', 11)
            .attr('markerHeight', 11)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
            .attr('class', 'arrowMarkerPath')
            .style('stroke-width', 2)
            .style('stroke-dasharray', '1,0'),
            e
              .append('marker')
              .attr('id', r + '_' + t + '-crossStart')
              .attr('class', 'marker cross ' + t)
              .attr('viewBox', '0 0 11 11')
              .attr('refX', -1)
              .attr('refY', 5.2)
              .attr('markerUnits', 'userSpaceOnUse')
              .attr('markerWidth', 11)
              .attr('markerHeight', 11)
              .attr('orient', 'auto')
              .append('path')
              .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
              .attr('class', 'arrowMarkerPath')
              .style('stroke-width', 2)
              .style('stroke-dasharray', '1,0')
        }, 'cross')),
        (eIt = a((e, t, r) => {
          e.append('defs')
            .append('marker')
            .attr('id', r + '_' + t + '-barbEnd')
            .attr('refX', 19)
            .attr('refY', 7)
            .attr('markerWidth', 20)
            .attr('markerHeight', 14)
            .attr('markerUnits', 'strokeWidth')
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z')
        }, 'barb')),
        (rIt = {
          extension: H7t,
          composition: Y7t,
          aggregation: X7t,
          dependency: K7t,
          lollipop: Q7t,
          point: Z7t,
          circle: J7t,
          cross: tIt,
          barb: eIt,
        }),
        (rot = q7t)
    })
  function nIt(e, t) {
    if (e === 0 || !Number.isInteger(e)) throw new Error('Columns must be an integer !== 0.')
    if (t < 0 || !Number.isInteger(t)) throw new Error('Position must be a non-negative integer.' + t)
    if (e < 0) return { px: t, py: 0 }
    if (e === 1) return { px: 0, py: t }
    let r = t % e,
      n = Math.floor(t / e)
    return { px: r, py: n }
  }
  function E8(e, t, r = 0, n = 0) {
    B.debug('setBlockSizes abc95 (start)', e.id, e?.size?.x, 'block width =', e?.size, 'siblingWidth', r),
      e?.size?.width || (e.size = { width: r, height: n, x: 0, y: 0 })
    let i = 0,
      s = 0
    if (e.children?.length > 0) {
      for (let m of e.children) E8(m, t)
      let o = iIt(e)
      ;(i = o.width), (s = o.height), B.debug('setBlockSizes abc95 maxWidth of', e.id, ':s children is ', i, s)
      for (let m of e.children)
        m.size &&
          (B.debug(`abc95 Setting size of children of ${e.id} id=${m.id} ${i} ${s} ${JSON.stringify(m.size)}`),
          (m.size.width = i * (m.widthInColumns ?? 1) + _n * ((m.widthInColumns ?? 1) - 1)),
          (m.size.height = s),
          (m.size.x = 0),
          (m.size.y = 0),
          B.debug(`abc95 updating size of ${e.id} children child:${m.id} maxWidth:${i} maxHeight:${s}`))
      for (let m of e.children) E8(m, t, i, s)
      let l = e.columns ?? -1,
        u = 0
      for (let m of e.children) u += m.widthInColumns ?? 1
      let h = e.children.length
      l > 0 && l < u && (h = l)
      let f = Math.ceil(u / h),
        d = h * (i + _n) + _n,
        p = f * (s + _n) + _n
      if (d < r) {
        B.debug(`Detected to small sibling: abc95 ${e.id} siblingWidth ${r} siblingHeight ${n} width ${d}`),
          (d = r),
          (p = n)
        let m = (r - h * _n - _n) / h,
          g = (n - f * _n - _n) / f
        B.debug('Size indata abc88', e.id, 'childWidth', m, 'maxWidth', i),
          B.debug('Size indata abc88', e.id, 'childHeight', g, 'maxHeight', s),
          B.debug('Size indata abc88 xSize', h, 'padding', _n)
        for (let y of e.children) y.size && ((y.size.width = m), (y.size.height = g), (y.size.x = 0), (y.size.y = 0))
      }
      if (
        (B.debug(
          `abc95 (finale calc) ${e.id} xSize ${h} ySize ${f} columns ${l}${e.children.length} width=${Math.max(d, e.size?.width || 0)}`,
        ),
        d < (e?.size?.width || 0))
      ) {
        d = e?.size?.width || 0
        let m = l > 0 ? Math.min(e.children.length, l) : e.children.length
        if (m > 0) {
          let g = (d - m * _n - _n) / m
          B.debug('abc95 (growing to fit) width', e.id, d, e.size?.width, g)
          for (let y of e.children) y.size && (y.size.width = g)
        }
      }
      e.size = { width: d, height: p, x: 0, y: 0 }
    }
    B.debug('setBlockSizes abc94 (done)', e.id, e?.size?.x, e?.size?.width, e?.size?.y, e?.size?.height)
  }
  function iot(e, t) {
    B.debug(`abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`)
    let r = e.columns ?? -1
    if ((B.debug('layoutBlocks columns abc95', e.id, '=>', r, e), e.children && e.children.length > 0)) {
      let n = e?.children[0]?.size?.width ?? 0,
        i = e.children.length * n + (e.children.length - 1) * _n
      B.debug('widthOfChildren 88', i, 'posX')
      let s = 0
      B.debug('abc91 block?.size?.x', e.id, e?.size?.x)
      let o = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -_n,
        l = 0
      for (let u of e.children) {
        let h = e
        if (!u.size) continue
        let { width: f, height: d } = u.size,
          { px: p, py: m } = nIt(r, s)
        if (
          (m != l &&
            ((l = m),
            (o = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -_n),
            B.debug('New row in layout for block', e.id, ' and child ', u.id, l)),
          B.debug(
            `abc89 layout blocks (child) id: ${u.id} Pos: ${s} (px, py) ${p},${m} (${h?.size?.x},${h?.size?.y}) parent: ${h.id} width: ${f}${_n}`,
          ),
          h.size)
        ) {
          let y = f / 2
          ;(u.size.x = o + _n + y),
            B.debug(
              `abc91 layout blocks (calc) px, pyid:${u.id} startingPos=X${o} new startingPosX${u.size.x} ${y} padding=${_n} width=${f} halfWidth=${y} => x:${u.size.x} y:${u.size.y} ${u.widthInColumns} (width * (child?.w || 1)) / 2 ${(f * (u?.widthInColumns ?? 1)) / 2}`,
            ),
            (o = u.size.x + y),
            (u.size.y = h.size.y - h.size.height / 2 + m * (d + _n) + d / 2 + _n),
            B.debug(
              `abc88 layout blocks (calc) px, pyid:${u.id}startingPosX${o}${_n}${y}=>x:${u.size.x}y:${u.size.y}${u.widthInColumns}(width * (child?.w || 1)) / 2${(f * (u?.widthInColumns ?? 1)) / 2}`,
            )
        }
        u.children && iot(u, t)
        let g = u?.widthInColumns ?? 1
        r > 0 && (g = Math.min(g, r - (s % r))), (s += g), B.debug('abc88 columnsPos', u, s)
      }
    }
    B.debug(`layout blocks (<==layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`)
  }
  function sot(e, { minX: t, minY: r, maxX: n, maxY: i } = { minX: 0, minY: 0, maxX: 0, maxY: 0 }) {
    if (e.size && e.id !== 'root') {
      let { x: s, y: o, width: l, height: u } = e.size
      s - l / 2 < t && (t = s - l / 2),
        o - u / 2 < r && (r = o - u / 2),
        s + l / 2 > n && (n = s + l / 2),
        o + u / 2 > i && (i = o + u / 2)
    }
    if (e.children)
      for (let s of e.children)
        ({ minX: t, minY: r, maxX: n, maxY: i } = sot(s, { minX: t, minY: r, maxX: n, maxY: i }))
    return { minX: t, minY: r, maxX: n, maxY: i }
  }
  function aot(e) {
    let t = e.getBlock('root')
    if (!t) return
    E8(t, e, 0, 0), iot(t, e), B.debug('getBlocks', JSON.stringify(t, null, 2))
    let { minX: r, minY: n, maxX: i, maxY: s } = sot(t),
      o = s - n,
      l = i - r
    return { x: r, y: n, width: l, height: o }
  }
  var _n,
    iIt,
    oot = x(() => {
      'use strict'
      Vt()
      pe()
      _n = K()?.block?.padding ?? 8
      a(nIt, 'calculateBlockPosition')
      iIt = a((e) => {
        let t = 0,
          r = 0
        for (let n of e.children) {
          let { width: i, height: s, x: o, y: l } = n.size ?? { width: 0, height: 0, x: 0, y: 0 }
          B.debug('getMaxChildSize abc95 child:', n.id, 'width:', i, 'height:', s, 'x:', o, 'y:', l, n.type),
            n.type !== 'space' && (i > t && (t = i / (e.widthInColumns ?? 1)), s > r && (r = s))
        }
        return { width: t, height: r }
      }, 'getMaxChildSize')
      a(E8, 'setBlockSizes')
      a(iot, 'layoutBlocks')
      a(sot, 'findBounds')
      a(aot, 'layout')
    })
  function lot(e, t) {
    t && e.attr('style', t)
  }
  function sIt(e, t) {
    let r = xt(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')),
      n = r.append('xhtml:div'),
      i = e.label,
      s = e.isNode ? 'nodeLabel' : 'edgeLabel',
      o = n.append('span')
    return (
      o.html(Ie(i, t)),
      lot(o, e.labelStyle),
      o.attr('class', s),
      lot(n, e.labelStyle),
      n.style('display', 'inline-block'),
      n.style('white-space', 'nowrap'),
      n.attr('xmlns', 'http://www.w3.org/1999/xhtml'),
      r.node()
    )
  }
  var aIt,
    Ji,
    uC = x(() => {
      'use strict'
      Ge()
      pe()
      Be()
      Vt()
      $a()
      Ce()
      a(lot, 'applyStyle')
      a(sIt, 'addHtmlLabel')
      ;(aIt = a(async (e, t, r, n) => {
        let i = e || ''
        typeof i == 'object' && (i = i[0])
        let s = K()
        if (Pe(s.flowchart.htmlLabels)) {
          ;(i = i.replace(/\\n|\n/g, '<br />')), B.debug('vertexText' + i)
          let o = await cA(Xn(i)),
            l = { isNode: n, label: o, labelStyle: t.replace('fill:', 'color:') }
          return sIt(l, s)
        } else {
          let o = document.createElementNS('http://www.w3.org/2000/svg', 'text')
          o.setAttribute('style', t.replace('color:', 'fill:'))
          let l = []
          typeof i == 'string' ? (l = i.split(/\\n|\n|<br\s*\/?>/gi)) : Array.isArray(i) ? (l = i) : (l = [])
          for (let u of l) {
            let h = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
            h.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'),
              h.setAttribute('dy', '1em'),
              h.setAttribute('x', '0'),
              r ? h.setAttribute('class', 'title-row') : h.setAttribute('class', 'row'),
              (h.textContent = u.trim()),
              o.appendChild(h)
          }
          return o
        }
      }, 'createLabel')),
        (Ji = aIt)
    })
  var uot,
    oIt,
    cot,
    hot = x(() => {
      'use strict'
      Vt()
      ;(uot = a((e, t, r, n, i) => {
        t.arrowTypeStart && cot(e, 'start', t.arrowTypeStart, r, n, i),
          t.arrowTypeEnd && cot(e, 'end', t.arrowTypeEnd, r, n, i)
      }, 'addEdgeMarkers')),
        (oIt = {
          arrow_cross: 'cross',
          arrow_point: 'point',
          arrow_barb: 'barb',
          arrow_circle: 'circle',
          aggregation: 'aggregation',
          extension: 'extension',
          composition: 'composition',
          dependency: 'dependency',
          lollipop: 'lollipop',
        }),
        (cot = a((e, t, r, n, i, s) => {
          let o = oIt[r]
          if (!o) {
            B.warn(`Unknown arrow type: ${r}`)
            return
          }
          let l = t === 'start' ? 'Start' : 'End'
          e.attr(`marker-${t}`, `url(${n}#${i}_${s}-${o}${l})`)
        }, 'addEdgeMarker'))
    })
  function hC(e, t) {
    K().flowchart.htmlLabels && e && ((e.style.width = t.length * 9 + 'px'), (e.style.height = '12px'))
  }
  var v8,
    Li,
    dot,
    pot,
    lIt,
    cIt,
    fot,
    mot,
    got = x(() => {
      'use strict'
      Vt()
      uC()
      $a()
      Ge()
      pe()
      Ce()
      Be()
      MA()
      $0()
      hot()
      ;(v8 = {}),
        (Li = {}),
        (dot = a(async (e, t) => {
          let r = K(),
            n = Pe(r.flowchart.htmlLabels),
            i =
              t.labelType === 'markdown'
                ? Kn(e, t.label, { style: t.labelStyle, useHtmlLabels: n, addSvgBackground: !0 }, r)
                : await Ji(t.label, t.labelStyle),
            s = e.insert('g').attr('class', 'edgeLabel'),
            o = s.insert('g').attr('class', 'label')
          o.node().appendChild(i)
          let l = i.getBBox()
          if (n) {
            let h = i.children[0],
              f = xt(i)
            ;(l = h.getBoundingClientRect()), f.attr('width', l.width), f.attr('height', l.height)
          }
          o.attr('transform', 'translate(' + -l.width / 2 + ', ' + -l.height / 2 + ')'),
            (v8[t.id] = s),
            (t.width = l.width),
            (t.height = l.height)
          let u
          if (t.startLabelLeft) {
            let h = await Ji(t.startLabelLeft, t.labelStyle),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              Li[t.id] || (Li[t.id] = {}),
              (Li[t.id].startLeft = f),
              hC(u, t.startLabelLeft)
          }
          if (t.startLabelRight) {
            let h = await Ji(t.startLabelRight, t.labelStyle),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            ;(u = f.node().appendChild(h)), d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              Li[t.id] || (Li[t.id] = {}),
              (Li[t.id].startRight = f),
              hC(u, t.startLabelRight)
          }
          if (t.endLabelLeft) {
            let h = await Ji(t.endLabelLeft, t.labelStyle),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              f.node().appendChild(h),
              Li[t.id] || (Li[t.id] = {}),
              (Li[t.id].endLeft = f),
              hC(u, t.endLabelLeft)
          }
          if (t.endLabelRight) {
            let h = await Ji(t.endLabelRight, t.labelStyle),
              f = e.insert('g').attr('class', 'edgeTerminals'),
              d = f.insert('g').attr('class', 'inner')
            u = d.node().appendChild(h)
            let p = h.getBBox()
            d.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
              f.node().appendChild(h),
              Li[t.id] || (Li[t.id] = {}),
              (Li[t.id].endRight = f),
              hC(u, t.endLabelRight)
          }
          return i
        }, 'insertEdgeLabel'))
      a(hC, 'setTerminalWidth')
      ;(pot = a((e, t) => {
        B.debug('Moving label abc88 ', e.id, e.label, v8[e.id], t)
        let r = t.updatedPath ? t.updatedPath : t.originalPath,
          n = K(),
          { subGraphTitleTotalMargin: i } = kl(n)
        if (e.label) {
          let s = v8[e.id],
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcLabelPosition(r)
            B.debug('Moving label ' + e.label + ' from (', o, ',', l, ') to (', u.x, ',', u.y, ') abc88'),
              t.updatedPath && ((o = u.x), (l = u.y))
          }
          s.attr('transform', `translate(${o}, ${l + i / 2})`)
        }
        if (e.startLabelLeft) {
          let s = Li[e.id].startLeft,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_left', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.startLabelRight) {
          let s = Li[e.id].startRight,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_right', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.endLabelLeft) {
          let s = Li[e.id].endLeft,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_left', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
        if (e.endLabelRight) {
          let s = Li[e.id].endRight,
            o = e.x,
            l = e.y
          if (r) {
            let u = le.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_right', r)
            ;(o = u.x), (l = u.y)
          }
          s.attr('transform', `translate(${o}, ${l})`)
        }
      }, 'positionEdgeLabel')),
        (lIt = a((e, t) => {
          let r = e.x,
            n = e.y,
            i = Math.abs(t.x - r),
            s = Math.abs(t.y - n),
            o = e.width / 2,
            l = e.height / 2
          return i >= o || s >= l
        }, 'outsideNode')),
        (cIt = a((e, t, r) => {
          B.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`)
          let n = e.x,
            i = e.y,
            s = Math.abs(n - r.x),
            o = e.width / 2,
            l = r.x < t.x ? o - s : o + s,
            u = e.height / 2,
            h = Math.abs(t.y - r.y),
            f = Math.abs(t.x - r.x)
          if (Math.abs(i - t.y) * o > Math.abs(n - t.x) * u) {
            let d = r.y < t.y ? t.y - u - i : i - u - t.y
            l = (f * d) / h
            let p = { x: r.x < t.x ? r.x + l : r.x - f + l, y: r.y < t.y ? r.y + h - d : r.y - h + d }
            return (
              l === 0 && ((p.x = t.x), (p.y = t.y)),
              f === 0 && (p.x = t.x),
              h === 0 && (p.y = t.y),
              B.debug(`abc89 topp/bott calc, Q ${h}, q ${d}, R ${f}, r ${l}`, p),
              p
            )
          } else {
            r.x < t.x ? (l = t.x - o - n) : (l = n - o - t.x)
            let d = (h * l) / f,
              p = r.x < t.x ? r.x + f - l : r.x - f + l,
              m = r.y < t.y ? r.y + d : r.y - d
            return (
              B.debug(`sides calc abc89, Q ${h}, q ${d}, R ${f}, r ${l}`, { _x: p, _y: m }),
              l === 0 && ((p = t.x), (m = t.y)),
              f === 0 && (p = t.x),
              h === 0 && (m = t.y),
              { x: p, y: m }
            )
          }
        }, 'intersection')),
        (fot = a((e, t) => {
          B.debug('abc88 cutPathAtIntersect', e, t)
          let r = [],
            n = e[0],
            i = !1
          return (
            e.forEach((s) => {
              if (!lIt(t, s) && !i) {
                let o = cIt(t, n, s),
                  l = !1
                r.forEach((u) => {
                  l = l || (u.x === o.x && u.y === o.y)
                }),
                  r.some((u) => u.x === o.x && u.y === o.y) || r.push(o),
                  (i = !0)
              } else (n = s), i || r.push(s)
            }),
            r
          )
        }, 'cutPathAtIntersect')),
        (mot = a(function (e, t, r, n, i, s, o) {
          let l = r.points
          B.debug('abc88 InsertEdge: edge=', r, 'e=', t)
          let u = !1,
            h = s.node(t.v)
          var f = s.node(t.w)
          f?.intersect &&
            h?.intersect &&
            ((l = l.slice(1, r.points.length - 1)), l.unshift(h.intersect(l[0])), l.push(f.intersect(l[l.length - 1]))),
            r.toCluster &&
              (B.debug('to cluster abc88', n[r.toCluster]), (l = fot(r.points, n[r.toCluster].node)), (u = !0)),
            r.fromCluster &&
              (B.debug('from cluster abc88', n[r.fromCluster]),
              (l = fot(l.reverse(), n[r.fromCluster].node).reverse()),
              (u = !0))
          let d = l.filter((A) => !Number.isNaN(A.y)),
            p = Xs
          r.curve && (i === 'graph' || i === 'flowchart') && (p = r.curve)
          let { x: m, y: g } = Xb(r),
            y = Ma().x(m).y(g).curve(p),
            b
          switch (r.thickness) {
            case 'normal':
              b = 'edge-thickness-normal'
              break
            case 'thick':
              b = 'edge-thickness-thick'
              break
            case 'invisible':
              b = 'edge-thickness-thick'
              break
            default:
              b = ''
          }
          switch (r.pattern) {
            case 'solid':
              b += ' edge-pattern-solid'
              break
            case 'dotted':
              b += ' edge-pattern-dotted'
              break
            case 'dashed':
              b += ' edge-pattern-dashed'
              break
          }
          let k = e
              .append('path')
              .attr('d', y(d))
              .attr('id', r.id)
              .attr('class', ' ' + b + (r.classes ? ' ' + r.classes : ''))
              .attr('style', r.style),
            T = ''
          ;(K().flowchart.arrowMarkerAbsolute || K().state.arrowMarkerAbsolute) && (T = yu(!0)), uot(k, r, T, o, i)
          let C = {}
          return u && (C.updatedPath = l), (C.originalPath = r.points), C
        }, 'insertEdge'))
    })
  var uIt,
    yot,
    xot = x(() => {
      'use strict'
      ;(uIt = a((e) => {
        let t = new Set()
        for (let r of e)
          switch (r) {
            case 'x':
              t.add('right'), t.add('left')
              break
            case 'y':
              t.add('up'), t.add('down')
              break
            default:
              t.add(r)
              break
          }
        return t
      }, 'expandAndDeduplicateDirections')),
        (yot = a((e, t, r) => {
          let n = uIt(e),
            i = 2,
            s = t.height + 2 * r.padding,
            o = s / i,
            l = t.width + 2 * o + r.padding,
            u = r.padding / 2
          return n.has('right') && n.has('left') && n.has('up') && n.has('down')
            ? [
                { x: 0, y: 0 },
                { x: o, y: 0 },
                { x: l / 2, y: 2 * u },
                { x: l - o, y: 0 },
                { x: l, y: 0 },
                { x: l, y: -s / 3 },
                { x: l + 2 * u, y: -s / 2 },
                { x: l, y: (-2 * s) / 3 },
                { x: l, y: -s },
                { x: l - o, y: -s },
                { x: l / 2, y: -s - 2 * u },
                { x: o, y: -s },
                { x: 0, y: -s },
                { x: 0, y: (-2 * s) / 3 },
                { x: -2 * u, y: -s / 2 },
                { x: 0, y: -s / 3 },
              ]
            : n.has('right') && n.has('left') && n.has('up')
              ? [
                  { x: o, y: 0 },
                  { x: l - o, y: 0 },
                  { x: l, y: -s / 2 },
                  { x: l - o, y: -s },
                  { x: o, y: -s },
                  { x: 0, y: -s / 2 },
                ]
              : n.has('right') && n.has('left') && n.has('down')
                ? [
                    { x: 0, y: 0 },
                    { x: o, y: -s },
                    { x: l - o, y: -s },
                    { x: l, y: 0 },
                  ]
                : n.has('right') && n.has('up') && n.has('down')
                  ? [
                      { x: 0, y: 0 },
                      { x: l, y: -o },
                      { x: l, y: -s + o },
                      { x: 0, y: -s },
                    ]
                  : n.has('left') && n.has('up') && n.has('down')
                    ? [
                        { x: l, y: 0 },
                        { x: 0, y: -o },
                        { x: 0, y: -s + o },
                        { x: l, y: -s },
                      ]
                    : n.has('right') && n.has('left')
                      ? [
                          { x: o, y: 0 },
                          { x: o, y: -u },
                          { x: l - o, y: -u },
                          { x: l - o, y: 0 },
                          { x: l, y: -s / 2 },
                          { x: l - o, y: -s },
                          { x: l - o, y: -s + u },
                          { x: o, y: -s + u },
                          { x: o, y: -s },
                          { x: 0, y: -s / 2 },
                        ]
                      : n.has('up') && n.has('down')
                        ? [
                            { x: l / 2, y: 0 },
                            { x: 0, y: -u },
                            { x: o, y: -u },
                            { x: o, y: -s + u },
                            { x: 0, y: -s + u },
                            { x: l / 2, y: -s },
                            { x: l, y: -s + u },
                            { x: l - o, y: -s + u },
                            { x: l - o, y: -u },
                            { x: l, y: -u },
                          ]
                        : n.has('right') && n.has('up')
                          ? [
                              { x: 0, y: 0 },
                              { x: l, y: -o },
                              { x: 0, y: -s },
                            ]
                          : n.has('right') && n.has('down')
                            ? [
                                { x: 0, y: 0 },
                                { x: l, y: 0 },
                                { x: 0, y: -s },
                              ]
                            : n.has('left') && n.has('up')
                              ? [
                                  { x: l, y: 0 },
                                  { x: 0, y: -o },
                                  { x: l, y: -s },
                                ]
                              : n.has('left') && n.has('down')
                                ? [
                                    { x: l, y: 0 },
                                    { x: 0, y: 0 },
                                    { x: l, y: -s },
                                  ]
                                : n.has('right')
                                  ? [
                                      { x: o, y: -u },
                                      { x: o, y: -u },
                                      { x: l - o, y: -u },
                                      { x: l - o, y: 0 },
                                      { x: l, y: -s / 2 },
                                      { x: l - o, y: -s },
                                      { x: l - o, y: -s + u },
                                      { x: o, y: -s + u },
                                      { x: o, y: -s + u },
                                    ]
                                  : n.has('left')
                                    ? [
                                        { x: o, y: 0 },
                                        { x: o, y: -u },
                                        { x: l - o, y: -u },
                                        { x: l - o, y: -s + u },
                                        { x: o, y: -s + u },
                                        { x: o, y: -s },
                                        { x: 0, y: -s / 2 },
                                      ]
                                    : n.has('up')
                                      ? [
                                          { x: o, y: -u },
                                          { x: o, y: -s + u },
                                          { x: 0, y: -s + u },
                                          { x: l / 2, y: -s },
                                          { x: l, y: -s + u },
                                          { x: l - o, y: -s + u },
                                          { x: l - o, y: -u },
                                        ]
                                      : n.has('down')
                                        ? [
                                            { x: l / 2, y: 0 },
                                            { x: 0, y: -u },
                                            { x: o, y: -u },
                                            { x: o, y: -s + u },
                                            { x: l - o, y: -s + u },
                                            { x: l - o, y: -u },
                                            { x: l, y: -u },
                                          ]
                                        : [{ x: 0, y: 0 }]
        }, 'getArrowPoints'))
    })
  function hIt(e, t) {
    return e.intersect(t)
  }
  var bot,
    kot = x(() => {
      'use strict'
      a(hIt, 'intersectNode')
      bot = hIt
    })
  function fIt(e, t, r, n) {
    var i = e.x,
      s = e.y,
      o = i - n.x,
      l = s - n.y,
      u = Math.sqrt(t * t * l * l + r * r * o * o),
      h = Math.abs((t * r * o) / u)
    n.x < i && (h = -h)
    var f = Math.abs((t * r * l) / u)
    return n.y < s && (f = -f), { x: i + h, y: s + f }
  }
  var fC,
    A8 = x(() => {
      'use strict'
      a(fIt, 'intersectEllipse')
      fC = fIt
    })
  function dIt(e, t, r) {
    return fC(e, t, t, r)
  }
  var Tot,
    Sot = x(() => {
      'use strict'
      A8()
      a(dIt, 'intersectCircle')
      Tot = dIt
    })
  function pIt(e, t, r, n) {
    var i, s, o, l, u, h, f, d, p, m, g, y, b, k, T
    if (
      ((i = t.y - e.y),
      (o = e.x - t.x),
      (u = t.x * e.y - e.x * t.y),
      (p = i * r.x + o * r.y + u),
      (m = i * n.x + o * n.y + u),
      !(p !== 0 && m !== 0 && _ot(p, m)) &&
        ((s = n.y - r.y),
        (l = r.x - n.x),
        (h = n.x * r.y - r.x * n.y),
        (f = s * e.x + l * e.y + h),
        (d = s * t.x + l * t.y + h),
        !(f !== 0 && d !== 0 && _ot(f, d)) && ((g = i * l - s * o), g !== 0)))
    )
      return (
        (y = Math.abs(g / 2)),
        (b = o * h - l * u),
        (k = b < 0 ? (b - y) / g : (b + y) / g),
        (b = s * u - i * h),
        (T = b < 0 ? (b - y) / g : (b + y) / g),
        { x: k, y: T }
      )
  }
  function _ot(e, t) {
    return e * t > 0
  }
  var Cot,
    wot = x(() => {
      'use strict'
      a(pIt, 'intersectLine')
      a(_ot, 'sameSign')
      Cot = pIt
    })
  function mIt(e, t, r) {
    var n = e.x,
      i = e.y,
      s = [],
      o = Number.POSITIVE_INFINITY,
      l = Number.POSITIVE_INFINITY
    typeof t.forEach == 'function'
      ? t.forEach(function (g) {
          ;(o = Math.min(o, g.x)), (l = Math.min(l, g.y))
        })
      : ((o = Math.min(o, t.x)), (l = Math.min(l, t.y)))
    for (var u = n - e.width / 2 - o, h = i - e.height / 2 - l, f = 0; f < t.length; f++) {
      var d = t[f],
        p = t[f < t.length - 1 ? f + 1 : 0],
        m = Cot(e, r, { x: u + d.x, y: h + d.y }, { x: u + p.x, y: h + p.y })
      m && s.push(m)
    }
    return s.length
      ? (s.length > 1 &&
          s.sort(function (g, y) {
            var b = g.x - r.x,
              k = g.y - r.y,
              T = Math.sqrt(b * b + k * k),
              C = y.x - r.x,
              A = y.y - r.y,
              w = Math.sqrt(C * C + A * A)
            return T < w ? -1 : T === w ? 0 : 1
          }),
        s[0])
      : e
  }
  var Eot,
    vot = x(() => {
      'use strict'
      wot()
      Eot = mIt
      a(mIt, 'intersectPolygon')
    })
  var gIt,
    Aot,
    Lot = x(() => {
      'use strict'
      ;(gIt = a((e, t) => {
        var r = e.x,
          n = e.y,
          i = t.x - r,
          s = t.y - n,
          o = e.width / 2,
          l = e.height / 2,
          u,
          h
        return (
          Math.abs(s) * o > Math.abs(i) * l
            ? (s < 0 && (l = -l), (u = s === 0 ? 0 : (l * i) / s), (h = l))
            : (i < 0 && (o = -o), (u = o), (h = i === 0 ? 0 : (o * s) / i)),
          { x: r + u, y: n + h }
        )
      }, 'intersectRect')),
        (Aot = gIt)
    })
  var Ur,
    L8 = x(() => {
      'use strict'
      kot()
      Sot()
      A8()
      vot()
      Lot()
      Ur = { node: bot, circle: Tot, ellipse: fC, polygon: Eot, rect: Aot }
    })
  function Za(e, t, r, n) {
    return e
      .insert('polygon', ':first-child')
      .attr(
        'points',
        n
          .map(function (i) {
            return i.x + ',' + i.y
          })
          .join(' '),
      )
      .attr('class', 'label-container')
      .attr('transform', 'translate(' + -t / 2 + ',' + r / 2 + ')')
  }
  var Rn,
    sn,
    R8 = x(() => {
      'use strict'
      uC()
      $a()
      pe()
      Ge()
      Be()
      Ce()
      ;(Rn = a(async (e, t, r, n) => {
        let i = K(),
          s,
          o = t.useHtmlLabels || Pe(i.flowchart.htmlLabels)
        r ? (s = r) : (s = 'node default')
        let l = e
            .insert('g')
            .attr('class', s)
            .attr('id', t.domId || t.id),
          u = l.insert('g').attr('class', 'label').attr('style', t.labelStyle),
          h
        t.labelText === void 0 ? (h = '') : (h = typeof t.labelText == 'string' ? t.labelText : t.labelText[0])
        let f = u.node(),
          d
        t.labelType === 'markdown'
          ? (d = Kn(
              u,
              Ie(Xn(h), i),
              { useHtmlLabels: o, width: t.width || i.flowchart.wrappingWidth, classes: 'markdown-node-label' },
              i,
            ))
          : (d = f.appendChild(await Ji(Ie(Xn(h), i), t.labelStyle, !1, n)))
        let p = d.getBBox(),
          m = t.padding / 2
        if (Pe(i.flowchart.htmlLabels)) {
          let g = d.children[0],
            y = xt(d),
            b = g.getElementsByTagName('img')
          if (b) {
            let k = h.replace(/<img[^>]*>/g, '').trim() === ''
            await Promise.all(
              [...b].map(
                (T) =>
                  new Promise((C) => {
                    function A() {
                      if (((T.style.display = 'flex'), (T.style.flexDirection = 'column'), k)) {
                        let w = i.fontSize ? i.fontSize : window.getComputedStyle(document.body).fontSize,
                          G = parseInt(w, 10) * 5 + 'px'
                        ;(T.style.minWidth = G), (T.style.maxWidth = G)
                      } else T.style.width = '100%'
                      C(T)
                    }
                    a(A, 'setupImage'),
                      setTimeout(() => {
                        T.complete && A()
                      }),
                      T.addEventListener('error', A),
                      T.addEventListener('load', A)
                  }),
              ),
            )
          }
          ;(p = g.getBoundingClientRect()), y.attr('width', p.width), y.attr('height', p.height)
        }
        return (
          o
            ? u.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')')
            : u.attr('transform', 'translate(0, ' + -p.height / 2 + ')'),
          t.centerLabel && u.attr('transform', 'translate(' + -p.width / 2 + ', ' + -p.height / 2 + ')'),
          u.insert('rect', ':first-child'),
          { shapeSvg: l, bbox: p, halfPadding: m, label: u }
        )
      }, 'labelHelper')),
        (sn = a((e, t) => {
          let r = t.node().getBBox()
          ;(e.width = r.width), (e.height = r.height)
        }, 'updateNodeBounds'))
      a(Za, 'insertPolygonShape')
    })
  var yIt,
    Rot,
    Dot = x(() => {
      'use strict'
      R8()
      Vt()
      pe()
      L8()
      ;(yIt = a(async (e, t) => {
        t.useHtmlLabels || K().flowchart.htmlLabels || (t.centerLabel = !0)
        let { shapeSvg: n, bbox: i, halfPadding: s } = await Rn(e, t, 'node ' + t.classes, !0)
        B.info('Classes = ', t.classes)
        let o = n.insert('rect', ':first-child')
        return (
          o
            .attr('rx', t.rx)
            .attr('ry', t.ry)
            .attr('x', -i.width / 2 - s)
            .attr('y', -i.height / 2 - s)
            .attr('width', i.width + t.padding)
            .attr('height', i.height + t.padding),
          sn(t, o),
          (t.intersect = function (l) {
            return Ur.rect(t, l)
          }),
          n
        )
      }, 'note')),
        (Rot = yIt)
    })
  function D8(e, t, r, n) {
    let i = [],
      s = a((l) => {
        i.push(l, 0)
      }, 'addBorder'),
      o = a((l) => {
        i.push(0, l)
      }, 'skipBorder')
    t.includes('t') ? (B.debug('add top border'), s(r)) : o(r),
      t.includes('r') ? (B.debug('add right border'), s(n)) : o(n),
      t.includes('b') ? (B.debug('add bottom border'), s(r)) : o(r),
      t.includes('l') ? (B.debug('add left border'), s(n)) : o(n),
      e.attr('stroke-dasharray', i.join(' '))
  }
  var Not,
    Vs,
    Iot,
    xIt,
    bIt,
    kIt,
    TIt,
    SIt,
    _It,
    CIt,
    wIt,
    EIt,
    vIt,
    AIt,
    LIt,
    RIt,
    DIt,
    NIt,
    IIt,
    MIt,
    OIt,
    PIt,
    Mot,
    BIt,
    FIt,
    Oot,
    dC,
    N8,
    Pot,
    Bot = x(() => {
      'use strict'
      Ge()
      pe()
      Be()
      Vt()
      xot()
      uC()
      L8()
      Dot()
      R8()
      ;(Not = a((e) => (e ? ' ' + e : ''), 'formatClass')),
        (Vs = a((e, t) => `${t || 'node default'}${Not(e.classes)} ${Not(e.class)}`, 'getClassesFromNode')),
        (Iot = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = i + s,
            l = [
              { x: o / 2, y: 0 },
              { x: o, y: -o / 2 },
              { x: o / 2, y: -o },
              { x: 0, y: -o / 2 },
            ]
          B.info('Question main (Circle)')
          let u = Za(r, o, o, l)
          return (
            u.attr('style', t.style),
            sn(t, u),
            (t.intersect = function (h) {
              return B.warn('Intersect called'), Ur.polygon(t, l, h)
            }),
            r
          )
        }, 'question')),
        (xIt = a((e, t) => {
          let r = e
              .insert('g')
              .attr('class', 'node default')
              .attr('id', t.domId || t.id),
            n = 28,
            i = [
              { x: 0, y: n / 2 },
              { x: n / 2, y: 0 },
              { x: 0, y: -n / 2 },
              { x: -n / 2, y: 0 },
            ]
          return (
            r
              .insert('polygon', ':first-child')
              .attr(
                'points',
                i
                  .map(function (o) {
                    return o.x + ',' + o.y
                  })
                  .join(' '),
              )
              .attr('class', 'state-start')
              .attr('r', 7)
              .attr('width', 28)
              .attr('height', 28),
            (t.width = 28),
            (t.height = 28),
            (t.intersect = function (o) {
              return Ur.circle(t, 14, o)
            }),
            r
          )
        }, 'choice')),
        (bIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = 4,
            s = n.height + t.padding,
            o = s / i,
            l = n.width + 2 * o + t.padding,
            u = [
              { x: o, y: 0 },
              { x: l - o, y: 0 },
              { x: l, y: -s / 2 },
              { x: l - o, y: -s },
              { x: o, y: -s },
              { x: 0, y: -s / 2 },
            ],
            h = Za(r, l, s, u)
          return (
            h.attr('style', t.style),
            sn(t, h),
            (t.intersect = function (f) {
              return Ur.polygon(t, u, f)
            }),
            r
          )
        }, 'hexagon')),
        (kIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, void 0, !0),
            i = 2,
            s = n.height + 2 * t.padding,
            o = s / i,
            l = n.width + 2 * o + t.padding,
            u = yot(t.directions, n, t),
            h = Za(r, l, s, u)
          return (
            h.attr('style', t.style),
            sn(t, h),
            (t.intersect = function (f) {
              return Ur.polygon(t, u, f)
            }),
            r
          )
        }, 'block_arrow')),
        (TIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: -s / 2, y: 0 },
              { x: i, y: 0 },
              { x: i, y: -s },
              { x: -s / 2, y: -s },
              { x: 0, y: -s / 2 },
            ]
          return (
            Za(r, i, s, o).attr('style', t.style),
            (t.width = i + s),
            (t.height = s),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'rect_left_inv_arrow')),
        (SIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (-2 * s) / 6, y: 0 },
              { x: i - s / 6, y: 0 },
              { x: i + (2 * s) / 6, y: -s },
              { x: s / 6, y: -s },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'lean_right')),
        (_It = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (2 * s) / 6, y: 0 },
              { x: i + s / 6, y: 0 },
              { x: i - (2 * s) / 6, y: -s },
              { x: -s / 6, y: -s },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'lean_left')),
        (CIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (-2 * s) / 6, y: 0 },
              { x: i + (2 * s) / 6, y: 0 },
              { x: i - s / 6, y: -s },
              { x: s / 6, y: -s },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'trapezoid')),
        (wIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: s / 6, y: 0 },
              { x: i - s / 6, y: 0 },
              { x: i + (2 * s) / 6, y: -s },
              { x: (-2 * s) / 6, y: -s },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'inv_trapezoid')),
        (EIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: 0, y: 0 },
              { x: i + s / 2, y: 0 },
              { x: i, y: -s / 2 },
              { x: i + s / 2, y: -s },
              { x: 0, y: -s },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'rect_right_inv_arrow')),
        (vIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = i / 2,
            o = s / (2.5 + i / 50),
            l = n.height + o + t.padding,
            u =
              'M 0,' +
              o +
              ' a ' +
              s +
              ',' +
              o +
              ' 0,0,0 ' +
              i +
              ' 0 a ' +
              s +
              ',' +
              o +
              ' 0,0,0 ' +
              -i +
              ' 0 l 0,' +
              l +
              ' a ' +
              s +
              ',' +
              o +
              ' 0,0,0 ' +
              i +
              ' 0 l 0,' +
              -l,
            h = r
              .attr('label-offset-y', o)
              .insert('path', ':first-child')
              .attr('style', t.style)
              .attr('d', u)
              .attr('transform', 'translate(' + -i / 2 + ',' + -(l / 2 + o) + ')')
          return (
            sn(t, h),
            (t.intersect = function (f) {
              let d = Ur.rect(t, f),
                p = d.x - t.x
              if (
                s != 0 &&
                (Math.abs(p) < t.width / 2 || (Math.abs(p) == t.width / 2 && Math.abs(d.y - t.y) > t.height / 2 - o))
              ) {
                let m = o * o * (1 - (p * p) / (s * s))
                m != 0 && (m = Math.sqrt(m)), (m = o - m), f.y - t.y > 0 && (m = -m), (d.y += m)
              }
              return d
            }),
            r
          )
        }, 'cylinder')),
        (AIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n, halfPadding: i } = await Rn(e, t, 'node ' + t.classes + ' ' + t.class, !0),
            s = r.insert('rect', ':first-child'),
            o = t.positioned ? t.width : n.width + t.padding,
            l = t.positioned ? t.height : n.height + t.padding,
            u = t.positioned ? -o / 2 : -n.width / 2 - i,
            h = t.positioned ? -l / 2 : -n.height / 2 - i
          if (
            (s
              .attr('class', 'basic label-container')
              .attr('style', t.style)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('x', u)
              .attr('y', h)
              .attr('width', o)
              .attr('height', l),
            t.props)
          ) {
            let f = new Set(Object.keys(t.props))
            t.props.borders && (D8(s, t.props.borders, o, l), f.delete('borders')),
              f.forEach((d) => {
                B.warn(`Unknown node property ${d}`)
              })
          }
          return (
            sn(t, s),
            (t.intersect = function (f) {
              return Ur.rect(t, f)
            }),
            r
          )
        }, 'rect')),
        (LIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n, halfPadding: i } = await Rn(e, t, 'node ' + t.classes, !0),
            s = r.insert('rect', ':first-child'),
            o = t.positioned ? t.width : n.width + t.padding,
            l = t.positioned ? t.height : n.height + t.padding,
            u = t.positioned ? -o / 2 : -n.width / 2 - i,
            h = t.positioned ? -l / 2 : -n.height / 2 - i
          if (
            (s
              .attr('class', 'basic cluster composite label-container')
              .attr('style', t.style)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('x', u)
              .attr('y', h)
              .attr('width', o)
              .attr('height', l),
            t.props)
          ) {
            let f = new Set(Object.keys(t.props))
            t.props.borders && (D8(s, t.props.borders, o, l), f.delete('borders')),
              f.forEach((d) => {
                B.warn(`Unknown node property ${d}`)
              })
          }
          return (
            sn(t, s),
            (t.intersect = function (f) {
              return Ur.rect(t, f)
            }),
            r
          )
        }, 'composite')),
        (RIt = a(async (e, t) => {
          let { shapeSvg: r } = await Rn(e, t, 'label', !0)
          B.trace('Classes = ', t.class)
          let n = r.insert('rect', ':first-child'),
            i = 0,
            s = 0
          if ((n.attr('width', i).attr('height', s), r.attr('class', 'label edgeLabel'), t.props)) {
            let o = new Set(Object.keys(t.props))
            t.props.borders && (D8(n, t.props.borders, i, s), o.delete('borders')),
              o.forEach((l) => {
                B.warn(`Unknown node property ${l}`)
              })
          }
          return (
            sn(t, n),
            (t.intersect = function (o) {
              return Ur.rect(t, o)
            }),
            r
          )
        }, 'labelRect'))
      a(D8, 'applyNodePropertyBorders')
      ;(DIt = a(async (e, t) => {
        let r
        t.classes ? (r = 'node ' + t.classes) : (r = 'node default')
        let n = e
            .insert('g')
            .attr('class', r)
            .attr('id', t.domId || t.id),
          i = n.insert('rect', ':first-child'),
          s = n.insert('line'),
          o = n.insert('g').attr('class', 'label'),
          l = t.labelText.flat ? t.labelText.flat() : t.labelText,
          u = ''
        typeof l == 'object' ? (u = l[0]) : (u = l), B.info('Label text abc79', u, l, typeof l == 'object')
        let h = o.node().appendChild(await Ji(u, t.labelStyle, !0, !0)),
          f = { width: 0, height: 0 }
        if (Pe(K().flowchart.htmlLabels)) {
          let y = h.children[0],
            b = xt(h)
          ;(f = y.getBoundingClientRect()), b.attr('width', f.width), b.attr('height', f.height)
        }
        B.info('Text 2', l)
        let d = l.slice(1, l.length),
          p = h.getBBox(),
          m = o.node().appendChild(await Ji(d.join ? d.join('<br/>') : d, t.labelStyle, !0, !0))
        if (Pe(K().flowchart.htmlLabels)) {
          let y = m.children[0],
            b = xt(m)
          ;(f = y.getBoundingClientRect()), b.attr('width', f.width), b.attr('height', f.height)
        }
        let g = t.padding / 2
        return (
          xt(m).attr(
            'transform',
            'translate( ' + (f.width > p.width ? 0 : (p.width - f.width) / 2) + ', ' + (p.height + g + 5) + ')',
          ),
          xt(h).attr('transform', 'translate( ' + (f.width < p.width ? 0 : -(p.width - f.width) / 2) + ', 0)'),
          (f = o.node().getBBox()),
          o.attr('transform', 'translate(' + -f.width / 2 + ', ' + (-f.height / 2 - g + 3) + ')'),
          i
            .attr('class', 'outer title-state')
            .attr('x', -f.width / 2 - g)
            .attr('y', -f.height / 2 - g)
            .attr('width', f.width + t.padding)
            .attr('height', f.height + t.padding),
          s
            .attr('class', 'divider')
            .attr('x1', -f.width / 2 - g)
            .attr('x2', f.width / 2 + g)
            .attr('y1', -f.height / 2 - g + p.height + g)
            .attr('y2', -f.height / 2 - g + p.height + g),
          sn(t, i),
          (t.intersect = function (y) {
            return Ur.rect(t, y)
          }),
          n
        )
      }, 'rectWithTitle')),
        (NIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.height + t.padding,
            s = n.width + i / 4 + t.padding,
            o = r
              .insert('rect', ':first-child')
              .attr('style', t.style)
              .attr('rx', i / 2)
              .attr('ry', i / 2)
              .attr('x', -s / 2)
              .attr('y', -i / 2)
              .attr('width', s)
              .attr('height', i)
          return (
            sn(t, o),
            (t.intersect = function (l) {
              return Ur.rect(t, l)
            }),
            r
          )
        }, 'stadium')),
        (IIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n, halfPadding: i } = await Rn(e, t, Vs(t, void 0), !0),
            s = r.insert('circle', ':first-child')
          return (
            s
              .attr('style', t.style)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('r', n.width / 2 + i)
              .attr('width', n.width + t.padding)
              .attr('height', n.height + t.padding),
            B.info('Circle main'),
            sn(t, s),
            (t.intersect = function (o) {
              return B.info('Circle intersect', t, n.width / 2 + i, o), Ur.circle(t, n.width / 2 + i, o)
            }),
            r
          )
        }, 'circle')),
        (MIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n, halfPadding: i } = await Rn(e, t, Vs(t, void 0), !0),
            s = 5,
            o = r.insert('g', ':first-child'),
            l = o.insert('circle'),
            u = o.insert('circle')
          return (
            o.attr('class', t.class),
            l
              .attr('style', t.style)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('r', n.width / 2 + i + s)
              .attr('width', n.width + t.padding + s * 2)
              .attr('height', n.height + t.padding + s * 2),
            u
              .attr('style', t.style)
              .attr('rx', t.rx)
              .attr('ry', t.ry)
              .attr('r', n.width / 2 + i)
              .attr('width', n.width + t.padding)
              .attr('height', n.height + t.padding),
            B.info('DoubleCircle main'),
            sn(t, l),
            (t.intersect = function (h) {
              return B.info('DoubleCircle intersect', t, n.width / 2 + i + s, h), Ur.circle(t, n.width / 2 + i + s, h)
            }),
            r
          )
        }, 'doublecircle')),
        (OIt = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Rn(e, t, Vs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: 0, y: 0 },
              { x: i, y: 0 },
              { x: i, y: -s },
              { x: 0, y: -s },
              { x: 0, y: 0 },
              { x: -8, y: 0 },
              { x: i + 8, y: 0 },
              { x: i + 8, y: -s },
              { x: -8, y: -s },
              { x: -8, y: 0 },
            ],
            l = Za(r, i, s, o)
          return (
            l.attr('style', t.style),
            sn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u)
            }),
            r
          )
        }, 'subroutine')),
        (PIt = a((e, t) => {
          let r = e
              .insert('g')
              .attr('class', 'node default')
              .attr('id', t.domId || t.id),
            n = r.insert('circle', ':first-child')
          return (
            n.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14),
            sn(t, n),
            (t.intersect = function (i) {
              return Ur.circle(t, 7, i)
            }),
            r
          )
        }, 'start')),
        (Mot = a((e, t, r) => {
          let n = e
              .insert('g')
              .attr('class', 'node default')
              .attr('id', t.domId || t.id),
            i = 70,
            s = 10
          r === 'LR' && ((i = 10), (s = 70))
          let o = n
            .append('rect')
            .attr('x', (-1 * i) / 2)
            .attr('y', (-1 * s) / 2)
            .attr('width', i)
            .attr('height', s)
            .attr('class', 'fork-join')
          return (
            sn(t, o),
            (t.height = t.height + t.padding / 2),
            (t.width = t.width + t.padding / 2),
            (t.intersect = function (l) {
              return Ur.rect(t, l)
            }),
            n
          )
        }, 'forkJoin')),
        (BIt = a((e, t) => {
          let r = e
              .insert('g')
              .attr('class', 'node default')
              .attr('id', t.domId || t.id),
            n = r.insert('circle', ':first-child'),
            i = r.insert('circle', ':first-child')
          return (
            i.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14),
            n.attr('class', 'state-end').attr('r', 5).attr('width', 10).attr('height', 10),
            sn(t, i),
            (t.intersect = function (s) {
              return Ur.circle(t, 7, s)
            }),
            r
          )
        }, 'end')),
        (FIt = a(async (e, t) => {
          let r = t.padding / 2,
            n = 4,
            i = 8,
            s
          t.classes ? (s = 'node ' + t.classes) : (s = 'node default')
          let o = e
              .insert('g')
              .attr('class', s)
              .attr('id', t.domId || t.id),
            l = o.insert('rect', ':first-child'),
            u = o.insert('line'),
            h = o.insert('line'),
            f = 0,
            d = n,
            p = o.insert('g').attr('class', 'label'),
            m = 0,
            g = t.classData.annotations?.[0],
            y = t.classData.annotations[0] ? '\xAB' + t.classData.annotations[0] + '\xBB' : '',
            b = p.node().appendChild(await Ji(y, t.labelStyle, !0, !0)),
            k = b.getBBox()
          if (Pe(K().flowchart.htmlLabels)) {
            let v = b.children[0],
              R = xt(b)
            ;(k = v.getBoundingClientRect()), R.attr('width', k.width), R.attr('height', k.height)
          }
          t.classData.annotations[0] && ((d += k.height + n), (f += k.width))
          let T = t.classData.label
          t.classData.type !== void 0 &&
            t.classData.type !== '' &&
            (K().flowchart.htmlLabels ? (T += '&lt;' + t.classData.type + '&gt;') : (T += '<' + t.classData.type + '>'))
          let C = p.node().appendChild(await Ji(T, t.labelStyle, !0, !0))
          xt(C).attr('class', 'classTitle')
          let A = C.getBBox()
          if (Pe(K().flowchart.htmlLabels)) {
            let v = C.children[0],
              R = xt(C)
            ;(A = v.getBoundingClientRect()), R.attr('width', A.width), R.attr('height', A.height)
          }
          ;(d += A.height + n), A.width > f && (f = A.width)
          let w = []
          t.classData.members.forEach(async (v) => {
            let R = v.getDisplayDetails(),
              F = R.displayText
            K().flowchart.htmlLabels && (F = F.replace(/</g, '&lt;').replace(/>/g, '&gt;'))
            let S = p.node().appendChild(await Ji(F, R.cssStyle ? R.cssStyle : t.labelStyle, !0, !0)),
              O = S.getBBox()
            if (Pe(K().flowchart.htmlLabels)) {
              let E = S.children[0],
                _ = xt(S)
              ;(O = E.getBoundingClientRect()), _.attr('width', O.width), _.attr('height', O.height)
            }
            O.width > f && (f = O.width), (d += O.height + n), w.push(S)
          }),
            (d += i)
          let D = []
          if (
            (t.classData.methods.forEach(async (v) => {
              let R = v.getDisplayDetails(),
                F = R.displayText
              K().flowchart.htmlLabels && (F = F.replace(/</g, '&lt;').replace(/>/g, '&gt;'))
              let S = p.node().appendChild(await Ji(F, R.cssStyle ? R.cssStyle : t.labelStyle, !0, !0)),
                O = S.getBBox()
              if (Pe(K().flowchart.htmlLabels)) {
                let E = S.children[0],
                  _ = xt(S)
                ;(O = E.getBoundingClientRect()), _.attr('width', O.width), _.attr('height', O.height)
              }
              O.width > f && (f = O.width), (d += O.height + n), D.push(S)
            }),
            (d += i),
            g)
          ) {
            let v = (f - k.width) / 2
            xt(b).attr('transform', 'translate( ' + ((-1 * f) / 2 + v) + ', ' + (-1 * d) / 2 + ')'), (m = k.height + n)
          }
          let G = (f - A.width) / 2
          return (
            xt(C).attr('transform', 'translate( ' + ((-1 * f) / 2 + G) + ', ' + ((-1 * d) / 2 + m) + ')'),
            (m += A.height + n),
            u
              .attr('class', 'divider')
              .attr('x1', -f / 2 - r)
              .attr('x2', f / 2 + r)
              .attr('y1', -d / 2 - r + i + m)
              .attr('y2', -d / 2 - r + i + m),
            (m += i),
            w.forEach((v) => {
              xt(v).attr('transform', 'translate( ' + -f / 2 + ', ' + ((-1 * d) / 2 + m + i / 2) + ')')
              let R = v?.getBBox()
              m += (R?.height ?? 0) + n
            }),
            (m += i),
            h
              .attr('class', 'divider')
              .attr('x1', -f / 2 - r)
              .attr('x2', f / 2 + r)
              .attr('y1', -d / 2 - r + i + m)
              .attr('y2', -d / 2 - r + i + m),
            (m += i),
            D.forEach((v) => {
              xt(v).attr('transform', 'translate( ' + -f / 2 + ', ' + ((-1 * d) / 2 + m) + ')')
              let R = v?.getBBox()
              m += (R?.height ?? 0) + n
            }),
            l
              .attr('style', t.style)
              .attr('class', 'outer title-state')
              .attr('x', -f / 2 - r)
              .attr('y', -(d / 2) - r)
              .attr('width', f + t.padding)
              .attr('height', d + t.padding),
            sn(t, l),
            (t.intersect = function (v) {
              return Ur.rect(t, v)
            }),
            o
          )
        }, 'class_box')),
        (Oot = {
          rhombus: Iot,
          composite: LIt,
          question: Iot,
          rect: AIt,
          labelRect: RIt,
          rectWithTitle: DIt,
          choice: xIt,
          circle: IIt,
          doublecircle: MIt,
          stadium: NIt,
          hexagon: bIt,
          block_arrow: kIt,
          rect_left_inv_arrow: TIt,
          lean_right: SIt,
          lean_left: _It,
          trapezoid: CIt,
          inv_trapezoid: wIt,
          rect_right_inv_arrow: EIt,
          cylinder: vIt,
          start: PIt,
          end: BIt,
          note: Rot,
          subroutine: OIt,
          fork: Mot,
          join: Mot,
          class_box: FIt,
        }),
        (dC = {}),
        (N8 = a(async (e, t, r) => {
          let n, i
          if (t.link) {
            let s
            K().securityLevel === 'sandbox' ? (s = '_top') : t.linkTarget && (s = t.linkTarget || '_blank'),
              (n = e.insert('svg:a').attr('xlink:href', t.link).attr('target', s)),
              (i = await Oot[t.shape](n, t, r))
          } else (i = await Oot[t.shape](e, t, r)), (n = i)
          return (
            t.tooltip && i.attr('title', t.tooltip),
            t.class && i.attr('class', 'node default ' + t.class),
            (dC[t.id] = n),
            t.haveCallback && dC[t.id].attr('class', dC[t.id].attr('class') + ' clickable'),
            n
          )
        }, 'insertNode')),
        (Pot = a((e) => {
          let t = dC[e.id]
          B.trace('Transforming node', e.diff, e, 'translate(' + (e.x - e.width / 2 - 5) + ', ' + e.width / 2 + ')')
          let r = 8,
            n = e.diff || 0
          return (
            e.clusterNode
              ? t.attr('transform', 'translate(' + (e.x + n - e.width / 2) + ', ' + (e.y - e.height / 2 - r) + ')')
              : t.attr('transform', 'translate(' + e.x + ', ' + e.y + ')'),
            n
          )
        }, 'positionNode'))
    })
  function Fot(e, t, r = !1) {
    let n = e,
      i = 'default'
    ;(n?.classes?.length || 0) > 0 && (i = (n?.classes ?? []).join(' ')), (i = i + ' flowchart-label')
    let s = 0,
      o = '',
      l
    switch (n.type) {
      case 'round':
        ;(s = 5), (o = 'rect')
        break
      case 'composite':
        ;(s = 0), (o = 'composite'), (l = 0)
        break
      case 'square':
        o = 'rect'
        break
      case 'diamond':
        o = 'question'
        break
      case 'hexagon':
        o = 'hexagon'
        break
      case 'block_arrow':
        o = 'block_arrow'
        break
      case 'odd':
        o = 'rect_left_inv_arrow'
        break
      case 'lean_right':
        o = 'lean_right'
        break
      case 'lean_left':
        o = 'lean_left'
        break
      case 'trapezoid':
        o = 'trapezoid'
        break
      case 'inv_trapezoid':
        o = 'inv_trapezoid'
        break
      case 'rect_left_inv_arrow':
        o = 'rect_left_inv_arrow'
        break
      case 'circle':
        o = 'circle'
        break
      case 'ellipse':
        o = 'ellipse'
        break
      case 'stadium':
        o = 'stadium'
        break
      case 'subroutine':
        o = 'subroutine'
        break
      case 'cylinder':
        o = 'cylinder'
        break
      case 'group':
        o = 'rect'
        break
      case 'doublecircle':
        o = 'doublecircle'
        break
      default:
        o = 'rect'
    }
    let u = E4(n?.styles ?? []),
      h = n.label,
      f = n.size ?? { width: 0, height: 0, x: 0, y: 0 }
    return {
      labelStyle: u.labelStyle,
      shape: o,
      labelText: h,
      rx: s,
      ry: s,
      class: i,
      style: u.style,
      id: n.id,
      directions: n.directions,
      width: f.width,
      height: f.height,
      x: f.x,
      y: f.y,
      positioned: r,
      intersect: void 0,
      type: n.type,
      padding: l ?? Te()?.block?.padding ?? 0,
    }
  }
  async function $It(e, t, r) {
    let n = Fot(t, r, !1)
    if (n.type === 'group') return
    let i = Te(),
      s = await N8(e, n, { config: i }),
      o = s.node().getBBox(),
      l = r.getBlock(n.id)
    ;(l.size = { width: o.width, height: o.height, x: 0, y: 0, node: s }), r.setBlock(l), s.remove()
  }
  async function GIt(e, t, r) {
    let n = Fot(t, r, !0)
    if (r.getBlock(n.id).type !== 'space') {
      let s = Te()
      await N8(e, n, { config: s }), (t.intersect = n?.intersect), Pot(n)
    }
  }
  async function I8(e, t, r, n) {
    for (let i of t) await n(e, i, r), i.children && (await I8(e, i.children, r, n))
  }
  async function $ot(e, t, r) {
    await I8(e, t, r, $It)
  }
  async function Got(e, t, r) {
    await I8(e, t, r, GIt)
  }
  async function Vot(e, t, r, n, i) {
    let s = new _r({ multigraph: !0, compound: !0 })
    s.setGraph({ rankdir: 'TB', nodesep: 10, ranksep: 10, marginx: 8, marginy: 8 })
    for (let o of r) o.size && s.setNode(o.id, { width: o.size.width, height: o.size.height, intersect: o.intersect })
    for (let o of t)
      if (o.start && o.end) {
        let l = n.getBlock(o.start),
          u = n.getBlock(o.end)
        if (l?.size && u?.size) {
          let h = l.size,
            f = u.size,
            d = [
              { x: h.x, y: h.y },
              { x: h.x + (f.x - h.x) / 2, y: h.y + (f.y - h.y) / 2 },
              { x: f.x, y: f.y },
            ]
          mot(
            e,
            { v: o.start, w: o.end, name: o.id },
            {
              ...o,
              arrowTypeEnd: o.arrowTypeEnd,
              arrowTypeStart: o.arrowTypeStart,
              points: d,
              classes: 'edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1',
            },
            void 0,
            'block',
            s,
            i,
          ),
            o.label &&
              (await dot(e, {
                ...o,
                label: o.label,
                labelStyle: 'stroke: #333; stroke-width: 1.5px;fill:none;',
                arrowTypeEnd: o.arrowTypeEnd,
                arrowTypeStart: o.arrowTypeStart,
                points: d,
                classes: 'edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1',
              }),
              pot({ ...o, x: d[1].x, y: d[1].y }, { originalPath: d }))
        }
      }
  }
  var zot = x(() => {
    'use strict'
    aa()
    fn()
    got()
    Bot()
    Ce()
    a(Fot, 'getNodeFromBlock')
    a($It, 'calculateBlockSize')
    a(GIt, 'insertBlockPositioned')
    a(I8, 'performOperations')
    a($ot, 'calculateBlockSizes')
    a(Got, 'insertBlocks')
    a(Vot, 'insertEdges')
  })
  var VIt,
    zIt,
    Wot,
    Uot = x(() => {
      'use strict'
      Ge()
      fn()
      not()
      Vt()
      On()
      oot()
      zot()
      ;(VIt = a(function (e, t) {
        return t.db.getClasses()
      }, 'getClasses')),
        (zIt = a(async function (e, t, r, n) {
          let { securityLevel: i, block: s } = Te(),
            o = n.db,
            l
          i === 'sandbox' && (l = xt('#i' + t))
          let u = i === 'sandbox' ? xt(l.nodes()[0].contentDocument.body) : xt('body'),
            h = i === 'sandbox' ? u.select(`[id="${t}"]`) : xt(`[id="${t}"]`)
          rot(h, ['point', 'circle', 'cross'], n.type, t)
          let d = o.getBlocks(),
            p = o.getBlocksFlat(),
            m = o.getEdges(),
            g = h.insert('g').attr('class', 'block')
          await $ot(g, d, o)
          let y = aot(o)
          if ((await Got(g, d, o), await Vot(g, m, p, o, t), y)) {
            let b = y,
              k = Math.max(1, Math.round(0.125 * (b.width / b.height))),
              T = b.height + k + 10,
              C = b.width + 10,
              { useMaxWidth: A } = s
            Ar(h, T, C, !!A),
              B.debug('Here Bounds', y, b),
              h.attr('viewBox', `${b.x - 5} ${b.y - 5} ${b.width + 10} ${b.height + 10}`)
          }
        }, 'draw')),
        (Wot = { draw: zIt, getClasses: VIt })
    })
  var jot = {}
  Oe(jot, { diagram: () => WIt })
  var WIt,
    qot = x(() => {
      'use strict'
      qat()
      Jat()
      eot()
      Uot()
      WIt = { parser: jat, db: Zat, renderer: Wot, styles: tot }
    })
  var Pm,
    M8 = x(() => {
      'use strict'
      _s()
      fn()
      Ce()
      re()
      bn()
      Pm = class {
        constructor() {
          this.nodes = []
          this.levels = new Map()
          this.outerNodes = []
          this.classes = new Map()
          this.setAccTitle = Xe
          this.getAccTitle = tr
          this.setDiagramTitle = lr
          this.getDiagramTitle = nr
          this.getAccDescription = rr
          this.setAccDescription = er
        }
        static {
          a(this, 'TreeMapDB')
        }
        getNodes() {
          return this.nodes
        }
        getConfig() {
          let t = ze,
            r = Te()
          return ln({ ...t.treemap, ...(r.treemap ?? {}) })
        }
        addNode(t, r) {
          this.nodes.push(t), this.levels.set(t, r), r === 0 && (this.outerNodes.push(t), (this.root ??= t))
        }
        getRoot() {
          return { name: '', children: this.outerNodes }
        }
        addClass(t, r) {
          let n = this.classes.get(t) ?? { id: t, styles: [], textStyles: [] },
            i = r.replace(/\\,/g, '\xA7\xA7\xA7').replace(/,/g, ';').replace(//g, ',').split(';')
          i &&
            i.forEach((s) => {
              N0(s) && (n?.textStyles ? n.textStyles.push(s) : (n.textStyles = [s])),
                n?.styles ? n.styles.push(s) : (n.styles = [s])
            }),
            this.classes.set(t, n)
        }
        getClasses() {
          return this.classes
        }
        getStylesForClass(t) {
          return this.classes.get(t)?.styles ?? []
        }
        clear() {
          Ye(),
            (this.nodes = []),
            (this.levels = new Map()),
            (this.outerNodes = []),
            (this.classes = new Map()),
            (this.root = void 0)
        }
      }
    })
  function Xot(e) {
    if (!e.length) return []
    let t = [],
      r = []
    return (
      e.forEach((n) => {
        let i = { name: n.name, children: n.type === 'Leaf' ? void 0 : [] }
        for (
          i.classSelector = n?.classSelector,
            n?.cssCompiledStyles && (i.cssCompiledStyles = [n.cssCompiledStyles]),
            n.type === 'Leaf' && n.value !== void 0 && (i.value = n.value);
          r.length > 0 && r[r.length - 1].level >= n.level;

        )
          r.pop()
        if (r.length === 0) t.push(i)
        else {
          let s = r[r.length - 1].node
          s.children ? s.children.push(i) : (s.children = [i])
        }
        n.type !== 'Leaf' && r.push({ node: i, level: n.level })
      }),
      t
    )
  }
  var Kot = x(() => {
    'use strict'
    a(Xot, 'buildHierarchy')
  })
  var HIt,
    YIt,
    O8,
    Qot = x(() => {
      'use strict'
      jh()
      Vt()
      gm()
      Kot()
      M8()
      ;(HIt = a((e, t) => {
        jo(e, t)
        let r = []
        for (let s of e.TreemapRows ?? [])
          s.$type === 'ClassDefStatement' && t.addClass(s.className ?? '', s.styleText ?? '')
        for (let s of e.TreemapRows ?? []) {
          let o = s.item
          if (!o) continue
          let l = s.indent ? parseInt(s.indent) : 0,
            u = YIt(o),
            h = o.classSelector ? t.getStylesForClass(o.classSelector) : [],
            f = h.length > 0 ? h.join(';') : void 0,
            d = {
              level: l,
              name: u,
              type: o.$type,
              value: o.value,
              classSelector: o.classSelector,
              cssCompiledStyles: f,
            }
          r.push(d)
        }
        let n = Xot(r),
          i = a((s, o) => {
            for (let l of s) t.addNode(l, o), l.children && l.children.length > 0 && i(l.children, o + 1)
          }, 'addNodesRecursively')
        i(n, 0)
      }, 'populate')),
        (YIt = a((e) => (e.name ? String(e.name) : ''), 'getItemName')),
        (O8 = {
          parser: { yy: void 0 },
          parse: a(async (e) => {
            try {
              let r = await Fs('treemap', e)
              B.debug('Treemap AST:', r)
              let n = O8.parser?.yy
              if (!(n instanceof Pm))
                throw new Error(
                  'parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.',
                )
              HIt(r, n)
            } catch (t) {
              throw (B.error('Error parsing treemap:', t), t)
            }
          }, 'parse'),
        })
    })
  var XIt,
    Bm,
    Zy,
    KIt,
    QIt,
    Zot,
    Jot = x(() => {
      'use strict'
      Bl()
      mh()
      On()
      Ge()
      re()
      fn()
      Vt()
      ;(XIt = 10),
        (Bm = 10),
        (Zy = 25),
        (KIt = a((e, t, r, n) => {
          let i = n.db,
            s = i.getConfig(),
            o = s.padding ?? XIt,
            l = i.getDiagramTitle(),
            u = i.getRoot(),
            { themeVariables: h } = Te()
          if (!u) return
          let f = l ? 30 : 0,
            d = Ai(t),
            p = s.nodeWidth ? s.nodeWidth * Bm : 960,
            m = s.nodeHeight ? s.nodeHeight * Bm : 500,
            g = p,
            y = m + f
          d.attr('viewBox', `0 0 ${g} ${y}`), Ar(d, y, g, s.useMaxWidth)
          let b
          try {
            let _ = s.valueFormat || ','
            if (_ === '$0,0') b = a((L) => '$' + oo(',')(L), 'valueFormat')
            else if (_.startsWith('$') && _.includes(',')) {
              let L = /\.\d+/.exec(_),
                N = L ? L[0] : ''
              b = a((P) => '$' + oo(',' + N)(P), 'valueFormat')
            } else if (_.startsWith('$')) {
              let L = _.substring(1)
              b = a((N) => '$' + oo(L || '')(N), 'valueFormat')
            } else b = oo(_)
          } catch (_) {
            B.error('Error creating format function:', _), (b = oo(','))
          }
          let k = Cs().range([
              'transparent',
              h.cScale0,
              h.cScale1,
              h.cScale2,
              h.cScale3,
              h.cScale4,
              h.cScale5,
              h.cScale6,
              h.cScale7,
              h.cScale8,
              h.cScale9,
              h.cScale10,
              h.cScale11,
            ]),
            T = Cs().range([
              'transparent',
              h.cScalePeer0,
              h.cScalePeer1,
              h.cScalePeer2,
              h.cScalePeer3,
              h.cScalePeer4,
              h.cScalePeer5,
              h.cScalePeer6,
              h.cScalePeer7,
              h.cScalePeer8,
              h.cScalePeer9,
              h.cScalePeer10,
              h.cScalePeer11,
            ]),
            C = Cs().range([
              h.cScaleLabel0,
              h.cScaleLabel1,
              h.cScaleLabel2,
              h.cScaleLabel3,
              h.cScaleLabel4,
              h.cScaleLabel5,
              h.cScaleLabel6,
              h.cScaleLabel7,
              h.cScaleLabel8,
              h.cScaleLabel9,
              h.cScaleLabel10,
              h.cScaleLabel11,
            ])
          l &&
            d
              .append('text')
              .attr('x', g / 2)
              .attr('y', f / 2)
              .attr('class', 'treemapTitle')
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'middle')
              .text(l)
          let A = d.append('g').attr('transform', `translate(0, ${f})`).attr('class', 'treemapContainer'),
            w = Lf(u)
              .sum((_) => _.value ?? 0)
              .sort((_, L) => (L.value ?? 0) - (_.value ?? 0)),
            G = m2()
              .size([p, m])
              .paddingTop((_) => (_.children && _.children.length > 0 ? Zy + Bm : 0))
              .paddingInner(o)
              .paddingLeft((_) => (_.children && _.children.length > 0 ? Bm : 0))
              .paddingRight((_) => (_.children && _.children.length > 0 ? Bm : 0))
              .paddingBottom((_) => (_.children && _.children.length > 0 ? Bm : 0))
              .round(!0)(w),
            v = G.descendants().filter((_) => _.children && _.children.length > 0),
            R = A.selectAll('.treemapSection')
              .data(v)
              .enter()
              .append('g')
              .attr('class', 'treemapSection')
              .attr('transform', (_) => `translate(${_.x0},${_.y0})`)
          R.append('rect')
            .attr('width', (_) => _.x1 - _.x0)
            .attr('height', Zy)
            .attr('class', 'treemapSectionHeader')
            .attr('fill', 'none')
            .attr('fill-opacity', 0.6)
            .attr('stroke-width', 0.6)
            .attr('style', (_) => (_.depth === 0 ? 'display: none;' : '')),
            R.append('clipPath')
              .attr('id', (_, L) => `clip-section-${t}-${L}`)
              .append('rect')
              .attr('width', (_) => Math.max(0, _.x1 - _.x0 - 12))
              .attr('height', Zy),
            R.append('rect')
              .attr('width', (_) => _.x1 - _.x0)
              .attr('height', (_) => _.y1 - _.y0)
              .attr('class', (_, L) => `treemapSection section${L}`)
              .attr('fill', (_) => k(_.data.name))
              .attr('fill-opacity', 0.6)
              .attr('stroke', (_) => T(_.data.name))
              .attr('stroke-width', 2)
              .attr('stroke-opacity', 0.4)
              .attr('style', (_) => {
                if (_.depth === 0) return 'display: none;'
                let L = St({ cssCompiledStyles: _.data.cssCompiledStyles })
                return L.nodeStyles + ';' + L.borderStyles.join(';')
              }),
            R.append('text')
              .attr('class', 'treemapSectionLabel')
              .attr('x', 6)
              .attr('y', Zy / 2)
              .attr('dominant-baseline', 'middle')
              .text((_) => (_.depth === 0 ? '' : _.data.name))
              .attr('font-weight', 'bold')
              .attr('style', (_) => {
                if (_.depth === 0) return 'display: none;'
                let L =
                    'dominant-baseline: middle; font-size: 12px; fill:' +
                    C(_.data.name) +
                    '; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;',
                  N = St({ cssCompiledStyles: _.data.cssCompiledStyles })
                return L + N.labelStyles.replace('color:', 'fill:')
              })
              .each(function (_) {
                if (_.depth === 0) return
                let L = xt(this),
                  N = _.data.name
                L.text(N)
                let P = _.x1 - _.x0,
                  I = 6,
                  M
                s.showValues !== !1 && _.value ? (M = P - 10 - 30 - 10 - I) : (M = P - I - 6)
                let $ = Math.max(15, M),
                  q = L.node()
                if (q.getComputedTextLength() > $) {
                  let H = N
                  for (; H.length > 0; ) {
                    if (((H = N.substring(0, H.length - 1)), H.length === 0)) {
                      L.text('...'), q.getComputedTextLength() > $ && L.text('')
                      break
                    }
                    if ((L.text(H + '...'), q.getComputedTextLength() <= $)) break
                  }
                }
              }),
            s.showValues !== !1 &&
              R.append('text')
                .attr('class', 'treemapSectionValue')
                .attr('x', (_) => _.x1 - _.x0 - 10)
                .attr('y', Zy / 2)
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .text((_) => (_.value ? b(_.value) : ''))
                .attr('font-style', 'italic')
                .attr('style', (_) => {
                  if (_.depth === 0) return 'display: none;'
                  let L =
                      'text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:' +
                      C(_.data.name) +
                      '; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;',
                    N = St({ cssCompiledStyles: _.data.cssCompiledStyles })
                  return L + N.labelStyles.replace('color:', 'fill:')
                })
          let F = G.leaves(),
            S = A.selectAll('.treemapLeafGroup')
              .data(F)
              .enter()
              .append('g')
              .attr(
                'class',
                (_, L) =>
                  `treemapNode treemapLeafGroup leaf${L}${_.data.classSelector ? ` ${_.data.classSelector}` : ''}x`,
              )
              .attr('transform', (_) => `translate(${_.x0},${_.y0})`)
          S.append('rect')
            .attr('width', (_) => _.x1 - _.x0)
            .attr('height', (_) => _.y1 - _.y0)
            .attr('class', 'treemapLeaf')
            .attr('fill', (_) => (_.parent ? k(_.parent.data.name) : k(_.data.name)))
            .attr('style', (_) => St({ cssCompiledStyles: _.data.cssCompiledStyles }).nodeStyles)
            .attr('fill-opacity', 0.3)
            .attr('stroke', (_) => (_.parent ? k(_.parent.data.name) : k(_.data.name)))
            .attr('stroke-width', 3),
            S.append('clipPath')
              .attr('id', (_, L) => `clip-${t}-${L}`)
              .append('rect')
              .attr('width', (_) => Math.max(0, _.x1 - _.x0 - 4))
              .attr('height', (_) => Math.max(0, _.y1 - _.y0 - 4)),
            S.append('text')
              .attr('class', 'treemapLabel')
              .attr('x', (_) => (_.x1 - _.x0) / 2)
              .attr('y', (_) => (_.y1 - _.y0) / 2)
              .attr('style', (_) => {
                let L = 'text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:' + C(_.data.name) + ';',
                  N = St({ cssCompiledStyles: _.data.cssCompiledStyles })
                return L + N.labelStyles.replace('color:', 'fill:')
              })
              .attr('clip-path', (_, L) => `url(#clip-${t}-${L})`)
              .text((_) => _.data.name)
              .each(function (_) {
                let L = xt(this),
                  N = _.x1 - _.x0,
                  P = _.y1 - _.y0,
                  I = L.node(),
                  M = 4,
                  V = N - 2 * M,
                  $ = P - 2 * M
                if (V < 10 || $ < 10) {
                  L.style('display', 'none')
                  return
                }
                let q = parseInt(L.style('font-size'), 10),
                  tt = 8,
                  ft = 28,
                  H = 0.6,
                  kt = 6,
                  ht = 2
                for (; I.getComputedTextLength() > V && q > tt; ) q--, L.style('font-size', `${q}px`)
                let yt = Math.max(kt, Math.min(ft, Math.round(q * H))),
                  ot = q + ht + yt
                for (
                  ;
                  ot > $ &&
                  q > tt &&
                  (q--, (yt = Math.max(kt, Math.min(ft, Math.round(q * H)))), !(yt < kt && q === tt));

                )
                  L.style('font-size', `${q}px`), (ot = q + ht + yt), yt <= kt && ot > $
                L.style('font-size', `${q}px`),
                  (I.getComputedTextLength() > V || q < tt || $ < q) && L.style('display', 'none')
              }),
            s.showValues !== !1 &&
              S.append('text')
                .attr('class', 'treemapValue')
                .attr('x', (L) => (L.x1 - L.x0) / 2)
                .attr('y', function (L) {
                  return (L.y1 - L.y0) / 2
                })
                .attr('style', (L) => {
                  let N =
                      'text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:' + C(L.data.name) + ';',
                    P = St({ cssCompiledStyles: L.data.cssCompiledStyles })
                  return N + P.labelStyles.replace('color:', 'fill:')
                })
                .attr('clip-path', (L, N) => `url(#clip-${t}-${N})`)
                .text((L) => (L.value ? b(L.value) : ''))
                .each(function (L) {
                  let N = xt(this),
                    P = this.parentNode
                  if (!P) {
                    N.style('display', 'none')
                    return
                  }
                  let I = xt(P).select('.treemapLabel')
                  if (I.empty() || I.style('display') === 'none') {
                    N.style('display', 'none')
                    return
                  }
                  let M = parseFloat(I.style('font-size')),
                    V = 28,
                    $ = 0.6,
                    q = 6,
                    tt = 2,
                    ft = Math.max(q, Math.min(V, Math.round(M * $)))
                  N.style('font-size', `${ft}px`)
                  let kt = (L.y1 - L.y0) / 2 + M / 2 + tt
                  N.attr('y', kt)
                  let ht = L.x1 - L.x0,
                    dt = L.y1 - L.y0 - 4,
                    it = ht - 8
                  N.node().getComputedTextLength() > it || kt + ft > dt || ft < q
                    ? N.style('display', 'none')
                    : N.style('display', null)
                })
          let E = s.diagramPadding ?? 8
          la(d, E, 'flowchart', s?.useMaxWidth || !1)
        }, 'draw')),
        (QIt = a(function (e, t) {
          return t.db.getClasses()
        }, 'getClasses')),
        (Zot = { draw: KIt, getClasses: QIt })
    })
  var ZIt,
    JIt,
    tlt,
    elt = x(() => {
      'use strict'
      Ce()
      ;(ZIt = {
        sectionStrokeColor: 'black',
        sectionStrokeWidth: '1',
        sectionFillColor: '#efefef',
        leafStrokeColor: 'black',
        leafStrokeWidth: '1',
        leafFillColor: '#efefef',
        labelColor: 'black',
        labelFontSize: '12px',
        valueFontSize: '10px',
        valueColor: 'black',
        titleColor: 'black',
        titleFontSize: '14px',
      }),
        (JIt = a(({ treemap: e } = {}) => {
          let t = ln(ZIt, e)
          return `
  .treemapNode.section {
    stroke: ${t.sectionStrokeColor};
    stroke-width: ${t.sectionStrokeWidth};
    fill: ${t.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${t.leafStrokeColor};
    stroke-width: ${t.leafStrokeWidth};
    fill: ${t.leafFillColor};
  }
  .treemapLabel {
    fill: ${t.labelColor};
    font-size: ${t.labelFontSize};
  }
  .treemapValue {
    fill: ${t.valueColor};
    font-size: ${t.valueFontSize};
  }
  .treemapTitle {
    fill: ${t.titleColor};
    font-size: ${t.titleFontSize};
  }
  `
        }, 'getStyles')),
        (tlt = JIt)
    })
  var rlt = {}
  Oe(rlt, { diagram: () => tMt })
  var tMt,
    nlt = x(() => {
      'use strict'
      M8()
      Qot()
      Jot()
      elt()
      tMt = {
        parser: O8,
        get db() {
          return new Pm()
        },
        renderer: Zot,
        styles: tlt,
      }
    })
  var GMt = {}
  Oe(GMt, { default: () => $Mt })
  bu()
  pw()
  Tu()
  var Z1t = a((e) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e), 'detector'),
    J1t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (tG(), J$))
      return { id: 'c4', diagram: e }
    }, 'loader'),
    tyt = { id: 'c4', detector: Z1t, loader: J1t },
    eG = tyt
  var lK = 'flowchart',
    $vt = a(
      (e, t) =>
        t?.flowchart?.defaultRenderer === 'dagre-wrapper' || t?.flowchart?.defaultRenderer === 'elk'
          ? !1
          : /^\s*graph/.test(e),
      'detector',
    ),
    Gvt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (n6(), r6))
      return { id: lK, diagram: e }
    }, 'loader'),
    Vvt = { id: lK, detector: $vt, loader: Gvt },
    cK = Vvt
  var uK = 'flowchart-v2',
    zvt = a(
      (e, t) =>
        t?.flowchart?.defaultRenderer === 'dagre-d3'
          ? !1
          : (t?.flowchart?.defaultRenderer === 'elk' && (t.layout = 'elk'),
            /^\s*graph/.test(e) && t?.flowchart?.defaultRenderer === 'dagre-wrapper' ? !0 : /^\s*flowchart/.test(e)),
      'detector',
    ),
    Wvt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (n6(), r6))
      return { id: uK, diagram: e }
    }, 'loader'),
    Uvt = { id: uK, detector: zvt, loader: Wvt },
    hK = Uvt
  var Xvt = a((e) => /^\s*erDiagram/.test(e), 'detector'),
    Kvt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (bK(), xK))
      return { id: 'er', diagram: e }
    }, 'loader'),
    Qvt = { id: 'er', detector: Xvt, loader: Kvt },
    kK = Qvt
  var Let = 'gitGraph',
    v6t = a((e) => /^\s*gitGraph/.test(e), 'detector'),
    A6t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Aet(), vet))
      return { id: Let, diagram: e }
    }, 'loader'),
    L6t = { id: Let, detector: v6t, loader: A6t },
    Ret = L6t
  var art = 'gantt',
    gLt = a((e) => /^\s*gantt/.test(e), 'detector'),
    yLt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (srt(), irt))
      return { id: art, diagram: e }
    }, 'loader'),
    xLt = { id: art, detector: gLt, loader: yLt },
    ort = xLt
  var grt = 'info',
    CLt = a((e) => /^\s*info/.test(e), 'detector'),
    wLt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (mrt(), prt))
      return { id: grt, diagram: e }
    }, 'loader'),
    yrt = { id: grt, detector: CLt, loader: wLt }
  var FLt = a((e) => /^\s*pie/.test(e), 'detector'),
    $Lt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Ert(), wrt))
      return { id: 'pie', diagram: e }
    }, 'loader'),
    vrt = { id: 'pie', detector: FLt, loader: $Lt }
  var Grt = 'quadrantChart',
    nRt = a((e) => /^\s*quadrantChart/.test(e), 'detector'),
    iRt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => ($rt(), Frt))
      return { id: Grt, diagram: e }
    }, 'loader'),
    sRt = { id: Grt, detector: nRt, loader: iRt },
    Vrt = sRt
  var pnt = 'xychart',
    SRt = a((e) => /^\s*xychart(-beta)?/.test(e), 'detector'),
    _Rt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (dnt(), fnt))
      return { id: pnt, diagram: e }
    }, 'loader'),
    CRt = { id: pnt, detector: SRt, loader: _Rt },
    mnt = CRt
  var Cnt = 'requirement',
    ARt = a((e) => /^\s*requirement(Diagram)?/.test(e), 'detector'),
    LRt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (_nt(), Snt))
      return { id: Cnt, diagram: e }
    }, 'loader'),
    RRt = { id: Cnt, detector: ARt, loader: LRt },
    wnt = RRt
  var Vnt = 'sequence',
    yDt = a((e) => /^\s*sequenceDiagram/.test(e), 'detector'),
    xDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Gnt(), $nt))
      return { id: Vnt, diagram: e }
    }, 'loader'),
    bDt = { id: Vnt, detector: yDt, loader: xDt },
    znt = bDt
  var Ynt = 'class',
    wDt = a((e, t) => (t?.class?.defaultRenderer === 'dagre-wrapper' ? !1 : /^\s*classDiagram/.test(e)), 'detector'),
    EDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Hnt(), qnt))
      return { id: Ynt, diagram: e }
    }, 'loader'),
    vDt = { id: Ynt, detector: wDt, loader: EDt },
    Xnt = vDt
  var Znt = 'classDiagram',
    LDt = a(
      (e, t) =>
        /^\s*classDiagram/.test(e) && t?.class?.defaultRenderer === 'dagre-wrapper'
          ? !0
          : /^\s*classDiagram-v2/.test(e),
      'detector',
    ),
    RDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Qnt(), Knt))
      return { id: Znt, diagram: e }
    }, 'loader'),
    DDt = { id: Znt, detector: LDt, loader: RDt },
    Jnt = DDt
  var Dit = 'state',
    nNt = a((e, t) => (t?.state?.defaultRenderer === 'dagre-wrapper' ? !1 : /^\s*stateDiagram/.test(e)), 'detector'),
    iNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Rit(), Lit))
      return { id: Dit, diagram: e }
    }, 'loader'),
    sNt = { id: Dit, detector: nNt, loader: iNt },
    Nit = sNt
  var Oit = 'stateDiagram',
    oNt = a(
      (e, t) =>
        !!(
          /^\s*stateDiagram-v2/.test(e) ||
          (/^\s*stateDiagram/.test(e) && t?.state?.defaultRenderer === 'dagre-wrapper')
        ),
      'detector',
    ),
    lNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Mit(), Iit))
      return { id: Oit, diagram: e }
    }, 'loader'),
    cNt = { id: Oit, detector: oNt, loader: lNt },
    Pit = cNt
  var Zit = 'journey',
    RNt = a((e) => /^\s*journey/.test(e), 'detector'),
    DNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Qit(), Kit))
      return { id: Zit, diagram: e }
    }, 'loader'),
    NNt = { id: Zit, detector: RNt, loader: DNt },
    Jit = NNt
  Vt()
  Bl()
  On()
  var INt = a((e, t, r) => {
      B.debug(`rendering svg for syntax error
`)
      let n = Ai(t),
        i = n.append('g')
      n.attr('viewBox', '0 0 2412 512'),
        Ar(n, 100, 512, !0),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z',
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z',
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z',
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z',
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z',
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z',
          ),
        i
          .append('text')
          .attr('class', 'error-text')
          .attr('x', 1440)
          .attr('y', 250)
          .attr('font-size', '150px')
          .style('text-anchor', 'middle')
          .text('Syntax error in text'),
        i
          .append('text')
          .attr('class', 'error-text')
          .attr('x', 1250)
          .attr('y', 400)
          .attr('font-size', '100px')
          .style('text-anchor', 'middle')
          .text(`mermaid version ${r}`)
    }, 'draw'),
    KN = { draw: INt },
    tst = KN
  var MNt = { db: {}, renderer: KN, parser: { parse: a(() => {}, 'parse') } },
    est = MNt
  var vst = 'timeline',
    JNt = a((e) => /^\s*timeline/.test(e), 'detector'),
    t8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Est(), wst))
      return { id: vst, diagram: e }
    }, 'loader'),
    e8t = { id: vst, detector: JNt, loader: t8t },
    Ast = e8t
  var Gst = 'kanban',
    y8t = a((e) => /^\s*kanban/.test(e), 'detector'),
    x8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => ($st(), Fst))
      return { id: Gst, diagram: e }
    }, 'loader'),
    b8t = { id: Gst, detector: y8t, loader: x8t },
    Vst = b8t
  var Sat = 'sankey',
    z8t = a((e) => /^\s*sankey(-beta)?/.test(e), 'detector'),
    W8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Tat(), kat))
      return { id: Sat, diagram: e }
    }, 'loader'),
    U8t = { id: Sat, detector: z8t, loader: W8t },
    _at = U8t
  var Dat = 'packet',
    J8t = a((e) => /^\s*packet(-beta)?/.test(e), 'detector'),
    t7t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Rat(), Lat))
      return { id: Dat, diagram: e }
    }, 'loader'),
    Nat = { id: Dat, detector: J8t, loader: t7t }
  var Wat = 'radar',
    S7t = a((e) => /^\s*radar-beta/.test(e), 'detector'),
    _7t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (zat(), Vat))
      return { id: Wat, diagram: e }
    }, 'loader'),
    Uat = { id: Wat, detector: S7t, loader: _7t }
  var Hot = 'block',
    UIt = a((e) => /^\s*block(-beta)?/.test(e), 'detector'),
    jIt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (qot(), jot))
      return { id: Hot, diagram: e }
    }, 'loader'),
    qIt = { id: Hot, detector: UIt, loader: jIt },
    Yot = qIt
  Tu()
  pe()
  var ilt = 'treemap',
    eMt = a((e) => /^\s*treemap/.test(e), 'detector'),
    rMt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (nlt(), rlt))
      return { id: ilt, diagram: e }
    }, 'loader'),
    slt = { id: ilt, detector: eMt, loader: rMt }
  var alt = !1,
    Fm = a(() => {
      alt ||
        ((alt = !0),
        Su('error', est, (e) => e.toLowerCase().trim() === 'error'),
        Su(
          '---',
          {
            db: { clear: a(() => {}, 'clear') },
            styles: {},
            renderer: { draw: a(() => {}, 'draw') },
            parser: {
              parse: a(() => {
                throw new Error(
                  "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks",
                )
              }, 'parse'),
            },
            init: a(() => null, 'init'),
          },
          (e) => e.toLowerCase().trimStart().startsWith('---'),
        ),
        Sx(
          eG,
          Vst,
          Jnt,
          Xnt,
          kK,
          ort,
          yrt,
          vrt,
          wnt,
          znt,
          hK,
          cK,
          Ast,
          Ret,
          Pit,
          Nit,
          Jit,
          Vrt,
          _at,
          Nat,
          mnt,
          Yot,
          Uat,
          slt,
        ))
    }, 'addDiagrams')
  Vt()
  Tu()
  pe()
  var olt = a(async () => {
    B.debug('Loading registered diagrams')
    let t = (
      await Promise.allSettled(
        Object.entries(tl).map(async ([r, { detector: n, loader: i }]) => {
          if (i)
            try {
              cg(r)
            } catch {
              try {
                let { diagram: s, id: o } = await i()
                Su(o, s, n)
              } catch (s) {
                throw (
                  (B.error(`Failed to load external diagram with key ${r}. Removing from detectors.`), delete tl[r], s)
                )
              }
            }
        }),
      )
    ).filter((r) => r.status === 'rejected')
    if (t.length > 0) {
      B.error(`Failed to load ${t.length} external diagrams`)
      for (let r of t) B.error(r)
      throw new Error(`Failed to load ${t.length} external diagrams`)
    }
  }, 'loadRegisteredDiagrams')
  Vt()
  Ge()
  var pC = 'comm',
    mC = 'rule',
    gC = 'decl'
  var llt = '@import'
  var clt = '@namespace',
    ult = '@keyframes'
  var hlt = '@layer'
  var P8 = Math.abs,
    Jy = String.fromCharCode
  function yC(e) {
    return e.trim()
  }
  a(yC, 'trim')
  function tx(e, t, r) {
    return e.replace(t, r)
  }
  a(tx, 'replace')
  function flt(e, t, r) {
    return e.indexOf(t, r)
  }
  a(flt, 'indexof')
  function ou(e, t) {
    return e.charCodeAt(t) | 0
  }
  a(ou, 'charat')
  function lu(e, t, r) {
    return e.slice(t, r)
  }
  a(lu, 'substr')
  function zs(e) {
    return e.length
  }
  a(zs, 'strlen')
  function dlt(e) {
    return e.length
  }
  a(dlt, 'sizeof')
  function $m(e, t) {
    return t.push(e), e
  }
  a($m, 'append')
  var xC = 1,
    Gm = 1,
    plt = 0,
    xa = 0,
    Dn = 0,
    zm = ''
  function bC(e, t, r, n, i, s, o, l) {
    return {
      value: e,
      root: t,
      parent: r,
      type: n,
      props: i,
      children: s,
      line: xC,
      column: Gm,
      length: o,
      return: '',
      siblings: l,
    }
  }
  a(bC, 'node')
  function mlt() {
    return Dn
  }
  a(mlt, 'char')
  function glt() {
    return (Dn = xa > 0 ? ou(zm, --xa) : 0), Gm--, Dn === 10 && ((Gm = 1), xC--), Dn
  }
  a(glt, 'prev')
  function ba() {
    return (Dn = xa < plt ? ou(zm, xa++) : 0), Gm++, Dn === 10 && ((Gm = 1), xC++), Dn
  }
  a(ba, 'next')
  function Vl() {
    return ou(zm, xa)
  }
  a(Vl, 'peek')
  function ex() {
    return xa
  }
  a(ex, 'caret')
  function kC(e, t) {
    return lu(zm, e, t)
  }
  a(kC, 'slice')
  function Vm(e) {
    switch (e) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4
      case 58:
        return 3
      case 34:
      case 39:
      case 40:
      case 91:
        return 2
      case 41:
      case 93:
        return 1
    }
    return 0
  }
  a(Vm, 'token')
  function ylt(e) {
    return (xC = Gm = 1), (plt = zs((zm = e))), (xa = 0), []
  }
  a(ylt, 'alloc')
  function xlt(e) {
    return (zm = ''), e
  }
  a(xlt, 'dealloc')
  function TC(e) {
    return yC(kC(xa - 1, B8(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
  }
  a(TC, 'delimit')
  function blt(e) {
    for (; (Dn = Vl()) && Dn < 33; ) ba()
    return Vm(e) > 2 || Vm(Dn) > 3 ? '' : ' '
  }
  a(blt, 'whitespace')
  function klt(e, t) {
    for (; --t && ba() && !(Dn < 48 || Dn > 102 || (Dn > 57 && Dn < 65) || (Dn > 70 && Dn < 97)); );
    return kC(e, ex() + (t < 6 && Vl() == 32 && ba() == 32))
  }
  a(klt, 'escaping')
  function B8(e) {
    for (; ba(); )
      switch (Dn) {
        case e:
          return xa
        case 34:
        case 39:
          e !== 34 && e !== 39 && B8(Dn)
          break
        case 40:
          e === 41 && B8(e)
          break
        case 92:
          ba()
          break
      }
    return xa
  }
  a(B8, 'delimiter')
  function Tlt(e, t) {
    for (; ba() && e + Dn !== 57; ) if (e + Dn === 84 && Vl() === 47) break
    return '/*' + kC(t, xa - 1) + '*' + Jy(e === 47 ? e : ba())
  }
  a(Tlt, 'commenter')
  function Slt(e) {
    for (; !Vm(Vl()); ) ba()
    return kC(e, xa)
  }
  a(Slt, 'identifier')
  function wlt(e) {
    return xlt(SC('', null, null, null, [''], (e = ylt(e)), 0, [0], e))
  }
  a(wlt, 'compile')
  function SC(e, t, r, n, i, s, o, l, u) {
    for (
      var h = 0, f = 0, d = o, p = 0, m = 0, g = 0, y = 1, b = 1, k = 1, T = 0, C = '', A = i, w = s, D = n, G = C;
      b;

    )
      switch (((g = T), (T = ba()))) {
        case 40:
          if (g != 108 && ou(G, d - 1) == 58) {
            flt((G += tx(TC(T), '&', '&\f')), '&\f', P8(h ? l[h - 1] : 0)) != -1 && (k = -1)
            break
          }
        case 34:
        case 39:
        case 91:
          G += TC(T)
          break
        case 9:
        case 10:
        case 13:
        case 32:
          G += blt(g)
          break
        case 92:
          G += klt(ex() - 1, 7)
          continue
        case 47:
          switch (Vl()) {
            case 42:
            case 47:
              $m(nMt(Tlt(ba(), ex()), t, r, u), u),
                (Vm(g || 1) == 5 || Vm(Vl() || 1) == 5) && zs(G) && lu(G, -1, void 0) !== ' ' && (G += ' ')
              break
            default:
              G += '/'
          }
          break
        case 123 * y:
          l[h++] = zs(G) * k
        case 125 * y:
        case 59:
        case 0:
          switch (T) {
            case 0:
            case 125:
              b = 0
            case 59 + f:
              k == -1 && (G = tx(G, /\f/g, '')),
                m > 0 &&
                  (zs(G) - d || (y === 0 && g === 47)) &&
                  $m(m > 32 ? Clt(G + ';', n, r, d - 1, u) : Clt(tx(G, ' ', '') + ';', n, r, d - 2, u), u)
              break
            case 59:
              G += ';'
            default:
              if (($m((D = _lt(G, t, r, h, f, i, l, C, (A = []), (w = []), d, s)), s), T === 123))
                if (f === 0) SC(G, t, D, D, A, s, d, l, w)
                else {
                  switch (p) {
                    case 99:
                      if (ou(G, 3) === 110) break
                    case 108:
                      if (ou(G, 2) === 97) break
                    default:
                      f = 0
                    case 100:
                    case 109:
                    case 115:
                  }
                  f
                    ? SC(e, D, D, n && $m(_lt(e, D, D, 0, 0, i, l, C, i, (A = []), d, w), w), i, w, d, l, n ? A : w)
                    : SC(G, D, D, D, [''], w, 0, l, w)
                }
          }
          ;(h = f = m = 0), (y = k = 1), (C = G = ''), (d = o)
          break
        case 58:
          ;(d = 1 + zs(G)), (m = g)
        default:
          if (y < 1) {
            if (T == 123) --y
            else if (T == 125 && y++ == 0 && glt() == 125) continue
          }
          switch (((G += Jy(T)), T * y)) {
            case 38:
              k = f > 0 ? 1 : ((G += '\f'), -1)
              break
            case 44:
              ;(l[h++] = (zs(G) - 1) * k), (k = 1)
              break
            case 64:
              Vl() === 45 && (G += TC(ba())), (p = Vl()), (f = d = zs((C = G += Slt(ex())))), T++
              break
            case 45:
              g === 45 && zs(G) == 2 && (y = 0)
          }
      }
    return s
  }
  a(SC, 'parse')
  function _lt(e, t, r, n, i, s, o, l, u, h, f, d) {
    for (var p = i - 1, m = i === 0 ? s : [''], g = dlt(m), y = 0, b = 0, k = 0; y < n; ++y)
      for (var T = 0, C = lu(e, p + 1, (p = P8((b = o[y])))), A = e; T < g; ++T)
        (A = yC(b > 0 ? m[T] + ' ' + C : tx(C, /&\f/g, m[T]))) && (u[k++] = A)
    return bC(e, t, r, i === 0 ? mC : l, u, h, f, d)
  }
  a(_lt, 'ruleset')
  function nMt(e, t, r, n) {
    return bC(e, t, r, pC, Jy(mlt()), lu(e, 2, -2), 0, n)
  }
  a(nMt, 'comment')
  function Clt(e, t, r, n, i) {
    return bC(e, t, r, gC, lu(e, 0, n), lu(e, n + 1, -1), n, i)
  }
  a(Clt, 'declaration')
  function _C(e, t) {
    for (var r = '', n = 0; n < e.length; n++) r += t(e[n], n, e, t) || ''
    return r
  }
  a(_C, 'serialize')
  function Elt(e, t, r, n) {
    switch (e.type) {
      case hlt:
        if (e.children.length) break
      case llt:
      case clt:
      case gC:
        return (e.return = e.return || e.value)
      case pC:
        return ''
      case ult:
        return (e.return = e.value + '{' + _C(e.children, n) + '}')
      case mC:
        if (!zs((e.value = e.props.join(',')))) return ''
    }
    return zs((r = _C(e.children, n))) ? (e.return = e.value + '{' + r + '}') : ''
  }
  a(Elt, 'stringify')
  uw()
  Yk()
  XD()
  var iMt = 'graphics-document document'
  function vlt(e, t) {
    e.attr('role', iMt), t !== '' && e.attr('aria-roledescription', t)
  }
  a(vlt, 'setA11yDiagramInfo')
  function Alt(e, t, r, n) {
    if (e.insert !== void 0) {
      if (r) {
        let i = `chart-desc-${n}`
        e.attr('aria-describedby', i), e.insert('desc', ':first-child').attr('id', i).text(r)
      }
      if (t) {
        let i = `chart-title-${n}`
        e.attr('aria-labelledby', i), e.insert('title', ':first-child').attr('id', i).text(t)
      }
    }
  }
  a(Alt, 'addSVGa11yTitleDescription')
  of()
  fn()
  fn()
  pe()
  Tu()
  mw()
  Ce()
  var Wm = class e {
    constructor(t, r, n, i, s) {
      this.type = t
      this.text = r
      this.db = n
      this.parser = i
      this.renderer = s
    }
    static {
      a(this, 'Diagram')
    }
    static async fromText(t, r = {}) {
      let n = Te(),
        i = pf(t, n)
      t =
        U$(t) +
        `
`
      try {
        cg(i)
      } catch {
        let h = CI(i)
        if (!h) throw new df(`Diagram ${i} not found.`)
        let { id: f, diagram: d } = await h()
        Su(f, d)
      }
      let { db: s, parser: o, renderer: l, init: u } = cg(i)
      return (
        o.parser && (o.parser.yy = s),
        s.clear?.(),
        u?.(n),
        r.title && s.setDiagramTitle?.(r.title),
        await o.parse(t),
        new e(i, t, s, o, l)
      )
    }
    async render(t, r) {
      await this.renderer.draw(this.text, t, r, this)
    }
    getParser() {
      return this.parser
    }
    getType() {
      return this.type
    }
  }
  Be()
  var Llt = []
  var Rlt = a(() => {
    Llt.forEach((e) => {
      e()
    }),
      (Llt = [])
  }, 'attachFunctions')
  Vt()
  var Dlt = a((e) => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, '').trimStart(), 'cleanupComments')
  Tx()
  E0()
  function Nlt(e) {
    let t = e.match(kx)
    if (!t) return { text: e, metadata: {} }
    let r = Cc(t[1], { schema: _c }) ?? {}
    r = typeof r == 'object' && !Array.isArray(r) ? r : {}
    let n = {}
    return (
      r.displayMode && (n.displayMode = r.displayMode.toString()),
      r.title && (n.title = r.title.toString()),
      r.config && (n.config = r.config),
      { text: e.slice(t[0].length), metadata: n }
    )
  }
  a(Nlt, 'extractFrontMatter')
  Ce()
  var sMt = a(
      (e) =>
        e
          .replace(
            /\r\n?/g,
            `
`,
          )
          .replace(/<(\w+)([^>]*)>/g, (t, r, n) => '<' + r + n.replace(/="([^"]*)"/g, "='$1'") + '>'),
      'cleanupText',
    ),
    aMt = a((e) => {
      let { text: t, metadata: r } = Nlt(e),
        { displayMode: n, title: i, config: s = {} } = r
      return n && (s.gantt || (s.gantt = {}), (s.gantt.displayMode = n)), { title: i, config: s, text: t }
    }, 'processFrontmatter'),
    oMt = a((e) => {
      let t = le.detectInit(e) ?? {},
        r = le.detectDirective(e, 'wrap')
      return (
        Array.isArray(r) ? (t.wrap = r.some(({ type: n }) => n === 'wrap')) : r?.type === 'wrap' && (t.wrap = !0),
        { text: z$(e), directive: t }
      )
    }, 'processDirectives')
  function F8(e) {
    let t = sMt(e),
      r = aMt(t),
      n = oMt(r.text),
      i = ln(r.config, n.directive)
    return (e = Dlt(n.text)), { code: e, title: r.title, config: i }
  }
  a(F8, 'preprocessDiagram')
  xw()
  dx()
  Ce()
  function Ilt(e) {
    let t = new TextEncoder().encode(e),
      r = Array.from(t, (n) => String.fromCodePoint(n)).join('')
    return btoa(r)
  }
  a(Ilt, 'toBase64')
  var lMt = 5e4,
    cMt = 'graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa',
    uMt = 'sandbox',
    hMt = 'loose',
    fMt = 'http://www.w3.org/2000/svg',
    dMt = 'http://www.w3.org/1999/xlink',
    pMt = 'http://www.w3.org/1999/xhtml',
    mMt = '100%',
    gMt = '100%',
    yMt = 'border:0;margin:0;',
    xMt = 'margin:0',
    bMt = 'allow-top-navigation-by-user-activation allow-popups',
    kMt = 'The "iframe" tag is not supported by your browser.',
    TMt = ['foreignobject'],
    SMt = ['dominant-baseline']
  function Blt(e) {
    let t = F8(e)
    return Jm(), tI(t.config ?? {}), t
  }
  a(Blt, 'processAndSetConfigs')
  async function _Mt(e, t) {
    Fm()
    try {
      let { code: r, config: n } = Blt(e)
      return { diagramType: (await Flt(r)).type, config: n }
    } catch (r) {
      if (t?.suppressErrors) return !1
      throw r
    }
  }
  a(_Mt, 'parse')
  var Mlt = a(
      (e, t, r = []) => `
.${e} ${t} { ${r.join(' !important; ')} !important; }`,
      'cssImportantStyles',
    ),
    CMt = a((e, t = new Map()) => {
      let r = ''
      if (
        (e.themeCSS !== void 0 &&
          (r += `
${e.themeCSS}`),
        e.fontFamily !== void 0 &&
          (r += `
:root { --mermaid-font-family: ${e.fontFamily}}`),
        e.altFontFamily !== void 0 &&
          (r += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`),
        t instanceof Map)
      ) {
        let o =
          (e.htmlLabels ?? e.flowchart?.htmlLabels) ? ['> *', 'span'] : ['rect', 'polygon', 'ellipse', 'circle', 'path']
        t.forEach((l) => {
          De(l.styles) ||
            o.forEach((u) => {
              r += Mlt(l.id, u, l.styles)
            }),
            De(l.textStyles) ||
              (r += Mlt(
                l.id,
                'tspan',
                (l?.textStyles || []).map((u) => u.replace('color', 'fill')),
              ))
        })
      }
      return r
    }, 'createCssStyles'),
    wMt = a((e, t, r, n) => {
      let i = CMt(e, r),
        s = vI(t, i, e.themeVariables)
      return _C(wlt(`${n}{${s}}`), Elt)
    }, 'createUserStyles'),
    EMt = a((e = '', t, r) => {
      let n = e
      return (
        !r && !t && (n = n.replace(/marker-end="url\([\d+./:=?A-Za-z-]*?#/g, 'marker-end="url(#')),
        (n = Xn(n)),
        (n = n.replace(/<br>/g, '<br/>')),
        n
      )
    }, 'cleanUpSvgCode'),
    vMt = a((e = '', t) => {
      let r = t?.viewBox?.baseVal?.height ? t.viewBox.baseVal.height + 'px' : gMt,
        n = Ilt(`<body style="${xMt}">${e}</body>`)
      return `<iframe style="width:${mMt};height:${r};${yMt}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${bMt}">
  ${kMt}
</iframe>`
    }, 'putIntoIFrame'),
    Olt = a((e, t, r, n, i) => {
      let s = e.append('div')
      s.attr('id', r), n && s.attr('style', n)
      let o = s.append('svg').attr('id', t).attr('width', '100%').attr('xmlns', fMt)
      return i && o.attr('xmlns:xlink', i), o.append('g'), e
    }, 'appendDivSvgG')
  function Plt(e, t) {
    return e.append('iframe').attr('id', t).attr('style', 'width: 100%; height: 100%;').attr('sandbox', '')
  }
  a(Plt, 'sandboxedIframe')
  var AMt = a((e, t, r, n) => {
      e.getElementById(t)?.remove(), e.getElementById(r)?.remove(), e.getElementById(n)?.remove()
    }, 'removeExistingElements'),
    LMt = a(async function (e, t, r) {
      Fm()
      let n = Blt(t)
      t = n.code
      let i = Te()
      B.debug(i), t.length > (i?.maxTextSize ?? lMt) && (t = cMt)
      let s = '#' + e,
        o = 'i' + e,
        l = '#' + o,
        u = 'd' + e,
        h = '#' + u,
        f = a(() => {
          let E = xt(p ? l : h).node()
          E && 'remove' in E && E.remove()
        }, 'removeTempElements'),
        d = xt('body'),
        p = i.securityLevel === uMt,
        m = i.securityLevel === hMt,
        g = i.fontFamily
      if (r !== void 0) {
        if ((r && (r.innerHTML = ''), p)) {
          let O = Plt(xt(r), o)
          ;(d = xt(O.nodes()[0].contentDocument.body)), (d.node().style.margin = 0)
        } else d = xt(r)
        Olt(d, e, u, `font-family: ${g}`, dMt)
      } else {
        if ((AMt(document, e, u, o), p)) {
          let O = Plt(xt('body'), o)
          ;(d = xt(O.nodes()[0].contentDocument.body)), (d.node().style.margin = 0)
        } else d = xt('body')
        Olt(d, e, u)
      }
      let y, b
      try {
        y = await Wm.fromText(t, { title: n.title })
      } catch (O) {
        if (i.suppressErrorRendering) throw (f(), O)
        ;(y = await Wm.fromText('error')), (b = O)
      }
      let k = d.select(h).node(),
        T = y.type,
        C = k.firstChild,
        A = C.firstChild,
        w = y.renderer.getClasses?.(t, y),
        D = wMt(i, T, w, s),
        G = document.createElement('style')
      ;(G.innerHTML = D), C.insertBefore(G, A)
      try {
        await y.renderer.draw(t, e, Py.version, y)
      } catch (O) {
        throw (i.suppressErrorRendering ? f() : tst.draw(t, e, Py.version), O)
      }
      let v = d.select(`${h} svg`),
        R = y.db.getAccTitle?.(),
        F = y.db.getAccDescription?.()
      DMt(T, v, R, F), d.select(`[id="${e}"]`).selectAll('foreignobject > *').attr('xmlns', pMt)
      let S = d.select(h).node().innerHTML
      if (
        (B.debug('config.arrowMarkerAbsolute', i.arrowMarkerAbsolute), (S = EMt(S, p, Pe(i.arrowMarkerAbsolute))), p)
      ) {
        let O = d.select(h + ' svg').node()
        S = vMt(S, O)
      } else m || (S = Yl.sanitize(S, { ADD_TAGS: TMt, ADD_ATTR: SMt, HTML_INTEGRATION_POINTS: { foreignobject: !0 } }))
      if ((Rlt(), b)) throw b
      return f(), { diagramType: T, svg: S, bindFunctions: y.db.bindFunctions }
    }, 'render')
  function RMt(e = {}) {
    let t = Kr({}, e)
    t?.fontFamily &&
      !t.themeVariables?.fontFamily &&
      (t.themeVariables || (t.themeVariables = {}), (t.themeVariables.fontFamily = t.fontFamily)),
      Q7(t),
      t?.theme && t.theme in qs
        ? (t.themeVariables = qs[t.theme].getThemeVariables(t.themeVariables))
        : t && (t.themeVariables = qs.default.getThemeVariables(t.themeVariables))
    let r = typeof t == 'object' ? ew(t) : rw()
    jm(r.logLevel), Fm()
  }
  a(RMt, 'initialize')
  var Flt = a((e, t = {}) => {
    let { code: r } = F8(e)
    return Wm.fromText(r, t)
  }, 'getDiagramFromText')
  function DMt(e, t, r, n) {
    vlt(t, e), Alt(t, r, n, t.attr('id'))
  }
  a(DMt, 'addA11yInfo')
  var cu = Object.freeze({
    render: LMt,
    parse: _Mt,
    getDiagramFromText: Flt,
    initialize: RMt,
    getConfig: Te,
    setConfig: mx,
    getSiteConfig: rw,
    updateSiteConfig: Z7,
    reset: a(() => {
      Jm()
    }, 'reset'),
    globalReset: a(() => {
      Jm(Hl)
    }, 'globalReset'),
    defaultConfig: Hl,
  })
  jm(Te().logLevel)
  Jm(Te())
  ph()
  Ce()
  var NMt = a((e, t, r) => {
      B.warn(e),
        D4(e)
          ? (r && r(e.str, e.hash), t.push({ ...e, message: e.str, error: e }))
          : (r && r(e), e instanceof Error && t.push({ str: e.message, message: e.message, hash: e.name, error: e }))
    }, 'handleError'),
    $lt = a(async function (e = { querySelector: '.mermaid' }) {
      try {
        await IMt(e)
      } catch (t) {
        if ((D4(t) && B.error(t.str), zl.parseError && zl.parseError(t), !e.suppressErrors))
          throw (B.error('Use the suppressErrors option to suppress these errors'), t)
      }
    }, 'run'),
    IMt = a(async function ({ postRenderCallback: e, querySelector: t, nodes: r } = { querySelector: '.mermaid' }) {
      let n = cu.getConfig()
      B.debug(`${e ? '' : 'No '}Callback function found`)
      let i
      if (r) i = r
      else if (t) i = document.querySelectorAll(t)
      else throw new Error('Nodes and querySelector are both undefined')
      B.debug(`Found ${i.length} diagrams`),
        n?.startOnLoad !== void 0 &&
          (B.debug('Start On Load: ' + n?.startOnLoad), cu.updateSiteConfig({ startOnLoad: n?.startOnLoad }))
      let s = new le.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed),
        o,
        l = []
      for (let u of Array.from(i)) {
        B.info('Rendering diagram: ' + u.id)
        if (u.getAttribute('data-processed')) continue
        u.setAttribute('data-processed', 'true')
        let h = `mermaid-${s.next()}`
        ;(o = u.innerHTML),
          (o = bx(le.entityDecode(o))
            .trim()
            .replace(/<br\s*\/?>/gi, '<br/>'))
        let f = le.detectInit(o)
        f && B.debug('Detected early reinit: ', f)
        try {
          let { svg: d, bindFunctions: p } = await Wlt(h, o, u)
          ;(u.innerHTML = d), e && (await e(h)), p && p(u)
        } catch (d) {
          NMt(d, l, zl.parseError)
        }
      }
      if (l.length > 0) throw l[0]
    }, 'runThrowsErrors'),
    Glt = a(function (e) {
      cu.initialize(e)
    }, 'initialize'),
    MMt = a(async function (e, t, r) {
      B.warn('mermaid.init is deprecated. Please use run instead.'), e && Glt(e)
      let n = { postRenderCallback: r, querySelector: '.mermaid' }
      typeof t == 'string' ? (n.querySelector = t) : t && (t instanceof HTMLElement ? (n.nodes = [t]) : (n.nodes = t)),
        await $lt(n)
    }, 'init'),
    OMt = a(async (e, { lazyLoad: t = !0 } = {}) => {
      Fm(), Sx(...e), t === !1 && (await olt())
    }, 'registerExternalDiagrams'),
    Vlt = a(function () {
      if (zl.startOnLoad) {
        let { startOnLoad: e } = cu.getConfig()
        e && zl.run().catch((t) => B.error('Mermaid failed to initialize', t))
      }
    }, 'contentLoaded')
  if (typeof document < 'u') {
    window.addEventListener('load', Vlt, !1)
  }
  var PMt = a(function (e) {
      zl.parseError = e
    }, 'setParseErrorHandler'),
    CC = [],
    $8 = !1,
    zlt = a(async () => {
      if (!$8) {
        for ($8 = !0; CC.length > 0; ) {
          let e = CC.shift()
          if (e)
            try {
              await e()
            } catch (t) {
              B.error('Error executing queue', t)
            }
        }
        $8 = !1
      }
    }, 'executeQueue'),
    BMt = a(
      async (e, t) =>
        new Promise((r, n) => {
          let i = a(
            () =>
              new Promise((s, o) => {
                cu.parse(e, t).then(
                  (l) => {
                    s(l), r(l)
                  },
                  (l) => {
                    B.error('Error parsing', l), zl.parseError?.(l), o(l), n(l)
                  },
                )
              }),
            'performCall',
          )
          CC.push(i), zlt().catch(n)
        }),
      'parse',
    ),
    Wlt = a(
      (e, t, r) =>
        new Promise((n, i) => {
          let s = a(
            () =>
              new Promise((o, l) => {
                cu.render(e, t, r).then(
                  (u) => {
                    o(u), n(u)
                  },
                  (u) => {
                    B.error('Error parsing', u), zl.parseError?.(u), l(u), i(u)
                  },
                )
              }),
            'performCall',
          )
          CC.push(s), zlt().catch(i)
        }),
      'render',
    ),
    FMt = a(() => Object.keys(tl).map((e) => ({ id: e })), 'getRegisteredDiagramsMetadata'),
    zl = {
      startOnLoad: !0,
      mermaidAPI: cu,
      parse: BMt,
      render: Wlt,
      init: MMt,
      run: $lt,
      registerExternalDiagrams: OMt,
      registerLayoutLoaders: J5,
      initialize: Glt,
      parseError: void 0,
      contentLoaded: Vlt,
      setParseErrorHandler: PMt,
      detectType: pf,
      registerIconPacks: kI,
      getRegisteredDiagramsMetadata: FMt,
    },
    $Mt = zl
  return Jlt(GMt)
})()
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
/*! Bundled license information:

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
globalThis['mermaid'] = globalThis.__esbuild_esm_mermaid_nm['mermaid'].default
